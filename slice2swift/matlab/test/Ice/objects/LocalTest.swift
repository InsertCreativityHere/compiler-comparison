//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `LocalTest.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice

/// Traits for Slice class`C1`.
public struct C1Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::LocalTest::C1"]
    public static let staticId = "::LocalTest::C1"
}

public class S1 {
    public var c1: C1? = nil

    public init() {}

    public init(c1: C1?) {
        self.c1 = c1
    }
}

/// An `Ice.InputStream` extension to read `S1` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `S1` structured value from the stream.
    ///
    /// - returns: `S1` - The structured value read from the stream.
    func read() throws -> S1 {
        let v = S1()
        try self.read(C1.self) { v.c1 = $0 }
        return v
    }

    /// Read an optional `S1?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `S1?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> S1? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as S1
    }
}

/// An `Ice.OutputStream` extension to write `S1` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `S1` structured value to the stream.
    ///
    /// - parameter _: `S1` - The value to write to the stream.
    func write(_ v: S1) {
        self.write(v.c1)
    }

    /// Write an optional `S1?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `S1?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: S1?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public typealias C1Seq = [C1?]

/// Helper class to read and write `C1Seq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct C1SeqHelper {
    /// Read a `C1Seq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `C1Seq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> C1Seq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = C1Seq(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(C1.self) { p.pointee = $0 }
            }
        }
        return v
    }
    /// Read an optional `C1Seq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `C1Seq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> C1Seq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `C1Seq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `C1Seq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: C1Seq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `C1Seq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `C1Seq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: C1Seq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias S1Seq = [S1]

/// Helper class to read and write `S1Seq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct S1SeqHelper {
    /// Read a `S1Seq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `S1Seq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> S1Seq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = S1Seq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: S1 = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `S1Seq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `S1Seq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> S1Seq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `S1Seq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `S1Seq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: S1Seq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `S1Seq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `S1Seq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: S1Seq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias C1Dict = [Swift.Int32: C1?]

/// Helper class to read and write `C1Dict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct C1DictHelper {
    /// Read a `C1Dict` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `C1Dict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> C1Dict {
        let sz = try Swift.Int(istr.readSize())
        var v = C1Dict()
        let e = Ice.DictEntryArray<Swift.Int32, C1?>(size: sz)
        for i in 0 ..< sz {
            let key: Swift.Int32 = try istr.read()
            v[key] = nil as C1?
            Swift.withUnsafeMutablePointer(to: &v[key, default:nil]) {
                e.values[i] = Ice.DictEntry<Swift.Int32, C1?>(key: key, value: $0)
            }
            try istr.read(C1.self) { e.values[i].value.pointee = $0 }
        }
        for i in 0..<sz {
            Swift.withUnsafeMutablePointer(to: &v[e.values[i].key, default:nil]) {
                e.values[i].value = $0
            }
        }
        return v
    }
    /// Read an optional `C1Dict?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `C1Dict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> C1Dict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `C1Dict` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `C1Dict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: C1Dict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `C1Dict?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `C1Dict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: C1Dict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias S1Dict = [Swift.Int32: S1]

/// Helper class to read and write `S1Dict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct S1DictHelper {
    /// Read a `S1Dict` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `S1Dict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> S1Dict {
        let sz = try Swift.Int(istr.readSize())
        var v = S1Dict()
        for _ in 0 ..< sz {
            let key: Swift.Int32 = try istr.read()
            let value: S1 = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `S1Dict?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `S1Dict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> S1Dict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `S1Dict` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `S1Dict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: S1Dict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `S1Dict?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `S1Dict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: S1Dict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias C1SeqSeq = [C1Seq]

/// Helper class to read and write `C1SeqSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct C1SeqSeqHelper {
    /// Read a `C1SeqSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `C1SeqSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> C1SeqSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = C1SeqSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: C1Seq = try C1SeqHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `C1SeqSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `C1SeqSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> C1SeqSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `C1SeqSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `C1SeqSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: C1SeqSeq) {
        ostr.write(size: v.count)
        for item in v {
            C1SeqHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `C1SeqSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `C1SeqSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: C1SeqSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias S1SeqSeq = [S1Seq]

/// Helper class to read and write `S1SeqSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct S1SeqSeqHelper {
    /// Read a `S1SeqSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `S1SeqSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> S1SeqSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = S1SeqSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: S1Seq = try S1SeqHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `S1SeqSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `S1SeqSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> S1SeqSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `S1SeqSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `S1SeqSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: S1SeqSeq) {
        ostr.write(size: v.count)
        for item in v {
            S1SeqHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `S1SeqSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `S1SeqSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: S1SeqSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public class S2 {
    public var s1: S1 = S1()

    public init() {}

    public init(s1: S1) {
        self.s1 = s1
    }
}

/// An `Ice.InputStream` extension to read `S2` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `S2` structured value from the stream.
    ///
    /// - returns: `S2` - The structured value read from the stream.
    func read() throws -> S2 {
        let v = S2()
        v.s1 = try self.read()
        return v
    }

    /// Read an optional `S2?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `S2?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> S2? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as S2
    }
}

/// An `Ice.OutputStream` extension to write `S2` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `S2` structured value to the stream.
    ///
    /// - parameter _: `S2` - The value to write to the stream.
    func write(_ v: S2) {
        self.write(v.s1)
    }

    /// Write an optional `S2?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `S2?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: S2?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public class S3 {
    public var c1seq: C1Seq = C1Seq()

    public init() {}

    public init(c1seq: C1Seq) {
        self.c1seq = c1seq
    }
}

/// An `Ice.InputStream` extension to read `S3` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `S3` structured value from the stream.
    ///
    /// - returns: `S3` - The structured value read from the stream.
    func read() throws -> S3 {
        let v = S3()
        v.c1seq = try C1SeqHelper.read(from: self)
        return v
    }

    /// Read an optional `S3?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `S3?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> S3? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as S3
    }
}

/// An `Ice.OutputStream` extension to write `S3` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `S3` structured value to the stream.
    ///
    /// - parameter _: `S3` - The value to write to the stream.
    func write(_ v: S3) {
        C1SeqHelper.write(to: self, value: v.c1seq)
    }

    /// Write an optional `S3?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `S3?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: S3?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public class S4 {
    public var s1seq: S1Seq = S1Seq()

    public init() {}

    public init(s1seq: S1Seq) {
        self.s1seq = s1seq
    }
}

/// An `Ice.InputStream` extension to read `S4` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `S4` structured value from the stream.
    ///
    /// - returns: `S4` - The structured value read from the stream.
    func read() throws -> S4 {
        let v = S4()
        v.s1seq = try S1SeqHelper.read(from: self)
        return v
    }

    /// Read an optional `S4?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `S4?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> S4? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as S4
    }
}

/// An `Ice.OutputStream` extension to write `S4` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `S4` structured value to the stream.
    ///
    /// - parameter _: `S4` - The value to write to the stream.
    func write(_ v: S4) {
        S1SeqHelper.write(to: self, value: v.s1seq)
    }

    /// Write an optional `S4?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `S4?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: S4?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public class S5 {
    public var c1dict: C1Dict = C1Dict()

    public init() {}

    public init(c1dict: C1Dict) {
        self.c1dict = c1dict
    }
}

/// An `Ice.InputStream` extension to read `S5` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `S5` structured value from the stream.
    ///
    /// - returns: `S5` - The structured value read from the stream.
    func read() throws -> S5 {
        let v = S5()
        v.c1dict = try C1DictHelper.read(from: self)
        return v
    }

    /// Read an optional `S5?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `S5?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> S5? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as S5
    }
}

/// An `Ice.OutputStream` extension to write `S5` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `S5` structured value to the stream.
    ///
    /// - parameter _: `S5` - The value to write to the stream.
    func write(_ v: S5) {
        C1DictHelper.write(to: self, value: v.c1dict)
    }

    /// Write an optional `S5?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `S5?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: S5?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public class S6 {
    public var s1dict: S1Dict = S1Dict()

    public init() {}

    public init(s1dict: S1Dict) {
        self.s1dict = s1dict
    }
}

/// An `Ice.InputStream` extension to read `S6` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `S6` structured value from the stream.
    ///
    /// - returns: `S6` - The structured value read from the stream.
    func read() throws -> S6 {
        let v = S6()
        v.s1dict = try S1DictHelper.read(from: self)
        return v
    }

    /// Read an optional `S6?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `S6?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> S6? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as S6
    }
}

/// An `Ice.OutputStream` extension to write `S6` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `S6` structured value to the stream.
    ///
    /// - parameter _: `S6` - The value to write to the stream.
    func write(_ v: S6) {
        S1DictHelper.write(to: self, value: v.s1dict)
    }

    /// Write an optional `S6?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `S6?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: S6?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public struct S7 {
    public var c1seqseq: C1SeqSeq = C1SeqSeq()

    public init() {}

    public init(c1seqseq: C1SeqSeq) {
        self.c1seqseq = c1seqseq
    }
}

/// An `Ice.InputStream` extension to read `S7` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `S7` structured value from the stream.
    ///
    /// - returns: `S7` - The structured value read from the stream.
    func read() throws -> S7 {
        var v = S7()
        v.c1seqseq = try C1SeqSeqHelper.read(from: self)
        return v
    }

    /// Read an optional `S7?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `S7?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> S7? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as S7
    }
}

/// An `Ice.OutputStream` extension to write `S7` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `S7` structured value to the stream.
    ///
    /// - parameter _: `S7` - The value to write to the stream.
    func write(_ v: S7) {
        C1SeqSeqHelper.write(to: self, value: v.c1seqseq)
    }

    /// Write an optional `S7?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `S7?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: S7?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public struct S8 {
    public var s1seqseq: S1SeqSeq = S1SeqSeq()

    public init() {}

    public init(s1seqseq: S1SeqSeq) {
        self.s1seqseq = s1seqseq
    }
}

/// An `Ice.InputStream` extension to read `S8` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `S8` structured value from the stream.
    ///
    /// - returns: `S8` - The structured value read from the stream.
    func read() throws -> S8 {
        var v = S8()
        v.s1seqseq = try S1SeqSeqHelper.read(from: self)
        return v
    }

    /// Read an optional `S8?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `S8?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> S8? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as S8
    }
}

/// An `Ice.OutputStream` extension to write `S8` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `S8` structured value to the stream.
    ///
    /// - parameter _: `S8` - The value to write to the stream.
    func write(_ v: S8) {
        S1SeqSeqHelper.write(to: self, value: v.s1seqseq)
    }

    /// Write an optional `S8?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `S8?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: S8?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// Traits for Slice class`CB1`.
public struct CB1Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::LocalTest::CB1"]
    public static let staticId = "::LocalTest::CB1"
}

/// Traits for Slice class`CB2`.
public struct CB2Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::LocalTest::CB2"]
    public static let staticId = "::LocalTest::CB2"
}

/// Traits for Slice class`CB3`.
public struct CB3Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::LocalTest::CB3"]
    public static let staticId = "::LocalTest::CB3"
}

/// Traits for Slice class`CB4`.
public struct CB4Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::LocalTest::CB4"]
    public static let staticId = "::LocalTest::CB4"
}

/// Traits for Slice class`CB5`.
public struct CB5Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::LocalTest::CB5"]
    public static let staticId = "::LocalTest::CB5"
}

/// Traits for Slice class`CB6`.
public struct CB6Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::LocalTest::CB6"]
    public static let staticId = "::LocalTest::CB6"
}

/// Traits for Slice class`CB7`.
public struct CB7Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::LocalTest::CB7"]
    public static let staticId = "::LocalTest::CB7"
}

/// Traits for Slice class`CB8`.
public struct CB8Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::LocalTest::CB8"]
    public static let staticId = "::LocalTest::CB8"
}

public struct StructKey: Swift.Hashable {
    public var i: Swift.Int32 = 0
    public var j: Swift.Int32 = 0

    public init() {}

    public init(i: Swift.Int32, j: Swift.Int32) {
        self.i = i
        self.j = j
    }
}

/// An `Ice.InputStream` extension to read `StructKey` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `StructKey` structured value from the stream.
    ///
    /// - returns: `StructKey` - The structured value read from the stream.
    func read() throws -> StructKey {
        var v = StructKey()
        v.i = try self.read()
        v.j = try self.read()
        return v
    }

    /// Read an optional `StructKey?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StructKey?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> StructKey? {
        guard try readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try skipSize()
        return try read() as StructKey
    }
}

/// An `Ice.OutputStream` extension to write `StructKey` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `StructKey` structured value to the stream.
    ///
    /// - parameter _: `StructKey` - The value to write to the stream.
    func write(_ v: StructKey) {
        self.write(v.i)
        self.write(v.j)
    }

    /// Write an optional `StructKey?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StructKey?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: StructKey?) {
        if let v = value {
            if writeOptional(tag: tag, format: .VSize) {
                write(size: 8)
                write(v)
            }
        }
    }
}

public typealias StructDict1 = [StructKey: C1?]

/// Helper class to read and write `StructDict1` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StructDict1Helper {
    /// Read a `StructDict1` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StructDict1` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StructDict1 {
        let sz = try Swift.Int(istr.readSize())
        var v = StructDict1()
        let e = Ice.DictEntryArray<StructKey, C1?>(size: sz)
        for i in 0 ..< sz {
            let key: StructKey = try istr.read()
            v[key] = nil as C1?
            Swift.withUnsafeMutablePointer(to: &v[key, default:nil]) {
                e.values[i] = Ice.DictEntry<StructKey, C1?>(key: key, value: $0)
            }
            try istr.read(C1.self) { e.values[i].value.pointee = $0 }
        }
        for i in 0..<sz {
            Swift.withUnsafeMutablePointer(to: &v[e.values[i].key, default:nil]) {
                e.values[i].value = $0
            }
        }
        return v
    }
    /// Read an optional `StructDict1?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StructDict1` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StructDict1? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StructDict1` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StructDict1` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StructDict1) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `StructDict1?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StructDict1` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: StructDict1?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StructDict2 = [StructKey: S1]

/// Helper class to read and write `StructDict2` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StructDict2Helper {
    /// Read a `StructDict2` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StructDict2` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StructDict2 {
        let sz = try Swift.Int(istr.readSize())
        var v = StructDict2()
        for _ in 0 ..< sz {
            let key: StructKey = try istr.read()
            let value: S1 = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `StructDict2?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StructDict2` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StructDict2? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StructDict2` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StructDict2` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StructDict2) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `StructDict2?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StructDict2` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: StructDict2?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias C1DictDict = [Swift.Int32: C1Dict]

/// Helper class to read and write `C1DictDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct C1DictDictHelper {
    /// Read a `C1DictDict` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `C1DictDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> C1DictDict {
        let sz = try Swift.Int(istr.readSize())
        var v = C1DictDict()
        for _ in 0 ..< sz {
            let key: Swift.Int32 = try istr.read()
            let value: C1Dict = try C1DictHelper.read(from: istr)
            v[key] = value
        }
        return v
    }
    /// Read an optional `C1DictDict?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `C1DictDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> C1DictDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `C1DictDict` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `C1DictDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: C1DictDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            C1DictHelper.write(to: ostr, value: value)
        }
    }

    /// Wite an optional `C1DictDict?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `C1DictDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: C1DictDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias S1DictDict = [Swift.Int32: S1Dict]

/// Helper class to read and write `S1DictDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct S1DictDictHelper {
    /// Read a `S1DictDict` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `S1DictDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> S1DictDict {
        let sz = try Swift.Int(istr.readSize())
        var v = S1DictDict()
        for _ in 0 ..< sz {
            let key: Swift.Int32 = try istr.read()
            let value: S1Dict = try S1DictHelper.read(from: istr)
            v[key] = value
        }
        return v
    }
    /// Read an optional `S1DictDict?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `S1DictDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> S1DictDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `S1DictDict` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `S1DictDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: S1DictDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            S1DictHelper.write(to: ostr, value: value)
        }
    }

    /// Wite an optional `S1DictDict?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `S1DictDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: S1DictDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// :nodoc:
public class C1_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return C1.self
    }
}

public extension Ice.ClassResolver {
    @objc static func LocalTest_C1() -> Ice.ValueTypeResolver {
        return C1_TypeResolver()
    }
}

open class C1: Ice.Value {
    public var i: Swift.Int32 = 0

    public required init() {}

    public init(i: Swift.Int32) {
        self.i = i
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return C1Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return C1Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.i = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: C1Traits.staticId, compactId: -1, last: true)
        ostr.write(self.i)
        ostr.endSlice()
    }
}

/// :nodoc:
public class CB1_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return CB1.self
    }
}

public extension Ice.ClassResolver {
    @objc static func LocalTest_CB1() -> Ice.ValueTypeResolver {
        return CB1_TypeResolver()
    }
}

open class CB1: Ice.Value {
    public var s1: S1 = S1()

    public required init() {}

    public init(s1: S1) {
        self.s1 = s1
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return CB1Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return CB1Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.s1 = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CB1Traits.staticId, compactId: -1, last: true)
        ostr.write(self.s1)
        ostr.endSlice()
    }
}

/// :nodoc:
public class CB2_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return CB2.self
    }
}

public extension Ice.ClassResolver {
    @objc static func LocalTest_CB2() -> Ice.ValueTypeResolver {
        return CB2_TypeResolver()
    }
}

open class CB2: Ice.Value {
    public var c1seq: C1Seq = C1Seq()

    public required init() {}

    public init(c1seq: C1Seq) {
        self.c1seq = c1seq
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return CB2Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return CB2Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.c1seq = try C1SeqHelper.read(from: istr)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CB2Traits.staticId, compactId: -1, last: true)
        C1SeqHelper.write(to: ostr, value: self.c1seq)
        ostr.endSlice()
    }
}

/// :nodoc:
public class CB3_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return CB3.self
    }
}

public extension Ice.ClassResolver {
    @objc static func LocalTest_CB3() -> Ice.ValueTypeResolver {
        return CB3_TypeResolver()
    }
}

open class CB3: Ice.Value {
    public var s1seq: S1Seq = S1Seq()

    public required init() {}

    public init(s1seq: S1Seq) {
        self.s1seq = s1seq
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return CB3Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return CB3Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.s1seq = try S1SeqHelper.read(from: istr)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CB3Traits.staticId, compactId: -1, last: true)
        S1SeqHelper.write(to: ostr, value: self.s1seq)
        ostr.endSlice()
    }
}

/// :nodoc:
public class CB4_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return CB4.self
    }
}

public extension Ice.ClassResolver {
    @objc static func LocalTest_CB4() -> Ice.ValueTypeResolver {
        return CB4_TypeResolver()
    }
}

open class CB4: Ice.Value {
    public var c1dict: C1Dict = C1Dict()

    public required init() {}

    public init(c1dict: C1Dict) {
        self.c1dict = c1dict
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return CB4Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return CB4Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.c1dict = try C1DictHelper.read(from: istr)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CB4Traits.staticId, compactId: -1, last: true)
        C1DictHelper.write(to: ostr, value: self.c1dict)
        ostr.endSlice()
    }
}

/// :nodoc:
public class CB5_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return CB5.self
    }
}

public extension Ice.ClassResolver {
    @objc static func LocalTest_CB5() -> Ice.ValueTypeResolver {
        return CB5_TypeResolver()
    }
}

open class CB5: Ice.Value {
    public var s1dict: S1Dict = S1Dict()

    public required init() {}

    public init(s1dict: S1Dict) {
        self.s1dict = s1dict
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return CB5Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return CB5Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.s1dict = try S1DictHelper.read(from: istr)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CB5Traits.staticId, compactId: -1, last: true)
        S1DictHelper.write(to: ostr, value: self.s1dict)
        ostr.endSlice()
    }
}

/// :nodoc:
public class CB6_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return CB6.self
    }
}

public extension Ice.ClassResolver {
    @objc static func LocalTest_CB6() -> Ice.ValueTypeResolver {
        return CB6_TypeResolver()
    }
}

open class CB6: Ice.Value {
    public var c1seqseq: C1SeqSeq = C1SeqSeq()

    public required init() {}

    public init(c1seqseq: C1SeqSeq) {
        self.c1seqseq = c1seqseq
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return CB6Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return CB6Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.c1seqseq = try C1SeqSeqHelper.read(from: istr)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CB6Traits.staticId, compactId: -1, last: true)
        C1SeqSeqHelper.write(to: ostr, value: self.c1seqseq)
        ostr.endSlice()
    }
}

/// :nodoc:
public class CB7_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return CB7.self
    }
}

public extension Ice.ClassResolver {
    @objc static func LocalTest_CB7() -> Ice.ValueTypeResolver {
        return CB7_TypeResolver()
    }
}

open class CB7: Ice.Value {
    public var s1seqseq: S1SeqSeq = S1SeqSeq()

    public required init() {}

    public init(s1seqseq: S1SeqSeq) {
        self.s1seqseq = s1seqseq
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return CB7Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return CB7Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.s1seqseq = try S1SeqSeqHelper.read(from: istr)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CB7Traits.staticId, compactId: -1, last: true)
        S1SeqSeqHelper.write(to: ostr, value: self.s1seqseq)
        ostr.endSlice()
    }
}

/// :nodoc:
public class CB8_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return CB8.self
    }
}

public extension Ice.ClassResolver {
    @objc static func LocalTest_CB8() -> Ice.ValueTypeResolver {
        return CB8_TypeResolver()
    }
}

open class CB8: Ice.Value {
    public var s1: S1 = S1()
    public var c1seq: C1Seq = C1Seq()
    public var s1dict: S1Dict = S1Dict()

    public required init() {}

    public init(s1: S1, c1seq: C1Seq, s1dict: S1Dict) {
        self.s1 = s1
        self.c1seq = c1seq
        self.s1dict = s1dict
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return CB8Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return CB8Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.s1 = try istr.read()
        self.c1seq = try C1SeqHelper.read(from: istr)
        self.s1dict = try S1DictHelper.read(from: istr)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CB8Traits.staticId, compactId: -1, last: true)
        ostr.write(self.s1)
        C1SeqHelper.write(to: ostr, value: self.c1seq)
        S1DictHelper.write(to: ostr, value: self.s1dict)
        ostr.endSlice()
    }
}
