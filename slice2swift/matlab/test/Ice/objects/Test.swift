//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice
import PromiseKit

public struct S: Swift.Hashable {
    public var str: Swift.String = ""

    public init() {}

    public init(str: Swift.String) {
        self.str = str
    }
}

/// An `Ice.InputStream` extension to read `S` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `S` structured value from the stream.
    ///
    /// - returns: `S` - The structured value read from the stream.
    func read() throws -> S {
        var v = S()
        v.str = try self.read()
        return v
    }

    /// Read an optional `S?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `S?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> S? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as S
    }
}

/// An `Ice.OutputStream` extension to write `S` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `S` structured value to the stream.
    ///
    /// - parameter _: `S` - The value to write to the stream.
    func write(_ v: S) {
        self.write(v.str)
    }

    /// Write an optional `S?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `S?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: S?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// Traits for Slice class `Base`.
public struct BaseTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Base"]
    public static let staticId = "::Test::Base"
}

/// Traits for Slice class `AbstractBase`.
public struct AbstractBaseTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::AbstractBase", "::Test::Base"]
    public static let staticId = "::Test::AbstractBase"
}

/// Traits for Slice class `A`.
public struct ATraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::A"]
    public static let staticId = "::Test::A"
}

/// Traits for Slice class `B`.
public struct BTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::A", "::Test::B"]
    public static let staticId = "::Test::B"
}

/// Traits for Slice class `C`.
public struct CTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::C"]
    public static let staticId = "::Test::C"
}

/// Traits for Slice class `D`.
public struct DTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::D"]
    public static let staticId = "::Test::D"
}

/// Traits for Slice class `E`.
public struct ETraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::E"]
    public static let staticId = "::Test::E"
}

/// Traits for Slice class `F`.
public struct FTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::F"]
    public static let staticId = "::Test::F"
}

/// Traits for Slice class `G`.
public struct GTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Base", "::Test::G"]
    public static let staticId = "::Test::G"
}

/// Traits for Slice interface `I`.
public struct ITraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::I"]
    public static let staticId = "::Test::I"
}

/// Traits for Slice interface `J`.
public struct JTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::I", "::Test::J"]
    public static let staticId = "::Test::J"
}

/// Traits for Slice class `H`.
public struct HTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::H", "::Test::I"]
    public static let staticId = "::Test::H"
}

/// Traits for Slice class `N`.
public struct NTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::N"]
    public static let staticId = "::Test::N"
}

public typealias BaseSeq = [Base?]

/// Helper class to read and write `BaseSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct BaseSeqHelper {
    /// Read a `BaseSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `BaseSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> BaseSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = BaseSeq(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(Base.self) { p.pointee = $0 }
            }
        }
        return v
    }
    /// Read an optional `BaseSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `BaseSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> BaseSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `BaseSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `BaseSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: BaseSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `BaseSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `BaseSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: BaseSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice class `Compact`.
public struct CompactTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Compact"]
    public static let staticId = "::Test::Compact"
}
public let CompactExtId: Swift.Int32 = 789


/// Traits for Slice class `CompactExt`.
public struct CompactExtTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Compact", "::Test::CompactExt"]
    public static let staticId = "::Test::CompactExt"
}

/// Traits for Slice class `InnerA`.
public struct InnerATraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Inner::A"]
    public static let staticId = "::Test::Inner::A"
}

/// :nodoc:
public class InnerEx_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return InnerEx.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Inner_Ex() -> Ice.UserExceptionTypeResolver {
        return InnerEx_TypeResolver()
    }
}

open class InnerEx: Ice.UserException {
    public var reason: Swift.String = ""

    public required init() {}

    public init(reason: Swift.String) {
        self.reason = reason
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::Test::Inner::Ex"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: InnerEx.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.reason)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.reason = try istr.read()
        try istr.endSlice()
    }
}

/// Traits for Slice class `InnerSubA`.
public struct InnerSubATraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Inner::Sub::A"]
    public static let staticId = "::Test::Inner::Sub::A"
}

/// :nodoc:
public class InnerSubEx_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return InnerSubEx.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Inner_Sub_Ex() -> Ice.UserExceptionTypeResolver {
        return InnerSubEx_TypeResolver()
    }
}

open class InnerSubEx: Ice.UserException {
    public var reason: Swift.String = ""

    public required init() {}

    public init(reason: Swift.String) {
        self.reason = reason
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::Test::Inner::Sub::Ex"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: InnerSubEx.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.reason)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.reason = try istr.read()
        try istr.endSlice()
    }
}

/// Traits for Slice class `A1`.
public struct A1Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::A1"]
    public static let staticId = "::Test::A1"
}

/// Traits for Slice class `B1`.
public struct B1Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::B1"]
    public static let staticId = "::Test::B1"
}

/// Traits for Slice class `D1`.
public struct D1Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::B1", "::Test::D1"]
    public static let staticId = "::Test::D1"
}

/// :nodoc:
public class EBase_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return EBase.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_EBase() -> Ice.UserExceptionTypeResolver {
        return EBase_TypeResolver()
    }
}

open class EBase: Ice.UserException {
    public var a1: A1? = nil
    public var a2: A1? = nil

    public required init() {}

    public init(a1: A1?, a2: A1?) {
        self.a1 = a1
        self.a2 = a2
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::Test::EBase"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: EBase.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.a1)
        ostr.write(self.a2)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(A1.self) { self.a1 = $0 }
        try istr.read(A1.self) { self.a2 = $0 }
        try istr.endSlice()
    }

    open override func _usesClasses() -> Swift.Bool {
        return true
    }
}

/// :nodoc:
public class EDerived_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return EDerived.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_EDerived() -> Ice.UserExceptionTypeResolver {
        return EDerived_TypeResolver()
    }
}

open class EDerived: EBase {
    public var a3: A1? = nil
    public var a4: A1? = nil

    public required init() {
        super.init()
    }

    public init(a1: A1?, a2: A1?, a3: A1?, a4: A1?) {
        self.a3 = a3
        self.a4 = a4
        super.init(a1: a1, a2: a2)
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::Test::EDerived"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: EDerived.ice_staticId(), compactId: -1, last: false)
        ostr.write(self.a3)
        ostr.write(self.a4)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(A1.self) { self.a3 = $0 }
        try istr.read(A1.self) { self.a4 = $0 }
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }
}

/// Traits for Slice class `Recursive`.
public struct RecursiveTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Recursive"]
    public static let staticId = "::Test::Recursive"
}

/// Traits for Slice class `K`.
public struct KTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::K"]
    public static let staticId = "::Test::K"
}

/// Traits for Slice class `L`.
public struct LTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::L"]
    public static let staticId = "::Test::L"
}

public typealias ValueSeq = [Ice.Value?]

/// Helper class to read and write `ValueSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ValueSeqHelper {
    /// Read a `ValueSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ValueSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ValueSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = ValueSeq(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read() { p.pointee = $0 }
            }
        }
        return v
    }
    /// Read an optional `ValueSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ValueSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ValueSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ValueSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ValueSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ValueSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `ValueSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ValueSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ValueSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ValueMap = [Swift.String: Ice.Value?]

/// Helper class to read and write `ValueMap` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ValueMapHelper {
    /// Read a `ValueMap` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ValueMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ValueMap {
        let sz = try Swift.Int(istr.readSize())
        var v = ValueMap()
        let e = Ice.DictEntryArray<Swift.String, Ice.Value?>(size: sz)
        for i in 0 ..< sz {
            let key: Swift.String = try istr.read()
            v[key] = nil as Ice.Value?
            Swift.withUnsafeMutablePointer(to: &v[key, default:nil]) {
                e.values[i] = Ice.DictEntry<Swift.String, Ice.Value?>(key: key, value: $0)
            }
            try istr.read() { e.values[i].value.pointee = $0 }
        }
        for i in 0..<sz {
            Swift.withUnsafeMutablePointer(to: &v[e.values[i].key, default:nil]) {
                e.values[i].value = $0
            }
        }
        return v
    }
    /// Read an optional `ValueMap?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ValueMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ValueMap? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ValueMap` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ValueMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ValueMap) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `ValueMap?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ValueMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: ValueMap?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public struct StructKey: Swift.Hashable {
    public var i: Swift.Int32 = 0
    public var s: Swift.String = ""

    public init() {}

    public init(i: Swift.Int32, s: Swift.String) {
        self.i = i
        self.s = s
    }
}

/// An `Ice.InputStream` extension to read `StructKey` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `StructKey` structured value from the stream.
    ///
    /// - returns: `StructKey` - The structured value read from the stream.
    func read() throws -> StructKey {
        var v = StructKey()
        v.i = try self.read()
        v.s = try self.read()
        return v
    }

    /// Read an optional `StructKey?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StructKey?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> StructKey? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as StructKey
    }
}

/// An `Ice.OutputStream` extension to write `StructKey` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `StructKey` structured value to the stream.
    ///
    /// - parameter _: `StructKey` - The value to write to the stream.
    func write(_ v: StructKey) {
        self.write(v.i)
        self.write(v.s)
    }

    /// Write an optional `StructKey?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StructKey?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: StructKey?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public typealias LMap = [StructKey: L?]

/// Helper class to read and write `LMap` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LMapHelper {
    /// Read a `LMap` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `LMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LMap {
        let sz = try Swift.Int(istr.readSize())
        var v = LMap()
        let e = Ice.DictEntryArray<StructKey, L?>(size: sz)
        for i in 0 ..< sz {
            let key: StructKey = try istr.read()
            v[key] = nil as L?
            Swift.withUnsafeMutablePointer(to: &v[key, default:nil]) {
                e.values[i] = Ice.DictEntry<StructKey, L?>(key: key, value: $0)
            }
            try istr.read(L.self) { e.values[i].value.pointee = $0 }
        }
        for i in 0..<sz {
            Swift.withUnsafeMutablePointer(to: &v[e.values[i].key, default:nil]) {
                e.values[i].value = $0
            }
        }
        return v
    }
    /// Read an optional `LMap?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LMap? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `LMap` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `LMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LMap) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `LMap?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: LMap?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice class `M`.
public struct MTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::M"]
    public static let staticId = "::Test::M"
}

/// Traits for Slice class `F3`.
public struct F3Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::F3"]
    public static let staticId = "::Test::F3"
}

/// Traits for Slice interface `Initial`.
public struct InitialTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Initial"]
    public static let staticId = "::Test::Initial"
}

/// Traits for Slice class `Empty`.
public struct EmptyTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Empty"]
    public static let staticId = "::Test::Empty"
}

/// Traits for Slice class `AlsoEmpty`.
public struct AlsoEmptyTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::AlsoEmpty"]
    public static let staticId = "::Test::AlsoEmpty"
}

/// Traits for Slice interface `UnexpectedObjectExceptionTest`.
public struct UnexpectedObjectExceptionTestTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::UnexpectedObjectExceptionTest"]
    public static let staticId = "::Test::UnexpectedObjectExceptionTest"
}

/// Traits for Slice class `COneMember`.
public struct COneMemberTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::COneMember"]
    public static let staticId = "::Test::COneMember"
}

/// Traits for Slice class `CTwoMembers`.
public struct CTwoMembersTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::CTwoMembers"]
    public static let staticId = "::Test::CTwoMembers"
}

/// :nodoc:
public class EOneMember_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return EOneMember.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_EOneMember() -> Ice.UserExceptionTypeResolver {
        return EOneMember_TypeResolver()
    }
}

open class EOneMember: Ice.UserException {
    public var e: Empty? = nil

    public required init() {}

    public init(e: Empty?) {
        self.e = e
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::Test::EOneMember"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: EOneMember.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.e)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(Empty.self) { self.e = $0 }
        try istr.endSlice()
    }

    open override func _usesClasses() -> Swift.Bool {
        return true
    }
}

/// :nodoc:
public class ETwoMembers_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return ETwoMembers.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_ETwoMembers() -> Ice.UserExceptionTypeResolver {
        return ETwoMembers_TypeResolver()
    }
}

open class ETwoMembers: Ice.UserException {
    public var e1: Empty? = nil
    public var e2: Empty? = nil

    public required init() {}

    public init(e1: Empty?, e2: Empty?) {
        self.e1 = e1
        self.e2 = e2
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::Test::ETwoMembers"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: ETwoMembers.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.e1)
        ostr.write(self.e2)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(Empty.self) { self.e1 = $0 }
        try istr.read(Empty.self) { self.e2 = $0 }
        try istr.endSlice()
    }

    open override func _usesClasses() -> Swift.Bool {
        return true
    }
}

public class SOneMember {
    public var e: Empty? = nil

    public init() {}

    public init(e: Empty?) {
        self.e = e
    }
}

/// An `Ice.InputStream` extension to read `SOneMember` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `SOneMember` structured value from the stream.
    ///
    /// - returns: `SOneMember` - The structured value read from the stream.
    func read() throws -> SOneMember {
        let v = SOneMember()
        try self.read(Empty.self) { v.e = $0 }
        return v
    }

    /// Read an optional `SOneMember?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `SOneMember?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> SOneMember? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as SOneMember
    }
}

/// An `Ice.OutputStream` extension to write `SOneMember` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `SOneMember` structured value to the stream.
    ///
    /// - parameter _: `SOneMember` - The value to write to the stream.
    func write(_ v: SOneMember) {
        self.write(v.e)
    }

    /// Write an optional `SOneMember?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `SOneMember?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: SOneMember?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public class STwoMembers {
    public var e1: Empty? = nil
    public var e2: Empty? = nil

    public init() {}

    public init(e1: Empty?, e2: Empty?) {
        self.e1 = e1
        self.e2 = e2
    }
}

/// An `Ice.InputStream` extension to read `STwoMembers` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `STwoMembers` structured value from the stream.
    ///
    /// - returns: `STwoMembers` - The structured value read from the stream.
    func read() throws -> STwoMembers {
        let v = STwoMembers()
        try self.read(Empty.self) { v.e1 = $0 }
        try self.read(Empty.self) { v.e2 = $0 }
        return v
    }

    /// Read an optional `STwoMembers?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `STwoMembers?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> STwoMembers? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as STwoMembers
    }
}

/// An `Ice.OutputStream` extension to write `STwoMembers` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `STwoMembers` structured value to the stream.
    ///
    /// - parameter _: `STwoMembers` - The value to write to the stream.
    func write(_ v: STwoMembers) {
        self.write(v.e1)
        self.write(v.e2)
    }

    /// Write an optional `STwoMembers?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `STwoMembers?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: STwoMembers?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public typealias DOneMember = [Swift.Int32: COneMember?]

/// Helper class to read and write `DOneMember` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct DOneMemberHelper {
    /// Read a `DOneMember` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `DOneMember` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> DOneMember {
        let sz = try Swift.Int(istr.readSize())
        var v = DOneMember()
        let e = Ice.DictEntryArray<Swift.Int32, COneMember?>(size: sz)
        for i in 0 ..< sz {
            let key: Swift.Int32 = try istr.read()
            v[key] = nil as COneMember?
            Swift.withUnsafeMutablePointer(to: &v[key, default:nil]) {
                e.values[i] = Ice.DictEntry<Swift.Int32, COneMember?>(key: key, value: $0)
            }
            try istr.read(COneMember.self) { e.values[i].value.pointee = $0 }
        }
        for i in 0..<sz {
            Swift.withUnsafeMutablePointer(to: &v[e.values[i].key, default:nil]) {
                e.values[i].value = $0
            }
        }
        return v
    }
    /// Read an optional `DOneMember?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `DOneMember` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> DOneMember? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `DOneMember` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `DOneMember` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: DOneMember) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `DOneMember?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `DOneMember` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: DOneMember?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias DTwoMembers = [Swift.Int32: CTwoMembers?]

/// Helper class to read and write `DTwoMembers` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct DTwoMembersHelper {
    /// Read a `DTwoMembers` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `DTwoMembers` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> DTwoMembers {
        let sz = try Swift.Int(istr.readSize())
        var v = DTwoMembers()
        let e = Ice.DictEntryArray<Swift.Int32, CTwoMembers?>(size: sz)
        for i in 0 ..< sz {
            let key: Swift.Int32 = try istr.read()
            v[key] = nil as CTwoMembers?
            Swift.withUnsafeMutablePointer(to: &v[key, default:nil]) {
                e.values[i] = Ice.DictEntry<Swift.Int32, CTwoMembers?>(key: key, value: $0)
            }
            try istr.read(CTwoMembers.self) { e.values[i].value.pointee = $0 }
        }
        for i in 0..<sz {
            Swift.withUnsafeMutablePointer(to: &v[e.values[i].key, default:nil]) {
                e.values[i].value = $0
            }
        }
        return v
    }
    /// Read an optional `DTwoMembers?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `DTwoMembers` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> DTwoMembers? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `DTwoMembers` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `DTwoMembers` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: DTwoMembers) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `DTwoMembers?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `DTwoMembers` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: DTwoMembers?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// AbstractBasePrx overview.
///
/// AbstractBasePrx Methods:
///
///  - op: 
///
///  - opAsync: 
public protocol AbstractBasePrx: Ice.ObjectPrx {}

private final class AbstractBasePrxI: Ice.ObjectPrxI, AbstractBasePrx {
    public override class func ice_staticId() -> Swift.String {
        return AbstractBaseTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `AbstractBasePrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `AbstractBasePrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: AbstractBasePrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> AbstractBasePrx? {
    return try AbstractBasePrxI.checkedCast(prx: prx, facet: facet, context: context) as AbstractBasePrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `AbstractBasePrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `AbstractBasePrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: AbstractBasePrx.Protocol, facet: Swift.String? = nil) -> AbstractBasePrx {
    return AbstractBasePrxI.uncheckedCast(prx: prx, facet: facet) as AbstractBasePrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `AbstractBasePrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: AbstractBasePrx.Protocol) -> Swift.String {
    return AbstractBaseTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `AbstractBasePrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `AbstractBasePrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `AbstractBasePrx?` - The extracted proxy
    func read(_ type: AbstractBasePrx.Protocol) throws -> AbstractBasePrx? {
        return try read() as AbstractBasePrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `AbstractBasePrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `AbstractBasePrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: AbstractBasePrx.Protocol) throws -> AbstractBasePrx? {
        return try read(tag: tag) as AbstractBasePrxI?
    }
}

/// AbstractBasePrx overview.
///
/// AbstractBasePrx Methods:
///
///  - op: 
///
///  - opAsync: 
public extension AbstractBasePrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func op(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "op",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func opAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "op",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// IPrx overview.
public protocol IPrx: Ice.ObjectPrx {}

private final class IPrxI: Ice.ObjectPrxI, IPrx {
    public override class func ice_staticId() -> Swift.String {
        return ITraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `IPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `IPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: IPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> IPrx? {
    return try IPrxI.checkedCast(prx: prx, facet: facet, context: context) as IPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `IPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `IPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: IPrx.Protocol, facet: Swift.String? = nil) -> IPrx {
    return IPrxI.uncheckedCast(prx: prx, facet: facet) as IPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `IPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: IPrx.Protocol) -> Swift.String {
    return ITraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `IPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `IPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `IPrx?` - The extracted proxy
    func read(_ type: IPrx.Protocol) throws -> IPrx? {
        return try read() as IPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `IPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `IPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: IPrx.Protocol) throws -> IPrx? {
        return try read(tag: tag) as IPrxI?
    }
}

/// IPrx overview.
public extension IPrx {}

/// JPrx overview.
public protocol JPrx: IPrx {}

private final class JPrxI: Ice.ObjectPrxI, JPrx {
    public override class func ice_staticId() -> Swift.String {
        return JTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `JPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `JPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: JPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> JPrx? {
    return try JPrxI.checkedCast(prx: prx, facet: facet, context: context) as JPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `JPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `JPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: JPrx.Protocol, facet: Swift.String? = nil) -> JPrx {
    return JPrxI.uncheckedCast(prx: prx, facet: facet) as JPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `JPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: JPrx.Protocol) -> Swift.String {
    return JTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `JPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `JPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `JPrx?` - The extracted proxy
    func read(_ type: JPrx.Protocol) throws -> JPrx? {
        return try read() as JPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `JPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `JPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: JPrx.Protocol) throws -> JPrx? {
        return try read(tag: tag) as JPrxI?
    }
}

/// JPrx overview.
public extension JPrx {}

/// InitialPrx overview.
///
/// InitialPrx Methods:
///
///  - shutdown: 
///
///  - shutdownAsync: 
///
///  - getB1: 
///
///  - getB1Async: 
///
///  - getB2: 
///
///  - getB2Async: 
///
///  - getC: 
///
///  - getCAsync: 
///
///  - getD: 
///
///  - getDAsync: 
///
///  - getE: 
///
///  - getEAsync: 
///
///  - getF: 
///
///  - getFAsync: 
///
///  - setRecursive: 
///
///  - setRecursiveAsync: 
///
///  - supportsClassGraphDepthMax: 
///
///  - supportsClassGraphDepthMaxAsync: 
///
///  - setCycle: 
///
///  - setCycleAsync: 
///
///  - acceptsClassCycles: 
///
///  - acceptsClassCyclesAsync: 
///
///  - getMB: 
///
///  - getMBAsync: 
///
///  - getAMDMB: 
///
///  - getAMDMBAsync: 
///
///  - getAll: 
///
///  - getAllAsync: 
///
///  - getH: 
///
///  - getHAsync: 
///
///  - getI: 
///
///  - getIAsync: 
///
///  - getJ: 
///
///  - getJAsync: 
///
///  - getK: 
///
///  - getKAsync: 
///
///  - opValue: 
///
///  - opValueAsync: 
///
///  - opValueSeq: 
///
///  - opValueSeqAsync: 
///
///  - opValueMap: 
///
///  - opValueMapAsync: 
///
///  - getD1: 
///
///  - getD1Async: 
///
///  - throwEDerived: 
///
///  - throwEDerivedAsync: 
///
///  - setG: 
///
///  - setGAsync: 
///
///  - setI: 
///
///  - setIAsync: 
///
///  - opBaseSeq: 
///
///  - opBaseSeqAsync: 
///
///  - getCompact: 
///
///  - getCompactAsync: 
///
///  - getInnerA: 
///
///  - getInnerAAsync: 
///
///  - getInnerSubA: 
///
///  - getInnerSubAAsync: 
///
///  - throwInnerEx: 
///
///  - throwInnerExAsync: 
///
///  - throwInnerSubEx: 
///
///  - throwInnerSubExAsync: 
///
///  - opM: 
///
///  - opMAsync: 
///
///  - opF1: 
///
///  - opF1Async: 
///
///  - opF2: 
///
///  - opF2Async: 
///
///  - opF3: 
///
///  - opF3Async: 
///
///  - hasF3: 
///
///  - hasF3Async: 
///
///  - opN: 
///
///  - opNAsync: 
public protocol InitialPrx: Ice.ObjectPrx {}

private final class InitialPrxI: Ice.ObjectPrxI, InitialPrx {
    public override class func ice_staticId() -> Swift.String {
        return InitialTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `InitialPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `InitialPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: InitialPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> InitialPrx? {
    return try InitialPrxI.checkedCast(prx: prx, facet: facet, context: context) as InitialPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `InitialPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `InitialPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: InitialPrx.Protocol, facet: Swift.String? = nil) -> InitialPrx {
    return InitialPrxI.uncheckedCast(prx: prx, facet: facet) as InitialPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `InitialPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: InitialPrx.Protocol) -> Swift.String {
    return InitialTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `InitialPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `InitialPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `InitialPrx?` - The extracted proxy
    func read(_ type: InitialPrx.Protocol) throws -> InitialPrx? {
        return try read() as InitialPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `InitialPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `InitialPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: InitialPrx.Protocol) throws -> InitialPrx? {
        return try read(tag: tag) as InitialPrxI?
    }
}

/// InitialPrx overview.
///
/// InitialPrx Methods:
///
///  - shutdown: 
///
///  - shutdownAsync: 
///
///  - getB1: 
///
///  - getB1Async: 
///
///  - getB2: 
///
///  - getB2Async: 
///
///  - getC: 
///
///  - getCAsync: 
///
///  - getD: 
///
///  - getDAsync: 
///
///  - getE: 
///
///  - getEAsync: 
///
///  - getF: 
///
///  - getFAsync: 
///
///  - setRecursive: 
///
///  - setRecursiveAsync: 
///
///  - supportsClassGraphDepthMax: 
///
///  - supportsClassGraphDepthMaxAsync: 
///
///  - setCycle: 
///
///  - setCycleAsync: 
///
///  - acceptsClassCycles: 
///
///  - acceptsClassCyclesAsync: 
///
///  - getMB: 
///
///  - getMBAsync: 
///
///  - getAMDMB: 
///
///  - getAMDMBAsync: 
///
///  - getAll: 
///
///  - getAllAsync: 
///
///  - getH: 
///
///  - getHAsync: 
///
///  - getI: 
///
///  - getIAsync: 
///
///  - getJ: 
///
///  - getJAsync: 
///
///  - getK: 
///
///  - getKAsync: 
///
///  - opValue: 
///
///  - opValueAsync: 
///
///  - opValueSeq: 
///
///  - opValueSeqAsync: 
///
///  - opValueMap: 
///
///  - opValueMapAsync: 
///
///  - getD1: 
///
///  - getD1Async: 
///
///  - throwEDerived: 
///
///  - throwEDerivedAsync: 
///
///  - setG: 
///
///  - setGAsync: 
///
///  - setI: 
///
///  - setIAsync: 
///
///  - opBaseSeq: 
///
///  - opBaseSeqAsync: 
///
///  - getCompact: 
///
///  - getCompactAsync: 
///
///  - getInnerA: 
///
///  - getInnerAAsync: 
///
///  - getInnerSubA: 
///
///  - getInnerSubAAsync: 
///
///  - throwInnerEx: 
///
///  - throwInnerExAsync: 
///
///  - throwInnerSubEx: 
///
///  - throwInnerSubExAsync: 
///
///  - opM: 
///
///  - opMAsync: 
///
///  - opF1: 
///
///  - opF1Async: 
///
///  - opF2: 
///
///  - opF2Async: 
///
///  - opF3: 
///
///  - opF3Async: 
///
///  - hasF3: 
///
///  - hasF3Async: 
///
///  - opN: 
///
///  - opNAsync: 
public extension InitialPrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func shutdown(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "shutdown",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func shutdownAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "shutdown",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `B?`
    func getB1(context: Ice.Context? = nil) throws -> B? {
        return try _impl._invoke(operation: "getB1",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: B?
                                     try istr.read(B.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<B?>` - The result of the operation
    func getB1Async(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<B?> {
        return _impl._invokeAsync(operation: "getB1",
                                  mode: .Normal,
                                  read: { istr in
                                      var iceP_returnValue: B?
                                      try istr.read(B.self) { iceP_returnValue = $0 }
                                      try istr.readPendingValues()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `B?`
    func getB2(context: Ice.Context? = nil) throws -> B? {
        return try _impl._invoke(operation: "getB2",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: B?
                                     try istr.read(B.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<B?>` - The result of the operation
    func getB2Async(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<B?> {
        return _impl._invokeAsync(operation: "getB2",
                                  mode: .Normal,
                                  read: { istr in
                                      var iceP_returnValue: B?
                                      try istr.read(B.self) { iceP_returnValue = $0 }
                                      try istr.readPendingValues()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `C?`
    func getC(context: Ice.Context? = nil) throws -> C? {
        return try _impl._invoke(operation: "getC",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: C?
                                     try istr.read(C.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<C?>` - The result of the operation
    func getCAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<C?> {
        return _impl._invokeAsync(operation: "getC",
                                  mode: .Normal,
                                  read: { istr in
                                      var iceP_returnValue: C?
                                      try istr.read(C.self) { iceP_returnValue = $0 }
                                      try istr.readPendingValues()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `D?`
    func getD(context: Ice.Context? = nil) throws -> D? {
        return try _impl._invoke(operation: "getD",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: D?
                                     try istr.read(D.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<D?>` - The result of the operation
    func getDAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<D?> {
        return _impl._invokeAsync(operation: "getD",
                                  mode: .Normal,
                                  read: { istr in
                                      var iceP_returnValue: D?
                                      try istr.read(D.self) { iceP_returnValue = $0 }
                                      try istr.readPendingValues()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `E?`
    func getE(context: Ice.Context? = nil) throws -> E? {
        return try _impl._invoke(operation: "getE",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: E?
                                     try istr.read(E.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<E?>` - The result of the operation
    func getEAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<E?> {
        return _impl._invokeAsync(operation: "getE",
                                  mode: .Normal,
                                  read: { istr in
                                      var iceP_returnValue: E?
                                      try istr.read(E.self) { iceP_returnValue = $0 }
                                      try istr.readPendingValues()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `F?`
    func getF(context: Ice.Context? = nil) throws -> F? {
        return try _impl._invoke(operation: "getF",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: F?
                                     try istr.read(F.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<F?>` - The result of the operation
    func getFAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<F?> {
        return _impl._invokeAsync(operation: "getF",
                                  mode: .Normal,
                                  read: { istr in
                                      var iceP_returnValue: F?
                                      try istr.read(F.self) { iceP_returnValue = $0 }
                                      try istr.readPendingValues()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `Recursive?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func setRecursive(_ iceP_p: Recursive?, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "setRecursive",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_p)
                              ostr.writePendingValues()
                          },
                          context: context)
    }

    ///
    /// - parameter _: `Recursive?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func setRecursiveAsync(_ iceP_p: Recursive?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "setRecursive",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_p)
                                      ostr.writePendingValues()
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Bool`
    func supportsClassGraphDepthMax(context: Ice.Context? = nil) throws -> Swift.Bool {
        return try _impl._invoke(operation: "supportsClassGraphDepthMax",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: Swift.Bool = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Bool>` - The result of the operation
    func supportsClassGraphDepthMaxAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Bool> {
        return _impl._invokeAsync(operation: "supportsClassGraphDepthMax",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_returnValue: Swift.Bool = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `Recursive?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func setCycle(_ iceP_r: Recursive?, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "setCycle",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_r)
                              ostr.writePendingValues()
                          },
                          context: context)
    }

    ///
    /// - parameter _: `Recursive?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func setCycleAsync(_ iceP_r: Recursive?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "setCycle",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_r)
                                      ostr.writePendingValues()
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Bool`
    func acceptsClassCycles(context: Ice.Context? = nil) throws -> Swift.Bool {
        return try _impl._invoke(operation: "acceptsClassCycles",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: Swift.Bool = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Bool>` - The result of the operation
    func acceptsClassCyclesAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Bool> {
        return _impl._invokeAsync(operation: "acceptsClassCycles",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_returnValue: Swift.Bool = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `B?`
    func getMB(context: Ice.Context? = nil) throws -> B? {
        return try _impl._invoke(operation: "getMB",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: B?
                                     try istr.read(B.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<B?>` - The result of the operation
    func getMBAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<B?> {
        return _impl._invokeAsync(operation: "getMB",
                                  mode: .Normal,
                                  read: { istr in
                                      var iceP_returnValue: B?
                                      try istr.read(B.self) { iceP_returnValue = $0 }
                                      try istr.readPendingValues()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `B?`
    func getAMDMB(context: Ice.Context? = nil) throws -> B? {
        return try _impl._invoke(operation: "getAMDMB",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: B?
                                     try istr.read(B.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<B?>` - The result of the operation
    func getAMDMBAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<B?> {
        return _impl._invokeAsync(operation: "getAMDMB",
                                  mode: .Normal,
                                  read: { istr in
                                      var iceP_returnValue: B?
                                      try istr.read(B.self) { iceP_returnValue = $0 }
                                      try istr.readPendingValues()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(b1: B?, b2: B?, theC: C?, theD: D?)`:
    ///
    ///   - b1: `B?`
    ///
    ///   - b2: `B?`
    ///
    ///   - theC: `C?`
    ///
    ///   - theD: `D?`
    func getAll(context: Ice.Context? = nil) throws -> (b1: B?, b2: B?, theC: C?, theD: D?) {
        return try _impl._invoke(operation: "getAll",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_b1: B?
                                     try istr.read(B.self) { iceP_b1 = $0 }
                                     var iceP_b2: B?
                                     try istr.read(B.self) { iceP_b2 = $0 }
                                     var iceP_theC: C?
                                     try istr.read(C.self) { iceP_theC = $0 }
                                     var iceP_theD: D?
                                     try istr.read(D.self) { iceP_theD = $0 }
                                     try istr.readPendingValues()
                                     return (iceP_b1, iceP_b2, iceP_theC, iceP_theD)
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(b1: B?, b2: B?, theC: C?, theD: D?)>` - The result of the operation
    func getAllAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(b1: B?, b2: B?, theC: C?, theD: D?)> {
        return _impl._invokeAsync(operation: "getAll",
                                  mode: .Normal,
                                  read: { istr in
                                      var iceP_b1: B?
                                      try istr.read(B.self) { iceP_b1 = $0 }
                                      var iceP_b2: B?
                                      try istr.read(B.self) { iceP_b2 = $0 }
                                      var iceP_theC: C?
                                      try istr.read(C.self) { iceP_theC = $0 }
                                      var iceP_theD: D?
                                      try istr.read(D.self) { iceP_theD = $0 }
                                      try istr.readPendingValues()
                                      return (iceP_b1, iceP_b2, iceP_theC, iceP_theD)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.Value?`
    func getH(context: Ice.Context? = nil) throws -> Ice.Value? {
        return try _impl._invoke(operation: "getH",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: Ice.Value?
                                     try istr.read() { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Ice.Value?>` - The result of the operation
    func getHAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Ice.Value?> {
        return _impl._invokeAsync(operation: "getH",
                                  mode: .Normal,
                                  read: { istr in
                                      var iceP_returnValue: Ice.Value?
                                      try istr.read() { iceP_returnValue = $0 }
                                      try istr.readPendingValues()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.Value?`
    func getI(context: Ice.Context? = nil) throws -> Ice.Value? {
        return try _impl._invoke(operation: "getI",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: Ice.Value?
                                     try istr.read() { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Ice.Value?>` - The result of the operation
    func getIAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Ice.Value?> {
        return _impl._invokeAsync(operation: "getI",
                                  mode: .Normal,
                                  read: { istr in
                                      var iceP_returnValue: Ice.Value?
                                      try istr.read() { iceP_returnValue = $0 }
                                      try istr.readPendingValues()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.Value?`
    func getJ(context: Ice.Context? = nil) throws -> Ice.Value? {
        return try _impl._invoke(operation: "getJ",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: Ice.Value?
                                     try istr.read() { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Ice.Value?>` - The result of the operation
    func getJAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Ice.Value?> {
        return _impl._invokeAsync(operation: "getJ",
                                  mode: .Normal,
                                  read: { istr in
                                      var iceP_returnValue: Ice.Value?
                                      try istr.read() { iceP_returnValue = $0 }
                                      try istr.readPendingValues()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `K?`
    func getK(context: Ice.Context? = nil) throws -> K? {
        return try _impl._invoke(operation: "getK",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: K?
                                     try istr.read(K.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<K?>` - The result of the operation
    func getKAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<K?> {
        return _impl._invokeAsync(operation: "getK",
                                  mode: .Normal,
                                  read: { istr in
                                      var iceP_returnValue: K?
                                      try istr.read(K.self) { iceP_returnValue = $0 }
                                      try istr.readPendingValues()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `Ice.Value?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: Ice.Value?, v2: Ice.Value?)`:
    ///
    ///   - returnValue: `Ice.Value?`
    ///
    ///   - v2: `Ice.Value?`
    func opValue(_ iceP_v1: Ice.Value?, context: Ice.Context? = nil) throws -> (returnValue: Ice.Value?, v2: Ice.Value?) {
        return try _impl._invoke(operation: "opValue",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_v1)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     var iceP_v2: Ice.Value?
                                     try istr.read() { iceP_v2 = $0 }
                                     var iceP_returnValue: Ice.Value?
                                     try istr.read() { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return (iceP_returnValue, iceP_v2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `Ice.Value?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: Ice.Value?, v2: Ice.Value?)>` - The result of the operation
    func opValueAsync(_ iceP_v1: Ice.Value?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: Ice.Value?, v2: Ice.Value?)> {
        return _impl._invokeAsync(operation: "opValue",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_v1)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      var iceP_v2: Ice.Value?
                                      try istr.read() { iceP_v2 = $0 }
                                      var iceP_returnValue: Ice.Value?
                                      try istr.read() { iceP_returnValue = $0 }
                                      try istr.readPendingValues()
                                      return (iceP_returnValue, iceP_v2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `ValueSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: ValueSeq, v2: ValueSeq)`:
    ///
    ///   - returnValue: `ValueSeq`
    ///
    ///   - v2: `ValueSeq`
    func opValueSeq(_ iceP_v1: ValueSeq, context: Ice.Context? = nil) throws -> (returnValue: ValueSeq, v2: ValueSeq) {
        return try _impl._invoke(operation: "opValueSeq",
                                 mode: .Normal,
                                 write: { ostr in
                                     ValueSeqHelper.write(to: ostr, value: iceP_v1)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     let iceP_v2: ValueSeq = try ValueSeqHelper.read(from: istr)
                                     let iceP_returnValue: ValueSeq = try ValueSeqHelper.read(from: istr)
                                     try istr.readPendingValues()
                                     return (iceP_returnValue, iceP_v2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `ValueSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: ValueSeq, v2: ValueSeq)>` - The result of the operation
    func opValueSeqAsync(_ iceP_v1: ValueSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: ValueSeq, v2: ValueSeq)> {
        return _impl._invokeAsync(operation: "opValueSeq",
                                  mode: .Normal,
                                  write: { ostr in
                                      ValueSeqHelper.write(to: ostr, value: iceP_v1)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      let iceP_v2: ValueSeq = try ValueSeqHelper.read(from: istr)
                                      let iceP_returnValue: ValueSeq = try ValueSeqHelper.read(from: istr)
                                      try istr.readPendingValues()
                                      return (iceP_returnValue, iceP_v2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `ValueMap`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: ValueMap, v2: ValueMap)`:
    ///
    ///   - returnValue: `ValueMap`
    ///
    ///   - v2: `ValueMap`
    func opValueMap(_ iceP_v1: ValueMap, context: Ice.Context? = nil) throws -> (returnValue: ValueMap, v2: ValueMap) {
        return try _impl._invoke(operation: "opValueMap",
                                 mode: .Normal,
                                 write: { ostr in
                                     ValueMapHelper.write(to: ostr, value: iceP_v1)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     let iceP_v2: ValueMap = try ValueMapHelper.read(from: istr)
                                     let iceP_returnValue: ValueMap = try ValueMapHelper.read(from: istr)
                                     try istr.readPendingValues()
                                     return (iceP_returnValue, iceP_v2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `ValueMap`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: ValueMap, v2: ValueMap)>` - The result of the operation
    func opValueMapAsync(_ iceP_v1: ValueMap, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: ValueMap, v2: ValueMap)> {
        return _impl._invokeAsync(operation: "opValueMap",
                                  mode: .Normal,
                                  write: { ostr in
                                      ValueMapHelper.write(to: ostr, value: iceP_v1)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      let iceP_v2: ValueMap = try ValueMapHelper.read(from: istr)
                                      let iceP_returnValue: ValueMap = try ValueMapHelper.read(from: istr)
                                      try istr.readPendingValues()
                                      return (iceP_returnValue, iceP_v2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `D1?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `D1?`
    func getD1(_ iceP_d1: D1?, context: Ice.Context? = nil) throws -> D1? {
        return try _impl._invoke(operation: "getD1",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_d1)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     var iceP_returnValue: D1?
                                     try istr.read(D1.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `D1?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<D1?>` - The result of the operation
    func getD1Async(_ iceP_d1: D1?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<D1?> {
        return _impl._invokeAsync(operation: "getD1",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_d1)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      var iceP_returnValue: D1?
                                      try istr.read(D1.self) { iceP_returnValue = $0 }
                                      try istr.readPendingValues()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func throwEDerived(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "throwEDerived",
                          mode: .Normal,
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as EDerived {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func throwEDerivedAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "throwEDerived",
                                  mode: .Normal,
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as EDerived {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `G?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func setG(_ iceP_theG: G?, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "setG",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_theG)
                              ostr.writePendingValues()
                          },
                          context: context)
    }

    ///
    /// - parameter _: `G?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func setGAsync(_ iceP_theG: G?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "setG",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_theG)
                                      ostr.writePendingValues()
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `Ice.Value?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func setI(_ iceP_theI: Ice.Value?, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "setI",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_theI)
                              ostr.writePendingValues()
                          },
                          context: context)
    }

    ///
    /// - parameter _: `Ice.Value?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func setIAsync(_ iceP_theI: Ice.Value?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "setI",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_theI)
                                      ostr.writePendingValues()
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `BaseSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: BaseSeq, outSeq: BaseSeq)`:
    ///
    ///   - returnValue: `BaseSeq`
    ///
    ///   - outSeq: `BaseSeq`
    func opBaseSeq(_ iceP_inSeq: BaseSeq, context: Ice.Context? = nil) throws -> (returnValue: BaseSeq, outSeq: BaseSeq) {
        return try _impl._invoke(operation: "opBaseSeq",
                                 mode: .Normal,
                                 write: { ostr in
                                     BaseSeqHelper.write(to: ostr, value: iceP_inSeq)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     let iceP_outSeq: BaseSeq = try BaseSeqHelper.read(from: istr)
                                     let iceP_returnValue: BaseSeq = try BaseSeqHelper.read(from: istr)
                                     try istr.readPendingValues()
                                     return (iceP_returnValue, iceP_outSeq)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `BaseSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: BaseSeq, outSeq: BaseSeq)>` - The result of the operation
    func opBaseSeqAsync(_ iceP_inSeq: BaseSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: BaseSeq, outSeq: BaseSeq)> {
        return _impl._invokeAsync(operation: "opBaseSeq",
                                  mode: .Normal,
                                  write: { ostr in
                                      BaseSeqHelper.write(to: ostr, value: iceP_inSeq)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      let iceP_outSeq: BaseSeq = try BaseSeqHelper.read(from: istr)
                                      let iceP_returnValue: BaseSeq = try BaseSeqHelper.read(from: istr)
                                      try istr.readPendingValues()
                                      return (iceP_returnValue, iceP_outSeq)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Compact?`
    func getCompact(context: Ice.Context? = nil) throws -> Compact? {
        return try _impl._invoke(operation: "getCompact",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: Compact?
                                     try istr.read(Compact.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Compact?>` - The result of the operation
    func getCompactAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Compact?> {
        return _impl._invokeAsync(operation: "getCompact",
                                  mode: .Normal,
                                  read: { istr in
                                      var iceP_returnValue: Compact?
                                      try istr.read(Compact.self) { iceP_returnValue = $0 }
                                      try istr.readPendingValues()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `InnerA?`
    func getInnerA(context: Ice.Context? = nil) throws -> InnerA? {
        return try _impl._invoke(operation: "getInnerA",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: InnerA?
                                     try istr.read(InnerA.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<InnerA?>` - The result of the operation
    func getInnerAAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<InnerA?> {
        return _impl._invokeAsync(operation: "getInnerA",
                                  mode: .Normal,
                                  read: { istr in
                                      var iceP_returnValue: InnerA?
                                      try istr.read(InnerA.self) { iceP_returnValue = $0 }
                                      try istr.readPendingValues()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `InnerSubA?`
    func getInnerSubA(context: Ice.Context? = nil) throws -> InnerSubA? {
        return try _impl._invoke(operation: "getInnerSubA",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: InnerSubA?
                                     try istr.read(InnerSubA.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<InnerSubA?>` - The result of the operation
    func getInnerSubAAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<InnerSubA?> {
        return _impl._invokeAsync(operation: "getInnerSubA",
                                  mode: .Normal,
                                  read: { istr in
                                      var iceP_returnValue: InnerSubA?
                                      try istr.read(InnerSubA.self) { iceP_returnValue = $0 }
                                      try istr.readPendingValues()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func throwInnerEx(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "throwInnerEx",
                          mode: .Normal,
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as InnerEx {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func throwInnerExAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "throwInnerEx",
                                  mode: .Normal,
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as InnerEx {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func throwInnerSubEx(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "throwInnerSubEx",
                          mode: .Normal,
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as InnerSubEx {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func throwInnerSubExAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "throwInnerSubEx",
                                  mode: .Normal,
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as InnerSubEx {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `M?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: M?, v2: M?)`:
    ///
    ///   - returnValue: `M?`
    ///
    ///   - v2: `M?`
    func opM(_ iceP_v1: M?, context: Ice.Context? = nil) throws -> (returnValue: M?, v2: M?) {
        return try _impl._invoke(operation: "opM",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_v1)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     var iceP_v2: M?
                                     try istr.read(M.self) { iceP_v2 = $0 }
                                     var iceP_returnValue: M?
                                     try istr.read(M.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return (iceP_returnValue, iceP_v2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `M?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: M?, v2: M?)>` - The result of the operation
    func opMAsync(_ iceP_v1: M?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: M?, v2: M?)> {
        return _impl._invokeAsync(operation: "opM",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_v1)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      var iceP_v2: M?
                                      try istr.read(M.self) { iceP_v2 = $0 }
                                      var iceP_returnValue: M?
                                      try istr.read(M.self) { iceP_returnValue = $0 }
                                      try istr.readPendingValues()
                                      return (iceP_returnValue, iceP_v2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `F1?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: F1?, f12: F1?)`:
    ///
    ///   - returnValue: `F1?`
    ///
    ///   - f12: `F1?`
    func opF1(_ iceP_f11: F1?, context: Ice.Context? = nil) throws -> (returnValue: F1?, f12: F1?) {
        return try _impl._invoke(operation: "opF1",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_f11)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     var iceP_f12: F1?
                                     try istr.read(F1.self) { iceP_f12 = $0 }
                                     var iceP_returnValue: F1?
                                     try istr.read(F1.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return (iceP_returnValue, iceP_f12)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `F1?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: F1?, f12: F1?)>` - The result of the operation
    func opF1Async(_ iceP_f11: F1?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: F1?, f12: F1?)> {
        return _impl._invokeAsync(operation: "opF1",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_f11)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      var iceP_f12: F1?
                                      try istr.read(F1.self) { iceP_f12 = $0 }
                                      var iceP_returnValue: F1?
                                      try istr.read(F1.self) { iceP_returnValue = $0 }
                                      try istr.readPendingValues()
                                      return (iceP_returnValue, iceP_f12)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `F2Prx?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: F2Prx?, f22: F2Prx?)`:
    ///
    ///   - returnValue: `F2Prx?`
    ///
    ///   - f22: `F2Prx?`
    func opF2(_ iceP_f21: F2Prx?, context: Ice.Context? = nil) throws -> (returnValue: F2Prx?, f22: F2Prx?) {
        return try _impl._invoke(operation: "opF2",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_f21)
                                 },
                                 read: { istr in
                                     let iceP_f22: F2Prx? = try istr.read(F2Prx.self)
                                     let iceP_returnValue: F2Prx? = try istr.read(F2Prx.self)
                                     return (iceP_returnValue, iceP_f22)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `F2Prx?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: F2Prx?, f22: F2Prx?)>` - The result of the operation
    func opF2Async(_ iceP_f21: F2Prx?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: F2Prx?, f22: F2Prx?)> {
        return _impl._invokeAsync(operation: "opF2",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_f21)
                                  },
                                  read: { istr in
                                      let iceP_f22: F2Prx? = try istr.read(F2Prx.self)
                                      let iceP_returnValue: F2Prx? = try istr.read(F2Prx.self)
                                      return (iceP_returnValue, iceP_f22)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `F3?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: F3?, f32: F3?)`:
    ///
    ///   - returnValue: `F3?`
    ///
    ///   - f32: `F3?`
    func opF3(_ iceP_f31: F3?, context: Ice.Context? = nil) throws -> (returnValue: F3?, f32: F3?) {
        return try _impl._invoke(operation: "opF3",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_f31)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     var iceP_f32: F3?
                                     try istr.read(F3.self) { iceP_f32 = $0 }
                                     var iceP_returnValue: F3?
                                     try istr.read(F3.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return (iceP_returnValue, iceP_f32)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `F3?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: F3?, f32: F3?)>` - The result of the operation
    func opF3Async(_ iceP_f31: F3?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: F3?, f32: F3?)> {
        return _impl._invokeAsync(operation: "opF3",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_f31)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      var iceP_f32: F3?
                                      try istr.read(F3.self) { iceP_f32 = $0 }
                                      var iceP_returnValue: F3?
                                      try istr.read(F3.self) { iceP_returnValue = $0 }
                                      try istr.readPendingValues()
                                      return (iceP_returnValue, iceP_f32)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Bool`
    func hasF3(context: Ice.Context? = nil) throws -> Swift.Bool {
        return try _impl._invoke(operation: "hasF3",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: Swift.Bool = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Bool>` - The result of the operation
    func hasF3Async(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Bool> {
        return _impl._invokeAsync(operation: "hasF3",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_returnValue: Swift.Bool = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `N?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `N?`
    func opN(_ iceP_p1: N?, context: Ice.Context? = nil) throws -> N? {
        return try _impl._invoke(operation: "opN",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_p1)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     var iceP_returnValue: N?
                                     try istr.read(N.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `N?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<N?>` - The result of the operation
    func opNAsync(_ iceP_p1: N?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<N?> {
        return _impl._invokeAsync(operation: "opN",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_p1)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      var iceP_returnValue: N?
                                      try istr.read(N.self) { iceP_returnValue = $0 }
                                      try istr.readPendingValues()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// UnexpectedObjectExceptionTestPrx overview.
///
/// UnexpectedObjectExceptionTestPrx Methods:
///
///  - op: 
///
///  - opAsync: 
public protocol UnexpectedObjectExceptionTestPrx: Ice.ObjectPrx {}

private final class UnexpectedObjectExceptionTestPrxI: Ice.ObjectPrxI, UnexpectedObjectExceptionTestPrx {
    public override class func ice_staticId() -> Swift.String {
        return UnexpectedObjectExceptionTestTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `UnexpectedObjectExceptionTestPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `UnexpectedObjectExceptionTestPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: UnexpectedObjectExceptionTestPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> UnexpectedObjectExceptionTestPrx? {
    return try UnexpectedObjectExceptionTestPrxI.checkedCast(prx: prx, facet: facet, context: context) as UnexpectedObjectExceptionTestPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `UnexpectedObjectExceptionTestPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `UnexpectedObjectExceptionTestPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: UnexpectedObjectExceptionTestPrx.Protocol, facet: Swift.String? = nil) -> UnexpectedObjectExceptionTestPrx {
    return UnexpectedObjectExceptionTestPrxI.uncheckedCast(prx: prx, facet: facet) as UnexpectedObjectExceptionTestPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `UnexpectedObjectExceptionTestPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: UnexpectedObjectExceptionTestPrx.Protocol) -> Swift.String {
    return UnexpectedObjectExceptionTestTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `UnexpectedObjectExceptionTestPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `UnexpectedObjectExceptionTestPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `UnexpectedObjectExceptionTestPrx?` - The extracted proxy
    func read(_ type: UnexpectedObjectExceptionTestPrx.Protocol) throws -> UnexpectedObjectExceptionTestPrx? {
        return try read() as UnexpectedObjectExceptionTestPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `UnexpectedObjectExceptionTestPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `UnexpectedObjectExceptionTestPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: UnexpectedObjectExceptionTestPrx.Protocol) throws -> UnexpectedObjectExceptionTestPrx? {
        return try read(tag: tag) as UnexpectedObjectExceptionTestPrxI?
    }
}

/// UnexpectedObjectExceptionTestPrx overview.
///
/// UnexpectedObjectExceptionTestPrx Methods:
///
///  - op: 
///
///  - opAsync: 
public extension UnexpectedObjectExceptionTestPrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Empty?`
    func op(context: Ice.Context? = nil) throws -> Empty? {
        return try _impl._invoke(operation: "op",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: Empty?
                                     try istr.read(Empty.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Empty?>` - The result of the operation
    func opAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Empty?> {
        return _impl._invokeAsync(operation: "op",
                                  mode: .Normal,
                                  read: { istr in
                                      var iceP_returnValue: Empty?
                                      try istr.read(Empty.self) { iceP_returnValue = $0 }
                                      try istr.readPendingValues()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// :nodoc:
public class Base_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Base.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Base() -> Ice.ValueTypeResolver {
        return Base_TypeResolver()
    }
}

open class Base: Ice.Value {
    public var theS: S = S()
    public var str: Swift.String = ""

    public required init() {}

    public init(theS: S, str: Swift.String) {
        self.theS = theS
        self.str = str
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return BaseTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return BaseTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.theS = try istr.read()
        self.str = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: BaseTraits.staticId, compactId: -1, last: true)
        ostr.write(self.theS)
        ostr.write(self.str)
        ostr.endSlice()
    }
}

/// :nodoc:
public class AbstractBase_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return AbstractBase.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_AbstractBase() -> Ice.ValueTypeResolver {
        return AbstractBase_TypeResolver()
    }
}

open class AbstractBase: Base {
    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return AbstractBaseTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return AbstractBaseTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: AbstractBaseTraits.staticId, compactId: -1, last: false)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}

/// :nodoc:
public class A_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return A.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_A() -> Ice.ValueTypeResolver {
        return A_TypeResolver()
    }
}

open class A: Ice.Value {
    public var theB: B? = nil
    public var theC: C? = nil
    public var preMarshalInvoked: Swift.Bool = false
    public var postUnmarshalInvoked: Swift.Bool = false

    public required init() {}

    public init(theB: B?, theC: C?, preMarshalInvoked: Swift.Bool, postUnmarshalInvoked: Swift.Bool) {
        self.theB = theB
        self.theC = theC
        self.preMarshalInvoked = preMarshalInvoked
        self.postUnmarshalInvoked = postUnmarshalInvoked
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return ATraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return ATraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(B.self) { self.theB = $0 }
        try istr.read(C.self) { self.theC = $0 }
        self.preMarshalInvoked = try istr.read()
        self.postUnmarshalInvoked = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: ATraits.staticId, compactId: -1, last: true)
        ostr.write(self.theB)
        ostr.write(self.theC)
        ostr.write(self.preMarshalInvoked)
        ostr.write(self.postUnmarshalInvoked)
        ostr.endSlice()
    }
}

/// :nodoc:
public class B_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return B.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_B() -> Ice.ValueTypeResolver {
        return B_TypeResolver()
    }
}

open class B: A {
    public var theA: A? = nil

    public required init() {
        super.init()
    }

    public init(theB: B?, theC: C?, preMarshalInvoked: Swift.Bool, postUnmarshalInvoked: Swift.Bool, theA: A?) {
        self.theA = theA
        super.init(theB: theB, theC: theC, preMarshalInvoked: preMarshalInvoked, postUnmarshalInvoked: postUnmarshalInvoked)
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return BTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return BTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(A.self) { self.theA = $0 }
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: BTraits.staticId, compactId: -1, last: false)
        ostr.write(self.theA)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}

/// :nodoc:
public class C_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return C.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_C() -> Ice.ValueTypeResolver {
        return C_TypeResolver()
    }
}

open class C: Ice.Value {
    public var theB: B? = nil
    public var preMarshalInvoked: Swift.Bool = false
    public var postUnmarshalInvoked: Swift.Bool = false

    public required init() {}

    public init(theB: B?, preMarshalInvoked: Swift.Bool, postUnmarshalInvoked: Swift.Bool) {
        self.theB = theB
        self.preMarshalInvoked = preMarshalInvoked
        self.postUnmarshalInvoked = postUnmarshalInvoked
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return CTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return CTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(B.self) { self.theB = $0 }
        self.preMarshalInvoked = try istr.read()
        self.postUnmarshalInvoked = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CTraits.staticId, compactId: -1, last: true)
        ostr.write(self.theB)
        ostr.write(self.preMarshalInvoked)
        ostr.write(self.postUnmarshalInvoked)
        ostr.endSlice()
    }
}

/// :nodoc:
public class D_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return D.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_D() -> Ice.ValueTypeResolver {
        return D_TypeResolver()
    }
}

open class D: Ice.Value {
    public var theA: A? = nil
    public var theB: B? = nil
    public var theC: C? = nil
    public var preMarshalInvoked: Swift.Bool = false
    public var postUnmarshalInvoked: Swift.Bool = false

    public required init() {}

    public init(theA: A?, theB: B?, theC: C?, preMarshalInvoked: Swift.Bool, postUnmarshalInvoked: Swift.Bool) {
        self.theA = theA
        self.theB = theB
        self.theC = theC
        self.preMarshalInvoked = preMarshalInvoked
        self.postUnmarshalInvoked = postUnmarshalInvoked
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return DTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return DTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(A.self) { self.theA = $0 }
        try istr.read(B.self) { self.theB = $0 }
        try istr.read(C.self) { self.theC = $0 }
        self.preMarshalInvoked = try istr.read()
        self.postUnmarshalInvoked = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: DTraits.staticId, compactId: -1, last: true)
        ostr.write(self.theA)
        ostr.write(self.theB)
        ostr.write(self.theC)
        ostr.write(self.preMarshalInvoked)
        ostr.write(self.postUnmarshalInvoked)
        ostr.endSlice()
    }
}

/// :nodoc:
public class E_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return E.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_E() -> Ice.ValueTypeResolver {
        return E_TypeResolver()
    }
}

open class E: Ice.Value {
    public var i: Swift.Int32 = 0
    public var s: Swift.String = ""

    public required init() {}

    public init(i: Swift.Int32, s: Swift.String) {
        self.i = i
        self.s = s
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return ETraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return ETraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.i = try istr.read()
        self.s = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: ETraits.staticId, compactId: -1, last: true)
        ostr.write(self.i)
        ostr.write(self.s)
        ostr.endSlice()
    }
}

/// :nodoc:
public class F_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return F.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_F() -> Ice.ValueTypeResolver {
        return F_TypeResolver()
    }
}

open class F: Ice.Value {
    public var e1: E? = nil
    public var e2: E? = nil

    public required init() {}

    public init(e1: E?, e2: E?) {
        self.e1 = e1
        self.e2 = e2
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return FTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return FTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(E.self) { self.e1 = $0 }
        try istr.read(E.self) { self.e2 = $0 }
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: FTraits.staticId, compactId: -1, last: true)
        ostr.write(self.e1)
        ostr.write(self.e2)
        ostr.endSlice()
    }
}

/// :nodoc:
public class G_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return G.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_G() -> Ice.ValueTypeResolver {
        return G_TypeResolver()
    }
}

open class G: Base {
    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return GTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return GTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: GTraits.staticId, compactId: -1, last: false)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}

/// :nodoc:
public class H_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return H.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_H() -> Ice.ValueTypeResolver {
        return H_TypeResolver()
    }
}

open class H: Ice.Value {
    public required init() {}

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return HTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return HTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: HTraits.staticId, compactId: -1, last: true)
        ostr.endSlice()
    }
}

/// :nodoc:
public class N_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return N.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_N() -> Ice.ValueTypeResolver {
        return N_TypeResolver()
    }
}

open class N: Ice.Value {
    public var i: Ice.Value? = nil

    public required init() {}

    public init(i: Ice.Value?) {
        self.i = i
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return NTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return NTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read() { self.i = $0 }
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: NTraits.staticId, compactId: -1, last: true)
        ostr.write(self.i)
        ostr.endSlice()
    }
}

/// :nodoc:
public class Compact_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Compact.self
    }
}

public extension Ice.TypeIdResolver {
    @objc static func TypeId_1() -> Swift.String {
        return "::Test::Compact"
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Compact() -> Ice.ValueTypeResolver {
        return Compact_TypeResolver()
    }
}

open class Compact: Ice.Value {
    public required init() {}

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return CompactTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return CompactTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CompactTraits.staticId, compactId: 1, last: true)
        ostr.endSlice()
    }
}

/// :nodoc:
public class CompactExt_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return CompactExt.self
    }
}

public extension Ice.TypeIdResolver {
    @objc static func TypeId_789() -> Swift.String {
        return "::Test::CompactExt"
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_CompactExt() -> Ice.ValueTypeResolver {
        return CompactExt_TypeResolver()
    }
}

open class CompactExt: Compact {
    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return CompactExtTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return CompactExtTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CompactExtTraits.staticId, compactId: 789, last: false)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}

/// :nodoc:
public class InnerA_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return InnerA.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Inner_A() -> Ice.ValueTypeResolver {
        return InnerA_TypeResolver()
    }
}

open class InnerA: Ice.Value {
    public var theA: A? = nil

    public required init() {}

    public init(theA: A?) {
        self.theA = theA
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return InnerATraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return InnerATraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(A.self) { self.theA = $0 }
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: InnerATraits.staticId, compactId: -1, last: true)
        ostr.write(self.theA)
        ostr.endSlice()
    }
}

/// :nodoc:
public class InnerSubA_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return InnerSubA.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Inner_Sub_A() -> Ice.ValueTypeResolver {
        return InnerSubA_TypeResolver()
    }
}

open class InnerSubA: Ice.Value {
    public var theA: InnerA? = nil

    public required init() {}

    public init(theA: InnerA?) {
        self.theA = theA
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return InnerSubATraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return InnerSubATraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(InnerA.self) { self.theA = $0 }
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: InnerSubATraits.staticId, compactId: -1, last: true)
        ostr.write(self.theA)
        ostr.endSlice()
    }
}

/// :nodoc:
public class A1_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return A1.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_A1() -> Ice.ValueTypeResolver {
        return A1_TypeResolver()
    }
}

open class A1: Ice.Value {
    public var name: Swift.String = ""

    public required init() {}

    public init(name: Swift.String) {
        self.name = name
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return A1Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return A1Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.name = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: A1Traits.staticId, compactId: -1, last: true)
        ostr.write(self.name)
        ostr.endSlice()
    }
}

/// :nodoc:
public class B1_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return B1.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_B1() -> Ice.ValueTypeResolver {
        return B1_TypeResolver()
    }
}

open class B1: Ice.Value {
    public var a1: A1? = nil
    public var a2: A1? = nil

    public required init() {}

    public init(a1: A1?, a2: A1?) {
        self.a1 = a1
        self.a2 = a2
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return B1Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return B1Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(A1.self) { self.a1 = $0 }
        try istr.read(A1.self) { self.a2 = $0 }
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: B1Traits.staticId, compactId: -1, last: true)
        ostr.write(self.a1)
        ostr.write(self.a2)
        ostr.endSlice()
    }
}

/// :nodoc:
public class D1_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return D1.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_D1() -> Ice.ValueTypeResolver {
        return D1_TypeResolver()
    }
}

open class D1: B1 {
    public var a3: A1? = nil
    public var a4: A1? = nil

    public required init() {
        super.init()
    }

    public init(a1: A1?, a2: A1?, a3: A1?, a4: A1?) {
        self.a3 = a3
        self.a4 = a4
        super.init(a1: a1, a2: a2)
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return D1Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return D1Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(A1.self) { self.a3 = $0 }
        try istr.read(A1.self) { self.a4 = $0 }
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: D1Traits.staticId, compactId: -1, last: false)
        ostr.write(self.a3)
        ostr.write(self.a4)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}

/// :nodoc:
public class Recursive_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Recursive.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Recursive() -> Ice.ValueTypeResolver {
        return Recursive_TypeResolver()
    }
}

open class Recursive: Ice.Value {
    public var v: Recursive? = nil

    public required init() {}

    public init(v: Recursive?) {
        self.v = v
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return RecursiveTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return RecursiveTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(Recursive.self) { self.v = $0 }
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: RecursiveTraits.staticId, compactId: -1, last: true)
        ostr.write(self.v)
        ostr.endSlice()
    }
}

/// :nodoc:
public class K_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return K.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_K() -> Ice.ValueTypeResolver {
        return K_TypeResolver()
    }
}

open class K: Ice.Value {
    public var value: Ice.Value? = nil

    public required init() {}

    public init(value: Ice.Value?) {
        self.value = value
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return KTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return KTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read() { self.value = $0 }
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: KTraits.staticId, compactId: -1, last: true)
        ostr.write(self.value)
        ostr.endSlice()
    }
}

/// :nodoc:
public class L_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return L.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_L() -> Ice.ValueTypeResolver {
        return L_TypeResolver()
    }
}

open class L: Ice.Value {
    public var data: Swift.String = ""

    public required init() {}

    public init(data: Swift.String) {
        self.data = data
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return LTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return LTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.data = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: LTraits.staticId, compactId: -1, last: true)
        ostr.write(self.data)
        ostr.endSlice()
    }
}

/// :nodoc:
public class M_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return M.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_M() -> Ice.ValueTypeResolver {
        return M_TypeResolver()
    }
}

open class M: Ice.Value {
    public var v: LMap = LMap()

    public required init() {}

    public init(v: LMap) {
        self.v = v
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return MTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return MTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.v = try LMapHelper.read(from: istr)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: MTraits.staticId, compactId: -1, last: true)
        LMapHelper.write(to: ostr, value: self.v)
        ostr.endSlice()
    }
}

/// :nodoc:
public class F3_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return F3.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_F3() -> Ice.ValueTypeResolver {
        return F3_TypeResolver()
    }
}

open class F3: Ice.Value {
    public var f1: F1? = nil
    public var f2: F2Prx? = nil

    public required init() {}

    public init(f1: F1?, f2: F2Prx?) {
        self.f1 = f1
        self.f2 = f2
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return F3Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return F3Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(F1.self) { self.f1 = $0 }
        self.f2 = try istr.read(F2Prx.self)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: F3Traits.staticId, compactId: -1, last: true)
        ostr.write(self.f1)
        ostr.write(self.f2)
        ostr.endSlice()
    }
}

/// :nodoc:
public class Empty_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Empty.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Empty() -> Ice.ValueTypeResolver {
        return Empty_TypeResolver()
    }
}

open class Empty: Ice.Value {
    public required init() {}

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return EmptyTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return EmptyTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: EmptyTraits.staticId, compactId: -1, last: true)
        ostr.endSlice()
    }
}

/// :nodoc:
public class AlsoEmpty_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return AlsoEmpty.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_AlsoEmpty() -> Ice.ValueTypeResolver {
        return AlsoEmpty_TypeResolver()
    }
}

open class AlsoEmpty: Ice.Value {
    public required init() {}

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return AlsoEmptyTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return AlsoEmptyTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: AlsoEmptyTraits.staticId, compactId: -1, last: true)
        ostr.endSlice()
    }
}

/// :nodoc:
public class COneMember_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return COneMember.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_COneMember() -> Ice.ValueTypeResolver {
        return COneMember_TypeResolver()
    }
}

open class COneMember: Ice.Value {
    public var e: Empty? = nil

    public required init() {}

    public init(e: Empty?) {
        self.e = e
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return COneMemberTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return COneMemberTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(Empty.self) { self.e = $0 }
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: COneMemberTraits.staticId, compactId: -1, last: true)
        ostr.write(self.e)
        ostr.endSlice()
    }
}

/// :nodoc:
public class CTwoMembers_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return CTwoMembers.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_CTwoMembers() -> Ice.ValueTypeResolver {
        return CTwoMembers_TypeResolver()
    }
}

open class CTwoMembers: Ice.Value {
    public var e1: Empty? = nil
    public var e2: Empty? = nil

    public required init() {}

    public init(e1: Empty?, e2: Empty?) {
        self.e1 = e1
        self.e2 = e2
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return CTwoMembersTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return CTwoMembersTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(Empty.self) { self.e1 = $0 }
        try istr.read(Empty.self) { self.e2 = $0 }
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CTwoMembersTraits.staticId, compactId: -1, last: true)
        ostr.write(self.e1)
        ostr.write(self.e2)
        ostr.endSlice()
    }
}


/// Dispatcher for `AbstractBaseOperations` servants.
public struct AbstractBaseDisp: Ice.Disp {
    public let servant: AbstractBaseOperations
    private static let defaultObject = Ice.ObjectI<AbstractBaseTraits>()

    public init(_ servant: AbstractBaseOperations) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "ice_id":
            return try (servant as? Object ?? AbstractBaseDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? AbstractBaseDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? AbstractBaseDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? AbstractBaseDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "op":
            return try servant._iceD_op(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol AbstractBaseOperations {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func op(current: Ice.Current) throws
}


/// Dispatcher for `I` servants.
public struct IDisp: Ice.Disp {
    public let servant: I
    private static let defaultObject = Ice.ObjectI<ITraits>()

    public init(_ servant: I) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "ice_id":
            return try (servant as? Object ?? IDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? IDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? IDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? IDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol I {}


/// Dispatcher for `J` servants.
public struct JDisp: Ice.Disp {
    public let servant: J
    private static let defaultObject = Ice.ObjectI<JTraits>()

    public init(_ servant: J) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "ice_id":
            return try (servant as? Object ?? JDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? JDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? JDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? JDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol J: I {}


/// Dispatcher for `Initial` servants.
public struct InitialDisp: Ice.Disp {
    public let servant: Initial
    private static let defaultObject = Ice.ObjectI<InitialTraits>()

    public init(_ servant: Initial) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "acceptsClassCycles":
            return try servant._iceD_acceptsClassCycles(incoming: request, current: current)
        case "getAMDMB":
            return try servant._iceD_getAMDMB(incoming: request, current: current)
        case "getAll":
            return try servant._iceD_getAll(incoming: request, current: current)
        case "getB1":
            return try servant._iceD_getB1(incoming: request, current: current)
        case "getB2":
            return try servant._iceD_getB2(incoming: request, current: current)
        case "getC":
            return try servant._iceD_getC(incoming: request, current: current)
        case "getCompact":
            return try servant._iceD_getCompact(incoming: request, current: current)
        case "getD":
            return try servant._iceD_getD(incoming: request, current: current)
        case "getD1":
            return try servant._iceD_getD1(incoming: request, current: current)
        case "getE":
            return try servant._iceD_getE(incoming: request, current: current)
        case "getF":
            return try servant._iceD_getF(incoming: request, current: current)
        case "getH":
            return try servant._iceD_getH(incoming: request, current: current)
        case "getI":
            return try servant._iceD_getI(incoming: request, current: current)
        case "getInnerA":
            return try servant._iceD_getInnerA(incoming: request, current: current)
        case "getInnerSubA":
            return try servant._iceD_getInnerSubA(incoming: request, current: current)
        case "getJ":
            return try servant._iceD_getJ(incoming: request, current: current)
        case "getK":
            return try servant._iceD_getK(incoming: request, current: current)
        case "getMB":
            return try servant._iceD_getMB(incoming: request, current: current)
        case "hasF3":
            return try servant._iceD_hasF3(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? InitialDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? InitialDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? InitialDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? InitialDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "opBaseSeq":
            return try servant._iceD_opBaseSeq(incoming: request, current: current)
        case "opF1":
            return try servant._iceD_opF1(incoming: request, current: current)
        case "opF2":
            return try servant._iceD_opF2(incoming: request, current: current)
        case "opF3":
            return try servant._iceD_opF3(incoming: request, current: current)
        case "opM":
            return try servant._iceD_opM(incoming: request, current: current)
        case "opN":
            return try servant._iceD_opN(incoming: request, current: current)
        case "opValue":
            return try servant._iceD_opValue(incoming: request, current: current)
        case "opValueMap":
            return try servant._iceD_opValueMap(incoming: request, current: current)
        case "opValueSeq":
            return try servant._iceD_opValueSeq(incoming: request, current: current)
        case "setCycle":
            return try servant._iceD_setCycle(incoming: request, current: current)
        case "setG":
            return try servant._iceD_setG(incoming: request, current: current)
        case "setI":
            return try servant._iceD_setI(incoming: request, current: current)
        case "setRecursive":
            return try servant._iceD_setRecursive(incoming: request, current: current)
        case "shutdown":
            return try servant._iceD_shutdown(incoming: request, current: current)
        case "supportsClassGraphDepthMax":
            return try servant._iceD_supportsClassGraphDepthMax(incoming: request, current: current)
        case "throwEDerived":
            return try servant._iceD_throwEDerived(incoming: request, current: current)
        case "throwInnerEx":
            return try servant._iceD_throwInnerEx(incoming: request, current: current)
        case "throwInnerSubEx":
            return try servant._iceD_throwInnerSubEx(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol Initial {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func shutdown(current: Ice.Current) throws

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `B?`
    func getB1(current: Ice.Current) throws -> B?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `B?`
    func getB2(current: Ice.Current) throws -> B?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `C?`
    func getC(current: Ice.Current) throws -> C?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `D?`
    func getD(current: Ice.Current) throws -> D?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `E?`
    func getE(current: Ice.Current) throws -> E?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `F?`
    func getF(current: Ice.Current) throws -> F?

    ///
    /// - parameter p: `Recursive?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func setRecursive(p: Recursive?, current: Ice.Current) throws

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Bool`
    func supportsClassGraphDepthMax(current: Ice.Current) throws -> Swift.Bool

    ///
    /// - parameter r: `Recursive?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func setCycle(r: Recursive?, current: Ice.Current) throws

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Bool`
    func acceptsClassCycles(current: Ice.Current) throws -> Swift.Bool

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `B?`
    func getMB(current: Ice.Current) throws -> B?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `PromiseKit.Promise<B?>` - The result of the operation
    func getAMDMBAsync(current: Ice.Current) -> PromiseKit.Promise<B?>

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(b1: B?, b2: B?, theC: C?, theD: D?)`:
    ///
    ///   - b1: `B?`
    ///
    ///   - b2: `B?`
    ///
    ///   - theC: `C?`
    ///
    ///   - theD: `D?`
    func getAll(current: Ice.Current) throws -> (b1: B?, b2: B?, theC: C?, theD: D?)

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.Value?`
    func getH(current: Ice.Current) throws -> Ice.Value?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.Value?`
    func getI(current: Ice.Current) throws -> Ice.Value?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.Value?`
    func getJ(current: Ice.Current) throws -> Ice.Value?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `K?`
    func getK(current: Ice.Current) throws -> K?

    ///
    /// - parameter v1: `Ice.Value?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: Ice.Value?, v2: Ice.Value?)`:
    ///
    ///   - returnValue: `Ice.Value?`
    ///
    ///   - v2: `Ice.Value?`
    func opValue(v1: Ice.Value?, current: Ice.Current) throws -> (returnValue: Ice.Value?, v2: Ice.Value?)

    ///
    /// - parameter v1: `ValueSeq`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: ValueSeq, v2: ValueSeq)`:
    ///
    ///   - returnValue: `ValueSeq`
    ///
    ///   - v2: `ValueSeq`
    func opValueSeq(v1: ValueSeq, current: Ice.Current) throws -> (returnValue: ValueSeq, v2: ValueSeq)

    ///
    /// - parameter v1: `ValueMap`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: ValueMap, v2: ValueMap)`:
    ///
    ///   - returnValue: `ValueMap`
    ///
    ///   - v2: `ValueMap`
    func opValueMap(v1: ValueMap, current: Ice.Current) throws -> (returnValue: ValueMap, v2: ValueMap)

    ///
    /// - parameter d1: `D1?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `D1?`
    func getD1(d1: D1?, current: Ice.Current) throws -> D1?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func throwEDerived(current: Ice.Current) throws

    ///
    /// - parameter theG: `G?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func setG(theG: G?, current: Ice.Current) throws

    ///
    /// - parameter theI: `Ice.Value?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func setI(theI: Ice.Value?, current: Ice.Current) throws

    ///
    /// - parameter inSeq: `BaseSeq`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: BaseSeq, outSeq: BaseSeq)`:
    ///
    ///   - returnValue: `BaseSeq`
    ///
    ///   - outSeq: `BaseSeq`
    func opBaseSeq(inSeq: BaseSeq, current: Ice.Current) throws -> (returnValue: BaseSeq, outSeq: BaseSeq)

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Compact?`
    func getCompact(current: Ice.Current) throws -> Compact?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `InnerA?`
    func getInnerA(current: Ice.Current) throws -> InnerA?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `InnerSubA?`
    func getInnerSubA(current: Ice.Current) throws -> InnerSubA?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func throwInnerEx(current: Ice.Current) throws

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func throwInnerSubEx(current: Ice.Current) throws

    ///
    /// - parameter v1: `M?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: M?, v2: M?)`:
    ///
    ///   - returnValue: `M?`
    ///
    ///   - v2: `M?`
    func opM(v1: M?, current: Ice.Current) throws -> (returnValue: M?, v2: M?)

    ///
    /// - parameter f11: `F1?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: F1?, f12: F1?)`:
    ///
    ///   - returnValue: `F1?`
    ///
    ///   - f12: `F1?`
    func opF1(f11: F1?, current: Ice.Current) throws -> (returnValue: F1?, f12: F1?)

    ///
    /// - parameter f21: `F2Prx?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: F2Prx?, f22: F2Prx?)`:
    ///
    ///   - returnValue: `F2Prx?`
    ///
    ///   - f22: `F2Prx?`
    func opF2(f21: F2Prx?, current: Ice.Current) throws -> (returnValue: F2Prx?, f22: F2Prx?)

    ///
    /// - parameter f31: `F3?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: F3?, f32: F3?)`:
    ///
    ///   - returnValue: `F3?`
    ///
    ///   - f32: `F3?`
    func opF3(f31: F3?, current: Ice.Current) throws -> (returnValue: F3?, f32: F3?)

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Bool`
    func hasF3(current: Ice.Current) throws -> Swift.Bool

    ///
    /// - parameter p1: `N?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `N?`
    func opN(p1: N?, current: Ice.Current) throws -> N?
}


/// Dispatcher for `UnexpectedObjectExceptionTest` servants.
public struct UnexpectedObjectExceptionTestDisp: Ice.Disp {
    public let servant: UnexpectedObjectExceptionTest
    private static let defaultObject = Ice.ObjectI<UnexpectedObjectExceptionTestTraits>()

    public init(_ servant: UnexpectedObjectExceptionTest) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "ice_id":
            return try (servant as? Object ?? UnexpectedObjectExceptionTestDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? UnexpectedObjectExceptionTestDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? UnexpectedObjectExceptionTestDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? UnexpectedObjectExceptionTestDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "op":
            return try servant._iceD_op(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol UnexpectedObjectExceptionTest {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Empty?`
    func op(current: Ice.Current) throws -> Empty?
}

/// AbstractBase overview.
///
/// AbstractBase Methods:
///
///  - op: 
public extension AbstractBaseOperations {
    func _iceD_op(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.op(current: current)

        return inS.setResult()
    }
}

/// I overview.
public extension I {}

/// J overview.
public extension J {}

/// Initial overview.
///
/// Initial Methods:
///
///  - shutdown: 
///
///  - getB1: 
///
///  - getB2: 
///
///  - getC: 
///
///  - getD: 
///
///  - getE: 
///
///  - getF: 
///
///  - setRecursive: 
///
///  - supportsClassGraphDepthMax: 
///
///  - setCycle: 
///
///  - acceptsClassCycles: 
///
///  - getMB: 
///
///  - getAMDMB: 
///
///  - getAll: 
///
///  - getH: 
///
///  - getI: 
///
///  - getJ: 
///
///  - getK: 
///
///  - opValue: 
///
///  - opValueSeq: 
///
///  - opValueMap: 
///
///  - getD1: 
///
///  - throwEDerived: 
///
///  - setG: 
///
///  - setI: 
///
///  - opBaseSeq: 
///
///  - getCompact: 
///
///  - getInnerA: 
///
///  - getInnerSubA: 
///
///  - throwInnerEx: 
///
///  - throwInnerSubEx: 
///
///  - opM: 
///
///  - opF1: 
///
///  - opF2: 
///
///  - opF3: 
///
///  - hasF3: 
///
///  - opN: 
public extension Initial {
    func _iceD_shutdown(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.shutdown(current: current)

        return inS.setResult()
    }

    func _iceD_getB1(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getB1(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_getB2(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getB2(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_getC(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getC(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_getD(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getD(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_getE(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getE(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_getF(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getF(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_setRecursive(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_p: Recursive? = try inS.read { istr in
            var iceP_p: Recursive?
            try istr.read(Recursive.self) { iceP_p = $0 }
            try istr.readPendingValues()
            return iceP_p
        }

        try self.setRecursive(p: iceP_p, current: current)

        return inS.setResult()
    }

    func _iceD_supportsClassGraphDepthMax(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.supportsClassGraphDepthMax(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_setCycle(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_r: Recursive? = try inS.read { istr in
            var iceP_r: Recursive?
            try istr.read(Recursive.self) { iceP_r = $0 }
            try istr.readPendingValues()
            return iceP_r
        }

        try self.setCycle(r: iceP_r, current: current)

        return inS.setResult()
    }

    func _iceD_acceptsClassCycles(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.acceptsClassCycles(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_getMB(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getMB(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_getAMDMB(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        return inS.setResultPromise(getAMDMBAsync(current: current)) { (ostr, retVals) in
            let iceP_returnValue = retVals
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_getAll(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let (iceP_b1, iceP_b2, iceP_theC, iceP_theD) = try self.getAll(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_b1)
            ostr.write(iceP_b2)
            ostr.write(iceP_theC)
            ostr.write(iceP_theD)
            ostr.writePendingValues()
        }
    }

    func _iceD_getH(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getH(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_getI(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getI(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_getJ(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getJ(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_getK(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getK(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_opValue(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_v1: Ice.Value? = try inS.read { istr in
            var iceP_v1: Ice.Value?
            try istr.read() { iceP_v1 = $0 }
            try istr.readPendingValues()
            return iceP_v1
        }

        let (iceP_returnValue, iceP_v2) = try self.opValue(v1: iceP_v1, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_v2)
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_opValueSeq(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_v1: ValueSeq = try inS.read { istr in
            let iceP_v1: ValueSeq = try ValueSeqHelper.read(from: istr)
            try istr.readPendingValues()
            return iceP_v1
        }

        let (iceP_returnValue, iceP_v2) = try self.opValueSeq(v1: iceP_v1, current: current)

        return inS.setResult{ ostr in
            ValueSeqHelper.write(to: ostr, value: iceP_v2)
            ValueSeqHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_opValueMap(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_v1: ValueMap = try inS.read { istr in
            let iceP_v1: ValueMap = try ValueMapHelper.read(from: istr)
            try istr.readPendingValues()
            return iceP_v1
        }

        let (iceP_returnValue, iceP_v2) = try self.opValueMap(v1: iceP_v1, current: current)

        return inS.setResult{ ostr in
            ValueMapHelper.write(to: ostr, value: iceP_v2)
            ValueMapHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_getD1(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_d1: D1? = try inS.read { istr in
            var iceP_d1: D1?
            try istr.read(D1.self) { iceP_d1 = $0 }
            try istr.readPendingValues()
            return iceP_d1
        }

        let iceP_returnValue = try self.getD1(d1: iceP_d1, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_throwEDerived(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.throwEDerived(current: current)

        return inS.setResult()
    }

    func _iceD_setG(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_theG: G? = try inS.read { istr in
            var iceP_theG: G?
            try istr.read(G.self) { iceP_theG = $0 }
            try istr.readPendingValues()
            return iceP_theG
        }

        try self.setG(theG: iceP_theG, current: current)

        return inS.setResult()
    }

    func _iceD_setI(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_theI: Ice.Value? = try inS.read { istr in
            var iceP_theI: Ice.Value?
            try istr.read() { iceP_theI = $0 }
            try istr.readPendingValues()
            return iceP_theI
        }

        try self.setI(theI: iceP_theI, current: current)

        return inS.setResult()
    }

    func _iceD_opBaseSeq(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_inSeq: BaseSeq = try inS.read { istr in
            let iceP_inSeq: BaseSeq = try BaseSeqHelper.read(from: istr)
            try istr.readPendingValues()
            return iceP_inSeq
        }

        let (iceP_returnValue, iceP_outSeq) = try self.opBaseSeq(inSeq: iceP_inSeq, current: current)

        return inS.setResult{ ostr in
            BaseSeqHelper.write(to: ostr, value: iceP_outSeq)
            BaseSeqHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_getCompact(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getCompact(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_getInnerA(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getInnerA(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_getInnerSubA(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getInnerSubA(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_throwInnerEx(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.throwInnerEx(current: current)

        return inS.setResult()
    }

    func _iceD_throwInnerSubEx(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.throwInnerSubEx(current: current)

        return inS.setResult()
    }

    func _iceD_opM(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_v1: M? = try inS.read { istr in
            var iceP_v1: M?
            try istr.read(M.self) { iceP_v1 = $0 }
            try istr.readPendingValues()
            return iceP_v1
        }

        let (iceP_returnValue, iceP_v2) = try self.opM(v1: iceP_v1, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_v2)
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_opF1(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_f11: F1? = try inS.read { istr in
            var iceP_f11: F1?
            try istr.read(F1.self) { iceP_f11 = $0 }
            try istr.readPendingValues()
            return iceP_f11
        }

        let (iceP_returnValue, iceP_f12) = try self.opF1(f11: iceP_f11, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_f12)
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_opF2(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_f21: F2Prx? = try inS.read { istr in
            let iceP_f21: F2Prx? = try istr.read(F2Prx.self)
            return iceP_f21
        }

        let (iceP_returnValue, iceP_f22) = try self.opF2(f21: iceP_f21, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_f22)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opF3(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_f31: F3? = try inS.read { istr in
            var iceP_f31: F3?
            try istr.read(F3.self) { iceP_f31 = $0 }
            try istr.readPendingValues()
            return iceP_f31
        }

        let (iceP_returnValue, iceP_f32) = try self.opF3(f31: iceP_f31, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_f32)
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_hasF3(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.hasF3(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opN(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_p1: N? = try inS.read { istr in
            var iceP_p1: N?
            try istr.read(N.self) { iceP_p1 = $0 }
            try istr.readPendingValues()
            return iceP_p1
        }

        let iceP_returnValue = try self.opN(p1: iceP_p1, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }
}

/// UnexpectedObjectExceptionTest overview.
///
/// UnexpectedObjectExceptionTest Methods:
///
///  - op: 
public extension UnexpectedObjectExceptionTest {
    func _iceD_op(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.op(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }
}
