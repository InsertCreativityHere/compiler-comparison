//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice

/// Traits for Slice interface`Empty`.
public struct EmptyTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Empty"]
    public static let staticId = "::Test::Empty"
}

/// Traits for Slice interface`A`.
public struct ATraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::A"]
    public static let staticId = "::Test::A"
}

/// Traits for Slice interface`B`.
public struct BTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::A", "::Test::B"]
    public static let staticId = "::Test::B"
}

/// Traits for Slice interface`C`.
public struct CTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::A", "::Test::C"]
    public static let staticId = "::Test::C"
}

/// Traits for Slice interface`D`.
public struct DTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::A", "::Test::B", "::Test::C", "::Test::D"]
    public static let staticId = "::Test::D"
}

/// Traits for Slice interface`E`.
public struct ETraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::E"]
    public static let staticId = "::Test::E"
}

/// Traits for Slice interface`F`.
public struct FTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::E", "::Test::F"]
    public static let staticId = "::Test::F"
}

/// Traits for Slice interface`G`.
public struct GTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::G"]
    public static let staticId = "::Test::G"
}

/// Traits for Slice interface`H`.
public struct HTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::G", "::Test::H"]
    public static let staticId = "::Test::H"
}

/// EmptyPrx overview.
public protocol EmptyPrx: Ice.ObjectPrx {}

private final class EmptyPrxI: Ice.ObjectPrxI, EmptyPrx {
    public override class func ice_staticId() -> Swift.String {
        return EmptyTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: EmptyPrx.Protocol) throws -> EmptyPrx {
    try communicator.makeProxyImpl(proxyString) as EmptyPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `EmptyPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `EmptyPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: EmptyPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> EmptyPrx? {
    return try await EmptyPrxI.checkedCast(prx: prx, facet: facet, context: context) as EmptyPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `EmptyPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `EmptyPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: EmptyPrx.Protocol, facet: Swift.String? = nil) -> EmptyPrx {
    return EmptyPrxI.uncheckedCast(prx: prx, facet: facet) as EmptyPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `EmptyPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: EmptyPrx.Protocol) -> Swift.String {
    return EmptyTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `EmptyPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `EmptyPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `EmptyPrx?` - The extracted proxy
    func read(_ type: EmptyPrx.Protocol) throws -> EmptyPrx? {
        return try read() as EmptyPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `EmptyPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `EmptyPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: EmptyPrx.Protocol) throws -> EmptyPrx? {
        return try read(tag: tag) as EmptyPrxI?
    }
}

/// EmptyPrx overview.
public extension EmptyPrx {}

/// APrx overview.
///
/// APrx Methods:
///
///  - callA: 
///
///  - callAAsync: 
public protocol APrx: Ice.ObjectPrx {}

private final class APrxI: Ice.ObjectPrxI, APrx {
    public override class func ice_staticId() -> Swift.String {
        return ATraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: APrx.Protocol) throws -> APrx {
    try communicator.makeProxyImpl(proxyString) as APrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `APrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `APrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: APrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> APrx? {
    return try await APrxI.checkedCast(prx: prx, facet: facet, context: context) as APrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `APrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `APrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: APrx.Protocol, facet: Swift.String? = nil) -> APrx {
    return APrxI.uncheckedCast(prx: prx, facet: facet) as APrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `APrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: APrx.Protocol) -> Swift.String {
    return ATraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `APrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `APrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `APrx?` - The extracted proxy
    func read(_ type: APrx.Protocol) throws -> APrx? {
        return try read() as APrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `APrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `APrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: APrx.Protocol) throws -> APrx? {
        return try read(tag: tag) as APrxI?
    }
}

/// APrx overview.
///
/// APrx Methods:
///
///  - callA: 
///
///  - callAAsync: 
public extension APrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String`
    func callA(context: Ice.Context? = nil) async throws -> Swift.String {
        return try await _impl._invoke(operation: "callA",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: Swift.String = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}

/// BPrx overview.
///
/// BPrx Methods:
///
///  - callB: 
///
///  - callBAsync: 
public protocol BPrx: APrx {}

private final class BPrxI: Ice.ObjectPrxI, BPrx {
    public override class func ice_staticId() -> Swift.String {
        return BTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: BPrx.Protocol) throws -> BPrx {
    try communicator.makeProxyImpl(proxyString) as BPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `BPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `BPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: BPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> BPrx? {
    return try await BPrxI.checkedCast(prx: prx, facet: facet, context: context) as BPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `BPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `BPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: BPrx.Protocol, facet: Swift.String? = nil) -> BPrx {
    return BPrxI.uncheckedCast(prx: prx, facet: facet) as BPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `BPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: BPrx.Protocol) -> Swift.String {
    return BTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `BPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `BPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `BPrx?` - The extracted proxy
    func read(_ type: BPrx.Protocol) throws -> BPrx? {
        return try read() as BPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `BPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `BPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: BPrx.Protocol) throws -> BPrx? {
        return try read(tag: tag) as BPrxI?
    }
}

/// BPrx overview.
///
/// BPrx Methods:
///
///  - callB: 
///
///  - callBAsync: 
public extension BPrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String`
    func callB(context: Ice.Context? = nil) async throws -> Swift.String {
        return try await _impl._invoke(operation: "callB",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: Swift.String = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}

/// CPrx overview.
///
/// CPrx Methods:
///
///  - callC: 
///
///  - callCAsync: 
public protocol CPrx: APrx {}

private final class CPrxI: Ice.ObjectPrxI, CPrx {
    public override class func ice_staticId() -> Swift.String {
        return CTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: CPrx.Protocol) throws -> CPrx {
    try communicator.makeProxyImpl(proxyString) as CPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `CPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `CPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: CPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> CPrx? {
    return try await CPrxI.checkedCast(prx: prx, facet: facet, context: context) as CPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `CPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `CPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: CPrx.Protocol, facet: Swift.String? = nil) -> CPrx {
    return CPrxI.uncheckedCast(prx: prx, facet: facet) as CPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `CPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: CPrx.Protocol) -> Swift.String {
    return CTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `CPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `CPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `CPrx?` - The extracted proxy
    func read(_ type: CPrx.Protocol) throws -> CPrx? {
        return try read() as CPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `CPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `CPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: CPrx.Protocol) throws -> CPrx? {
        return try read(tag: tag) as CPrxI?
    }
}

/// CPrx overview.
///
/// CPrx Methods:
///
///  - callC: 
///
///  - callCAsync: 
public extension CPrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String`
    func callC(context: Ice.Context? = nil) async throws -> Swift.String {
        return try await _impl._invoke(operation: "callC",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: Swift.String = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}

/// DPrx overview.
///
/// DPrx Methods:
///
///  - callD: 
///
///  - callDAsync: 
public protocol DPrx: BPrx, CPrx {}

private final class DPrxI: Ice.ObjectPrxI, DPrx {
    public override class func ice_staticId() -> Swift.String {
        return DTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: DPrx.Protocol) throws -> DPrx {
    try communicator.makeProxyImpl(proxyString) as DPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `DPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `DPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: DPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> DPrx? {
    return try await DPrxI.checkedCast(prx: prx, facet: facet, context: context) as DPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `DPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `DPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: DPrx.Protocol, facet: Swift.String? = nil) -> DPrx {
    return DPrxI.uncheckedCast(prx: prx, facet: facet) as DPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `DPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: DPrx.Protocol) -> Swift.String {
    return DTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `DPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `DPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `DPrx?` - The extracted proxy
    func read(_ type: DPrx.Protocol) throws -> DPrx? {
        return try read() as DPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `DPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `DPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: DPrx.Protocol) throws -> DPrx? {
        return try read(tag: tag) as DPrxI?
    }
}

/// DPrx overview.
///
/// DPrx Methods:
///
///  - callD: 
///
///  - callDAsync: 
public extension DPrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String`
    func callD(context: Ice.Context? = nil) async throws -> Swift.String {
        return try await _impl._invoke(operation: "callD",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: Swift.String = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}

/// EPrx overview.
///
/// EPrx Methods:
///
///  - callE: 
///
///  - callEAsync: 
public protocol EPrx: Ice.ObjectPrx {}

private final class EPrxI: Ice.ObjectPrxI, EPrx {
    public override class func ice_staticId() -> Swift.String {
        return ETraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: EPrx.Protocol) throws -> EPrx {
    try communicator.makeProxyImpl(proxyString) as EPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `EPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `EPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: EPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> EPrx? {
    return try await EPrxI.checkedCast(prx: prx, facet: facet, context: context) as EPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `EPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `EPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: EPrx.Protocol, facet: Swift.String? = nil) -> EPrx {
    return EPrxI.uncheckedCast(prx: prx, facet: facet) as EPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `EPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: EPrx.Protocol) -> Swift.String {
    return ETraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `EPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `EPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `EPrx?` - The extracted proxy
    func read(_ type: EPrx.Protocol) throws -> EPrx? {
        return try read() as EPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `EPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `EPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: EPrx.Protocol) throws -> EPrx? {
        return try read(tag: tag) as EPrxI?
    }
}

/// EPrx overview.
///
/// EPrx Methods:
///
///  - callE: 
///
///  - callEAsync: 
public extension EPrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String`
    func callE(context: Ice.Context? = nil) async throws -> Swift.String {
        return try await _impl._invoke(operation: "callE",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: Swift.String = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}

/// FPrx overview.
///
/// FPrx Methods:
///
///  - callF: 
///
///  - callFAsync: 
public protocol FPrx: EPrx {}

private final class FPrxI: Ice.ObjectPrxI, FPrx {
    public override class func ice_staticId() -> Swift.String {
        return FTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: FPrx.Protocol) throws -> FPrx {
    try communicator.makeProxyImpl(proxyString) as FPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `FPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `FPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: FPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> FPrx? {
    return try await FPrxI.checkedCast(prx: prx, facet: facet, context: context) as FPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `FPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `FPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: FPrx.Protocol, facet: Swift.String? = nil) -> FPrx {
    return FPrxI.uncheckedCast(prx: prx, facet: facet) as FPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `FPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: FPrx.Protocol) -> Swift.String {
    return FTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `FPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `FPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `FPrx?` - The extracted proxy
    func read(_ type: FPrx.Protocol) throws -> FPrx? {
        return try read() as FPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `FPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `FPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: FPrx.Protocol) throws -> FPrx? {
        return try read(tag: tag) as FPrxI?
    }
}

/// FPrx overview.
///
/// FPrx Methods:
///
///  - callF: 
///
///  - callFAsync: 
public extension FPrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String`
    func callF(context: Ice.Context? = nil) async throws -> Swift.String {
        return try await _impl._invoke(operation: "callF",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: Swift.String = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}

/// GPrx overview.
///
/// GPrx Methods:
///
///  - shutdown: 
///
///  - shutdownAsync: 
///
///  - callG: 
///
///  - callGAsync: 
public protocol GPrx: Ice.ObjectPrx {}

private final class GPrxI: Ice.ObjectPrxI, GPrx {
    public override class func ice_staticId() -> Swift.String {
        return GTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: GPrx.Protocol) throws -> GPrx {
    try communicator.makeProxyImpl(proxyString) as GPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `GPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `GPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: GPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> GPrx? {
    return try await GPrxI.checkedCast(prx: prx, facet: facet, context: context) as GPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `GPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `GPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: GPrx.Protocol, facet: Swift.String? = nil) -> GPrx {
    return GPrxI.uncheckedCast(prx: prx, facet: facet) as GPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `GPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: GPrx.Protocol) -> Swift.String {
    return GTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `GPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `GPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `GPrx?` - The extracted proxy
    func read(_ type: GPrx.Protocol) throws -> GPrx? {
        return try read() as GPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `GPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `GPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: GPrx.Protocol) throws -> GPrx? {
        return try read(tag: tag) as GPrxI?
    }
}

/// GPrx overview.
///
/// GPrx Methods:
///
///  - shutdown: 
///
///  - shutdownAsync: 
///
///  - callG: 
///
///  - callGAsync: 
public extension GPrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func shutdown(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "shutdown",
                                       mode: .Normal,
                                       context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String`
    func callG(context: Ice.Context? = nil) async throws -> Swift.String {
        return try await _impl._invoke(operation: "callG",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: Swift.String = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}

/// HPrx overview.
///
/// HPrx Methods:
///
///  - callH: 
///
///  - callHAsync: 
public protocol HPrx: GPrx {}

private final class HPrxI: Ice.ObjectPrxI, HPrx {
    public override class func ice_staticId() -> Swift.String {
        return HTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: HPrx.Protocol) throws -> HPrx {
    try communicator.makeProxyImpl(proxyString) as HPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `HPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `HPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: HPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> HPrx? {
    return try await HPrxI.checkedCast(prx: prx, facet: facet, context: context) as HPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `HPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `HPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: HPrx.Protocol, facet: Swift.String? = nil) -> HPrx {
    return HPrxI.uncheckedCast(prx: prx, facet: facet) as HPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `HPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: HPrx.Protocol) -> Swift.String {
    return HTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `HPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `HPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `HPrx?` - The extracted proxy
    func read(_ type: HPrx.Protocol) throws -> HPrx? {
        return try read() as HPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `HPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `HPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: HPrx.Protocol) throws -> HPrx? {
        return try read(tag: tag) as HPrxI?
    }
}

/// HPrx overview.
///
/// HPrx Methods:
///
///  - callH: 
///
///  - callHAsync: 
public extension HPrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String`
    func callH(context: Ice.Context? = nil) async throws -> Swift.String {
        return try await _impl._invoke(operation: "callH",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: Swift.String = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}


/// Dispatcher for `Empty` servants.
public struct EmptyDisp: Ice.Dispatcher {
    public let servant: Empty
    private static let defaultObject = Ice.ObjectI<EmptyTraits>()

    public init(_ servant: Empty) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "ice_id":
            try await (servant as? Ice.Object ?? EmptyDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? EmptyDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? EmptyDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? EmptyDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol Empty {}


/// Dispatcher for `A` servants.
public struct ADisp: Ice.Dispatcher {
    public let servant: A
    private static let defaultObject = Ice.ObjectI<ATraits>()

    public init(_ servant: A) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "callA":
            try await servant._iceD_callA(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? ADisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? ADisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? ADisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? ADisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol A {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String`
    func callA(current: Ice.Current) async throws -> Swift.String
}


/// Dispatcher for `B` servants.
public struct BDisp: Ice.Dispatcher {
    public let servant: B
    private static let defaultObject = Ice.ObjectI<BTraits>()

    public init(_ servant: B) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "callA":
            try await servant._iceD_callA(request)
        case "callB":
            try await servant._iceD_callB(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? BDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? BDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? BDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? BDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol B: A {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String`
    func callB(current: Ice.Current) async throws -> Swift.String
}


/// Dispatcher for `C` servants.
public struct CDisp: Ice.Dispatcher {
    public let servant: C
    private static let defaultObject = Ice.ObjectI<CTraits>()

    public init(_ servant: C) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "callA":
            try await servant._iceD_callA(request)
        case "callC":
            try await servant._iceD_callC(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? CDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? CDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? CDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? CDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol C: A {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String`
    func callC(current: Ice.Current) async throws -> Swift.String
}


/// Dispatcher for `D` servants.
public struct DDisp: Ice.Dispatcher {
    public let servant: D
    private static let defaultObject = Ice.ObjectI<DTraits>()

    public init(_ servant: D) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "callA":
            try await servant._iceD_callA(request)
        case "callB":
            try await servant._iceD_callB(request)
        case "callC":
            try await servant._iceD_callC(request)
        case "callD":
            try await servant._iceD_callD(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? DDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? DDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? DDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? DDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol D: B, C {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String`
    func callD(current: Ice.Current) async throws -> Swift.String
}


/// Dispatcher for `E` servants.
public struct EDisp: Ice.Dispatcher {
    public let servant: E
    private static let defaultObject = Ice.ObjectI<ETraits>()

    public init(_ servant: E) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "callE":
            try await servant._iceD_callE(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? EDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? EDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? EDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? EDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol E {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String`
    func callE(current: Ice.Current) async throws -> Swift.String
}


/// Dispatcher for `F` servants.
public struct FDisp: Ice.Dispatcher {
    public let servant: F
    private static let defaultObject = Ice.ObjectI<FTraits>()

    public init(_ servant: F) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "callE":
            try await servant._iceD_callE(request)
        case "callF":
            try await servant._iceD_callF(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? FDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? FDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? FDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? FDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol F: E {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String`
    func callF(current: Ice.Current) async throws -> Swift.String
}


/// Dispatcher for `G` servants.
public struct GDisp: Ice.Dispatcher {
    public let servant: G
    private static let defaultObject = Ice.ObjectI<GTraits>()

    public init(_ servant: G) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "callG":
            try await servant._iceD_callG(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? GDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? GDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? GDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? GDisp.defaultObject)._iceD_ice_ping(request)
        case "shutdown":
            try await servant._iceD_shutdown(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol G {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func shutdown(current: Ice.Current) async throws

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String`
    func callG(current: Ice.Current) async throws -> Swift.String
}


/// Dispatcher for `H` servants.
public struct HDisp: Ice.Dispatcher {
    public let servant: H
    private static let defaultObject = Ice.ObjectI<HTraits>()

    public init(_ servant: H) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "callG":
            try await servant._iceD_callG(request)
        case "callH":
            try await servant._iceD_callH(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? HDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? HDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? HDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? HDisp.defaultObject)._iceD_ice_ping(request)
        case "shutdown":
            try await servant._iceD_shutdown(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol H: G {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String`
    func callH(current: Ice.Current) async throws -> Swift.String
}

/// Empty overview.
extension Empty {}

/// A overview.
///
/// A Methods:
///
///  - callA: 
extension A {
    public func _iceD_callA(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.callA(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }
}

/// B overview.
///
/// B Methods:
///
///  - callB: 
extension B {
    public func _iceD_callB(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.callB(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }
}

/// C overview.
///
/// C Methods:
///
///  - callC: 
extension C {
    public func _iceD_callC(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.callC(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }
}

/// D overview.
///
/// D Methods:
///
///  - callD: 
extension D {
    public func _iceD_callD(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.callD(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }
}

/// E overview.
///
/// E Methods:
///
///  - callE: 
extension E {
    public func _iceD_callE(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.callE(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }
}

/// F overview.
///
/// F Methods:
///
///  - callF: 
extension F {
    public func _iceD_callF(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.callF(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }
}

/// G overview.
///
/// G Methods:
///
///  - shutdown: 
///
///  - callG: 
extension G {
    public func _iceD_shutdown(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.shutdown(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_callG(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.callG(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }
}

/// H overview.
///
/// H Methods:
///
///  - callH: 
extension H {
    public func _iceD_callH(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.callH(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }
}
