//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice
import Test

public enum MyEnum: Swift.UInt8 {
    case enum1 = 0
    case enum2 = 1
    case enum3 = 2
    public init() {
        self = .enum1
    }
}

/// An `Ice.InputStream` extension to read `MyEnum` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - Returns:  The enumerated value.
    func read() throws -> MyEnum {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 2)
        guard let val = MyEnum(rawValue: rawValue) else {
            throw Ice.MarshalException("invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The enumerated value.
    func read(tag: Swift.Int32) throws -> MyEnum? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as MyEnum
    }
}

/// An `Ice.OutputStream` extension to write `MyEnum` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// - Parameter v: The enumerator to write.
    func write(_ v: MyEnum) {
        write(enum: v.rawValue, maxValue: 2)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The enumerator to write.
    func write(tag: Swift.Int32, value: MyEnum?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 2)
    }
}

public struct AnotherStruct: Swift.Hashable {
    public var s: Swift.String = ""

    public init() {}

    public init(s: Swift.String) {
        self.s = s
    }
}

/// An `Ice.InputStream` extension to read `AnotherStruct` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `AnotherStruct` structured value from the stream.
    ///
    /// - Returns: The structured value read from the stream.
    func read() throws -> AnotherStruct {
        var v = AnotherStruct()
        v.s = try self.read()
        return v
    }

    /// Read an optional `AnotherStruct?` structured value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> AnotherStruct? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as AnotherStruct
    }
}

/// An `Ice.OutputStream` extension to write `AnotherStruct` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `AnotherStruct` structured value to the stream.
    ///
    /// - Parameter v: The value to write to the stream.
    func write(_ v: AnotherStruct) {
        self.write(v.s)
    }

    /// Write an optional `AnotherStruct?` structured value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The value to write to the stream.
    func write(tag: Swift.Int32, value: AnotherStruct?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public struct Structure {
    public var p: MyClassPrx? = nil
    public var e: MyEnum = .enum1
    public var s: AnotherStruct = AnotherStruct()

    public init() {}

    public init(p: MyClassPrx?, e: MyEnum, s: AnotherStruct) {
        self.p = p
        self.e = e
        self.s = s
    }
}

/// An `Ice.InputStream` extension to read `Structure` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `Structure` structured value from the stream.
    ///
    /// - Returns: The structured value read from the stream.
    func read() throws -> Structure {
        var v = Structure()
        v.p = try self.read(MyClassPrx.self)
        v.e = try self.read()
        v.s = try self.read()
        return v
    }

    /// Read an optional `Structure?` structured value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> Structure? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as Structure
    }
}

/// An `Ice.OutputStream` extension to write `Structure` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `Structure` structured value to the stream.
    ///
    /// - Parameter v: The value to write to the stream.
    func write(_ v: Structure) {
        self.write(v.p)
        self.write(v.e)
        self.write(v.s)
    }

    /// Write an optional `Structure?` structured value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The value to write to the stream.
    func write(tag: Swift.Int32, value: Structure?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public typealias ByteS = Foundation.Data

public typealias BoolS = [Swift.Bool]

public typealias ShortS = [Swift.Int16]

public typealias IntS = [Swift.Int32]

public typealias LongS = [Swift.Int64]

public typealias FloatS = [Swift.Float]

public typealias DoubleS = [Swift.Double]

public typealias StringS = [Swift.String]

public typealias MyEnumS = [MyEnum]

/// Helper class to read and write `MyEnumS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyEnumSHelper {
    /// Read a `MyEnumS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyEnumS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = MyEnumS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: MyEnum = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `MyEnumS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyEnumS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `MyEnumS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyEnumS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `MyEnumS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: MyEnumS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias MyClassS = [MyClassPrx?]

/// Helper class to read and write `MyClassS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyClassSHelper {
    /// Read a `MyClassS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyClassS {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = MyClassS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: MyClassPrx? = try istr.read(MyClassPrx.self)
            v.append(j)
        }
        return v
    }

    /// Read an optional `MyClassS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyClassS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `MyClassS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyClassS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `MyClassS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: MyClassS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ByteSS = [ByteS]

/// Helper class to read and write `ByteSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ByteSSHelper {
    /// Read a `ByteSS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ByteSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = ByteSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: ByteS = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `ByteSS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ByteSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `ByteSS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ByteSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `ByteSS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ByteSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias BoolSS = [BoolS]

/// Helper class to read and write `BoolSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct BoolSSHelper {
    /// Read a `BoolSS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> BoolSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = BoolSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: BoolS = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `BoolSS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> BoolSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `BoolSS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: BoolSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `BoolSS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: BoolSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ShortSS = [ShortS]

/// Helper class to read and write `ShortSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ShortSSHelper {
    /// Read a `ShortSS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ShortSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = ShortSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: ShortS = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `ShortSS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ShortSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `ShortSS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ShortSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `ShortSS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ShortSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias IntSS = [IntS]

/// Helper class to read and write `IntSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct IntSSHelper {
    /// Read a `IntSS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> IntSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = IntSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: IntS = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `IntSS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> IntSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `IntSS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: IntSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `IntSS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: IntSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias LongSS = [LongS]

/// Helper class to read and write `LongSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LongSSHelper {
    /// Read a `LongSS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LongSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = LongSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: LongS = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `LongSS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LongSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `LongSS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LongSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `LongSS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: LongSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias FloatSS = [FloatS]

/// Helper class to read and write `FloatSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct FloatSSHelper {
    /// Read a `FloatSS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> FloatSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = FloatSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: FloatS = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `FloatSS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> FloatSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `FloatSS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: FloatSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `FloatSS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: FloatSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias DoubleSS = [DoubleS]

/// Helper class to read and write `DoubleSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct DoubleSSHelper {
    /// Read a `DoubleSS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> DoubleSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = DoubleSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: DoubleS = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `DoubleSS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> DoubleSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `DoubleSS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: DoubleSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `DoubleSS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: DoubleSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringSS = [StringS]

/// Helper class to read and write `StringSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringSSHelper {
    /// Read a `StringSS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = StringSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: StringS = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `StringSS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `StringSS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `StringSS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: StringSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias MyEnumSS = [MyEnumS]

/// Helper class to read and write `MyEnumSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyEnumSSHelper {
    /// Read a `MyEnumSS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyEnumSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = MyEnumSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: MyEnumS = try MyEnumSHelper.read(from: istr)
            v.append(j)
        }
        return v
    }

    /// Read an optional `MyEnumSS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyEnumSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `MyEnumSS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyEnumSS) {
        ostr.write(size: v.count)
        for item in v {
            MyEnumSHelper.write(to: ostr, value: item)
        }
    }

    /// Write an optional `MyEnumSS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: MyEnumSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias MyClassSS = [MyClassS]

/// Helper class to read and write `MyClassSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyClassSSHelper {
    /// Read a `MyClassSS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyClassSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = MyClassSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: MyClassS = try MyClassSHelper.read(from: istr)
            v.append(j)
        }
        return v
    }

    /// Read an optional `MyClassSS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyClassSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `MyClassSS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyClassSS) {
        ostr.write(size: v.count)
        for item in v {
            MyClassSHelper.write(to: ostr, value: item)
        }
    }

    /// Write an optional `MyClassSS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: MyClassSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringSSS = [StringSS]

/// Helper class to read and write `StringSSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringSSSHelper {
    /// Read a `StringSSS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringSSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = StringSSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: StringSS = try StringSSHelper.read(from: istr)
            v.append(j)
        }
        return v
    }

    /// Read an optional `StringSSS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringSSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `StringSSS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringSSS) {
        ostr.write(size: v.count)
        for item in v {
            StringSSHelper.write(to: ostr, value: item)
        }
    }

    /// Write an optional `StringSSS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: StringSSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public struct MyStruct: Swift.Hashable {
    public var i: Swift.Int32 = 0
    public var j: Swift.Int32 = 0

    public init() {}

    public init(i: Swift.Int32, j: Swift.Int32) {
        self.i = i
        self.j = j
    }
}

/// An `Ice.InputStream` extension to read `MyStruct` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `MyStruct` structured value from the stream.
    ///
    /// - Returns: The structured value read from the stream.
    func read() throws -> MyStruct {
        var v = MyStruct()
        v.i = try self.read()
        v.j = try self.read()
        return v
    }

    /// Read an optional `MyStruct?` structured value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> MyStruct? {
        guard try readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try skipSize()
        return try read() as MyStruct
    }
}

/// An `Ice.OutputStream` extension to write `MyStruct` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `MyStruct` structured value to the stream.
    ///
    /// - Parameter v: The value to write to the stream.
    func write(_ v: MyStruct) {
        self.write(v.i)
        self.write(v.j)
    }

    /// Write an optional `MyStruct?` structured value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The value to write to the stream.
    func write(tag: Swift.Int32, value: MyStruct?) {
        if let v = value {
            if writeOptional(tag: tag, format: .VSize) {
                write(size: 8)
                write(v)
            }
        }
    }
}

public typealias ByteBoolD = [Swift.UInt8: Swift.Bool]

/// Helper class to read and write `ByteBoolD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ByteBoolDHelper {
    /// Read a `ByteBoolD` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ByteBoolD {
        let sz = try Swift.Int(istr.readSize())
        var v = ByteBoolD()
        for _ in 0 ..< sz {
            let key: Swift.UInt8 = try istr.read()
            let value: Swift.Bool = try istr.read()
            v[key] = value
        }
        return v
    }

    /// Read an optional `ByteBoolD?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ByteBoolD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Write a `ByteBoolD` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ByteBoolD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `ByteBoolD?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: ByteBoolD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 2) {
            write(to: ostr, value: val)
        }
    }
}

public typealias ShortIntD = [Swift.Int16: Swift.Int32]

/// Helper class to read and write `ShortIntD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ShortIntDHelper {
    /// Read a `ShortIntD` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ShortIntD {
        let sz = try Swift.Int(istr.readSize())
        var v = ShortIntD()
        for _ in 0 ..< sz {
            let key: Swift.Int16 = try istr.read()
            let value: Swift.Int32 = try istr.read()
            v[key] = value
        }
        return v
    }

    /// Read an optional `ShortIntD?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ShortIntD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Write a `ShortIntD` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ShortIntD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `ShortIntD?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: ShortIntD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 6) {
            write(to: ostr, value: val)
        }
    }
}

public typealias LongFloatD = [Swift.Int64: Swift.Float]

/// Helper class to read and write `LongFloatD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LongFloatDHelper {
    /// Read a `LongFloatD` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LongFloatD {
        let sz = try Swift.Int(istr.readSize())
        var v = LongFloatD()
        for _ in 0 ..< sz {
            let key: Swift.Int64 = try istr.read()
            let value: Swift.Float = try istr.read()
            v[key] = value
        }
        return v
    }

    /// Read an optional `LongFloatD?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LongFloatD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Write a `LongFloatD` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LongFloatD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `LongFloatD?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: LongFloatD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 12) {
            write(to: ostr, value: val)
        }
    }
}

public typealias StringStringD = [Swift.String: Swift.String]

/// Helper class to read and write `StringStringD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringStringDHelper {
    /// Read a `StringStringD` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringStringD {
        let sz = try Swift.Int(istr.readSize())
        var v = StringStringD()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: Swift.String = try istr.read()
            v[key] = value
        }
        return v
    }

    /// Read an optional `StringStringD?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringStringD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `StringStringD` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringStringD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `StringStringD?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: StringStringD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringMyEnumD = [Swift.String: MyEnum]

/// Helper class to read and write `StringMyEnumD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringMyEnumDHelper {
    /// Read a `StringMyEnumD` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringMyEnumD {
        let sz = try Swift.Int(istr.readSize())
        var v = StringMyEnumD()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: MyEnum = try istr.read()
            v[key] = value
        }
        return v
    }

    /// Read an optional `StringMyEnumD?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringMyEnumD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `StringMyEnumD` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringMyEnumD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `StringMyEnumD?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: StringMyEnumD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias MyEnumStringD = [MyEnum: Swift.String]

/// Helper class to read and write `MyEnumStringD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyEnumStringDHelper {
    /// Read a `MyEnumStringD` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyEnumStringD {
        let sz = try Swift.Int(istr.readSize())
        var v = MyEnumStringD()
        for _ in 0 ..< sz {
            let key: MyEnum = try istr.read()
            let value: Swift.String = try istr.read()
            v[key] = value
        }
        return v
    }

    /// Read an optional `MyEnumStringD?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyEnumStringD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `MyEnumStringD` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyEnumStringD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `MyEnumStringD?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: MyEnumStringD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias MyStructMyEnumD = [MyStruct: MyEnum]

/// Helper class to read and write `MyStructMyEnumD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyStructMyEnumDHelper {
    /// Read a `MyStructMyEnumD` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyStructMyEnumD {
        let sz = try Swift.Int(istr.readSize())
        var v = MyStructMyEnumD()
        for _ in 0 ..< sz {
            let key: MyStruct = try istr.read()
            let value: MyEnum = try istr.read()
            v[key] = value
        }
        return v
    }

    /// Read an optional `MyStructMyEnumD?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyStructMyEnumD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `MyStructMyEnumD` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyStructMyEnumD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `MyStructMyEnumD?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: MyStructMyEnumD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ByteBoolDS = [ByteBoolD]

/// Helper class to read and write `ByteBoolDS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ByteBoolDSHelper {
    /// Read a `ByteBoolDS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ByteBoolDS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = ByteBoolDS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: ByteBoolD = try ByteBoolDHelper.read(from: istr)
            v.append(j)
        }
        return v
    }

    /// Read an optional `ByteBoolDS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ByteBoolDS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `ByteBoolDS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ByteBoolDS) {
        ostr.write(size: v.count)
        for item in v {
            ByteBoolDHelper.write(to: ostr, value: item)
        }
    }

    /// Write an optional `ByteBoolDS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ByteBoolDS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ShortIntDS = [ShortIntD]

/// Helper class to read and write `ShortIntDS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ShortIntDSHelper {
    /// Read a `ShortIntDS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ShortIntDS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = ShortIntDS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: ShortIntD = try ShortIntDHelper.read(from: istr)
            v.append(j)
        }
        return v
    }

    /// Read an optional `ShortIntDS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ShortIntDS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `ShortIntDS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ShortIntDS) {
        ostr.write(size: v.count)
        for item in v {
            ShortIntDHelper.write(to: ostr, value: item)
        }
    }

    /// Write an optional `ShortIntDS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ShortIntDS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias LongFloatDS = [LongFloatD]

/// Helper class to read and write `LongFloatDS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LongFloatDSHelper {
    /// Read a `LongFloatDS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LongFloatDS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = LongFloatDS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: LongFloatD = try LongFloatDHelper.read(from: istr)
            v.append(j)
        }
        return v
    }

    /// Read an optional `LongFloatDS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LongFloatDS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `LongFloatDS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LongFloatDS) {
        ostr.write(size: v.count)
        for item in v {
            LongFloatDHelper.write(to: ostr, value: item)
        }
    }

    /// Write an optional `LongFloatDS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: LongFloatDS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringStringDS = [StringStringD]

/// Helper class to read and write `StringStringDS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringStringDSHelper {
    /// Read a `StringStringDS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringStringDS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = StringStringDS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: StringStringD = try StringStringDHelper.read(from: istr)
            v.append(j)
        }
        return v
    }

    /// Read an optional `StringStringDS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringStringDS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `StringStringDS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringStringDS) {
        ostr.write(size: v.count)
        for item in v {
            StringStringDHelper.write(to: ostr, value: item)
        }
    }

    /// Write an optional `StringStringDS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: StringStringDS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringMyEnumDS = [StringMyEnumD]

/// Helper class to read and write `StringMyEnumDS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringMyEnumDSHelper {
    /// Read a `StringMyEnumDS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringMyEnumDS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = StringMyEnumDS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: StringMyEnumD = try StringMyEnumDHelper.read(from: istr)
            v.append(j)
        }
        return v
    }

    /// Read an optional `StringMyEnumDS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringMyEnumDS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `StringMyEnumDS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringMyEnumDS) {
        ostr.write(size: v.count)
        for item in v {
            StringMyEnumDHelper.write(to: ostr, value: item)
        }
    }

    /// Write an optional `StringMyEnumDS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: StringMyEnumDS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias MyEnumStringDS = [MyEnumStringD]

/// Helper class to read and write `MyEnumStringDS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyEnumStringDSHelper {
    /// Read a `MyEnumStringDS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyEnumStringDS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = MyEnumStringDS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: MyEnumStringD = try MyEnumStringDHelper.read(from: istr)
            v.append(j)
        }
        return v
    }

    /// Read an optional `MyEnumStringDS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyEnumStringDS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `MyEnumStringDS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyEnumStringDS) {
        ostr.write(size: v.count)
        for item in v {
            MyEnumStringDHelper.write(to: ostr, value: item)
        }
    }

    /// Write an optional `MyEnumStringDS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: MyEnumStringDS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias MyStructMyEnumDS = [MyStructMyEnumD]

/// Helper class to read and write `MyStructMyEnumDS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyStructMyEnumDSHelper {
    /// Read a `MyStructMyEnumDS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyStructMyEnumDS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = MyStructMyEnumDS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: MyStructMyEnumD = try MyStructMyEnumDHelper.read(from: istr)
            v.append(j)
        }
        return v
    }

    /// Read an optional `MyStructMyEnumDS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyStructMyEnumDS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `MyStructMyEnumDS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyStructMyEnumDS) {
        ostr.write(size: v.count)
        for item in v {
            MyStructMyEnumDHelper.write(to: ostr, value: item)
        }
    }

    /// Write an optional `MyStructMyEnumDS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: MyStructMyEnumDS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ByteByteSD = [Swift.UInt8: ByteS]

/// Helper class to read and write `ByteByteSD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ByteByteSDHelper {
    /// Read a `ByteByteSD` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ByteByteSD {
        let sz = try Swift.Int(istr.readSize())
        var v = ByteByteSD()
        for _ in 0 ..< sz {
            let key: Swift.UInt8 = try istr.read()
            let value: ByteS = try istr.read()
            v[key] = value
        }
        return v
    }

    /// Read an optional `ByteByteSD?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ByteByteSD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `ByteByteSD` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ByteByteSD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `ByteByteSD?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: ByteByteSD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias BoolBoolSD = [Swift.Bool: BoolS]

/// Helper class to read and write `BoolBoolSD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct BoolBoolSDHelper {
    /// Read a `BoolBoolSD` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> BoolBoolSD {
        let sz = try Swift.Int(istr.readSize())
        var v = BoolBoolSD()
        for _ in 0 ..< sz {
            let key: Swift.Bool = try istr.read()
            let value: BoolS = try istr.read()
            v[key] = value
        }
        return v
    }

    /// Read an optional `BoolBoolSD?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> BoolBoolSD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `BoolBoolSD` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: BoolBoolSD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `BoolBoolSD?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: BoolBoolSD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ShortShortSD = [Swift.Int16: ShortS]

/// Helper class to read and write `ShortShortSD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ShortShortSDHelper {
    /// Read a `ShortShortSD` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ShortShortSD {
        let sz = try Swift.Int(istr.readSize())
        var v = ShortShortSD()
        for _ in 0 ..< sz {
            let key: Swift.Int16 = try istr.read()
            let value: ShortS = try istr.read()
            v[key] = value
        }
        return v
    }

    /// Read an optional `ShortShortSD?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ShortShortSD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `ShortShortSD` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ShortShortSD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `ShortShortSD?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: ShortShortSD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias IntIntSD = [Swift.Int32: IntS]

/// Helper class to read and write `IntIntSD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct IntIntSDHelper {
    /// Read a `IntIntSD` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> IntIntSD {
        let sz = try Swift.Int(istr.readSize())
        var v = IntIntSD()
        for _ in 0 ..< sz {
            let key: Swift.Int32 = try istr.read()
            let value: IntS = try istr.read()
            v[key] = value
        }
        return v
    }

    /// Read an optional `IntIntSD?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> IntIntSD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `IntIntSD` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: IntIntSD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `IntIntSD?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: IntIntSD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias LongLongSD = [Swift.Int64: LongS]

/// Helper class to read and write `LongLongSD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LongLongSDHelper {
    /// Read a `LongLongSD` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LongLongSD {
        let sz = try Swift.Int(istr.readSize())
        var v = LongLongSD()
        for _ in 0 ..< sz {
            let key: Swift.Int64 = try istr.read()
            let value: LongS = try istr.read()
            v[key] = value
        }
        return v
    }

    /// Read an optional `LongLongSD?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LongLongSD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `LongLongSD` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LongLongSD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `LongLongSD?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: LongLongSD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringFloatSD = [Swift.String: FloatS]

/// Helper class to read and write `StringFloatSD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringFloatSDHelper {
    /// Read a `StringFloatSD` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringFloatSD {
        let sz = try Swift.Int(istr.readSize())
        var v = StringFloatSD()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: FloatS = try istr.read()
            v[key] = value
        }
        return v
    }

    /// Read an optional `StringFloatSD?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringFloatSD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `StringFloatSD` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringFloatSD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `StringFloatSD?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: StringFloatSD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringDoubleSD = [Swift.String: DoubleS]

/// Helper class to read and write `StringDoubleSD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringDoubleSDHelper {
    /// Read a `StringDoubleSD` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringDoubleSD {
        let sz = try Swift.Int(istr.readSize())
        var v = StringDoubleSD()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: DoubleS = try istr.read()
            v[key] = value
        }
        return v
    }

    /// Read an optional `StringDoubleSD?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringDoubleSD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `StringDoubleSD` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringDoubleSD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `StringDoubleSD?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: StringDoubleSD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringStringSD = [Swift.String: StringS]

/// Helper class to read and write `StringStringSD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringStringSDHelper {
    /// Read a `StringStringSD` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringStringSD {
        let sz = try Swift.Int(istr.readSize())
        var v = StringStringSD()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: StringS = try istr.read()
            v[key] = value
        }
        return v
    }

    /// Read an optional `StringStringSD?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringStringSD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `StringStringSD` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringStringSD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `StringStringSD?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: StringStringSD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias MyEnumMyEnumSD = [MyEnum: MyEnumS]

/// Helper class to read and write `MyEnumMyEnumSD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyEnumMyEnumSDHelper {
    /// Read a `MyEnumMyEnumSD` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyEnumMyEnumSD {
        let sz = try Swift.Int(istr.readSize())
        var v = MyEnumMyEnumSD()
        for _ in 0 ..< sz {
            let key: MyEnum = try istr.read()
            let value: MyEnumS = try MyEnumSHelper.read(from: istr)
            v[key] = value
        }
        return v
    }

    /// Read an optional `MyEnumMyEnumSD?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyEnumMyEnumSD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `MyEnumMyEnumSD` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyEnumMyEnumSD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            MyEnumSHelper.write(to: ostr, value: value)
        }
    }

    /// Write an optional `MyEnumMyEnumSD?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: MyEnumMyEnumSD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

@_documentation(visibility: internal)
public class SomeException_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return SomeException.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_SomeException() -> Ice.UserExceptionTypeResolver {
        return SomeException_TypeResolver()
    }
}

open class SomeException: Ice.UserException, @unchecked Sendable {
    /// - Returns: The Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Test::SomeException" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: SomeException.ice_staticId(), compactId: -1, last: true)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }
}

/// Traits for Slice interface `MyClass`.
public struct MyClassTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::MyClass"]
    public static let staticId = "::Test::MyClass"
}

public struct MyStruct1 {
    public var tesT: Swift.String = ""
    public var myClass: MyClassPrx? = nil
    public var myStruct1: Swift.String = ""

    public init() {}

    public init(tesT: Swift.String, myClass: MyClassPrx?, myStruct1: Swift.String) {
        self.tesT = tesT
        self.myClass = myClass
        self.myStruct1 = myStruct1
    }
}

/// An `Ice.InputStream` extension to read `MyStruct1` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `MyStruct1` structured value from the stream.
    ///
    /// - Returns: The structured value read from the stream.
    func read() throws -> MyStruct1 {
        var v = MyStruct1()
        v.tesT = try self.read()
        v.myClass = try self.read(MyClassPrx.self)
        v.myStruct1 = try self.read()
        return v
    }

    /// Read an optional `MyStruct1?` structured value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> MyStruct1? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as MyStruct1
    }
}

/// An `Ice.OutputStream` extension to write `MyStruct1` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `MyStruct1` structured value to the stream.
    ///
    /// - Parameter v: The value to write to the stream.
    func write(_ v: MyStruct1) {
        self.write(v.tesT)
        self.write(v.myClass)
        self.write(v.myStruct1)
    }

    /// Write an optional `MyStruct1?` structured value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The value to write to the stream.
    func write(tag: Swift.Int32, value: MyStruct1?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// Traits for Slice interface `MyDerivedClass`.
public struct MyDerivedClassTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::MyClass", "::Test::MyDerivedClass"]
    public static let staticId = "::Test::MyDerivedClass"
}
public let s0: Swift.String = "\\"

public let s1: Swift.String = "A"

public let s2: Swift.String = "Ice"

public let s3: Swift.String = "A21"

public let s4: Swift.String = "\\u0041 \\U00000041"

public let s5: Swift.String = "\u{ff}"

public let s6: Swift.String = "\u{3ff}"

public let s7: Swift.String = "\u{5f0}"

public let s8: Swift.String = "\u{10000}"

public let s9: Swift.String = "\u{1f34c}"

public let s10: Swift.String = "\u{da7}"

public let s11: Swift.String = "\u{20ac}\u{20ac}\u{20ac}"

public let s12: Swift.String = "\\101"

public let s13: Swift.String = "\u{1f34c}0123"

public let s14: Swift.String = "\u{1f34c}abcd"

public let s15: Swift.String = "\u{1f34c}ABCD"

public let s16: Swift.String = "\u{007f}abcd"

public let s17: Swift.String = "\u{007f}ABCD"

public let s18: Swift.String = "\u{0001}1238"

public let s19: Swift.String = "abc\u{0001}1238\u{0008}abcd"

public let sw0: Swift.String = "\\"

public let sw1: Swift.String = "A"

public let sw2: Swift.String = "Ice"

public let sw3: Swift.String = "A21"

public let sw4: Swift.String = "\\u0041 \\U00000041"

public let sw5: Swift.String = "\u{ff}"

public let sw6: Swift.String = "\u{3ff}"

public let sw7: Swift.String = "\u{5f0}"

public let sw8: Swift.String = "\u{10000}"

public let sw9: Swift.String = "\u{1f34c}"

public let sw10: Swift.String = "\u{da7}"

public let ss0: Swift.String = "'\"?\\\u{0007}\u{0008}\u{000c}\n\r\t\u{000b}\u{0006}"

public let ss1: Swift.String = "'\"?\\\u{0007}\u{0008}\u{000c}\n\r\t\u{000b}\u{0006}"

public let ss2: Swift.String = "'\"?\\\u{0007}\u{0008}\u{000c}\n\r\t\u{000b}\u{0006}"

public let ss3: Swift.String = "\\\\U\\u\\"

public let ss4: Swift.String = "\\A\\"

public let ss5: Swift.String = "\\u0041\\"

public let su0: Swift.String = "\u{128}\u{178}\u{ff}\u{100}\u{1f00}\u{10194}\u{1016a}\u{10198}\u{1f340}\u{1f341}\u{1f342}\u{1f343}"

public let su1: Swift.String = "\u{128}\u{178}\u{ff}\u{100}\u{1f00}\u{10194}\u{1016a}\u{10198}\u{1f340}\u{1f341}\u{1f342}\u{1f343}"

public let su2: Swift.String = "\u{128}\u{178}\u{ff}\u{100}\u{1f00}\u{10194}\u{1016a}\u{10198}\u{1f340}\u{1f341}\u{1f342}\u{1f343}"


/// Traits for Slice interface `MyDerivedClass`.
public struct MyDerivedClassTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test2::MyDerivedClass", "::Test::MyClass"]
    public static let staticId = "::Test2::MyDerivedClass"
}

public protocol MyClassPrx: Ice.ObjectPrx {}

private final class MyClassPrxI: Ice.ObjectPrxI, MyClassPrx {
    public override class func ice_staticId() -> Swift.String {
        return MyClassTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: MyClassPrx.Protocol) throws -> MyClassPrx {
    try communicator.makeProxyImpl(proxyString) as MyClassPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: MyClassPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> MyClassPrx? {
    return try await MyClassPrxI.checkedCast(prx: prx, facet: facet, context: context) as MyClassPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: MyClassPrx.Protocol, facet: Swift.String? = nil) -> MyClassPrx {
    return MyClassPrxI.uncheckedCast(prx: prx, facet: facet) as MyClassPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: MyClassPrx.Protocol) -> Swift.String {
    return MyClassTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `MyClassPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: MyClassPrx.Protocol) throws -> MyClassPrx? {
        return try read() as MyClassPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: MyClassPrx.Protocol) throws -> MyClassPrx? {
        return try read(tag: tag) as MyClassPrxI?
    }
}

public extension MyClassPrx {
    func shutdown(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "shutdown",
                                       mode: .Normal,
                                       context: context)
    }

    func supportsCompress(context: Ice.Context? = nil) async throws -> Swift.Bool {
        return try await _impl._invoke(operation: "supportsCompress",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: Swift.Bool = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opVoid(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "opVoid",
                                       mode: .Normal,
                                       context: context)
    }

    func opByte(p1 iceP_p1: Swift.UInt8, p2 iceP_p2: Swift.UInt8, context: Ice.Context? = nil) async throws -> (returnValue: Swift.UInt8, p3: Swift.UInt8) {
        return try await _impl._invoke(operation: "opByte",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_p1)
                                           ostr.write(iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: Swift.UInt8 = try istr.read()
                                           let iceP_returnValue: Swift.UInt8 = try istr.read()
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opBool(p1 iceP_p1: Swift.Bool, p2 iceP_p2: Swift.Bool, context: Ice.Context? = nil) async throws -> (returnValue: Swift.Bool, p3: Swift.Bool) {
        return try await _impl._invoke(operation: "opBool",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_p1)
                                           ostr.write(iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: Swift.Bool = try istr.read()
                                           let iceP_returnValue: Swift.Bool = try istr.read()
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opShortIntLong(p1 iceP_p1: Swift.Int16, p2 iceP_p2: Swift.Int32, p3 iceP_p3: Swift.Int64, context: Ice.Context? = nil) async throws -> (returnValue: Swift.Int64, p4: Swift.Int16, p5: Swift.Int32, p6: Swift.Int64) {
        return try await _impl._invoke(operation: "opShortIntLong",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_p1)
                                           ostr.write(iceP_p2)
                                           ostr.write(iceP_p3)
                                       },
                                       read: { istr in
                                           let iceP_p4: Swift.Int16 = try istr.read()
                                           let iceP_p5: Swift.Int32 = try istr.read()
                                           let iceP_p6: Swift.Int64 = try istr.read()
                                           let iceP_returnValue: Swift.Int64 = try istr.read()
                                           return (iceP_returnValue, iceP_p4, iceP_p5, iceP_p6)
                                       },
                                       context: context)
    }

    func opFloatDouble(p1 iceP_p1: Swift.Float, p2 iceP_p2: Swift.Double, context: Ice.Context? = nil) async throws -> (returnValue: Swift.Double, p3: Swift.Float, p4: Swift.Double) {
        return try await _impl._invoke(operation: "opFloatDouble",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_p1)
                                           ostr.write(iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: Swift.Float = try istr.read()
                                           let iceP_p4: Swift.Double = try istr.read()
                                           let iceP_returnValue: Swift.Double = try istr.read()
                                           return (iceP_returnValue, iceP_p3, iceP_p4)
                                       },
                                       context: context)
    }

    func opString(p1 iceP_p1: Swift.String, p2 iceP_p2: Swift.String, context: Ice.Context? = nil) async throws -> (returnValue: Swift.String, p3: Swift.String) {
        return try await _impl._invoke(operation: "opString",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_p1)
                                           ostr.write(iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: Swift.String = try istr.read()
                                           let iceP_returnValue: Swift.String = try istr.read()
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opMyEnum(_ iceP_p1: MyEnum, context: Ice.Context? = nil) async throws -> (returnValue: MyEnum, p2: MyEnum) {
        return try await _impl._invoke(operation: "opMyEnum",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_p2: MyEnum = try istr.read()
                                           let iceP_returnValue: MyEnum = try istr.read()
                                           return (iceP_returnValue, iceP_p2)
                                       },
                                       context: context)
    }

    func opMyClass(_ iceP_p1: MyClassPrx?, context: Ice.Context? = nil) async throws -> (returnValue: MyClassPrx?, p2: MyClassPrx?, p3: MyClassPrx?) {
        return try await _impl._invoke(operation: "opMyClass",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_p2: MyClassPrx? = try istr.read(MyClassPrx.self)
                                           let iceP_p3: MyClassPrx? = try istr.read(MyClassPrx.self)
                                           let iceP_returnValue: MyClassPrx? = try istr.read(MyClassPrx.self)
                                           return (iceP_returnValue, iceP_p2, iceP_p3)
                                       },
                                       context: context)
    }

    func opStruct(p1 iceP_p1: Structure, p2 iceP_p2: Structure, context: Ice.Context? = nil) async throws -> (returnValue: Structure, p3: Structure) {
        return try await _impl._invoke(operation: "opStruct",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_p1)
                                           ostr.write(iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: Structure = try istr.read()
                                           let iceP_returnValue: Structure = try istr.read()
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opByteS(p1 iceP_p1: ByteS, p2 iceP_p2: ByteS, context: Ice.Context? = nil) async throws -> (returnValue: ByteS, p3: ByteS) {
        return try await _impl._invoke(operation: "opByteS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_p1)
                                           ostr.write(iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: ByteS = try istr.read()
                                           let iceP_returnValue: ByteS = try istr.read()
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opBoolS(p1 iceP_p1: BoolS, p2 iceP_p2: BoolS, context: Ice.Context? = nil) async throws -> (returnValue: BoolS, p3: BoolS) {
        return try await _impl._invoke(operation: "opBoolS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_p1)
                                           ostr.write(iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: BoolS = try istr.read()
                                           let iceP_returnValue: BoolS = try istr.read()
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opShortIntLongS(p1 iceP_p1: ShortS, p2 iceP_p2: IntS, p3 iceP_p3: LongS, context: Ice.Context? = nil) async throws -> (returnValue: LongS, p4: ShortS, p5: IntS, p6: LongS) {
        return try await _impl._invoke(operation: "opShortIntLongS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_p1)
                                           ostr.write(iceP_p2)
                                           ostr.write(iceP_p3)
                                       },
                                       read: { istr in
                                           let iceP_p4: ShortS = try istr.read()
                                           let iceP_p5: IntS = try istr.read()
                                           let iceP_p6: LongS = try istr.read()
                                           let iceP_returnValue: LongS = try istr.read()
                                           return (iceP_returnValue, iceP_p4, iceP_p5, iceP_p6)
                                       },
                                       context: context)
    }

    func opFloatDoubleS(p1 iceP_p1: FloatS, p2 iceP_p2: DoubleS, context: Ice.Context? = nil) async throws -> (returnValue: DoubleS, p3: FloatS, p4: DoubleS) {
        return try await _impl._invoke(operation: "opFloatDoubleS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_p1)
                                           ostr.write(iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: FloatS = try istr.read()
                                           let iceP_p4: DoubleS = try istr.read()
                                           let iceP_returnValue: DoubleS = try istr.read()
                                           return (iceP_returnValue, iceP_p3, iceP_p4)
                                       },
                                       context: context)
    }

    func opStringS(p1 iceP_p1: StringS, p2 iceP_p2: StringS, context: Ice.Context? = nil) async throws -> (returnValue: StringS, p3: StringS) {
        return try await _impl._invoke(operation: "opStringS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_p1)
                                           ostr.write(iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: StringS = try istr.read()
                                           let iceP_returnValue: StringS = try istr.read()
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opByteSS(p1 iceP_p1: ByteSS, p2 iceP_p2: ByteSS, context: Ice.Context? = nil) async throws -> (returnValue: ByteSS, p3: ByteSS) {
        return try await _impl._invoke(operation: "opByteSS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ByteSSHelper.write(to: ostr, value: iceP_p1)
                                           ByteSSHelper.write(to: ostr, value: iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: ByteSS = try ByteSSHelper.read(from: istr)
                                           let iceP_returnValue: ByteSS = try ByteSSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opBoolSS(p1 iceP_p1: BoolSS, p2 iceP_p2: BoolSS, context: Ice.Context? = nil) async throws -> (returnValue: BoolSS, p3: BoolSS) {
        return try await _impl._invoke(operation: "opBoolSS",
                                       mode: .Normal,
                                       write: { ostr in
                                           BoolSSHelper.write(to: ostr, value: iceP_p1)
                                           BoolSSHelper.write(to: ostr, value: iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: BoolSS = try BoolSSHelper.read(from: istr)
                                           let iceP_returnValue: BoolSS = try BoolSSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opShortIntLongSS(p1 iceP_p1: ShortSS, p2 iceP_p2: IntSS, p3 iceP_p3: LongSS, context: Ice.Context? = nil) async throws -> (returnValue: LongSS, p4: ShortSS, p5: IntSS, p6: LongSS) {
        return try await _impl._invoke(operation: "opShortIntLongSS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ShortSSHelper.write(to: ostr, value: iceP_p1)
                                           IntSSHelper.write(to: ostr, value: iceP_p2)
                                           LongSSHelper.write(to: ostr, value: iceP_p3)
                                       },
                                       read: { istr in
                                           let iceP_p4: ShortSS = try ShortSSHelper.read(from: istr)
                                           let iceP_p5: IntSS = try IntSSHelper.read(from: istr)
                                           let iceP_p6: LongSS = try LongSSHelper.read(from: istr)
                                           let iceP_returnValue: LongSS = try LongSSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p4, iceP_p5, iceP_p6)
                                       },
                                       context: context)
    }

    func opFloatDoubleSS(p1 iceP_p1: FloatSS, p2 iceP_p2: DoubleSS, context: Ice.Context? = nil) async throws -> (returnValue: DoubleSS, p3: FloatSS, p4: DoubleSS) {
        return try await _impl._invoke(operation: "opFloatDoubleSS",
                                       mode: .Normal,
                                       write: { ostr in
                                           FloatSSHelper.write(to: ostr, value: iceP_p1)
                                           DoubleSSHelper.write(to: ostr, value: iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: FloatSS = try FloatSSHelper.read(from: istr)
                                           let iceP_p4: DoubleSS = try DoubleSSHelper.read(from: istr)
                                           let iceP_returnValue: DoubleSS = try DoubleSSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p3, iceP_p4)
                                       },
                                       context: context)
    }

    func opStringSS(p1 iceP_p1: StringSS, p2 iceP_p2: StringSS, context: Ice.Context? = nil) async throws -> (returnValue: StringSS, p3: StringSS) {
        return try await _impl._invoke(operation: "opStringSS",
                                       mode: .Normal,
                                       write: { ostr in
                                           StringSSHelper.write(to: ostr, value: iceP_p1)
                                           StringSSHelper.write(to: ostr, value: iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: StringSS = try StringSSHelper.read(from: istr)
                                           let iceP_returnValue: StringSS = try StringSSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opStringSSS(p1 iceP_p1: StringSSS, p2 iceP_p2: StringSSS, context: Ice.Context? = nil) async throws -> (returnValue: StringSSS, p3: StringSSS) {
        return try await _impl._invoke(operation: "opStringSSS",
                                       mode: .Normal,
                                       write: { ostr in
                                           StringSSSHelper.write(to: ostr, value: iceP_p1)
                                           StringSSSHelper.write(to: ostr, value: iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: StringSSS = try StringSSSHelper.read(from: istr)
                                           let iceP_returnValue: StringSSS = try StringSSSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opByteBoolD(p1 iceP_p1: ByteBoolD, p2 iceP_p2: ByteBoolD, context: Ice.Context? = nil) async throws -> (returnValue: ByteBoolD, p3: ByteBoolD) {
        return try await _impl._invoke(operation: "opByteBoolD",
                                       mode: .Normal,
                                       write: { ostr in
                                           ByteBoolDHelper.write(to: ostr, value: iceP_p1)
                                           ByteBoolDHelper.write(to: ostr, value: iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: ByteBoolD = try ByteBoolDHelper.read(from: istr)
                                           let iceP_returnValue: ByteBoolD = try ByteBoolDHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opShortIntD(p1 iceP_p1: ShortIntD, p2 iceP_p2: ShortIntD, context: Ice.Context? = nil) async throws -> (returnValue: ShortIntD, p3: ShortIntD) {
        return try await _impl._invoke(operation: "opShortIntD",
                                       mode: .Normal,
                                       write: { ostr in
                                           ShortIntDHelper.write(to: ostr, value: iceP_p1)
                                           ShortIntDHelper.write(to: ostr, value: iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: ShortIntD = try ShortIntDHelper.read(from: istr)
                                           let iceP_returnValue: ShortIntD = try ShortIntDHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opLongFloatD(p1 iceP_p1: LongFloatD, p2 iceP_p2: LongFloatD, context: Ice.Context? = nil) async throws -> (returnValue: LongFloatD, p3: LongFloatD) {
        return try await _impl._invoke(operation: "opLongFloatD",
                                       mode: .Normal,
                                       write: { ostr in
                                           LongFloatDHelper.write(to: ostr, value: iceP_p1)
                                           LongFloatDHelper.write(to: ostr, value: iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: LongFloatD = try LongFloatDHelper.read(from: istr)
                                           let iceP_returnValue: LongFloatD = try LongFloatDHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opStringStringD(p1 iceP_p1: StringStringD, p2 iceP_p2: StringStringD, context: Ice.Context? = nil) async throws -> (returnValue: StringStringD, p3: StringStringD) {
        return try await _impl._invoke(operation: "opStringStringD",
                                       mode: .Normal,
                                       write: { ostr in
                                           StringStringDHelper.write(to: ostr, value: iceP_p1)
                                           StringStringDHelper.write(to: ostr, value: iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: StringStringD = try StringStringDHelper.read(from: istr)
                                           let iceP_returnValue: StringStringD = try StringStringDHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opStringMyEnumD(p1 iceP_p1: StringMyEnumD, p2 iceP_p2: StringMyEnumD, context: Ice.Context? = nil) async throws -> (returnValue: StringMyEnumD, p3: StringMyEnumD) {
        return try await _impl._invoke(operation: "opStringMyEnumD",
                                       mode: .Normal,
                                       write: { ostr in
                                           StringMyEnumDHelper.write(to: ostr, value: iceP_p1)
                                           StringMyEnumDHelper.write(to: ostr, value: iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: StringMyEnumD = try StringMyEnumDHelper.read(from: istr)
                                           let iceP_returnValue: StringMyEnumD = try StringMyEnumDHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opMyEnumStringD(p1 iceP_p1: MyEnumStringD, p2 iceP_p2: MyEnumStringD, context: Ice.Context? = nil) async throws -> (returnValue: MyEnumStringD, p3: MyEnumStringD) {
        return try await _impl._invoke(operation: "opMyEnumStringD",
                                       mode: .Normal,
                                       write: { ostr in
                                           MyEnumStringDHelper.write(to: ostr, value: iceP_p1)
                                           MyEnumStringDHelper.write(to: ostr, value: iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: MyEnumStringD = try MyEnumStringDHelper.read(from: istr)
                                           let iceP_returnValue: MyEnumStringD = try MyEnumStringDHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opMyStructMyEnumD(p1 iceP_p1: MyStructMyEnumD, p2 iceP_p2: MyStructMyEnumD, context: Ice.Context? = nil) async throws -> (returnValue: MyStructMyEnumD, p3: MyStructMyEnumD) {
        return try await _impl._invoke(operation: "opMyStructMyEnumD",
                                       mode: .Normal,
                                       write: { ostr in
                                           MyStructMyEnumDHelper.write(to: ostr, value: iceP_p1)
                                           MyStructMyEnumDHelper.write(to: ostr, value: iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: MyStructMyEnumD = try MyStructMyEnumDHelper.read(from: istr)
                                           let iceP_returnValue: MyStructMyEnumD = try MyStructMyEnumDHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opByteBoolDS(p1 iceP_p1: ByteBoolDS, p2 iceP_p2: ByteBoolDS, context: Ice.Context? = nil) async throws -> (returnValue: ByteBoolDS, p3: ByteBoolDS) {
        return try await _impl._invoke(operation: "opByteBoolDS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ByteBoolDSHelper.write(to: ostr, value: iceP_p1)
                                           ByteBoolDSHelper.write(to: ostr, value: iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: ByteBoolDS = try ByteBoolDSHelper.read(from: istr)
                                           let iceP_returnValue: ByteBoolDS = try ByteBoolDSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opShortIntDS(p1 iceP_p1: ShortIntDS, p2 iceP_p2: ShortIntDS, context: Ice.Context? = nil) async throws -> (returnValue: ShortIntDS, p3: ShortIntDS) {
        return try await _impl._invoke(operation: "opShortIntDS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ShortIntDSHelper.write(to: ostr, value: iceP_p1)
                                           ShortIntDSHelper.write(to: ostr, value: iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: ShortIntDS = try ShortIntDSHelper.read(from: istr)
                                           let iceP_returnValue: ShortIntDS = try ShortIntDSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opLongFloatDS(p1 iceP_p1: LongFloatDS, p2 iceP_p2: LongFloatDS, context: Ice.Context? = nil) async throws -> (returnValue: LongFloatDS, p3: LongFloatDS) {
        return try await _impl._invoke(operation: "opLongFloatDS",
                                       mode: .Normal,
                                       write: { ostr in
                                           LongFloatDSHelper.write(to: ostr, value: iceP_p1)
                                           LongFloatDSHelper.write(to: ostr, value: iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: LongFloatDS = try LongFloatDSHelper.read(from: istr)
                                           let iceP_returnValue: LongFloatDS = try LongFloatDSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opStringStringDS(p1 iceP_p1: StringStringDS, p2 iceP_p2: StringStringDS, context: Ice.Context? = nil) async throws -> (returnValue: StringStringDS, p3: StringStringDS) {
        return try await _impl._invoke(operation: "opStringStringDS",
                                       mode: .Normal,
                                       write: { ostr in
                                           StringStringDSHelper.write(to: ostr, value: iceP_p1)
                                           StringStringDSHelper.write(to: ostr, value: iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: StringStringDS = try StringStringDSHelper.read(from: istr)
                                           let iceP_returnValue: StringStringDS = try StringStringDSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opStringMyEnumDS(p1 iceP_p1: StringMyEnumDS, p2 iceP_p2: StringMyEnumDS, context: Ice.Context? = nil) async throws -> (returnValue: StringMyEnumDS, p3: StringMyEnumDS) {
        return try await _impl._invoke(operation: "opStringMyEnumDS",
                                       mode: .Normal,
                                       write: { ostr in
                                           StringMyEnumDSHelper.write(to: ostr, value: iceP_p1)
                                           StringMyEnumDSHelper.write(to: ostr, value: iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: StringMyEnumDS = try StringMyEnumDSHelper.read(from: istr)
                                           let iceP_returnValue: StringMyEnumDS = try StringMyEnumDSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opMyEnumStringDS(p1 iceP_p1: MyEnumStringDS, p2 iceP_p2: MyEnumStringDS, context: Ice.Context? = nil) async throws -> (returnValue: MyEnumStringDS, p3: MyEnumStringDS) {
        return try await _impl._invoke(operation: "opMyEnumStringDS",
                                       mode: .Normal,
                                       write: { ostr in
                                           MyEnumStringDSHelper.write(to: ostr, value: iceP_p1)
                                           MyEnumStringDSHelper.write(to: ostr, value: iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: MyEnumStringDS = try MyEnumStringDSHelper.read(from: istr)
                                           let iceP_returnValue: MyEnumStringDS = try MyEnumStringDSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opMyStructMyEnumDS(p1 iceP_p1: MyStructMyEnumDS, p2 iceP_p2: MyStructMyEnumDS, context: Ice.Context? = nil) async throws -> (returnValue: MyStructMyEnumDS, p3: MyStructMyEnumDS) {
        return try await _impl._invoke(operation: "opMyStructMyEnumDS",
                                       mode: .Normal,
                                       write: { ostr in
                                           MyStructMyEnumDSHelper.write(to: ostr, value: iceP_p1)
                                           MyStructMyEnumDSHelper.write(to: ostr, value: iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: MyStructMyEnumDS = try MyStructMyEnumDSHelper.read(from: istr)
                                           let iceP_returnValue: MyStructMyEnumDS = try MyStructMyEnumDSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opByteByteSD(p1 iceP_p1: ByteByteSD, p2 iceP_p2: ByteByteSD, context: Ice.Context? = nil) async throws -> (returnValue: ByteByteSD, p3: ByteByteSD) {
        return try await _impl._invoke(operation: "opByteByteSD",
                                       mode: .Normal,
                                       write: { ostr in
                                           ByteByteSDHelper.write(to: ostr, value: iceP_p1)
                                           ByteByteSDHelper.write(to: ostr, value: iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: ByteByteSD = try ByteByteSDHelper.read(from: istr)
                                           let iceP_returnValue: ByteByteSD = try ByteByteSDHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opBoolBoolSD(p1 iceP_p1: BoolBoolSD, p2 iceP_p2: BoolBoolSD, context: Ice.Context? = nil) async throws -> (returnValue: BoolBoolSD, p3: BoolBoolSD) {
        return try await _impl._invoke(operation: "opBoolBoolSD",
                                       mode: .Normal,
                                       write: { ostr in
                                           BoolBoolSDHelper.write(to: ostr, value: iceP_p1)
                                           BoolBoolSDHelper.write(to: ostr, value: iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: BoolBoolSD = try BoolBoolSDHelper.read(from: istr)
                                           let iceP_returnValue: BoolBoolSD = try BoolBoolSDHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opShortShortSD(p1 iceP_p1: ShortShortSD, p2 iceP_p2: ShortShortSD, context: Ice.Context? = nil) async throws -> (returnValue: ShortShortSD, p3: ShortShortSD) {
        return try await _impl._invoke(operation: "opShortShortSD",
                                       mode: .Normal,
                                       write: { ostr in
                                           ShortShortSDHelper.write(to: ostr, value: iceP_p1)
                                           ShortShortSDHelper.write(to: ostr, value: iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: ShortShortSD = try ShortShortSDHelper.read(from: istr)
                                           let iceP_returnValue: ShortShortSD = try ShortShortSDHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opIntIntSD(p1 iceP_p1: IntIntSD, p2 iceP_p2: IntIntSD, context: Ice.Context? = nil) async throws -> (returnValue: IntIntSD, p3: IntIntSD) {
        return try await _impl._invoke(operation: "opIntIntSD",
                                       mode: .Normal,
                                       write: { ostr in
                                           IntIntSDHelper.write(to: ostr, value: iceP_p1)
                                           IntIntSDHelper.write(to: ostr, value: iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: IntIntSD = try IntIntSDHelper.read(from: istr)
                                           let iceP_returnValue: IntIntSD = try IntIntSDHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opLongLongSD(p1 iceP_p1: LongLongSD, p2 iceP_p2: LongLongSD, context: Ice.Context? = nil) async throws -> (returnValue: LongLongSD, p3: LongLongSD) {
        return try await _impl._invoke(operation: "opLongLongSD",
                                       mode: .Normal,
                                       write: { ostr in
                                           LongLongSDHelper.write(to: ostr, value: iceP_p1)
                                           LongLongSDHelper.write(to: ostr, value: iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: LongLongSD = try LongLongSDHelper.read(from: istr)
                                           let iceP_returnValue: LongLongSD = try LongLongSDHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opStringFloatSD(p1 iceP_p1: StringFloatSD, p2 iceP_p2: StringFloatSD, context: Ice.Context? = nil) async throws -> (returnValue: StringFloatSD, p3: StringFloatSD) {
        return try await _impl._invoke(operation: "opStringFloatSD",
                                       mode: .Normal,
                                       write: { ostr in
                                           StringFloatSDHelper.write(to: ostr, value: iceP_p1)
                                           StringFloatSDHelper.write(to: ostr, value: iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: StringFloatSD = try StringFloatSDHelper.read(from: istr)
                                           let iceP_returnValue: StringFloatSD = try StringFloatSDHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opStringDoubleSD(p1 iceP_p1: StringDoubleSD, p2 iceP_p2: StringDoubleSD, context: Ice.Context? = nil) async throws -> (returnValue: StringDoubleSD, p3: StringDoubleSD) {
        return try await _impl._invoke(operation: "opStringDoubleSD",
                                       mode: .Normal,
                                       write: { ostr in
                                           StringDoubleSDHelper.write(to: ostr, value: iceP_p1)
                                           StringDoubleSDHelper.write(to: ostr, value: iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: StringDoubleSD = try StringDoubleSDHelper.read(from: istr)
                                           let iceP_returnValue: StringDoubleSD = try StringDoubleSDHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opStringStringSD(p1 iceP_p1: StringStringSD, p2 iceP_p2: StringStringSD, context: Ice.Context? = nil) async throws -> (returnValue: StringStringSD, p3: StringStringSD) {
        return try await _impl._invoke(operation: "opStringStringSD",
                                       mode: .Normal,
                                       write: { ostr in
                                           StringStringSDHelper.write(to: ostr, value: iceP_p1)
                                           StringStringSDHelper.write(to: ostr, value: iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: StringStringSD = try StringStringSDHelper.read(from: istr)
                                           let iceP_returnValue: StringStringSD = try StringStringSDHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opMyEnumMyEnumSD(p1 iceP_p1: MyEnumMyEnumSD, p2 iceP_p2: MyEnumMyEnumSD, context: Ice.Context? = nil) async throws -> (returnValue: MyEnumMyEnumSD, p3: MyEnumMyEnumSD) {
        return try await _impl._invoke(operation: "opMyEnumMyEnumSD",
                                       mode: .Normal,
                                       write: { ostr in
                                           MyEnumMyEnumSDHelper.write(to: ostr, value: iceP_p1)
                                           MyEnumMyEnumSDHelper.write(to: ostr, value: iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p3: MyEnumMyEnumSD = try MyEnumMyEnumSDHelper.read(from: istr)
                                           let iceP_returnValue: MyEnumMyEnumSD = try MyEnumMyEnumSDHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opIntS(_ iceP_s: IntS, context: Ice.Context? = nil) async throws -> IntS {
        return try await _impl._invoke(operation: "opIntS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_s)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: IntS = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opByteSOneway(_ iceP_s: ByteS, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "opByteSOneway",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_s)
                                       },
                                       context: context)
    }

    func opByteSOnewayCallCount(context: Ice.Context? = nil) async throws -> Swift.Int32 {
        return try await _impl._invoke(operation: "opByteSOnewayCallCount",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: Swift.Int32 = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opContext(context: Ice.Context? = nil) async throws -> Ice.Context {
        return try await _impl._invoke(operation: "opContext",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: Ice.Context = try Ice.ContextHelper.read(from: istr)
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opDoubleMarshaling(p1 iceP_p1: Swift.Double, p2 iceP_p2: DoubleS, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "opDoubleMarshaling",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_p1)
                                           ostr.write(iceP_p2)
                                       },
                                       context: context)
    }

    func opIdempotent(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "opIdempotent",
                                       mode: .Idempotent,
                                       context: context)
    }

    func opByte1(_ iceP_opByte1: Swift.UInt8, context: Ice.Context? = nil) async throws -> Swift.UInt8 {
        return try await _impl._invoke(operation: "opByte1",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_opByte1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Swift.UInt8 = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opShort1(_ iceP_opShort1: Swift.Int16, context: Ice.Context? = nil) async throws -> Swift.Int16 {
        return try await _impl._invoke(operation: "opShort1",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_opShort1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Swift.Int16 = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opInt1(_ iceP_opInt1: Swift.Int32, context: Ice.Context? = nil) async throws -> Swift.Int32 {
        return try await _impl._invoke(operation: "opInt1",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_opInt1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Swift.Int32 = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opLong1(_ iceP_opLong1: Swift.Int64, context: Ice.Context? = nil) async throws -> Swift.Int64 {
        return try await _impl._invoke(operation: "opLong1",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_opLong1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Swift.Int64 = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opFloat1(_ iceP_opFloat1: Swift.Float, context: Ice.Context? = nil) async throws -> Swift.Float {
        return try await _impl._invoke(operation: "opFloat1",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_opFloat1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Swift.Float = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opDouble1(_ iceP_opDouble1: Swift.Double, context: Ice.Context? = nil) async throws -> Swift.Double {
        return try await _impl._invoke(operation: "opDouble1",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_opDouble1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Swift.Double = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opString1(_ iceP_opString1: Swift.String, context: Ice.Context? = nil) async throws -> Swift.String {
        return try await _impl._invoke(operation: "opString1",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_opString1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Swift.String = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opStringS1(_ iceP_opStringS1: StringS, context: Ice.Context? = nil) async throws -> StringS {
        return try await _impl._invoke(operation: "opStringS1",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_opStringS1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: StringS = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opByteBoolD1(_ iceP_opByteBoolD1: ByteBoolD, context: Ice.Context? = nil) async throws -> ByteBoolD {
        return try await _impl._invoke(operation: "opByteBoolD1",
                                       mode: .Normal,
                                       write: { ostr in
                                           ByteBoolDHelper.write(to: ostr, value: iceP_opByteBoolD1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: ByteBoolD = try ByteBoolDHelper.read(from: istr)
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opStringS2(_ iceP_stringS: StringS, context: Ice.Context? = nil) async throws -> StringS {
        return try await _impl._invoke(operation: "opStringS2",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_stringS)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: StringS = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opByteBoolD2(_ iceP_byteBoolD: ByteBoolD, context: Ice.Context? = nil) async throws -> ByteBoolD {
        return try await _impl._invoke(operation: "opByteBoolD2",
                                       mode: .Normal,
                                       write: { ostr in
                                           ByteBoolDHelper.write(to: ostr, value: iceP_byteBoolD)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: ByteBoolD = try ByteBoolDHelper.read(from: istr)
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opStringLiterals(context: Ice.Context? = nil) async throws -> StringS {
        return try await _impl._invoke(operation: "opStringLiterals",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: StringS = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opMStruct1(context: Ice.Context? = nil) async throws -> Structure {
        return try await _impl._invoke(operation: "opMStruct1",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: Structure = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opMStruct2(_ iceP_p1: Structure, context: Ice.Context? = nil) async throws -> (returnValue: Structure, p2: Structure) {
        return try await _impl._invoke(operation: "opMStruct2",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_p2: Structure = try istr.read()
                                           let iceP_returnValue: Structure = try istr.read()
                                           return (iceP_returnValue, iceP_p2)
                                       },
                                       context: context)
    }

    func opMSeq1(context: Ice.Context? = nil) async throws -> StringS {
        return try await _impl._invoke(operation: "opMSeq1",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: StringS = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opMSeq2(_ iceP_p1: StringS, context: Ice.Context? = nil) async throws -> (returnValue: StringS, p2: StringS) {
        return try await _impl._invoke(operation: "opMSeq2",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_p2: StringS = try istr.read()
                                           let iceP_returnValue: StringS = try istr.read()
                                           return (iceP_returnValue, iceP_p2)
                                       },
                                       context: context)
    }

    func opMDict1(context: Ice.Context? = nil) async throws -> StringStringD {
        return try await _impl._invoke(operation: "opMDict1",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: StringStringD = try StringStringDHelper.read(from: istr)
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opMDict2(_ iceP_p1: StringStringD, context: Ice.Context? = nil) async throws -> (returnValue: StringStringD, p2: StringStringD) {
        return try await _impl._invoke(operation: "opMDict2",
                                       mode: .Normal,
                                       write: { ostr in
                                           StringStringDHelper.write(to: ostr, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_p2: StringStringD = try StringStringDHelper.read(from: istr)
                                           let iceP_returnValue: StringStringD = try StringStringDHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_p2)
                                       },
                                       context: context)
    }
}

public protocol MyDerivedClassPrx: MyClassPrx {}

private final class MyDerivedClassPrxI: Ice.ObjectPrxI, MyDerivedClassPrx {
    public override class func ice_staticId() -> Swift.String {
        return MyDerivedClassTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: MyDerivedClassPrx.Protocol) throws -> MyDerivedClassPrx {
    try communicator.makeProxyImpl(proxyString) as MyDerivedClassPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: MyDerivedClassPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> MyDerivedClassPrx? {
    return try await MyDerivedClassPrxI.checkedCast(prx: prx, facet: facet, context: context) as MyDerivedClassPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: MyDerivedClassPrx.Protocol, facet: Swift.String? = nil) -> MyDerivedClassPrx {
    return MyDerivedClassPrxI.uncheckedCast(prx: prx, facet: facet) as MyDerivedClassPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: MyDerivedClassPrx.Protocol) -> Swift.String {
    return MyDerivedClassTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `MyDerivedClassPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: MyDerivedClassPrx.Protocol) throws -> MyDerivedClassPrx? {
        return try read() as MyDerivedClassPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: MyDerivedClassPrx.Protocol) throws -> MyDerivedClassPrx? {
        return try read(tag: tag) as MyDerivedClassPrxI?
    }
}

public extension MyDerivedClassPrx {
    func opDerived(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "opDerived",
                                       mode: .Normal,
                                       context: context)
    }

    func opMyClass1(_ iceP_opMyClass1: MyClass1?, context: Ice.Context? = nil) async throws -> MyClass1? {
        return try await _impl._invoke(operation: "opMyClass1",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_opMyClass1)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           var iceP_returnValue: MyClass1?
                                           try istr.read(MyClass1.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opMyStruct1(_ iceP_opMyStruct1: MyStruct1, context: Ice.Context? = nil) async throws -> MyStruct1 {
        return try await _impl._invoke(operation: "opMyStruct1",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_opMyStruct1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: MyStruct1 = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}

public protocol MyDerivedClassPrx: Test.MyClassPrx {}

private final class MyDerivedClassPrxI: Ice.ObjectPrxI, MyDerivedClassPrx {
    public override class func ice_staticId() -> Swift.String {
        return MyDerivedClassTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: MyDerivedClassPrx.Protocol) throws -> MyDerivedClassPrx {
    try communicator.makeProxyImpl(proxyString) as MyDerivedClassPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: MyDerivedClassPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> MyDerivedClassPrx? {
    return try await MyDerivedClassPrxI.checkedCast(prx: prx, facet: facet, context: context) as MyDerivedClassPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: MyDerivedClassPrx.Protocol, facet: Swift.String? = nil) -> MyDerivedClassPrx {
    return MyDerivedClassPrxI.uncheckedCast(prx: prx, facet: facet) as MyDerivedClassPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: MyDerivedClassPrx.Protocol) -> Swift.String {
    return MyDerivedClassTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `MyDerivedClassPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: MyDerivedClassPrx.Protocol) throws -> MyDerivedClassPrx? {
        return try read() as MyDerivedClassPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: MyDerivedClassPrx.Protocol) throws -> MyDerivedClassPrx? {
        return try read(tag: tag) as MyDerivedClassPrxI?
    }
}

public extension MyDerivedClassPrx {}

@_documentation(visibility: internal)
public class MyClass1_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return MyClass1.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_MyClass1() -> Ice.ValueTypeResolver {
        return MyClass1_TypeResolver()
    }
}

open class MyClass1: Ice.Value {
    public var tesT: Swift.String = ""
    public var myClass: MyClassPrx? = nil
    public var myClass1: Swift.String = ""

    public required init() {}

    public init(tesT: Swift.String, myClass: MyClassPrx?, myClass1: Swift.String) {
        self.tesT = tesT
        self.myClass = myClass
        self.myClass1 = myClass1
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::MyClass1" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.tesT = try istr.read()
        self.myClass = try istr.read(MyClassPrx.self)
        self.myClass1 = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: MyClass1.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.tesT)
        ostr.write(self.myClass)
        ostr.write(self.myClass1)
        ostr.endSlice()
    }
}


/// Dispatcher for `MyClass` servants.
public struct MyClassDisp: Ice.Dispatcher {
    public let servant: MyClass
    private static let defaultObject = Ice.ObjectI<MyClassTraits>()

    public init(_ servant: MyClass) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "ice_id":
            try await (servant as? Ice.Object ?? MyClassDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? MyClassDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? MyClassDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? MyClassDisp.defaultObject)._iceD_ice_ping(request)
        case "opBool":
            try await servant._iceD_opBool(request)
        case "opBoolBoolSD":
            try await servant._iceD_opBoolBoolSD(request)
        case "opBoolS":
            try await servant._iceD_opBoolS(request)
        case "opBoolSS":
            try await servant._iceD_opBoolSS(request)
        case "opByte":
            try await servant._iceD_opByte(request)
        case "opByte1":
            try await servant._iceD_opByte1(request)
        case "opByteBoolD":
            try await servant._iceD_opByteBoolD(request)
        case "opByteBoolD1":
            try await servant._iceD_opByteBoolD1(request)
        case "opByteBoolD2":
            try await servant._iceD_opByteBoolD2(request)
        case "opByteBoolDS":
            try await servant._iceD_opByteBoolDS(request)
        case "opByteByteSD":
            try await servant._iceD_opByteByteSD(request)
        case "opByteS":
            try await servant._iceD_opByteS(request)
        case "opByteSOneway":
            try await servant._iceD_opByteSOneway(request)
        case "opByteSOnewayCallCount":
            try await servant._iceD_opByteSOnewayCallCount(request)
        case "opByteSS":
            try await servant._iceD_opByteSS(request)
        case "opContext":
            try await servant._iceD_opContext(request)
        case "opDouble1":
            try await servant._iceD_opDouble1(request)
        case "opDoubleMarshaling":
            try await servant._iceD_opDoubleMarshaling(request)
        case "opFloat1":
            try await servant._iceD_opFloat1(request)
        case "opFloatDouble":
            try await servant._iceD_opFloatDouble(request)
        case "opFloatDoubleS":
            try await servant._iceD_opFloatDoubleS(request)
        case "opFloatDoubleSS":
            try await servant._iceD_opFloatDoubleSS(request)
        case "opIdempotent":
            try await servant._iceD_opIdempotent(request)
        case "opInt1":
            try await servant._iceD_opInt1(request)
        case "opIntIntSD":
            try await servant._iceD_opIntIntSD(request)
        case "opIntS":
            try await servant._iceD_opIntS(request)
        case "opLong1":
            try await servant._iceD_opLong1(request)
        case "opLongFloatD":
            try await servant._iceD_opLongFloatD(request)
        case "opLongFloatDS":
            try await servant._iceD_opLongFloatDS(request)
        case "opLongLongSD":
            try await servant._iceD_opLongLongSD(request)
        case "opMDict1":
            try await servant._iceD_opMDict1(request)
        case "opMDict2":
            try await servant._iceD_opMDict2(request)
        case "opMSeq1":
            try await servant._iceD_opMSeq1(request)
        case "opMSeq2":
            try await servant._iceD_opMSeq2(request)
        case "opMStruct1":
            try await servant._iceD_opMStruct1(request)
        case "opMStruct2":
            try await servant._iceD_opMStruct2(request)
        case "opMyClass":
            try await servant._iceD_opMyClass(request)
        case "opMyEnum":
            try await servant._iceD_opMyEnum(request)
        case "opMyEnumMyEnumSD":
            try await servant._iceD_opMyEnumMyEnumSD(request)
        case "opMyEnumStringD":
            try await servant._iceD_opMyEnumStringD(request)
        case "opMyEnumStringDS":
            try await servant._iceD_opMyEnumStringDS(request)
        case "opMyStructMyEnumD":
            try await servant._iceD_opMyStructMyEnumD(request)
        case "opMyStructMyEnumDS":
            try await servant._iceD_opMyStructMyEnumDS(request)
        case "opShort1":
            try await servant._iceD_opShort1(request)
        case "opShortIntD":
            try await servant._iceD_opShortIntD(request)
        case "opShortIntDS":
            try await servant._iceD_opShortIntDS(request)
        case "opShortIntLong":
            try await servant._iceD_opShortIntLong(request)
        case "opShortIntLongS":
            try await servant._iceD_opShortIntLongS(request)
        case "opShortIntLongSS":
            try await servant._iceD_opShortIntLongSS(request)
        case "opShortShortSD":
            try await servant._iceD_opShortShortSD(request)
        case "opString":
            try await servant._iceD_opString(request)
        case "opString1":
            try await servant._iceD_opString1(request)
        case "opStringDoubleSD":
            try await servant._iceD_opStringDoubleSD(request)
        case "opStringFloatSD":
            try await servant._iceD_opStringFloatSD(request)
        case "opStringLiterals":
            try await servant._iceD_opStringLiterals(request)
        case "opStringMyEnumD":
            try await servant._iceD_opStringMyEnumD(request)
        case "opStringMyEnumDS":
            try await servant._iceD_opStringMyEnumDS(request)
        case "opStringS":
            try await servant._iceD_opStringS(request)
        case "opStringS1":
            try await servant._iceD_opStringS1(request)
        case "opStringS2":
            try await servant._iceD_opStringS2(request)
        case "opStringSS":
            try await servant._iceD_opStringSS(request)
        case "opStringSSS":
            try await servant._iceD_opStringSSS(request)
        case "opStringStringD":
            try await servant._iceD_opStringStringD(request)
        case "opStringStringDS":
            try await servant._iceD_opStringStringDS(request)
        case "opStringStringSD":
            try await servant._iceD_opStringStringSD(request)
        case "opStruct":
            try await servant._iceD_opStruct(request)
        case "opVoid":
            try await servant._iceD_opVoid(request)
        case "shutdown":
            try await servant._iceD_shutdown(request)
        case "supportsCompress":
            try await servant._iceD_supportsCompress(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol MyClass {
    func shutdown(current: Ice.Current) async throws

    func supportsCompress(current: Ice.Current) async throws -> Swift.Bool

    func opVoid(current: Ice.Current) async throws

    func opByte(p1: Swift.UInt8, p2: Swift.UInt8, current: Ice.Current) async throws -> (returnValue: Swift.UInt8, p3: Swift.UInt8)

    func opBool(p1: Swift.Bool, p2: Swift.Bool, current: Ice.Current) async throws -> (returnValue: Swift.Bool, p3: Swift.Bool)

    func opShortIntLong(p1: Swift.Int16, p2: Swift.Int32, p3: Swift.Int64, current: Ice.Current) async throws -> (returnValue: Swift.Int64, p4: Swift.Int16, p5: Swift.Int32, p6: Swift.Int64)

    func opFloatDouble(p1: Swift.Float, p2: Swift.Double, current: Ice.Current) async throws -> (returnValue: Swift.Double, p3: Swift.Float, p4: Swift.Double)

    func opString(p1: Swift.String, p2: Swift.String, current: Ice.Current) async throws -> (returnValue: Swift.String, p3: Swift.String)

    func opMyEnum(p1: MyEnum, current: Ice.Current) async throws -> (returnValue: MyEnum, p2: MyEnum)

    func opMyClass(p1: MyClassPrx?, current: Ice.Current) async throws -> (returnValue: MyClassPrx?, p2: MyClassPrx?, p3: MyClassPrx?)

    func opStruct(p1: Structure, p2: Structure, current: Ice.Current) async throws -> (returnValue: Structure, p3: Structure)

    func opByteS(p1: ByteS, p2: ByteS, current: Ice.Current) async throws -> (returnValue: ByteS, p3: ByteS)

    func opBoolS(p1: BoolS, p2: BoolS, current: Ice.Current) async throws -> (returnValue: BoolS, p3: BoolS)

    func opShortIntLongS(p1: ShortS, p2: IntS, p3: LongS, current: Ice.Current) async throws -> (returnValue: LongS, p4: ShortS, p5: IntS, p6: LongS)

    func opFloatDoubleS(p1: FloatS, p2: DoubleS, current: Ice.Current) async throws -> (returnValue: DoubleS, p3: FloatS, p4: DoubleS)

    func opStringS(p1: StringS, p2: StringS, current: Ice.Current) async throws -> (returnValue: StringS, p3: StringS)

    func opByteSS(p1: ByteSS, p2: ByteSS, current: Ice.Current) async throws -> (returnValue: ByteSS, p3: ByteSS)

    func opBoolSS(p1: BoolSS, p2: BoolSS, current: Ice.Current) async throws -> (returnValue: BoolSS, p3: BoolSS)

    func opShortIntLongSS(p1: ShortSS, p2: IntSS, p3: LongSS, current: Ice.Current) async throws -> (returnValue: LongSS, p4: ShortSS, p5: IntSS, p6: LongSS)

    func opFloatDoubleSS(p1: FloatSS, p2: DoubleSS, current: Ice.Current) async throws -> (returnValue: DoubleSS, p3: FloatSS, p4: DoubleSS)

    func opStringSS(p1: StringSS, p2: StringSS, current: Ice.Current) async throws -> (returnValue: StringSS, p3: StringSS)

    func opStringSSS(p1: StringSSS, p2: StringSSS, current: Ice.Current) async throws -> (returnValue: StringSSS, p3: StringSSS)

    func opByteBoolD(p1: ByteBoolD, p2: ByteBoolD, current: Ice.Current) async throws -> (returnValue: ByteBoolD, p3: ByteBoolD)

    func opShortIntD(p1: ShortIntD, p2: ShortIntD, current: Ice.Current) async throws -> (returnValue: ShortIntD, p3: ShortIntD)

    func opLongFloatD(p1: LongFloatD, p2: LongFloatD, current: Ice.Current) async throws -> (returnValue: LongFloatD, p3: LongFloatD)

    func opStringStringD(p1: StringStringD, p2: StringStringD, current: Ice.Current) async throws -> (returnValue: StringStringD, p3: StringStringD)

    func opStringMyEnumD(p1: StringMyEnumD, p2: StringMyEnumD, current: Ice.Current) async throws -> (returnValue: StringMyEnumD, p3: StringMyEnumD)

    func opMyEnumStringD(p1: MyEnumStringD, p2: MyEnumStringD, current: Ice.Current) async throws -> (returnValue: MyEnumStringD, p3: MyEnumStringD)

    func opMyStructMyEnumD(p1: MyStructMyEnumD, p2: MyStructMyEnumD, current: Ice.Current) async throws -> (returnValue: MyStructMyEnumD, p3: MyStructMyEnumD)

    func opByteBoolDS(p1: ByteBoolDS, p2: ByteBoolDS, current: Ice.Current) async throws -> (returnValue: ByteBoolDS, p3: ByteBoolDS)

    func opShortIntDS(p1: ShortIntDS, p2: ShortIntDS, current: Ice.Current) async throws -> (returnValue: ShortIntDS, p3: ShortIntDS)

    func opLongFloatDS(p1: LongFloatDS, p2: LongFloatDS, current: Ice.Current) async throws -> (returnValue: LongFloatDS, p3: LongFloatDS)

    func opStringStringDS(p1: StringStringDS, p2: StringStringDS, current: Ice.Current) async throws -> (returnValue: StringStringDS, p3: StringStringDS)

    func opStringMyEnumDS(p1: StringMyEnumDS, p2: StringMyEnumDS, current: Ice.Current) async throws -> (returnValue: StringMyEnumDS, p3: StringMyEnumDS)

    func opMyEnumStringDS(p1: MyEnumStringDS, p2: MyEnumStringDS, current: Ice.Current) async throws -> (returnValue: MyEnumStringDS, p3: MyEnumStringDS)

    func opMyStructMyEnumDS(p1: MyStructMyEnumDS, p2: MyStructMyEnumDS, current: Ice.Current) async throws -> (returnValue: MyStructMyEnumDS, p3: MyStructMyEnumDS)

    func opByteByteSD(p1: ByteByteSD, p2: ByteByteSD, current: Ice.Current) async throws -> (returnValue: ByteByteSD, p3: ByteByteSD)

    func opBoolBoolSD(p1: BoolBoolSD, p2: BoolBoolSD, current: Ice.Current) async throws -> (returnValue: BoolBoolSD, p3: BoolBoolSD)

    func opShortShortSD(p1: ShortShortSD, p2: ShortShortSD, current: Ice.Current) async throws -> (returnValue: ShortShortSD, p3: ShortShortSD)

    func opIntIntSD(p1: IntIntSD, p2: IntIntSD, current: Ice.Current) async throws -> (returnValue: IntIntSD, p3: IntIntSD)

    func opLongLongSD(p1: LongLongSD, p2: LongLongSD, current: Ice.Current) async throws -> (returnValue: LongLongSD, p3: LongLongSD)

    func opStringFloatSD(p1: StringFloatSD, p2: StringFloatSD, current: Ice.Current) async throws -> (returnValue: StringFloatSD, p3: StringFloatSD)

    func opStringDoubleSD(p1: StringDoubleSD, p2: StringDoubleSD, current: Ice.Current) async throws -> (returnValue: StringDoubleSD, p3: StringDoubleSD)

    func opStringStringSD(p1: StringStringSD, p2: StringStringSD, current: Ice.Current) async throws -> (returnValue: StringStringSD, p3: StringStringSD)

    func opMyEnumMyEnumSD(p1: MyEnumMyEnumSD, p2: MyEnumMyEnumSD, current: Ice.Current) async throws -> (returnValue: MyEnumMyEnumSD, p3: MyEnumMyEnumSD)

    func opIntS(s: IntS, current: Ice.Current) async throws -> IntS

    func opByteSOneway(s: ByteS, current: Ice.Current) async throws

    func opByteSOnewayCallCount(current: Ice.Current) async throws -> Swift.Int32

    func opContext(current: Ice.Current) async throws -> Ice.Context

    func opDoubleMarshaling(p1: Swift.Double, p2: DoubleS, current: Ice.Current) async throws

    func opIdempotent(current: Ice.Current) async throws

    func opByte1(opByte1: Swift.UInt8, current: Ice.Current) async throws -> Swift.UInt8

    func opShort1(opShort1: Swift.Int16, current: Ice.Current) async throws -> Swift.Int16

    func opInt1(opInt1: Swift.Int32, current: Ice.Current) async throws -> Swift.Int32

    func opLong1(opLong1: Swift.Int64, current: Ice.Current) async throws -> Swift.Int64

    func opFloat1(opFloat1: Swift.Float, current: Ice.Current) async throws -> Swift.Float

    func opDouble1(opDouble1: Swift.Double, current: Ice.Current) async throws -> Swift.Double

    func opString1(opString1: Swift.String, current: Ice.Current) async throws -> Swift.String

    func opStringS1(opStringS1: StringS, current: Ice.Current) async throws -> StringS

    func opByteBoolD1(opByteBoolD1: ByteBoolD, current: Ice.Current) async throws -> ByteBoolD

    func opStringS2(stringS: StringS, current: Ice.Current) async throws -> StringS

    func opByteBoolD2(byteBoolD: ByteBoolD, current: Ice.Current) async throws -> ByteBoolD

    func opStringLiterals(current: Ice.Current) async throws -> StringS

    func opMStruct1(current: Ice.Current) async throws -> Structure

    func opMStruct2(p1: Structure, current: Ice.Current) async throws -> (returnValue: Structure, p2: Structure)

    func opMSeq1(current: Ice.Current) async throws -> StringS

    func opMSeq2(p1: StringS, current: Ice.Current) async throws -> (returnValue: StringS, p2: StringS)

    func opMDict1(current: Ice.Current) async throws -> StringStringD

    func opMDict2(p1: StringStringD, current: Ice.Current) async throws -> (returnValue: StringStringD, p2: StringStringD)
}


/// Dispatcher for `MyDerivedClass` servants.
public struct MyDerivedClassDisp: Ice.Dispatcher {
    public let servant: MyDerivedClass
    private static let defaultObject = Ice.ObjectI<MyDerivedClassTraits>()

    public init(_ servant: MyDerivedClass) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "ice_id":
            try await (servant as? Ice.Object ?? MyDerivedClassDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? MyDerivedClassDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? MyDerivedClassDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? MyDerivedClassDisp.defaultObject)._iceD_ice_ping(request)
        case "opBool":
            try await servant._iceD_opBool(request)
        case "opBoolBoolSD":
            try await servant._iceD_opBoolBoolSD(request)
        case "opBoolS":
            try await servant._iceD_opBoolS(request)
        case "opBoolSS":
            try await servant._iceD_opBoolSS(request)
        case "opByte":
            try await servant._iceD_opByte(request)
        case "opByte1":
            try await servant._iceD_opByte1(request)
        case "opByteBoolD":
            try await servant._iceD_opByteBoolD(request)
        case "opByteBoolD1":
            try await servant._iceD_opByteBoolD1(request)
        case "opByteBoolD2":
            try await servant._iceD_opByteBoolD2(request)
        case "opByteBoolDS":
            try await servant._iceD_opByteBoolDS(request)
        case "opByteByteSD":
            try await servant._iceD_opByteByteSD(request)
        case "opByteS":
            try await servant._iceD_opByteS(request)
        case "opByteSOneway":
            try await servant._iceD_opByteSOneway(request)
        case "opByteSOnewayCallCount":
            try await servant._iceD_opByteSOnewayCallCount(request)
        case "opByteSS":
            try await servant._iceD_opByteSS(request)
        case "opContext":
            try await servant._iceD_opContext(request)
        case "opDerived":
            try await servant._iceD_opDerived(request)
        case "opDouble1":
            try await servant._iceD_opDouble1(request)
        case "opDoubleMarshaling":
            try await servant._iceD_opDoubleMarshaling(request)
        case "opFloat1":
            try await servant._iceD_opFloat1(request)
        case "opFloatDouble":
            try await servant._iceD_opFloatDouble(request)
        case "opFloatDoubleS":
            try await servant._iceD_opFloatDoubleS(request)
        case "opFloatDoubleSS":
            try await servant._iceD_opFloatDoubleSS(request)
        case "opIdempotent":
            try await servant._iceD_opIdempotent(request)
        case "opInt1":
            try await servant._iceD_opInt1(request)
        case "opIntIntSD":
            try await servant._iceD_opIntIntSD(request)
        case "opIntS":
            try await servant._iceD_opIntS(request)
        case "opLong1":
            try await servant._iceD_opLong1(request)
        case "opLongFloatD":
            try await servant._iceD_opLongFloatD(request)
        case "opLongFloatDS":
            try await servant._iceD_opLongFloatDS(request)
        case "opLongLongSD":
            try await servant._iceD_opLongLongSD(request)
        case "opMDict1":
            try await servant._iceD_opMDict1(request)
        case "opMDict2":
            try await servant._iceD_opMDict2(request)
        case "opMSeq1":
            try await servant._iceD_opMSeq1(request)
        case "opMSeq2":
            try await servant._iceD_opMSeq2(request)
        case "opMStruct1":
            try await servant._iceD_opMStruct1(request)
        case "opMStruct2":
            try await servant._iceD_opMStruct2(request)
        case "opMyClass":
            try await servant._iceD_opMyClass(request)
        case "opMyClass1":
            try await servant._iceD_opMyClass1(request)
        case "opMyEnum":
            try await servant._iceD_opMyEnum(request)
        case "opMyEnumMyEnumSD":
            try await servant._iceD_opMyEnumMyEnumSD(request)
        case "opMyEnumStringD":
            try await servant._iceD_opMyEnumStringD(request)
        case "opMyEnumStringDS":
            try await servant._iceD_opMyEnumStringDS(request)
        case "opMyStruct1":
            try await servant._iceD_opMyStruct1(request)
        case "opMyStructMyEnumD":
            try await servant._iceD_opMyStructMyEnumD(request)
        case "opMyStructMyEnumDS":
            try await servant._iceD_opMyStructMyEnumDS(request)
        case "opShort1":
            try await servant._iceD_opShort1(request)
        case "opShortIntD":
            try await servant._iceD_opShortIntD(request)
        case "opShortIntDS":
            try await servant._iceD_opShortIntDS(request)
        case "opShortIntLong":
            try await servant._iceD_opShortIntLong(request)
        case "opShortIntLongS":
            try await servant._iceD_opShortIntLongS(request)
        case "opShortIntLongSS":
            try await servant._iceD_opShortIntLongSS(request)
        case "opShortShortSD":
            try await servant._iceD_opShortShortSD(request)
        case "opString":
            try await servant._iceD_opString(request)
        case "opString1":
            try await servant._iceD_opString1(request)
        case "opStringDoubleSD":
            try await servant._iceD_opStringDoubleSD(request)
        case "opStringFloatSD":
            try await servant._iceD_opStringFloatSD(request)
        case "opStringLiterals":
            try await servant._iceD_opStringLiterals(request)
        case "opStringMyEnumD":
            try await servant._iceD_opStringMyEnumD(request)
        case "opStringMyEnumDS":
            try await servant._iceD_opStringMyEnumDS(request)
        case "opStringS":
            try await servant._iceD_opStringS(request)
        case "opStringS1":
            try await servant._iceD_opStringS1(request)
        case "opStringS2":
            try await servant._iceD_opStringS2(request)
        case "opStringSS":
            try await servant._iceD_opStringSS(request)
        case "opStringSSS":
            try await servant._iceD_opStringSSS(request)
        case "opStringStringD":
            try await servant._iceD_opStringStringD(request)
        case "opStringStringDS":
            try await servant._iceD_opStringStringDS(request)
        case "opStringStringSD":
            try await servant._iceD_opStringStringSD(request)
        case "opStruct":
            try await servant._iceD_opStruct(request)
        case "opVoid":
            try await servant._iceD_opVoid(request)
        case "shutdown":
            try await servant._iceD_shutdown(request)
        case "supportsCompress":
            try await servant._iceD_supportsCompress(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol MyDerivedClass: MyClass {
    func opDerived(current: Ice.Current) async throws

    func opMyClass1(opMyClass1: MyClass1?, current: Ice.Current) async throws -> MyClass1?

    func opMyStruct1(opMyStruct1: MyStruct1, current: Ice.Current) async throws -> MyStruct1
}


/// Dispatcher for `MyDerivedClass` servants.
public struct MyDerivedClassDisp: Ice.Dispatcher {
    public let servant: MyDerivedClass
    private static let defaultObject = Ice.ObjectI<MyDerivedClassTraits>()

    public init(_ servant: MyDerivedClass) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "ice_id":
            try await (servant as? Ice.Object ?? MyDerivedClassDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? MyDerivedClassDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? MyDerivedClassDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? MyDerivedClassDisp.defaultObject)._iceD_ice_ping(request)
        case "opBool":
            try await servant._iceD_opBool(request)
        case "opBoolBoolSD":
            try await servant._iceD_opBoolBoolSD(request)
        case "opBoolS":
            try await servant._iceD_opBoolS(request)
        case "opBoolSS":
            try await servant._iceD_opBoolSS(request)
        case "opByte":
            try await servant._iceD_opByte(request)
        case "opByte1":
            try await servant._iceD_opByte1(request)
        case "opByteBoolD":
            try await servant._iceD_opByteBoolD(request)
        case "opByteBoolD1":
            try await servant._iceD_opByteBoolD1(request)
        case "opByteBoolD2":
            try await servant._iceD_opByteBoolD2(request)
        case "opByteBoolDS":
            try await servant._iceD_opByteBoolDS(request)
        case "opByteByteSD":
            try await servant._iceD_opByteByteSD(request)
        case "opByteS":
            try await servant._iceD_opByteS(request)
        case "opByteSOneway":
            try await servant._iceD_opByteSOneway(request)
        case "opByteSOnewayCallCount":
            try await servant._iceD_opByteSOnewayCallCount(request)
        case "opByteSS":
            try await servant._iceD_opByteSS(request)
        case "opContext":
            try await servant._iceD_opContext(request)
        case "opDouble1":
            try await servant._iceD_opDouble1(request)
        case "opDoubleMarshaling":
            try await servant._iceD_opDoubleMarshaling(request)
        case "opFloat1":
            try await servant._iceD_opFloat1(request)
        case "opFloatDouble":
            try await servant._iceD_opFloatDouble(request)
        case "opFloatDoubleS":
            try await servant._iceD_opFloatDoubleS(request)
        case "opFloatDoubleSS":
            try await servant._iceD_opFloatDoubleSS(request)
        case "opIdempotent":
            try await servant._iceD_opIdempotent(request)
        case "opInt1":
            try await servant._iceD_opInt1(request)
        case "opIntIntSD":
            try await servant._iceD_opIntIntSD(request)
        case "opIntS":
            try await servant._iceD_opIntS(request)
        case "opLong1":
            try await servant._iceD_opLong1(request)
        case "opLongFloatD":
            try await servant._iceD_opLongFloatD(request)
        case "opLongFloatDS":
            try await servant._iceD_opLongFloatDS(request)
        case "opLongLongSD":
            try await servant._iceD_opLongLongSD(request)
        case "opMDict1":
            try await servant._iceD_opMDict1(request)
        case "opMDict2":
            try await servant._iceD_opMDict2(request)
        case "opMSeq1":
            try await servant._iceD_opMSeq1(request)
        case "opMSeq2":
            try await servant._iceD_opMSeq2(request)
        case "opMStruct1":
            try await servant._iceD_opMStruct1(request)
        case "opMStruct2":
            try await servant._iceD_opMStruct2(request)
        case "opMyClass":
            try await servant._iceD_opMyClass(request)
        case "opMyEnum":
            try await servant._iceD_opMyEnum(request)
        case "opMyEnumMyEnumSD":
            try await servant._iceD_opMyEnumMyEnumSD(request)
        case "opMyEnumStringD":
            try await servant._iceD_opMyEnumStringD(request)
        case "opMyEnumStringDS":
            try await servant._iceD_opMyEnumStringDS(request)
        case "opMyStructMyEnumD":
            try await servant._iceD_opMyStructMyEnumD(request)
        case "opMyStructMyEnumDS":
            try await servant._iceD_opMyStructMyEnumDS(request)
        case "opShort1":
            try await servant._iceD_opShort1(request)
        case "opShortIntD":
            try await servant._iceD_opShortIntD(request)
        case "opShortIntDS":
            try await servant._iceD_opShortIntDS(request)
        case "opShortIntLong":
            try await servant._iceD_opShortIntLong(request)
        case "opShortIntLongS":
            try await servant._iceD_opShortIntLongS(request)
        case "opShortIntLongSS":
            try await servant._iceD_opShortIntLongSS(request)
        case "opShortShortSD":
            try await servant._iceD_opShortShortSD(request)
        case "opString":
            try await servant._iceD_opString(request)
        case "opString1":
            try await servant._iceD_opString1(request)
        case "opStringDoubleSD":
            try await servant._iceD_opStringDoubleSD(request)
        case "opStringFloatSD":
            try await servant._iceD_opStringFloatSD(request)
        case "opStringLiterals":
            try await servant._iceD_opStringLiterals(request)
        case "opStringMyEnumD":
            try await servant._iceD_opStringMyEnumD(request)
        case "opStringMyEnumDS":
            try await servant._iceD_opStringMyEnumDS(request)
        case "opStringS":
            try await servant._iceD_opStringS(request)
        case "opStringS1":
            try await servant._iceD_opStringS1(request)
        case "opStringS2":
            try await servant._iceD_opStringS2(request)
        case "opStringSS":
            try await servant._iceD_opStringSS(request)
        case "opStringSSS":
            try await servant._iceD_opStringSSS(request)
        case "opStringStringD":
            try await servant._iceD_opStringStringD(request)
        case "opStringStringDS":
            try await servant._iceD_opStringStringDS(request)
        case "opStringStringSD":
            try await servant._iceD_opStringStringSD(request)
        case "opStruct":
            try await servant._iceD_opStruct(request)
        case "opVoid":
            try await servant._iceD_opVoid(request)
        case "shutdown":
            try await servant._iceD_shutdown(request)
        case "supportsCompress":
            try await servant._iceD_supportsCompress(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol MyDerivedClass: Test.MyClass {}

extension MyClass {
    public func _iceD_shutdown(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.shutdown(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_supportsCompress(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.supportsCompress(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opVoid(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.opVoid(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_opByte(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: Swift.UInt8 = try istr.read()
        let iceP_p2: Swift.UInt8 = try istr.read()
        let result = try await self.opByte(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(iceP_p3)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opBool(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: Swift.Bool = try istr.read()
        let iceP_p2: Swift.Bool = try istr.read()
        let result = try await self.opBool(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(iceP_p3)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opShortIntLong(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: Swift.Int16 = try istr.read()
        let iceP_p2: Swift.Int32 = try istr.read()
        let iceP_p3: Swift.Int64 = try istr.read()
        let result = try await self.opShortIntLong(p1: iceP_p1, p2: iceP_p2, p3: iceP_p3, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p4, iceP_p5, iceP_p6) = value
            ostr.write(iceP_p4)
            ostr.write(iceP_p5)
            ostr.write(iceP_p6)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opFloatDouble(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: Swift.Float = try istr.read()
        let iceP_p2: Swift.Double = try istr.read()
        let result = try await self.opFloatDouble(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3, iceP_p4) = value
            ostr.write(iceP_p3)
            ostr.write(iceP_p4)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opString(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: Swift.String = try istr.read()
        let iceP_p2: Swift.String = try istr.read()
        let result = try await self.opString(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(iceP_p3)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opMyEnum(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: MyEnum = try istr.read()
        let result = try await self.opMyEnum(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p2) = value
            ostr.write(iceP_p2)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opMyClass(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: MyClassPrx? = try istr.read(MyClassPrx.self)
        let result = try await self.opMyClass(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p2, iceP_p3) = value
            ostr.write(iceP_p2)
            ostr.write(iceP_p3)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opStruct(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: Structure = try istr.read()
        let iceP_p2: Structure = try istr.read()
        let result = try await self.opStruct(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(iceP_p3)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opByteS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: ByteS = try istr.read()
        let iceP_p2: ByteS = try istr.read()
        let result = try await self.opByteS(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(iceP_p3)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opBoolS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: BoolS = try istr.read()
        let iceP_p2: BoolS = try istr.read()
        let result = try await self.opBoolS(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(iceP_p3)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opShortIntLongS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: ShortS = try istr.read()
        let iceP_p2: IntS = try istr.read()
        let iceP_p3: LongS = try istr.read()
        let result = try await self.opShortIntLongS(p1: iceP_p1, p2: iceP_p2, p3: iceP_p3, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p4, iceP_p5, iceP_p6) = value
            ostr.write(iceP_p4)
            ostr.write(iceP_p5)
            ostr.write(iceP_p6)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opFloatDoubleS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: FloatS = try istr.read()
        let iceP_p2: DoubleS = try istr.read()
        let result = try await self.opFloatDoubleS(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3, iceP_p4) = value
            ostr.write(iceP_p3)
            ostr.write(iceP_p4)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opStringS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: StringS = try istr.read()
        let iceP_p2: StringS = try istr.read()
        let result = try await self.opStringS(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(iceP_p3)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opByteSS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: ByteSS = try ByteSSHelper.read(from: istr)
        let iceP_p2: ByteSS = try ByteSSHelper.read(from: istr)
        let result = try await self.opByteSS(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ByteSSHelper.write(to: ostr, value: iceP_p3)
            ByteSSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opBoolSS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: BoolSS = try BoolSSHelper.read(from: istr)
        let iceP_p2: BoolSS = try BoolSSHelper.read(from: istr)
        let result = try await self.opBoolSS(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            BoolSSHelper.write(to: ostr, value: iceP_p3)
            BoolSSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opShortIntLongSS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: ShortSS = try ShortSSHelper.read(from: istr)
        let iceP_p2: IntSS = try IntSSHelper.read(from: istr)
        let iceP_p3: LongSS = try LongSSHelper.read(from: istr)
        let result = try await self.opShortIntLongSS(p1: iceP_p1, p2: iceP_p2, p3: iceP_p3, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p4, iceP_p5, iceP_p6) = value
            ShortSSHelper.write(to: ostr, value: iceP_p4)
            IntSSHelper.write(to: ostr, value: iceP_p5)
            LongSSHelper.write(to: ostr, value: iceP_p6)
            LongSSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opFloatDoubleSS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: FloatSS = try FloatSSHelper.read(from: istr)
        let iceP_p2: DoubleSS = try DoubleSSHelper.read(from: istr)
        let result = try await self.opFloatDoubleSS(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3, iceP_p4) = value
            FloatSSHelper.write(to: ostr, value: iceP_p3)
            DoubleSSHelper.write(to: ostr, value: iceP_p4)
            DoubleSSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opStringSS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: StringSS = try StringSSHelper.read(from: istr)
        let iceP_p2: StringSS = try StringSSHelper.read(from: istr)
        let result = try await self.opStringSS(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            StringSSHelper.write(to: ostr, value: iceP_p3)
            StringSSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opStringSSS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: StringSSS = try StringSSSHelper.read(from: istr)
        let iceP_p2: StringSSS = try StringSSSHelper.read(from: istr)
        let result = try await self.opStringSSS(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            StringSSSHelper.write(to: ostr, value: iceP_p3)
            StringSSSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opByteBoolD(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: ByteBoolD = try ByteBoolDHelper.read(from: istr)
        let iceP_p2: ByteBoolD = try ByteBoolDHelper.read(from: istr)
        let result = try await self.opByteBoolD(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ByteBoolDHelper.write(to: ostr, value: iceP_p3)
            ByteBoolDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opShortIntD(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: ShortIntD = try ShortIntDHelper.read(from: istr)
        let iceP_p2: ShortIntD = try ShortIntDHelper.read(from: istr)
        let result = try await self.opShortIntD(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ShortIntDHelper.write(to: ostr, value: iceP_p3)
            ShortIntDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opLongFloatD(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: LongFloatD = try LongFloatDHelper.read(from: istr)
        let iceP_p2: LongFloatD = try LongFloatDHelper.read(from: istr)
        let result = try await self.opLongFloatD(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            LongFloatDHelper.write(to: ostr, value: iceP_p3)
            LongFloatDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opStringStringD(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: StringStringD = try StringStringDHelper.read(from: istr)
        let iceP_p2: StringStringD = try StringStringDHelper.read(from: istr)
        let result = try await self.opStringStringD(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            StringStringDHelper.write(to: ostr, value: iceP_p3)
            StringStringDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opStringMyEnumD(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: StringMyEnumD = try StringMyEnumDHelper.read(from: istr)
        let iceP_p2: StringMyEnumD = try StringMyEnumDHelper.read(from: istr)
        let result = try await self.opStringMyEnumD(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            StringMyEnumDHelper.write(to: ostr, value: iceP_p3)
            StringMyEnumDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opMyEnumStringD(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: MyEnumStringD = try MyEnumStringDHelper.read(from: istr)
        let iceP_p2: MyEnumStringD = try MyEnumStringDHelper.read(from: istr)
        let result = try await self.opMyEnumStringD(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            MyEnumStringDHelper.write(to: ostr, value: iceP_p3)
            MyEnumStringDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opMyStructMyEnumD(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: MyStructMyEnumD = try MyStructMyEnumDHelper.read(from: istr)
        let iceP_p2: MyStructMyEnumD = try MyStructMyEnumDHelper.read(from: istr)
        let result = try await self.opMyStructMyEnumD(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            MyStructMyEnumDHelper.write(to: ostr, value: iceP_p3)
            MyStructMyEnumDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opByteBoolDS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: ByteBoolDS = try ByteBoolDSHelper.read(from: istr)
        let iceP_p2: ByteBoolDS = try ByteBoolDSHelper.read(from: istr)
        let result = try await self.opByteBoolDS(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ByteBoolDSHelper.write(to: ostr, value: iceP_p3)
            ByteBoolDSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opShortIntDS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: ShortIntDS = try ShortIntDSHelper.read(from: istr)
        let iceP_p2: ShortIntDS = try ShortIntDSHelper.read(from: istr)
        let result = try await self.opShortIntDS(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ShortIntDSHelper.write(to: ostr, value: iceP_p3)
            ShortIntDSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opLongFloatDS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: LongFloatDS = try LongFloatDSHelper.read(from: istr)
        let iceP_p2: LongFloatDS = try LongFloatDSHelper.read(from: istr)
        let result = try await self.opLongFloatDS(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            LongFloatDSHelper.write(to: ostr, value: iceP_p3)
            LongFloatDSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opStringStringDS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: StringStringDS = try StringStringDSHelper.read(from: istr)
        let iceP_p2: StringStringDS = try StringStringDSHelper.read(from: istr)
        let result = try await self.opStringStringDS(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            StringStringDSHelper.write(to: ostr, value: iceP_p3)
            StringStringDSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opStringMyEnumDS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: StringMyEnumDS = try StringMyEnumDSHelper.read(from: istr)
        let iceP_p2: StringMyEnumDS = try StringMyEnumDSHelper.read(from: istr)
        let result = try await self.opStringMyEnumDS(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            StringMyEnumDSHelper.write(to: ostr, value: iceP_p3)
            StringMyEnumDSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opMyEnumStringDS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: MyEnumStringDS = try MyEnumStringDSHelper.read(from: istr)
        let iceP_p2: MyEnumStringDS = try MyEnumStringDSHelper.read(from: istr)
        let result = try await self.opMyEnumStringDS(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            MyEnumStringDSHelper.write(to: ostr, value: iceP_p3)
            MyEnumStringDSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opMyStructMyEnumDS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: MyStructMyEnumDS = try MyStructMyEnumDSHelper.read(from: istr)
        let iceP_p2: MyStructMyEnumDS = try MyStructMyEnumDSHelper.read(from: istr)
        let result = try await self.opMyStructMyEnumDS(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            MyStructMyEnumDSHelper.write(to: ostr, value: iceP_p3)
            MyStructMyEnumDSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opByteByteSD(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: ByteByteSD = try ByteByteSDHelper.read(from: istr)
        let iceP_p2: ByteByteSD = try ByteByteSDHelper.read(from: istr)
        let result = try await self.opByteByteSD(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ByteByteSDHelper.write(to: ostr, value: iceP_p3)
            ByteByteSDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opBoolBoolSD(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: BoolBoolSD = try BoolBoolSDHelper.read(from: istr)
        let iceP_p2: BoolBoolSD = try BoolBoolSDHelper.read(from: istr)
        let result = try await self.opBoolBoolSD(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            BoolBoolSDHelper.write(to: ostr, value: iceP_p3)
            BoolBoolSDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opShortShortSD(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: ShortShortSD = try ShortShortSDHelper.read(from: istr)
        let iceP_p2: ShortShortSD = try ShortShortSDHelper.read(from: istr)
        let result = try await self.opShortShortSD(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ShortShortSDHelper.write(to: ostr, value: iceP_p3)
            ShortShortSDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opIntIntSD(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: IntIntSD = try IntIntSDHelper.read(from: istr)
        let iceP_p2: IntIntSD = try IntIntSDHelper.read(from: istr)
        let result = try await self.opIntIntSD(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            IntIntSDHelper.write(to: ostr, value: iceP_p3)
            IntIntSDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opLongLongSD(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: LongLongSD = try LongLongSDHelper.read(from: istr)
        let iceP_p2: LongLongSD = try LongLongSDHelper.read(from: istr)
        let result = try await self.opLongLongSD(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            LongLongSDHelper.write(to: ostr, value: iceP_p3)
            LongLongSDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opStringFloatSD(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: StringFloatSD = try StringFloatSDHelper.read(from: istr)
        let iceP_p2: StringFloatSD = try StringFloatSDHelper.read(from: istr)
        let result = try await self.opStringFloatSD(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            StringFloatSDHelper.write(to: ostr, value: iceP_p3)
            StringFloatSDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opStringDoubleSD(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: StringDoubleSD = try StringDoubleSDHelper.read(from: istr)
        let iceP_p2: StringDoubleSD = try StringDoubleSDHelper.read(from: istr)
        let result = try await self.opStringDoubleSD(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            StringDoubleSDHelper.write(to: ostr, value: iceP_p3)
            StringDoubleSDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opStringStringSD(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: StringStringSD = try StringStringSDHelper.read(from: istr)
        let iceP_p2: StringStringSD = try StringStringSDHelper.read(from: istr)
        let result = try await self.opStringStringSD(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            StringStringSDHelper.write(to: ostr, value: iceP_p3)
            StringStringSDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opMyEnumMyEnumSD(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: MyEnumMyEnumSD = try MyEnumMyEnumSDHelper.read(from: istr)
        let iceP_p2: MyEnumMyEnumSD = try MyEnumMyEnumSDHelper.read(from: istr)
        let result = try await self.opMyEnumMyEnumSD(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            MyEnumMyEnumSDHelper.write(to: ostr, value: iceP_p3)
            MyEnumMyEnumSDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opIntS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_s: IntS = try istr.read()
        let result = try await self.opIntS(s: iceP_s, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opByteSOneway(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_s: ByteS = try istr.read()
        try await self.opByteSOneway(s: iceP_s, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_opByteSOnewayCallCount(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.opByteSOnewayCallCount(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opContext(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.opContext(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            Ice.ContextHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opDoubleMarshaling(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: Swift.Double = try istr.read()
        let iceP_p2: DoubleS = try istr.read()
        try await self.opDoubleMarshaling(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_opIdempotent(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.opIdempotent(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_opByte1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_opByte1: Swift.UInt8 = try istr.read()
        let result = try await self.opByte1(opByte1: iceP_opByte1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opShort1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_opShort1: Swift.Int16 = try istr.read()
        let result = try await self.opShort1(opShort1: iceP_opShort1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opInt1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_opInt1: Swift.Int32 = try istr.read()
        let result = try await self.opInt1(opInt1: iceP_opInt1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opLong1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_opLong1: Swift.Int64 = try istr.read()
        let result = try await self.opLong1(opLong1: iceP_opLong1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opFloat1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_opFloat1: Swift.Float = try istr.read()
        let result = try await self.opFloat1(opFloat1: iceP_opFloat1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opDouble1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_opDouble1: Swift.Double = try istr.read()
        let result = try await self.opDouble1(opDouble1: iceP_opDouble1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opString1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_opString1: Swift.String = try istr.read()
        let result = try await self.opString1(opString1: iceP_opString1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opStringS1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_opStringS1: StringS = try istr.read()
        let result = try await self.opStringS1(opStringS1: iceP_opStringS1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opByteBoolD1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_opByteBoolD1: ByteBoolD = try ByteBoolDHelper.read(from: istr)
        let result = try await self.opByteBoolD1(opByteBoolD1: iceP_opByteBoolD1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ByteBoolDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opStringS2(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_stringS: StringS = try istr.read()
        let result = try await self.opStringS2(stringS: iceP_stringS, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opByteBoolD2(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_byteBoolD: ByteBoolD = try ByteBoolDHelper.read(from: istr)
        let result = try await self.opByteBoolD2(byteBoolD: iceP_byteBoolD, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ByteBoolDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opStringLiterals(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.opStringLiterals(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opMStruct1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.opMStruct1(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opMStruct2(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: Structure = try istr.read()
        let result = try await self.opMStruct2(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p2) = value
            ostr.write(iceP_p2)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opMSeq1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.opMSeq1(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opMSeq2(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: StringS = try istr.read()
        let result = try await self.opMSeq2(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p2) = value
            ostr.write(iceP_p2)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opMDict1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.opMDict1(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            StringStringDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opMDict2(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: StringStringD = try StringStringDHelper.read(from: istr)
        let result = try await self.opMDict2(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p2) = value
            StringStringDHelper.write(to: ostr, value: iceP_p2)
            StringStringDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }
}

extension MyDerivedClass {
    public func _iceD_opDerived(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.opDerived(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_opMyClass1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_opMyClass1: MyClass1?
        try istr.read(MyClass1.self) { iceP_opMyClass1 = $0 }
        try istr.readPendingValues()
        let result = try await self.opMyClass1(opMyClass1: iceP_opMyClass1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_opMyStruct1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_opMyStruct1: MyStruct1 = try istr.read()
        let result = try await self.opMyStruct1(opMyStruct1: iceP_opMyStruct1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }
}

extension MyDerivedClass {}
