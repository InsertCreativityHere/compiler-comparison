//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `FileInfo.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice

/// Basic information about a single file.
public struct FileInfo: Swift.Hashable {
    /// The pathname.
    public var path: Swift.String = ""
    /// The SHA-1 checksum of the file.
    public var checksum: Ice.ByteSeq = Ice.ByteSeq()
    /// The size of the compressed file in number of bytes.
    public var size: Swift.Int32 = 0
    /// The executable flag.
    public var executable: Swift.Bool = false

    public init() {}

    public init(path: Swift.String, checksum: Ice.ByteSeq, size: Swift.Int32, executable: Swift.Bool) {
        self.path = path
        self.checksum = checksum
        self.size = size
        self.executable = executable
    }
}

/// An `Ice.InputStream` extension to read `FileInfo` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `FileInfo` structured value from the stream.
    ///
    /// - returns: `FileInfo` - The structured value read from the stream.
    func read() throws -> FileInfo {
        var v = FileInfo()
        v.path = try self.read()
        v.checksum = try self.read()
        v.size = try self.read()
        v.executable = try self.read()
        return v
    }

    /// Read an optional `FileInfo?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `FileInfo?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> FileInfo? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as FileInfo
    }
}

/// An `Ice.OutputStream` extension to write `FileInfo` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `FileInfo` structured value to the stream.
    ///
    /// - parameter _: `FileInfo` - The value to write to the stream.
    func write(_ v: FileInfo) {
        self.write(v.path)
        self.write(v.checksum)
        self.write(v.size)
        self.write(v.executable)
    }

    /// Write an optional `FileInfo?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `FileInfo?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: FileInfo?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// A sequence with information about many files.
public typealias FileInfoSeq = [FileInfo]

/// Helper class to read and write `FileInfoSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct FileInfoSeqHelper {
    /// Read a `FileInfoSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `FileInfoSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> FileInfoSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 7)
        var v = FileInfoSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: FileInfo = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `FileInfoSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `FileInfoSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> FileInfoSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `FileInfoSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `FileInfoSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: FileInfoSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `FileInfoSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `FileInfoSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: FileInfoSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Basic information about a single file.
public struct LargeFileInfo: Swift.Hashable {
    /// The pathname.
    public var path: Swift.String = ""
    /// The SHA-1 checksum of the file.
    public var checksum: Ice.ByteSeq = Ice.ByteSeq()
    /// The size of the compressed file in number of bytes.
    public var size: Swift.Int64 = 0
    /// The executable flag.
    public var executable: Swift.Bool = false

    public init() {}

    public init(path: Swift.String, checksum: Ice.ByteSeq, size: Swift.Int64, executable: Swift.Bool) {
        self.path = path
        self.checksum = checksum
        self.size = size
        self.executable = executable
    }
}

/// An `Ice.InputStream` extension to read `LargeFileInfo` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `LargeFileInfo` structured value from the stream.
    ///
    /// - returns: `LargeFileInfo` - The structured value read from the stream.
    func read() throws -> LargeFileInfo {
        var v = LargeFileInfo()
        v.path = try self.read()
        v.checksum = try self.read()
        v.size = try self.read()
        v.executable = try self.read()
        return v
    }

    /// Read an optional `LargeFileInfo?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LargeFileInfo?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> LargeFileInfo? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as LargeFileInfo
    }
}

/// An `Ice.OutputStream` extension to write `LargeFileInfo` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `LargeFileInfo` structured value to the stream.
    ///
    /// - parameter _: `LargeFileInfo` - The value to write to the stream.
    func write(_ v: LargeFileInfo) {
        self.write(v.path)
        self.write(v.checksum)
        self.write(v.size)
        self.write(v.executable)
    }

    /// Write an optional `LargeFileInfo?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LargeFileInfo?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: LargeFileInfo?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// A sequence with information about many files.
public typealias LargeFileInfoSeq = [LargeFileInfo]

/// Helper class to read and write `LargeFileInfoSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LargeFileInfoSeqHelper {
    /// Read a `LargeFileInfoSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `LargeFileInfoSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LargeFileInfoSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 11)
        var v = LargeFileInfoSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: LargeFileInfo = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `LargeFileInfoSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LargeFileInfoSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LargeFileInfoSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `LargeFileInfoSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `LargeFileInfoSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LargeFileInfoSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `LargeFileInfoSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LargeFileInfoSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: LargeFileInfoSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}
