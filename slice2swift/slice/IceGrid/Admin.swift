//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Admin.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice
import PromiseKit
import Glacier2

/// An enumeration representing the state of the server.
public enum ServerState: Swift.UInt8 {
    /// Inactive The server is not running.
    case Inactive = 0
    /// Activating The server is being activated and will change to the active state when the registered server object adapters
    /// are activated or to the activation timed out state if the activation timeout expires.
    case Activating = 1
    /// ActivationTimedOut The activation timed out state indicates that the server activation timed out.
    case ActivationTimedOut = 2
    /// Active The server is running.
    case Active = 3
    /// Deactivating The server is being deactivated.
    case Deactivating = 4
    /// Destroying The server is being destroyed.
    case Destroying = 5
    /// Destroyed The server is destroyed.
    case Destroyed = 6
    public init() {
        self = .Inactive
    }
}

/// An `Ice.InputStream` extension to read `ServerState` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - returns: `ServerState` - The enumarated value.
    func read() throws -> ServerState {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 6)
        guard let val = ServerState(rawValue: rawValue) else {
            throw Ice.MarshalException("invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ServerState` - The enumerated value.
    func read(tag: Swift.Int32) throws -> ServerState? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as ServerState
    }
}

/// An `Ice.OutputStream` extension to write `ServerState` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// parameter _: `ServerState` - The enumerator to write.
    func write(_ v: ServerState) {
        write(enum: v.rawValue, maxValue: 6)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// parameter _: `ServerState` - The enumerator to write.
    func write(tag: Swift.Int32, value: ServerState?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 6)
    }
}

/// A dictionary of proxies.
public typealias StringObjectProxyDict = [Swift.String: Ice.ObjectPrx?]

/// Helper class to read and write `StringObjectProxyDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringObjectProxyDictHelper {
    /// Read a `StringObjectProxyDict` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringObjectProxyDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringObjectProxyDict {
        let sz = try Swift.Int(istr.readSize())
        var v = StringObjectProxyDict()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
            v[key] = value
        }
        return v
    }
    /// Read an optional `StringObjectProxyDict?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringObjectProxyDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringObjectProxyDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringObjectProxyDict` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringObjectProxyDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringObjectProxyDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `StringObjectProxyDict?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringObjectProxyDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: StringObjectProxyDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Information about an Ice object.
public struct ObjectInfo {
    /// The proxy of the object.
    public var proxy: Ice.ObjectPrx? = nil
    /// The type of the object.
    public var `type`: Swift.String = ""

    public init() {}

    public init(proxy: Ice.ObjectPrx?, `type`: Swift.String) {
        self.proxy = proxy
        self.`type` = `type`
    }
}

/// An `Ice.InputStream` extension to read `ObjectInfo` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `ObjectInfo` structured value from the stream.
    ///
    /// - returns: `ObjectInfo` - The structured value read from the stream.
    func read() throws -> ObjectInfo {
        var v = ObjectInfo()
        v.proxy = try self.read(Ice.ObjectPrx.self)
        v.`type` = try self.read()
        return v
    }

    /// Read an optional `ObjectInfo?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ObjectInfo?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> ObjectInfo? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as ObjectInfo
    }
}

/// An `Ice.OutputStream` extension to write `ObjectInfo` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `ObjectInfo` structured value to the stream.
    ///
    /// - parameter _: `ObjectInfo` - The value to write to the stream.
    func write(_ v: ObjectInfo) {
        self.write(v.proxy)
        self.write(v.`type`)
    }

    /// Write an optional `ObjectInfo?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ObjectInfo?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: ObjectInfo?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// A sequence of object information structures.
public typealias ObjectInfoSeq = [ObjectInfo]

/// Helper class to read and write `ObjectInfoSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ObjectInfoSeqHelper {
    /// Read a `ObjectInfoSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ObjectInfoSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ObjectInfoSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 3)
        var v = ObjectInfoSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: ObjectInfo = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `ObjectInfoSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ObjectInfoSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ObjectInfoSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ObjectInfoSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ObjectInfoSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ObjectInfoSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `ObjectInfoSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ObjectInfoSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ObjectInfoSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Information about an adapter registered with the IceGrid registry.
public struct AdapterInfo {
    /// The id of the adapter.
    public var id: Swift.String = ""
    /// A dummy direct proxy that contains the adapter endpoints.
    public var proxy: Ice.ObjectPrx? = nil
    /// The replica group id of the object adapter, or empty if the adapter doesn't belong to a replica group.
    public var replicaGroupId: Swift.String = ""

    public init() {}

    public init(id: Swift.String, proxy: Ice.ObjectPrx?, replicaGroupId: Swift.String) {
        self.id = id
        self.proxy = proxy
        self.replicaGroupId = replicaGroupId
    }
}

/// An `Ice.InputStream` extension to read `AdapterInfo` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `AdapterInfo` structured value from the stream.
    ///
    /// - returns: `AdapterInfo` - The structured value read from the stream.
    func read() throws -> AdapterInfo {
        var v = AdapterInfo()
        v.id = try self.read()
        v.proxy = try self.read(Ice.ObjectPrx.self)
        v.replicaGroupId = try self.read()
        return v
    }

    /// Read an optional `AdapterInfo?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `AdapterInfo?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> AdapterInfo? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as AdapterInfo
    }
}

/// An `Ice.OutputStream` extension to write `AdapterInfo` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `AdapterInfo` structured value to the stream.
    ///
    /// - parameter _: `AdapterInfo` - The value to write to the stream.
    func write(_ v: AdapterInfo) {
        self.write(v.id)
        self.write(v.proxy)
        self.write(v.replicaGroupId)
    }

    /// Write an optional `AdapterInfo?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `AdapterInfo?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: AdapterInfo?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// A sequence of adapter information structures.
public typealias AdapterInfoSeq = [AdapterInfo]

/// Helper class to read and write `AdapterInfoSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct AdapterInfoSeqHelper {
    /// Read a `AdapterInfoSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `AdapterInfoSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> AdapterInfoSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 4)
        var v = AdapterInfoSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: AdapterInfo = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `AdapterInfoSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `AdapterInfoSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> AdapterInfoSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `AdapterInfoSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `AdapterInfoSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: AdapterInfoSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `AdapterInfoSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `AdapterInfoSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: AdapterInfoSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Information about a server managed by an IceGrid node.
public class ServerInfo {
    /// The server application.
    public var application: Swift.String = ""
    /// The application uuid.
    public var uuid: Swift.String = ""
    /// The application revision.
    public var revision: Swift.Int32 = 0
    /// The server node.
    public var node: Swift.String = ""
    /// The server descriptor.
    public var descriptor: ServerDescriptor? = nil
    /// The id of the session which allocated the server.
    public var sessionId: Swift.String = ""

    public init() {}

    public init(application: Swift.String, uuid: Swift.String, revision: Swift.Int32, node: Swift.String, descriptor: ServerDescriptor?, sessionId: Swift.String) {
        self.application = application
        self.uuid = uuid
        self.revision = revision
        self.node = node
        self.descriptor = descriptor
        self.sessionId = sessionId
    }
}

/// An `Ice.InputStream` extension to read `ServerInfo` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `ServerInfo` structured value from the stream.
    ///
    /// - returns: `ServerInfo` - The structured value read from the stream.
    func read() throws -> ServerInfo {
        let v = ServerInfo()
        v.application = try self.read()
        v.uuid = try self.read()
        v.revision = try self.read()
        v.node = try self.read()
        try self.read(ServerDescriptor.self) { v.descriptor = $0 }
        v.sessionId = try self.read()
        return v
    }

    /// Read an optional `ServerInfo?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ServerInfo?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> ServerInfo? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as ServerInfo
    }
}

/// An `Ice.OutputStream` extension to write `ServerInfo` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `ServerInfo` structured value to the stream.
    ///
    /// - parameter _: `ServerInfo` - The value to write to the stream.
    func write(_ v: ServerInfo) {
        self.write(v.application)
        self.write(v.uuid)
        self.write(v.revision)
        self.write(v.node)
        self.write(v.descriptor)
        self.write(v.sessionId)
    }

    /// Write an optional `ServerInfo?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ServerInfo?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: ServerInfo?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// Information about an IceGrid node.
public struct NodeInfo: Swift.Hashable {
    /// The name of the node.
    public var name: Swift.String = ""
    /// The operating system name.
    public var os: Swift.String = ""
    /// The network name of the host running this node (as defined in uname()).
    public var hostname: Swift.String = ""
    /// The operation system release level (as defined in uname()).
    public var release: Swift.String = ""
    /// The operation system version (as defined in uname()).
    public var version: Swift.String = ""
    /// The machine hardware type (as defined in uname()).
    public var machine: Swift.String = ""
    /// The number of processor threads on the node. For example, nProcessors is 8 on a computer with a single
    /// quad-core processor and two HT threads per core.
    public var nProcessors: Swift.Int32 = 0
    /// The path to the node data directory.
    public var dataDir: Swift.String = ""

    public init() {}

    public init(name: Swift.String, os: Swift.String, hostname: Swift.String, release: Swift.String, version: Swift.String, machine: Swift.String, nProcessors: Swift.Int32, dataDir: Swift.String) {
        self.name = name
        self.os = os
        self.hostname = hostname
        self.release = release
        self.version = version
        self.machine = machine
        self.nProcessors = nProcessors
        self.dataDir = dataDir
    }
}

/// An `Ice.InputStream` extension to read `NodeInfo` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `NodeInfo` structured value from the stream.
    ///
    /// - returns: `NodeInfo` - The structured value read from the stream.
    func read() throws -> NodeInfo {
        var v = NodeInfo()
        v.name = try self.read()
        v.os = try self.read()
        v.hostname = try self.read()
        v.release = try self.read()
        v.version = try self.read()
        v.machine = try self.read()
        v.nProcessors = try self.read()
        v.dataDir = try self.read()
        return v
    }

    /// Read an optional `NodeInfo?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `NodeInfo?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> NodeInfo? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as NodeInfo
    }
}

/// An `Ice.OutputStream` extension to write `NodeInfo` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `NodeInfo` structured value to the stream.
    ///
    /// - parameter _: `NodeInfo` - The value to write to the stream.
    func write(_ v: NodeInfo) {
        self.write(v.name)
        self.write(v.os)
        self.write(v.hostname)
        self.write(v.release)
        self.write(v.version)
        self.write(v.machine)
        self.write(v.nProcessors)
        self.write(v.dataDir)
    }

    /// Write an optional `NodeInfo?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `NodeInfo?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: NodeInfo?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// Information about an IceGrid registry replica.
public struct RegistryInfo: Swift.Hashable {
    /// The name of the registry.
    public var name: Swift.String = ""
    /// The network name of the host running this registry (as defined in uname()).
    public var hostname: Swift.String = ""

    public init() {}

    public init(name: Swift.String, hostname: Swift.String) {
        self.name = name
        self.hostname = hostname
    }
}

/// An `Ice.InputStream` extension to read `RegistryInfo` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `RegistryInfo` structured value from the stream.
    ///
    /// - returns: `RegistryInfo` - The structured value read from the stream.
    func read() throws -> RegistryInfo {
        var v = RegistryInfo()
        v.name = try self.read()
        v.hostname = try self.read()
        return v
    }

    /// Read an optional `RegistryInfo?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `RegistryInfo?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> RegistryInfo? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as RegistryInfo
    }
}

/// An `Ice.OutputStream` extension to write `RegistryInfo` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `RegistryInfo` structured value to the stream.
    ///
    /// - parameter _: `RegistryInfo` - The value to write to the stream.
    func write(_ v: RegistryInfo) {
        self.write(v.name)
        self.write(v.hostname)
    }

    /// Write an optional `RegistryInfo?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `RegistryInfo?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: RegistryInfo?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// A sequence of RegistryInfo structures.
public typealias RegistryInfoSeq = [RegistryInfo]

/// Helper class to read and write `RegistryInfoSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct RegistryInfoSeqHelper {
    /// Read a `RegistryInfoSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `RegistryInfoSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> RegistryInfoSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = RegistryInfoSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: RegistryInfo = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `RegistryInfoSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `RegistryInfoSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> RegistryInfoSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `RegistryInfoSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `RegistryInfoSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: RegistryInfoSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `RegistryInfoSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `RegistryInfoSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: RegistryInfoSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Information about the load of a node.
public struct LoadInfo {
    /// The load average over the past minute.
    public var avg1: Swift.Float = 0.0
    /// The load average over the past 5 minutes.
    public var avg5: Swift.Float = 0.0
    /// The load average over the past 15 minutes.
    public var avg15: Swift.Float = 0.0

    public init() {}

    public init(avg1: Swift.Float, avg5: Swift.Float, avg15: Swift.Float) {
        self.avg1 = avg1
        self.avg5 = avg5
        self.avg15 = avg15
    }
}

/// An `Ice.InputStream` extension to read `LoadInfo` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `LoadInfo` structured value from the stream.
    ///
    /// - returns: `LoadInfo` - The structured value read from the stream.
    func read() throws -> LoadInfo {
        var v = LoadInfo()
        v.avg1 = try self.read()
        v.avg5 = try self.read()
        v.avg15 = try self.read()
        return v
    }

    /// Read an optional `LoadInfo?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LoadInfo?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> LoadInfo? {
        guard try readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try skipSize()
        return try read() as LoadInfo
    }
}

/// An `Ice.OutputStream` extension to write `LoadInfo` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `LoadInfo` structured value to the stream.
    ///
    /// - parameter _: `LoadInfo` - The value to write to the stream.
    func write(_ v: LoadInfo) {
        self.write(v.avg1)
        self.write(v.avg5)
        self.write(v.avg15)
    }

    /// Write an optional `LoadInfo?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LoadInfo?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: LoadInfo?) {
        if let v = value {
            if writeOptional(tag: tag, format: .VSize) {
                write(size: 12)
                write(v)
            }
        }
    }
}

/// Information about an IceGrid application.
public class ApplicationInfo {
    /// Unique application identifier.
    public var uuid: Swift.String = ""
    /// The creation time.
    public var createTime: Swift.Int64 = 0
    /// The user who created the application.
    public var createUser: Swift.String = ""
    /// The update time.
    public var updateTime: Swift.Int64 = 0
    /// The user who updated the application.
    public var updateUser: Swift.String = ""
    /// The application revision number.
    public var revision: Swift.Int32 = 0
    /// The application descriptor
    public var descriptor: ApplicationDescriptor = ApplicationDescriptor()

    public init() {}

    public init(uuid: Swift.String, createTime: Swift.Int64, createUser: Swift.String, updateTime: Swift.Int64, updateUser: Swift.String, revision: Swift.Int32, descriptor: ApplicationDescriptor) {
        self.uuid = uuid
        self.createTime = createTime
        self.createUser = createUser
        self.updateTime = updateTime
        self.updateUser = updateUser
        self.revision = revision
        self.descriptor = descriptor
    }
}

/// An `Ice.InputStream` extension to read `ApplicationInfo` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `ApplicationInfo` structured value from the stream.
    ///
    /// - returns: `ApplicationInfo` - The structured value read from the stream.
    func read() throws -> ApplicationInfo {
        let v = ApplicationInfo()
        v.uuid = try self.read()
        v.createTime = try self.read()
        v.createUser = try self.read()
        v.updateTime = try self.read()
        v.updateUser = try self.read()
        v.revision = try self.read()
        v.descriptor = try self.read()
        return v
    }

    /// Read an optional `ApplicationInfo?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ApplicationInfo?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> ApplicationInfo? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as ApplicationInfo
    }
}

/// An `Ice.OutputStream` extension to write `ApplicationInfo` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `ApplicationInfo` structured value to the stream.
    ///
    /// - parameter _: `ApplicationInfo` - The value to write to the stream.
    func write(_ v: ApplicationInfo) {
        self.write(v.uuid)
        self.write(v.createTime)
        self.write(v.createUser)
        self.write(v.updateTime)
        self.write(v.updateUser)
        self.write(v.revision)
        self.write(v.descriptor)
    }

    /// Write an optional `ApplicationInfo?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ApplicationInfo?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: ApplicationInfo?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// A sequence of ApplicationInfo structures.
public typealias ApplicationInfoSeq = [ApplicationInfo]

/// Helper class to read and write `ApplicationInfoSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ApplicationInfoSeqHelper {
    /// Read a `ApplicationInfoSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ApplicationInfoSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ApplicationInfoSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 33)
        var v = ApplicationInfoSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: ApplicationInfo = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `ApplicationInfoSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ApplicationInfoSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ApplicationInfoSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ApplicationInfoSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ApplicationInfoSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ApplicationInfoSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `ApplicationInfoSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ApplicationInfoSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ApplicationInfoSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Information about updates to an IceGrid application.
public class ApplicationUpdateInfo {
    /// The update time.
    public var updateTime: Swift.Int64 = 0
    /// The user who updated the application.
    public var updateUser: Swift.String = ""
    /// The application revision number.
    public var revision: Swift.Int32 = 0
    /// The update descriptor.
    public var descriptor: ApplicationUpdateDescriptor = ApplicationUpdateDescriptor()

    public init() {}

    public init(updateTime: Swift.Int64, updateUser: Swift.String, revision: Swift.Int32, descriptor: ApplicationUpdateDescriptor) {
        self.updateTime = updateTime
        self.updateUser = updateUser
        self.revision = revision
        self.descriptor = descriptor
    }
}

/// An `Ice.InputStream` extension to read `ApplicationUpdateInfo` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `ApplicationUpdateInfo` structured value from the stream.
    ///
    /// - returns: `ApplicationUpdateInfo` - The structured value read from the stream.
    func read() throws -> ApplicationUpdateInfo {
        let v = ApplicationUpdateInfo()
        v.updateTime = try self.read()
        v.updateUser = try self.read()
        v.revision = try self.read()
        v.descriptor = try self.read()
        return v
    }

    /// Read an optional `ApplicationUpdateInfo?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ApplicationUpdateInfo?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> ApplicationUpdateInfo? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as ApplicationUpdateInfo
    }
}

/// An `Ice.OutputStream` extension to write `ApplicationUpdateInfo` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `ApplicationUpdateInfo` structured value to the stream.
    ///
    /// - parameter _: `ApplicationUpdateInfo` - The value to write to the stream.
    func write(_ v: ApplicationUpdateInfo) {
        self.write(v.updateTime)
        self.write(v.updateUser)
        self.write(v.revision)
        self.write(v.descriptor)
    }

    /// Write an optional `ApplicationUpdateInfo?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ApplicationUpdateInfo?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: ApplicationUpdateInfo?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// Traits for Slice interface`Admin`.
public struct AdminTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::Admin"]
    public static let staticId = "::IceGrid::Admin"
}

/// Traits for Slice interface`FileIterator`.
public struct FileIteratorTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::FileIterator"]
    public static let staticId = "::IceGrid::FileIterator"
}

/// Dynamic information about the state of a server.
public struct ServerDynamicInfo: Swift.Hashable {
    /// The id of the server.
    public var id: Swift.String = ""
    /// The state of the server.
    public var state: ServerState = .Inactive
    /// The process id of the server.
    public var pid: Swift.Int32 = 0
    /// Indicates whether the server is enabled.
    public var enabled: Swift.Bool = false

    public init() {}

    public init(id: Swift.String, state: ServerState, pid: Swift.Int32, enabled: Swift.Bool) {
        self.id = id
        self.state = state
        self.pid = pid
        self.enabled = enabled
    }
}

/// An `Ice.InputStream` extension to read `ServerDynamicInfo` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `ServerDynamicInfo` structured value from the stream.
    ///
    /// - returns: `ServerDynamicInfo` - The structured value read from the stream.
    func read() throws -> ServerDynamicInfo {
        var v = ServerDynamicInfo()
        v.id = try self.read()
        v.state = try self.read()
        v.pid = try self.read()
        v.enabled = try self.read()
        return v
    }

    /// Read an optional `ServerDynamicInfo?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ServerDynamicInfo?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> ServerDynamicInfo? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as ServerDynamicInfo
    }
}

/// An `Ice.OutputStream` extension to write `ServerDynamicInfo` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `ServerDynamicInfo` structured value to the stream.
    ///
    /// - parameter _: `ServerDynamicInfo` - The value to write to the stream.
    func write(_ v: ServerDynamicInfo) {
        self.write(v.id)
        self.write(v.state)
        self.write(v.pid)
        self.write(v.enabled)
    }

    /// Write an optional `ServerDynamicInfo?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ServerDynamicInfo?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: ServerDynamicInfo?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// A sequence of server dynamic information structures.
public typealias ServerDynamicInfoSeq = [ServerDynamicInfo]

/// Helper class to read and write `ServerDynamicInfoSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ServerDynamicInfoSeqHelper {
    /// Read a `ServerDynamicInfoSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ServerDynamicInfoSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ServerDynamicInfoSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 7)
        var v = ServerDynamicInfoSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: ServerDynamicInfo = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `ServerDynamicInfoSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ServerDynamicInfoSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ServerDynamicInfoSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ServerDynamicInfoSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ServerDynamicInfoSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ServerDynamicInfoSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `ServerDynamicInfoSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ServerDynamicInfoSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ServerDynamicInfoSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Dynamic information about the state of an adapter.
public struct AdapterDynamicInfo {
    /// The id of the adapter.
    public var id: Swift.String = ""
    /// The direct proxy containing the adapter endpoints. This proxy is never null.
    public var proxy: Ice.ObjectPrx? = nil

    public init() {}

    public init(id: Swift.String, proxy: Ice.ObjectPrx?) {
        self.id = id
        self.proxy = proxy
    }
}

/// An `Ice.InputStream` extension to read `AdapterDynamicInfo` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `AdapterDynamicInfo` structured value from the stream.
    ///
    /// - returns: `AdapterDynamicInfo` - The structured value read from the stream.
    func read() throws -> AdapterDynamicInfo {
        var v = AdapterDynamicInfo()
        v.id = try self.read()
        v.proxy = try self.read(Ice.ObjectPrx.self)
        return v
    }

    /// Read an optional `AdapterDynamicInfo?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `AdapterDynamicInfo?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> AdapterDynamicInfo? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as AdapterDynamicInfo
    }
}

/// An `Ice.OutputStream` extension to write `AdapterDynamicInfo` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `AdapterDynamicInfo` structured value to the stream.
    ///
    /// - parameter _: `AdapterDynamicInfo` - The value to write to the stream.
    func write(_ v: AdapterDynamicInfo) {
        self.write(v.id)
        self.write(v.proxy)
    }

    /// Write an optional `AdapterDynamicInfo?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `AdapterDynamicInfo?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: AdapterDynamicInfo?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// A sequence of adapter dynamic information structures.
public typealias AdapterDynamicInfoSeq = [AdapterDynamicInfo]

/// Helper class to read and write `AdapterDynamicInfoSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct AdapterDynamicInfoSeqHelper {
    /// Read a `AdapterDynamicInfoSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `AdapterDynamicInfoSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> AdapterDynamicInfoSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 3)
        var v = AdapterDynamicInfoSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: AdapterDynamicInfo = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `AdapterDynamicInfoSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `AdapterDynamicInfoSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> AdapterDynamicInfoSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `AdapterDynamicInfoSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `AdapterDynamicInfoSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: AdapterDynamicInfoSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `AdapterDynamicInfoSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `AdapterDynamicInfoSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: AdapterDynamicInfoSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Dynamic information about the state of a node.
public struct NodeDynamicInfo {
    /// Some static information about the node.
    public var info: NodeInfo = NodeInfo()
    /// The dynamic information of the servers deployed on this node.
    public var servers: ServerDynamicInfoSeq = ServerDynamicInfoSeq()
    /// The dynamic information of the adapters deployed on this node.
    public var adapters: AdapterDynamicInfoSeq = AdapterDynamicInfoSeq()

    public init() {}

    public init(info: NodeInfo, servers: ServerDynamicInfoSeq, adapters: AdapterDynamicInfoSeq) {
        self.info = info
        self.servers = servers
        self.adapters = adapters
    }
}

/// An `Ice.InputStream` extension to read `NodeDynamicInfo` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `NodeDynamicInfo` structured value from the stream.
    ///
    /// - returns: `NodeDynamicInfo` - The structured value read from the stream.
    func read() throws -> NodeDynamicInfo {
        var v = NodeDynamicInfo()
        v.info = try self.read()
        v.servers = try ServerDynamicInfoSeqHelper.read(from: self)
        v.adapters = try AdapterDynamicInfoSeqHelper.read(from: self)
        return v
    }

    /// Read an optional `NodeDynamicInfo?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `NodeDynamicInfo?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> NodeDynamicInfo? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as NodeDynamicInfo
    }
}

/// An `Ice.OutputStream` extension to write `NodeDynamicInfo` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `NodeDynamicInfo` structured value to the stream.
    ///
    /// - parameter _: `NodeDynamicInfo` - The value to write to the stream.
    func write(_ v: NodeDynamicInfo) {
        self.write(v.info)
        ServerDynamicInfoSeqHelper.write(to: self, value: v.servers)
        AdapterDynamicInfoSeqHelper.write(to: self, value: v.adapters)
    }

    /// Write an optional `NodeDynamicInfo?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `NodeDynamicInfo?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: NodeDynamicInfo?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// Traits for Slice interface`RegistryObserver`.
public struct RegistryObserverTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::RegistryObserver"]
    public static let staticId = "::IceGrid::RegistryObserver"
}

/// A sequence of node dynamic information structures.
public typealias NodeDynamicInfoSeq = [NodeDynamicInfo]

/// Helper class to read and write `NodeDynamicInfoSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct NodeDynamicInfoSeqHelper {
    /// Read a `NodeDynamicInfoSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `NodeDynamicInfoSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> NodeDynamicInfoSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 13)
        var v = NodeDynamicInfoSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: NodeDynamicInfo = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `NodeDynamicInfoSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `NodeDynamicInfoSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> NodeDynamicInfoSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `NodeDynamicInfoSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `NodeDynamicInfoSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: NodeDynamicInfoSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `NodeDynamicInfoSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `NodeDynamicInfoSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: NodeDynamicInfoSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice interface`NodeObserver`.
public struct NodeObserverTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::NodeObserver"]
    public static let staticId = "::IceGrid::NodeObserver"
}

/// Traits for Slice interface`ApplicationObserver`.
public struct ApplicationObserverTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::ApplicationObserver"]
    public static let staticId = "::IceGrid::ApplicationObserver"
}

/// Traits for Slice interface`AdapterObserver`.
public struct AdapterObserverTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::AdapterObserver"]
    public static let staticId = "::IceGrid::AdapterObserver"
}

/// Traits for Slice interface`ObjectObserver`.
public struct ObjectObserverTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::ObjectObserver"]
    public static let staticId = "::IceGrid::ObjectObserver"
}

/// Traits for Slice interface`AdminSession`.
public struct AdminSessionTraits: Ice.SliceTraits {
    public static let staticIds = ["::Glacier2::Session", "::Ice::Object", "::IceGrid::AdminSession"]
    public static let staticId = "::IceGrid::AdminSession"
}

/// The IceGrid administrative interface. Allowing access to this interface is a security risk!
/// Please see the IceGrid documentation for further information.
///
/// AdminPrx Methods:
///
///  - addApplication: Add an application to IceGrid.
///
///  - addApplicationAsync: Add an application to IceGrid.
///
///  - syncApplication: Synchronize a deployed application with the given application descriptor.
///
///  - syncApplicationAsync: Synchronize a deployed application with the given application descriptor.
///
///  - updateApplication: Update a deployed application with the given update application descriptor.
///
///  - updateApplicationAsync: Update a deployed application with the given update application descriptor.
///
///  - syncApplicationWithoutRestart: Synchronize a deployed application with the given application descriptor.
///
///  - syncApplicationWithoutRestartAsync: Synchronize a deployed application with the given application descriptor.
///
///  - updateApplicationWithoutRestart: Update a deployed application with the given update application descriptor only if no server restarts are necessary for the update of the application.
///
///  - updateApplicationWithoutRestartAsync: Update a deployed application with the given update application descriptor only if no server restarts are necessary for the update of the application.
///
///  - removeApplication: Remove an application from IceGrid.
///
///  - removeApplicationAsync: Remove an application from IceGrid.
///
///  - instantiateServer: Instantiate a server template from an application on the given node.
///
///  - instantiateServerAsync: Instantiate a server template from an application on the given node.
///
///  - getApplicationInfo: Get an application descriptor.
///
///  - getApplicationInfoAsync: Get an application descriptor.
///
///  - getDefaultApplicationDescriptor: Get the default application descriptor.
///
///  - getDefaultApplicationDescriptorAsync: Get the default application descriptor.
///
///  - getAllApplicationNames: Get all the IceGrid applications currently registered.
///
///  - getAllApplicationNamesAsync: Get all the IceGrid applications currently registered.
///
///  - getServerInfo: Get the server information for the server with the given id.
///
///  - getServerInfoAsync: Get the server information for the server with the given id.
///
///  - getServerState: Get a server's state.
///
///  - getServerStateAsync: Get a server's state.
///
///  - getServerPid: Get a server's system process id.
///
///  - getServerPidAsync: Get a server's system process id.
///
///  - getServerAdminCategory: Get the category for server admin objects.
///
///  - getServerAdminCategoryAsync: Get the category for server admin objects.
///
///  - getServerAdmin: Get a proxy to the server's admin object.
///
///  - getServerAdminAsync: Get a proxy to the server's admin object.
///
///  - enableServer: Enable or disable a server.
///
///  - enableServerAsync: Enable or disable a server.
///
///  - isServerEnabled: Check if the server is enabled or disabled.
///
///  - isServerEnabledAsync: Check if the server is enabled or disabled.
///
///  - startServer: Start a server and wait for its activation.
///
///  - startServerAsync: Start a server and wait for its activation.
///
///  - stopServer: Stop a server.
///
///  - stopServerAsync: Stop a server.
///
///  - sendSignal: Send signal to a server.
///
///  - sendSignalAsync: Send signal to a server.
///
///  - getAllServerIds: Get all the server ids registered with IceGrid.
///
///  - getAllServerIdsAsync: Get all the server ids registered with IceGrid.
///
///  - getAdapterInfo: Get the adapter information for the replica group or adapter with the given id.
///
///  - getAdapterInfoAsync: Get the adapter information for the replica group or adapter with the given id.
///
///  - removeAdapter: Remove the adapter with the given id.
///
///  - removeAdapterAsync: Remove the adapter with the given id.
///
///  - getAllAdapterIds: Get all the adapter ids registered with IceGrid.
///
///  - getAllAdapterIdsAsync: Get all the adapter ids registered with IceGrid.
///
///  - addObject: Add an object to the object registry.
///
///  - addObjectAsync: Add an object to the object registry.
///
///  - updateObject: Update an object in the object registry.
///
///  - updateObjectAsync: Update an object in the object registry.
///
///  - addObjectWithType: Add an object to the object registry and explicitly specify its type.
///
///  - addObjectWithTypeAsync: Add an object to the object registry and explicitly specify its type.
///
///  - removeObject: Remove an object from the object registry.
///
///  - removeObjectAsync: Remove an object from the object registry.
///
///  - getObjectInfo: Get the object info for the object with the given identity.
///
///  - getObjectInfoAsync: Get the object info for the object with the given identity.
///
///  - getObjectInfosByType: Get the object info of all the registered objects with the given type.
///
///  - getObjectInfosByTypeAsync: Get the object info of all the registered objects with the given type.
///
///  - getAllObjectInfos: Get the object info of all the registered objects whose stringified identities match the given expression.
///
///  - getAllObjectInfosAsync: Get the object info of all the registered objects whose stringified identities match the given expression.
///
///  - pingNode: Ping an IceGrid node to see if it is active.
///
///  - pingNodeAsync: Ping an IceGrid node to see if it is active.
///
///  - getNodeLoad: Get the load averages of the node.
///
///  - getNodeLoadAsync: Get the load averages of the node.
///
///  - getNodeInfo: Get the node information for the node with the given name.
///
///  - getNodeInfoAsync: Get the node information for the node with the given name.
///
///  - getNodeAdmin: Get a proxy to the IceGrid node's admin object.
///
///  - getNodeAdminAsync: Get a proxy to the IceGrid node's admin object.
///
///  - getNodeProcessorSocketCount: Get the number of physical processor sockets for the machine running the node with the given name.
///
///  - getNodeProcessorSocketCountAsync: Get the number of physical processor sockets for the machine running the node with the given name.
///
///  - shutdownNode: Shutdown an IceGrid node.
///
///  - shutdownNodeAsync: Shutdown an IceGrid node.
///
///  - getNodeHostname: Get the hostname of this node.
///
///  - getNodeHostnameAsync: Get the hostname of this node.
///
///  - getAllNodeNames: Get all the IceGrid nodes currently registered.
///
///  - getAllNodeNamesAsync: Get all the IceGrid nodes currently registered.
///
///  - pingRegistry: Ping an IceGrid registry to see if it is active.
///
///  - pingRegistryAsync: Ping an IceGrid registry to see if it is active.
///
///  - getRegistryInfo: Get the registry information for the registry with the given name.
///
///  - getRegistryInfoAsync: Get the registry information for the registry with the given name.
///
///  - getRegistryAdmin: Get a proxy to the IceGrid registry's admin object.
///
///  - getRegistryAdminAsync: Get a proxy to the IceGrid registry's admin object.
///
///  - shutdownRegistry: Shutdown an IceGrid registry.
///
///  - shutdownRegistryAsync: Shutdown an IceGrid registry.
///
///  - getAllRegistryNames: Get all the IceGrid registries currently registered.
///
///  - getAllRegistryNamesAsync: Get all the IceGrid registries currently registered.
///
///  - shutdown: Shut down the IceGrid registry.
///
///  - shutdownAsync: Shut down the IceGrid registry.
public protocol AdminPrx: Ice.ObjectPrx {}

private final class AdminPrxI: Ice.ObjectPrxI, AdminPrx {
    public override class func ice_staticId() -> Swift.String {
        return AdminTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: AdminPrx.Protocol) throws -> AdminPrx {
    try communicator.makeProxyImpl(proxyString) as AdminPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `AdminPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `AdminPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: AdminPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> AdminPrx? {
    return try AdminPrxI.checkedCast(prx: prx, facet: facet, context: context) as AdminPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `AdminPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `AdminPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: AdminPrx.Protocol, facet: Swift.String? = nil) -> AdminPrx {
    return AdminPrxI.uncheckedCast(prx: prx, facet: facet) as AdminPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `AdminPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: AdminPrx.Protocol) -> Swift.String {
    return AdminTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `AdminPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `AdminPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `AdminPrx?` - The extracted proxy
    func read(_ type: AdminPrx.Protocol) throws -> AdminPrx? {
        return try read() as AdminPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `AdminPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `AdminPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: AdminPrx.Protocol) throws -> AdminPrx? {
        return try read(tag: tag) as AdminPrxI?
    }
}

/// The IceGrid administrative interface. Allowing access to this interface is a security risk!
/// Please see the IceGrid documentation for further information.
///
/// AdminPrx Methods:
///
///  - addApplication: Add an application to IceGrid.
///
///  - addApplicationAsync: Add an application to IceGrid.
///
///  - syncApplication: Synchronize a deployed application with the given application descriptor.
///
///  - syncApplicationAsync: Synchronize a deployed application with the given application descriptor.
///
///  - updateApplication: Update a deployed application with the given update application descriptor.
///
///  - updateApplicationAsync: Update a deployed application with the given update application descriptor.
///
///  - syncApplicationWithoutRestart: Synchronize a deployed application with the given application descriptor.
///
///  - syncApplicationWithoutRestartAsync: Synchronize a deployed application with the given application descriptor.
///
///  - updateApplicationWithoutRestart: Update a deployed application with the given update application descriptor only if no server restarts are necessary for the update of the application.
///
///  - updateApplicationWithoutRestartAsync: Update a deployed application with the given update application descriptor only if no server restarts are necessary for the update of the application.
///
///  - removeApplication: Remove an application from IceGrid.
///
///  - removeApplicationAsync: Remove an application from IceGrid.
///
///  - instantiateServer: Instantiate a server template from an application on the given node.
///
///  - instantiateServerAsync: Instantiate a server template from an application on the given node.
///
///  - getApplicationInfo: Get an application descriptor.
///
///  - getApplicationInfoAsync: Get an application descriptor.
///
///  - getDefaultApplicationDescriptor: Get the default application descriptor.
///
///  - getDefaultApplicationDescriptorAsync: Get the default application descriptor.
///
///  - getAllApplicationNames: Get all the IceGrid applications currently registered.
///
///  - getAllApplicationNamesAsync: Get all the IceGrid applications currently registered.
///
///  - getServerInfo: Get the server information for the server with the given id.
///
///  - getServerInfoAsync: Get the server information for the server with the given id.
///
///  - getServerState: Get a server's state.
///
///  - getServerStateAsync: Get a server's state.
///
///  - getServerPid: Get a server's system process id.
///
///  - getServerPidAsync: Get a server's system process id.
///
///  - getServerAdminCategory: Get the category for server admin objects.
///
///  - getServerAdminCategoryAsync: Get the category for server admin objects.
///
///  - getServerAdmin: Get a proxy to the server's admin object.
///
///  - getServerAdminAsync: Get a proxy to the server's admin object.
///
///  - enableServer: Enable or disable a server.
///
///  - enableServerAsync: Enable or disable a server.
///
///  - isServerEnabled: Check if the server is enabled or disabled.
///
///  - isServerEnabledAsync: Check if the server is enabled or disabled.
///
///  - startServer: Start a server and wait for its activation.
///
///  - startServerAsync: Start a server and wait for its activation.
///
///  - stopServer: Stop a server.
///
///  - stopServerAsync: Stop a server.
///
///  - sendSignal: Send signal to a server.
///
///  - sendSignalAsync: Send signal to a server.
///
///  - getAllServerIds: Get all the server ids registered with IceGrid.
///
///  - getAllServerIdsAsync: Get all the server ids registered with IceGrid.
///
///  - getAdapterInfo: Get the adapter information for the replica group or adapter with the given id.
///
///  - getAdapterInfoAsync: Get the adapter information for the replica group or adapter with the given id.
///
///  - removeAdapter: Remove the adapter with the given id.
///
///  - removeAdapterAsync: Remove the adapter with the given id.
///
///  - getAllAdapterIds: Get all the adapter ids registered with IceGrid.
///
///  - getAllAdapterIdsAsync: Get all the adapter ids registered with IceGrid.
///
///  - addObject: Add an object to the object registry.
///
///  - addObjectAsync: Add an object to the object registry.
///
///  - updateObject: Update an object in the object registry.
///
///  - updateObjectAsync: Update an object in the object registry.
///
///  - addObjectWithType: Add an object to the object registry and explicitly specify its type.
///
///  - addObjectWithTypeAsync: Add an object to the object registry and explicitly specify its type.
///
///  - removeObject: Remove an object from the object registry.
///
///  - removeObjectAsync: Remove an object from the object registry.
///
///  - getObjectInfo: Get the object info for the object with the given identity.
///
///  - getObjectInfoAsync: Get the object info for the object with the given identity.
///
///  - getObjectInfosByType: Get the object info of all the registered objects with the given type.
///
///  - getObjectInfosByTypeAsync: Get the object info of all the registered objects with the given type.
///
///  - getAllObjectInfos: Get the object info of all the registered objects whose stringified identities match the given expression.
///
///  - getAllObjectInfosAsync: Get the object info of all the registered objects whose stringified identities match the given expression.
///
///  - pingNode: Ping an IceGrid node to see if it is active.
///
///  - pingNodeAsync: Ping an IceGrid node to see if it is active.
///
///  - getNodeLoad: Get the load averages of the node.
///
///  - getNodeLoadAsync: Get the load averages of the node.
///
///  - getNodeInfo: Get the node information for the node with the given name.
///
///  - getNodeInfoAsync: Get the node information for the node with the given name.
///
///  - getNodeAdmin: Get a proxy to the IceGrid node's admin object.
///
///  - getNodeAdminAsync: Get a proxy to the IceGrid node's admin object.
///
///  - getNodeProcessorSocketCount: Get the number of physical processor sockets for the machine running the node with the given name.
///
///  - getNodeProcessorSocketCountAsync: Get the number of physical processor sockets for the machine running the node with the given name.
///
///  - shutdownNode: Shutdown an IceGrid node.
///
///  - shutdownNodeAsync: Shutdown an IceGrid node.
///
///  - getNodeHostname: Get the hostname of this node.
///
///  - getNodeHostnameAsync: Get the hostname of this node.
///
///  - getAllNodeNames: Get all the IceGrid nodes currently registered.
///
///  - getAllNodeNamesAsync: Get all the IceGrid nodes currently registered.
///
///  - pingRegistry: Ping an IceGrid registry to see if it is active.
///
///  - pingRegistryAsync: Ping an IceGrid registry to see if it is active.
///
///  - getRegistryInfo: Get the registry information for the registry with the given name.
///
///  - getRegistryInfoAsync: Get the registry information for the registry with the given name.
///
///  - getRegistryAdmin: Get a proxy to the IceGrid registry's admin object.
///
///  - getRegistryAdminAsync: Get a proxy to the IceGrid registry's admin object.
///
///  - shutdownRegistry: Shutdown an IceGrid registry.
///
///  - shutdownRegistryAsync: Shutdown an IceGrid registry.
///
///  - getAllRegistryNames: Get all the IceGrid registries currently registered.
///
///  - getAllRegistryNamesAsync: Get all the IceGrid registries currently registered.
///
///  - shutdown: Shut down the IceGrid registry.
///
///  - shutdownAsync: Shut down the IceGrid registry.
public extension AdminPrx {
    /// Add an application to IceGrid.
    ///
    /// - parameter _: `ApplicationDescriptor` The application descriptor.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - AccessDeniedException - Raised if the session doesn't hold the exclusive lock or if another session is
    ///     holding the lock.
    ///
    ///   - DeploymentException - Raised if application deployment failed.
    func addApplication(_ iceP_descriptor: ApplicationDescriptor, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "addApplication",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_descriptor)
                              ostr.writePendingValues()
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as DeploymentException {
                                  throw error
                              } catch let error as AccessDeniedException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Add an application to IceGrid.
    ///
    /// - parameter _: `ApplicationDescriptor` The application descriptor.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func addApplicationAsync(_ iceP_descriptor: ApplicationDescriptor, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "addApplication",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_descriptor)
                                      ostr.writePendingValues()
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch let error as AccessDeniedException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Synchronize a deployed application with the given application descriptor. This operation will replace the
    /// current descriptor with this new descriptor.
    ///
    /// - parameter _: `ApplicationDescriptor` The application descriptor.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - AccessDeniedException - Raised if the session doesn't hold the exclusive lock or if another session is
    ///     holding the lock.
    ///
    ///   - ApplicationNotExistException - Raised if the application doesn't exist.
    ///
    ///   - DeploymentException - Raised if application deployment failed.
    func syncApplication(_ iceP_descriptor: ApplicationDescriptor, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "syncApplication",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_descriptor)
                              ostr.writePendingValues()
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as ApplicationNotExistException {
                                  throw error
                              } catch let error as DeploymentException {
                                  throw error
                              } catch let error as AccessDeniedException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Synchronize a deployed application with the given application descriptor. This operation will replace the
    /// current descriptor with this new descriptor.
    ///
    /// - parameter _: `ApplicationDescriptor` The application descriptor.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func syncApplicationAsync(_ iceP_descriptor: ApplicationDescriptor, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "syncApplication",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_descriptor)
                                      ostr.writePendingValues()
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ApplicationNotExistException {
                                          throw error
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch let error as AccessDeniedException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Update a deployed application with the given update application descriptor.
    ///
    /// - parameter _: `ApplicationUpdateDescriptor` The update descriptor.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - AccessDeniedException - Raised if the session doesn't hold the exclusive lock or if another session is
    ///     holding the lock.
    ///
    ///   - ApplicationNotExistException - Raised if the application doesn't exist.
    ///
    ///   - DeploymentException - Raised if application deployment failed.
    func updateApplication(_ iceP_descriptor: ApplicationUpdateDescriptor, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "updateApplication",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_descriptor)
                              ostr.writePendingValues()
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as ApplicationNotExistException {
                                  throw error
                              } catch let error as DeploymentException {
                                  throw error
                              } catch let error as AccessDeniedException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Update a deployed application with the given update application descriptor.
    ///
    /// - parameter _: `ApplicationUpdateDescriptor` The update descriptor.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func updateApplicationAsync(_ iceP_descriptor: ApplicationUpdateDescriptor, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "updateApplication",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_descriptor)
                                      ostr.writePendingValues()
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ApplicationNotExistException {
                                          throw error
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch let error as AccessDeniedException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Synchronize a deployed application with the given application descriptor. This operation will replace the
    /// current descriptor with this new descriptor only if no server restarts are necessary for the update of the
    /// application. If some servers need to be restarted, the synchronization is rejected with a
    /// DeploymentException.
    ///
    /// - parameter _: `ApplicationDescriptor` The application descriptor.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - AccessDeniedException - Raised if the session doesn't hold the exclusive lock or if another session is
    ///     holding the lock.
    ///
    ///   - ApplicationNotExistException - Raised if the application doesn't exist.
    ///
    ///   - DeploymentException - Raised if application deployment failed.
    func syncApplicationWithoutRestart(_ iceP_descriptor: ApplicationDescriptor, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "syncApplicationWithoutRestart",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_descriptor)
                              ostr.writePendingValues()
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as ApplicationNotExistException {
                                  throw error
                              } catch let error as DeploymentException {
                                  throw error
                              } catch let error as AccessDeniedException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Synchronize a deployed application with the given application descriptor. This operation will replace the
    /// current descriptor with this new descriptor only if no server restarts are necessary for the update of the
    /// application. If some servers need to be restarted, the synchronization is rejected with a
    /// DeploymentException.
    ///
    /// - parameter _: `ApplicationDescriptor` The application descriptor.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func syncApplicationWithoutRestartAsync(_ iceP_descriptor: ApplicationDescriptor, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "syncApplicationWithoutRestart",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_descriptor)
                                      ostr.writePendingValues()
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ApplicationNotExistException {
                                          throw error
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch let error as AccessDeniedException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Update a deployed application with the given update application descriptor only if no server restarts are
    /// necessary for the update of the application. If some servers need to be restarted, the synchronization is
    /// rejected with a DeploymentException.
    ///
    /// - parameter _: `ApplicationUpdateDescriptor` The update descriptor.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - AccessDeniedException - Raised if the session doesn't hold the exclusive lock or if another session is
    ///     holding the lock.
    ///
    ///   - ApplicationNotExistException - Raised if the application doesn't exist.
    ///
    ///   - DeploymentException - Raised if application deployment failed.
    func updateApplicationWithoutRestart(_ iceP_descriptor: ApplicationUpdateDescriptor, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "updateApplicationWithoutRestart",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_descriptor)
                              ostr.writePendingValues()
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as ApplicationNotExistException {
                                  throw error
                              } catch let error as DeploymentException {
                                  throw error
                              } catch let error as AccessDeniedException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Update a deployed application with the given update application descriptor only if no server restarts are
    /// necessary for the update of the application. If some servers need to be restarted, the synchronization is
    /// rejected with a DeploymentException.
    ///
    /// - parameter _: `ApplicationUpdateDescriptor` The update descriptor.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func updateApplicationWithoutRestartAsync(_ iceP_descriptor: ApplicationUpdateDescriptor, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "updateApplicationWithoutRestart",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_descriptor)
                                      ostr.writePendingValues()
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ApplicationNotExistException {
                                          throw error
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch let error as AccessDeniedException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Remove an application from IceGrid.
    ///
    /// - parameter _: `Swift.String` The application name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - AccessDeniedException - Raised if the session doesn't hold the exclusive lock or if another session is
    ///     holding the lock.
    ///
    ///   - ApplicationNotExistException - Raised if the application doesn't exist.
    ///
    ///   - DeploymentException - Raised if application deployment failed.
    func removeApplication(_ iceP_name: Swift.String, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "removeApplication",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_name)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as ApplicationNotExistException {
                                  throw error
                              } catch let error as DeploymentException {
                                  throw error
                              } catch let error as AccessDeniedException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Remove an application from IceGrid.
    ///
    /// - parameter _: `Swift.String` The application name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func removeApplicationAsync(_ iceP_name: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "removeApplication",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_name)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ApplicationNotExistException {
                                          throw error
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch let error as AccessDeniedException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Instantiate a server template from an application on the given node.
    ///
    /// - parameter application: `Swift.String` The application name.
    ///
    /// - parameter node: `Swift.String` The name of the node where the server will be deployed.
    ///
    /// - parameter desc: `ServerInstanceDescriptor` The descriptor of the server instance to deploy.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - AccessDeniedException - Raised if the session doesn't hold the exclusive lock or if another session is
    ///     holding the lock.
    ///
    ///   - ApplicationNotExistException - Raised if the application doesn't exist.
    ///
    ///   - DeploymentException - Raised if server instantiation failed.
    func instantiateServer(application iceP_application: Swift.String, node iceP_node: Swift.String, desc iceP_desc: ServerInstanceDescriptor, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "instantiateServer",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_application)
                              ostr.write(iceP_node)
                              ostr.write(iceP_desc)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as ApplicationNotExistException {
                                  throw error
                              } catch let error as DeploymentException {
                                  throw error
                              } catch let error as AccessDeniedException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Instantiate a server template from an application on the given node.
    ///
    /// - parameter application: `Swift.String` The application name.
    ///
    /// - parameter node: `Swift.String` The name of the node where the server will be deployed.
    ///
    /// - parameter desc: `ServerInstanceDescriptor` The descriptor of the server instance to deploy.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func instantiateServerAsync(application iceP_application: Swift.String, node iceP_node: Swift.String, desc iceP_desc: ServerInstanceDescriptor, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "instantiateServer",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_application)
                                      ostr.write(iceP_node)
                                      ostr.write(iceP_desc)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ApplicationNotExistException {
                                          throw error
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch let error as AccessDeniedException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get an application descriptor.
    ///
    /// - parameter _: `Swift.String` The application name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `ApplicationInfo` - The application descriptor.
    ///
    /// - throws:
    ///
    ///   - ApplicationNotExistException - Raised if the application doesn't exist.
    func getApplicationInfo(_ iceP_name: Swift.String, context: Ice.Context? = nil) throws -> ApplicationInfo {
        return try _impl._invoke(operation: "getApplicationInfo",
                                 mode: .Idempotent,
                                 write: { ostr in
                                     ostr.write(iceP_name)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: ApplicationInfo = try istr.read()
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as ApplicationNotExistException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Get an application descriptor.
    ///
    /// - parameter _: `Swift.String` The application name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<ApplicationInfo>` - The result of the operation
    func getApplicationInfoAsync(_ iceP_name: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<ApplicationInfo> {
        return _impl._invokeAsync(operation: "getApplicationInfo",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_name)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: ApplicationInfo = try istr.read()
                                      try istr.readPendingValues()
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ApplicationNotExistException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get the default application descriptor.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `ApplicationDescriptor` - The default application descriptor.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if the default application descriptor can't be accessed or is invalid.
    func getDefaultApplicationDescriptor(context: Ice.Context? = nil) throws -> ApplicationDescriptor {
        return try _impl._invoke(operation: "getDefaultApplicationDescriptor",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: ApplicationDescriptor = try istr.read()
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as DeploymentException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Get the default application descriptor.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<ApplicationDescriptor>` - The result of the operation
    func getDefaultApplicationDescriptorAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<ApplicationDescriptor> {
        return _impl._invokeAsync(operation: "getDefaultApplicationDescriptor",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: ApplicationDescriptor = try istr.read()
                                      try istr.readPendingValues()
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get all the IceGrid applications currently registered.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.StringSeq` - The application names.
    func getAllApplicationNames(context: Ice.Context? = nil) throws -> Ice.StringSeq {
        return try _impl._invoke(operation: "getAllApplicationNames",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: Ice.StringSeq = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get all the IceGrid applications currently registered.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Ice.StringSeq>` - The result of the operation
    func getAllApplicationNamesAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Ice.StringSeq> {
        return _impl._invokeAsync(operation: "getAllApplicationNames",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: Ice.StringSeq = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get the server information for the server with the given id.
    ///
    /// - parameter _: `Swift.String` The server id.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `ServerInfo` - The server information.
    ///
    /// - throws:
    ///
    ///   - ServerNotExistException - Raised if the server doesn't exist.
    func getServerInfo(_ iceP_id: Swift.String, context: Ice.Context? = nil) throws -> ServerInfo {
        return try _impl._invoke(operation: "getServerInfo",
                                 mode: .Idempotent,
                                 write: { ostr in
                                     ostr.write(iceP_id)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: ServerInfo = try istr.read()
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as ServerNotExistException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Get the server information for the server with the given id.
    ///
    /// - parameter _: `Swift.String` The server id.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<ServerInfo>` - The result of the operation
    func getServerInfoAsync(_ iceP_id: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<ServerInfo> {
        return _impl._invokeAsync(operation: "getServerInfo",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_id)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: ServerInfo = try istr.read()
                                      try istr.readPendingValues()
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ServerNotExistException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get a server's state.
    ///
    /// - parameter _: `Swift.String` The server id.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `ServerState` - The server state.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if the server couldn't be deployed on the node.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    ///
    ///   - ServerNotExistException - Raised if the server doesn't exist.
    func getServerState(_ iceP_id: Swift.String, context: Ice.Context? = nil) throws -> ServerState {
        return try _impl._invoke(operation: "getServerState",
                                 mode: .Idempotent,
                                 write: { ostr in
                                     ostr.write(iceP_id)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: ServerState = try istr.read()
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as ServerNotExistException {
                                         throw error
                                     } catch let error as DeploymentException {
                                         throw error
                                     } catch let error as NodeUnreachableException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Get a server's state.
    ///
    /// - parameter _: `Swift.String` The server id.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<ServerState>` - The result of the operation
    func getServerStateAsync(_ iceP_id: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<ServerState> {
        return _impl._invokeAsync(operation: "getServerState",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_id)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: ServerState = try istr.read()
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ServerNotExistException {
                                          throw error
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch let error as NodeUnreachableException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get a server's system process id. The process id is operating system dependent.
    ///
    /// - parameter _: `Swift.String` The server id.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Int32` - The server's process id.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if the server couldn't be deployed on the node.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    ///
    ///   - ServerNotExistException - Raised if the server doesn't exist.
    func getServerPid(_ iceP_id: Swift.String, context: Ice.Context? = nil) throws -> Swift.Int32 {
        return try _impl._invoke(operation: "getServerPid",
                                 mode: .Idempotent,
                                 write: { ostr in
                                     ostr.write(iceP_id)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: Swift.Int32 = try istr.read()
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as ServerNotExistException {
                                         throw error
                                     } catch let error as DeploymentException {
                                         throw error
                                     } catch let error as NodeUnreachableException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Get a server's system process id. The process id is operating system dependent.
    ///
    /// - parameter _: `Swift.String` The server id.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Int32>` - The result of the operation
    func getServerPidAsync(_ iceP_id: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Int32> {
        return _impl._invokeAsync(operation: "getServerPid",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_id)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: Swift.Int32 = try istr.read()
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ServerNotExistException {
                                          throw error
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch let error as NodeUnreachableException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get the category for server admin objects. You can manufacture a server admin proxy from the admin proxy by
    /// changing its identity: use the server ID as name and the returned category as category.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String` - The category for server admin objects.
    func getServerAdminCategory(context: Ice.Context? = nil) throws -> Swift.String {
        return try _impl._invoke(operation: "getServerAdminCategory",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: Swift.String = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get the category for server admin objects. You can manufacture a server admin proxy from the admin proxy by
    /// changing its identity: use the server ID as name and the returned category as category.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.String>` - The result of the operation
    func getServerAdminCategoryAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.String> {
        return _impl._invokeAsync(operation: "getServerAdminCategory",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: Swift.String = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get a proxy to the server's admin object.
    ///
    /// - parameter _: `Swift.String` The server id.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.ObjectPrx?` - A proxy to the server's admin object. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if the server couldn't be deployed on the node.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    ///
    ///   - ServerNotExistException - Raised if the server doesn't exist.
    func getServerAdmin(_ iceP_id: Swift.String, context: Ice.Context? = nil) throws -> Ice.ObjectPrx? {
        return try _impl._invoke(operation: "getServerAdmin",
                                 mode: .Idempotent,
                                 write: { ostr in
                                     ostr.write(iceP_id)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as ServerNotExistException {
                                         throw error
                                     } catch let error as DeploymentException {
                                         throw error
                                     } catch let error as NodeUnreachableException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Get a proxy to the server's admin object.
    ///
    /// - parameter _: `Swift.String` The server id.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Ice.ObjectPrx?>` - The result of the operation
    func getServerAdminAsync(_ iceP_id: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Ice.ObjectPrx?> {
        return _impl._invokeAsync(operation: "getServerAdmin",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_id)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ServerNotExistException {
                                          throw error
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch let error as NodeUnreachableException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Enable or disable a server. A disabled server can't be started on demand or administratively. The enable
    /// state of the server is not persistent: if the node is shut down and restarted, the server will be enabled by
    /// default.
    ///
    /// - parameter id: `Swift.String` The server id.
    ///
    /// - parameter enabled: `Swift.Bool` True to enable the server, false to disable it.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if the server couldn't be deployed on the node.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    ///
    ///   - ServerNotExistException - Raised if the server doesn't exist.
    func enableServer(id iceP_id: Swift.String, enabled iceP_enabled: Swift.Bool, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "enableServer",
                          mode: .Idempotent,
                          write: { ostr in
                              ostr.write(iceP_id)
                              ostr.write(iceP_enabled)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as ServerNotExistException {
                                  throw error
                              } catch let error as DeploymentException {
                                  throw error
                              } catch let error as NodeUnreachableException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Enable or disable a server. A disabled server can't be started on demand or administratively. The enable
    /// state of the server is not persistent: if the node is shut down and restarted, the server will be enabled by
    /// default.
    ///
    /// - parameter id: `Swift.String` The server id.
    ///
    /// - parameter enabled: `Swift.Bool` True to enable the server, false to disable it.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func enableServerAsync(id iceP_id: Swift.String, enabled iceP_enabled: Swift.Bool, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "enableServer",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_id)
                                      ostr.write(iceP_enabled)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ServerNotExistException {
                                          throw error
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch let error as NodeUnreachableException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Check if the server is enabled or disabled.
    ///
    /// - parameter _: `Swift.String` The server id.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Bool` - True if the server is enabled.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if the server couldn't be deployed on the node.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    ///
    ///   - ServerNotExistException - Raised if the server doesn't exist.
    func isServerEnabled(_ iceP_id: Swift.String, context: Ice.Context? = nil) throws -> Swift.Bool {
        return try _impl._invoke(operation: "isServerEnabled",
                                 mode: .Idempotent,
                                 write: { ostr in
                                     ostr.write(iceP_id)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: Swift.Bool = try istr.read()
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as ServerNotExistException {
                                         throw error
                                     } catch let error as DeploymentException {
                                         throw error
                                     } catch let error as NodeUnreachableException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Check if the server is enabled or disabled.
    ///
    /// - parameter _: `Swift.String` The server id.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Bool>` - The result of the operation
    func isServerEnabledAsync(_ iceP_id: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Bool> {
        return _impl._invokeAsync(operation: "isServerEnabled",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_id)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: Swift.Bool = try istr.read()
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ServerNotExistException {
                                          throw error
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch let error as NodeUnreachableException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Start a server and wait for its activation.
    ///
    /// - parameter _: `Swift.String` The server id.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if the server couldn't be deployed on the node.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    ///
    ///   - ServerNotExistException - Raised if the server doesn't exist.
    ///
    ///   - ServerStartException - Raised if the server couldn't be started.
    func startServer(_ iceP_id: Swift.String, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "startServer",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_id)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as ServerNotExistException {
                                  throw error
                              } catch let error as ServerStartException {
                                  throw error
                              } catch let error as DeploymentException {
                                  throw error
                              } catch let error as NodeUnreachableException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Start a server and wait for its activation.
    ///
    /// - parameter _: `Swift.String` The server id.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func startServerAsync(_ iceP_id: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "startServer",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_id)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ServerNotExistException {
                                          throw error
                                      } catch let error as ServerStartException {
                                          throw error
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch let error as NodeUnreachableException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Stop a server.
    ///
    /// - parameter _: `Swift.String` The server id.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if the server couldn't be deployed on the node.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    ///
    ///   - ServerNotExistException - Raised if the server doesn't exist.
    ///
    ///   - ServerStopException - Raised if the server couldn't be stopped.
    func stopServer(_ iceP_id: Swift.String, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "stopServer",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_id)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as ServerNotExistException {
                                  throw error
                              } catch let error as ServerStopException {
                                  throw error
                              } catch let error as DeploymentException {
                                  throw error
                              } catch let error as NodeUnreachableException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Stop a server.
    ///
    /// - parameter _: `Swift.String` The server id.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func stopServerAsync(_ iceP_id: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "stopServer",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_id)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ServerNotExistException {
                                          throw error
                                      } catch let error as ServerStopException {
                                          throw error
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch let error as NodeUnreachableException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Send signal to a server.
    ///
    /// - parameter id: `Swift.String` The server id.
    ///
    /// - parameter signal: `Swift.String` The signal, for example SIGTERM or 15.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - BadSignalException - Raised if the signal is not recognized by the target server.
    ///
    ///   - DeploymentException - Raised if the server couldn't be deployed on the node.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    ///
    ///   - ServerNotExistException - Raised if the server doesn't exist.
    func sendSignal(id iceP_id: Swift.String, signal iceP_signal: Swift.String, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "sendSignal",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_id)
                              ostr.write(iceP_signal)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as ServerNotExistException {
                                  throw error
                              } catch let error as DeploymentException {
                                  throw error
                              } catch let error as NodeUnreachableException {
                                  throw error
                              } catch let error as BadSignalException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Send signal to a server.
    ///
    /// - parameter id: `Swift.String` The server id.
    ///
    /// - parameter signal: `Swift.String` The signal, for example SIGTERM or 15.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func sendSignalAsync(id iceP_id: Swift.String, signal iceP_signal: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "sendSignal",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_id)
                                      ostr.write(iceP_signal)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ServerNotExistException {
                                          throw error
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch let error as NodeUnreachableException {
                                          throw error
                                      } catch let error as BadSignalException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get all the server ids registered with IceGrid.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.StringSeq` - The server ids.
    func getAllServerIds(context: Ice.Context? = nil) throws -> Ice.StringSeq {
        return try _impl._invoke(operation: "getAllServerIds",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: Ice.StringSeq = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get all the server ids registered with IceGrid.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Ice.StringSeq>` - The result of the operation
    func getAllServerIdsAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Ice.StringSeq> {
        return _impl._invokeAsync(operation: "getAllServerIds",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: Ice.StringSeq = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get the adapter information for the replica group or adapter with the given id.
    ///
    /// - parameter _: `Swift.String` The adapter id.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `AdapterInfoSeq` - A sequence of adapter information structures. If the given id refers to an adapter, this sequence
    /// will contain only one element. If the given id refers to a replica group, the sequence will contain the
    /// adapter information of each member of the replica group.
    ///
    /// - throws:
    ///
    ///   - AdapterNotExistException - Raised if the adapter or replica group doesn't exist.
    func getAdapterInfo(_ iceP_id: Swift.String, context: Ice.Context? = nil) throws -> AdapterInfoSeq {
        return try _impl._invoke(operation: "getAdapterInfo",
                                 mode: .Idempotent,
                                 write: { ostr in
                                     ostr.write(iceP_id)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: AdapterInfoSeq = try AdapterInfoSeqHelper.read(from: istr)
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as AdapterNotExistException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Get the adapter information for the replica group or adapter with the given id.
    ///
    /// - parameter _: `Swift.String` The adapter id.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<AdapterInfoSeq>` - The result of the operation
    func getAdapterInfoAsync(_ iceP_id: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<AdapterInfoSeq> {
        return _impl._invokeAsync(operation: "getAdapterInfo",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_id)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: AdapterInfoSeq = try AdapterInfoSeqHelper.read(from: istr)
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as AdapterNotExistException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Remove the adapter with the given id.
    ///
    /// - parameter _: `Swift.String` The adapter id.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - AdapterNotExistException - Raised if the adapter doesn't exist.
    ///
    ///   - DeploymentException - Raised if application deployment failed.
    func removeAdapter(_ iceP_id: Swift.String, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "removeAdapter",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_id)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as AdapterNotExistException {
                                  throw error
                              } catch let error as DeploymentException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Remove the adapter with the given id.
    ///
    /// - parameter _: `Swift.String` The adapter id.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func removeAdapterAsync(_ iceP_id: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "removeAdapter",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_id)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as AdapterNotExistException {
                                          throw error
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get all the adapter ids registered with IceGrid.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.StringSeq` - The adapter ids.
    func getAllAdapterIds(context: Ice.Context? = nil) throws -> Ice.StringSeq {
        return try _impl._invoke(operation: "getAllAdapterIds",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: Ice.StringSeq = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get all the adapter ids registered with IceGrid.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Ice.StringSeq>` - The result of the operation
    func getAllAdapterIdsAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Ice.StringSeq> {
        return _impl._invokeAsync(operation: "getAllAdapterIds",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: Ice.StringSeq = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Add an object to the object registry. IceGrid will get the object type by calling ice_id on the
    /// given proxy. The object must be reachable.
    ///
    /// - parameter _: `Ice.ObjectPrx?` The object to be added to the registry.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if the object can't be added. This might be raised if the invocation on
    ///     the proxy to get the object type failed.
    ///
    ///   - ObjectExistsException - Raised if the object is already registered.
    func addObject(_ iceP_obj: Ice.ObjectPrx?, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "addObject",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_obj)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as DeploymentException {
                                  throw error
                              } catch let error as ObjectExistsException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Add an object to the object registry. IceGrid will get the object type by calling ice_id on the
    /// given proxy. The object must be reachable.
    ///
    /// - parameter _: `Ice.ObjectPrx?` The object to be added to the registry.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func addObjectAsync(_ iceP_obj: Ice.ObjectPrx?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "addObject",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_obj)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch let error as ObjectExistsException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Update an object in the object registry. Only objects added with this interface can be updated with this
    /// operation. Objects added with deployment descriptors should be updated with the deployment mechanism.
    ///
    /// - parameter _: `Ice.ObjectPrx?` The object to be updated to the registry.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if the object can't be updated. This might happen if the object was added
    ///     with a deployment descriptor.
    ///
    ///   - ObjectNotRegisteredException - Raised if the object isn't registered with the registry.
    func updateObject(_ iceP_obj: Ice.ObjectPrx?, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "updateObject",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_obj)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as ObjectNotRegisteredException {
                                  throw error
                              } catch let error as DeploymentException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Update an object in the object registry. Only objects added with this interface can be updated with this
    /// operation. Objects added with deployment descriptors should be updated with the deployment mechanism.
    ///
    /// - parameter _: `Ice.ObjectPrx?` The object to be updated to the registry.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func updateObjectAsync(_ iceP_obj: Ice.ObjectPrx?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "updateObject",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_obj)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ObjectNotRegisteredException {
                                          throw error
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Add an object to the object registry and explicitly specify its type.
    ///
    /// - parameter obj: `Ice.ObjectPrx?` The object to be added to the registry. The proxy is never null.
    ///
    /// - parameter type: `Swift.String` The object type.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if application deployment failed.
    ///
    ///   - ObjectExistsException - Raised if the object is already registered.
    func addObjectWithType(obj iceP_obj: Ice.ObjectPrx?, type iceP_type: Swift.String, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "addObjectWithType",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_obj)
                              ostr.write(iceP_type)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as DeploymentException {
                                  throw error
                              } catch let error as ObjectExistsException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Add an object to the object registry and explicitly specify its type.
    ///
    /// - parameter obj: `Ice.ObjectPrx?` The object to be added to the registry. The proxy is never null.
    ///
    /// - parameter type: `Swift.String` The object type.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func addObjectWithTypeAsync(obj iceP_obj: Ice.ObjectPrx?, type iceP_type: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "addObjectWithType",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_obj)
                                      ostr.write(iceP_type)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch let error as ObjectExistsException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Remove an object from the object registry. Only objects added with this interface can be removed with this
    /// operation. Objects added with deployment descriptors should be removed with the deployment mechanism.
    ///
    /// - parameter _: `Ice.Identity` The identity of the object to be removed from the registry.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if the object can't be removed. This might happen if the object was added
    ///     with a deployment descriptor.
    ///
    ///   - ObjectNotRegisteredException - Raised if the object isn't registered with the registry.
    func removeObject(_ iceP_id: Ice.Identity, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "removeObject",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_id)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as ObjectNotRegisteredException {
                                  throw error
                              } catch let error as DeploymentException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Remove an object from the object registry. Only objects added with this interface can be removed with this
    /// operation. Objects added with deployment descriptors should be removed with the deployment mechanism.
    ///
    /// - parameter _: `Ice.Identity` The identity of the object to be removed from the registry.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func removeObjectAsync(_ iceP_id: Ice.Identity, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "removeObject",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_id)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ObjectNotRegisteredException {
                                          throw error
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get the object info for the object with the given identity.
    ///
    /// - parameter _: `Ice.Identity` The identity of the object.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `ObjectInfo` - The object info.
    ///
    /// - throws:
    ///
    ///   - ObjectNotRegisteredException - Raised if the object isn't registered with the registry.
    func getObjectInfo(_ iceP_id: Ice.Identity, context: Ice.Context? = nil) throws -> ObjectInfo {
        return try _impl._invoke(operation: "getObjectInfo",
                                 mode: .Idempotent,
                                 write: { ostr in
                                     ostr.write(iceP_id)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: ObjectInfo = try istr.read()
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as ObjectNotRegisteredException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Get the object info for the object with the given identity.
    ///
    /// - parameter _: `Ice.Identity` The identity of the object.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<ObjectInfo>` - The result of the operation
    func getObjectInfoAsync(_ iceP_id: Ice.Identity, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<ObjectInfo> {
        return _impl._invokeAsync(operation: "getObjectInfo",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_id)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: ObjectInfo = try istr.read()
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ObjectNotRegisteredException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get the object info of all the registered objects with the given type.
    ///
    /// - parameter _: `Swift.String` The type of the object.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `ObjectInfoSeq` - The object infos.
    func getObjectInfosByType(_ iceP_type: Swift.String, context: Ice.Context? = nil) throws -> ObjectInfoSeq {
        return try _impl._invoke(operation: "getObjectInfosByType",
                                 mode: .Idempotent,
                                 write: { ostr in
                                     ostr.write(iceP_type)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: ObjectInfoSeq = try ObjectInfoSeqHelper.read(from: istr)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get the object info of all the registered objects with the given type.
    ///
    /// - parameter _: `Swift.String` The type of the object.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<ObjectInfoSeq>` - The result of the operation
    func getObjectInfosByTypeAsync(_ iceP_type: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<ObjectInfoSeq> {
        return _impl._invokeAsync(operation: "getObjectInfosByType",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_type)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: ObjectInfoSeq = try ObjectInfoSeqHelper.read(from: istr)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get the object info of all the registered objects whose stringified identities match the given expression.
    ///
    /// - parameter _: `Swift.String` The expression to match against the stringified identities of registered objects. The expression
    /// may contain a trailing wildcard (*) character.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `ObjectInfoSeq` - All the object infos with a stringified identity matching the given expression.
    func getAllObjectInfos(_ iceP_expr: Swift.String, context: Ice.Context? = nil) throws -> ObjectInfoSeq {
        return try _impl._invoke(operation: "getAllObjectInfos",
                                 mode: .Idempotent,
                                 write: { ostr in
                                     ostr.write(iceP_expr)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: ObjectInfoSeq = try ObjectInfoSeqHelper.read(from: istr)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get the object info of all the registered objects whose stringified identities match the given expression.
    ///
    /// - parameter _: `Swift.String` The expression to match against the stringified identities of registered objects. The expression
    /// may contain a trailing wildcard (*) character.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<ObjectInfoSeq>` - The result of the operation
    func getAllObjectInfosAsync(_ iceP_expr: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<ObjectInfoSeq> {
        return _impl._invokeAsync(operation: "getAllObjectInfos",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_expr)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: ObjectInfoSeq = try ObjectInfoSeqHelper.read(from: istr)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Ping an IceGrid node to see if it is active.
    ///
    /// - parameter _: `Swift.String` The node name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Bool` - true if the node ping succeeded, false otherwise.
    ///
    /// - throws:
    ///
    ///   - NodeNotExistException - Raised if the node doesn't exist.
    func pingNode(_ iceP_name: Swift.String, context: Ice.Context? = nil) throws -> Swift.Bool {
        return try _impl._invoke(operation: "pingNode",
                                 mode: .Idempotent,
                                 write: { ostr in
                                     ostr.write(iceP_name)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: Swift.Bool = try istr.read()
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as NodeNotExistException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Ping an IceGrid node to see if it is active.
    ///
    /// - parameter _: `Swift.String` The node name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Bool>` - The result of the operation
    func pingNodeAsync(_ iceP_name: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Bool> {
        return _impl._invokeAsync(operation: "pingNode",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_name)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: Swift.Bool = try istr.read()
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as NodeNotExistException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get the load averages of the node.
    ///
    /// - parameter _: `Swift.String` The node name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `LoadInfo` - The node load information.
    ///
    /// - throws:
    ///
    ///   - NodeNotExistException - Raised if the node doesn't exist.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    func getNodeLoad(_ iceP_name: Swift.String, context: Ice.Context? = nil) throws -> LoadInfo {
        return try _impl._invoke(operation: "getNodeLoad",
                                 mode: .Idempotent,
                                 write: { ostr in
                                     ostr.write(iceP_name)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: LoadInfo = try istr.read()
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as NodeNotExistException {
                                         throw error
                                     } catch let error as NodeUnreachableException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Get the load averages of the node.
    ///
    /// - parameter _: `Swift.String` The node name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<LoadInfo>` - The result of the operation
    func getNodeLoadAsync(_ iceP_name: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<LoadInfo> {
        return _impl._invokeAsync(operation: "getNodeLoad",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_name)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: LoadInfo = try istr.read()
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as NodeNotExistException {
                                          throw error
                                      } catch let error as NodeUnreachableException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get the node information for the node with the given name.
    ///
    /// - parameter _: `Swift.String` The node name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `NodeInfo` - The node information.
    ///
    /// - throws:
    ///
    ///   - NodeNotExistException - Raised if the node doesn't exist.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    func getNodeInfo(_ iceP_name: Swift.String, context: Ice.Context? = nil) throws -> NodeInfo {
        return try _impl._invoke(operation: "getNodeInfo",
                                 mode: .Idempotent,
                                 write: { ostr in
                                     ostr.write(iceP_name)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: NodeInfo = try istr.read()
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as NodeNotExistException {
                                         throw error
                                     } catch let error as NodeUnreachableException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Get the node information for the node with the given name.
    ///
    /// - parameter _: `Swift.String` The node name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<NodeInfo>` - The result of the operation
    func getNodeInfoAsync(_ iceP_name: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<NodeInfo> {
        return _impl._invokeAsync(operation: "getNodeInfo",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_name)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: NodeInfo = try istr.read()
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as NodeNotExistException {
                                          throw error
                                      } catch let error as NodeUnreachableException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get a proxy to the IceGrid node's admin object.
    ///
    /// - parameter _: `Swift.String` The IceGrid node name
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.ObjectPrx?` - A proxy to the IceGrid node's admin object. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - NodeNotExistException - Raised if the node doesn't exist.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    func getNodeAdmin(_ iceP_name: Swift.String, context: Ice.Context? = nil) throws -> Ice.ObjectPrx? {
        return try _impl._invoke(operation: "getNodeAdmin",
                                 mode: .Idempotent,
                                 write: { ostr in
                                     ostr.write(iceP_name)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as NodeNotExistException {
                                         throw error
                                     } catch let error as NodeUnreachableException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Get a proxy to the IceGrid node's admin object.
    ///
    /// - parameter _: `Swift.String` The IceGrid node name
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Ice.ObjectPrx?>` - The result of the operation
    func getNodeAdminAsync(_ iceP_name: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Ice.ObjectPrx?> {
        return _impl._invokeAsync(operation: "getNodeAdmin",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_name)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as NodeNotExistException {
                                          throw error
                                      } catch let error as NodeUnreachableException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get the number of physical processor sockets for the machine running the node with the given name.
    /// Note that this method will return 1 on operating systems where this can't be automatically determined and
    /// where the IceGrid.Node.ProcessorSocketCount property for the node is not set.
    ///
    /// - parameter _: `Swift.String` The node name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Int32` - The number of processor sockets or 1 if the number of sockets can't determined.
    ///
    /// - throws:
    ///
    ///   - NodeNotExistException - Raised if the node doesn't exist.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    func getNodeProcessorSocketCount(_ iceP_name: Swift.String, context: Ice.Context? = nil) throws -> Swift.Int32 {
        return try _impl._invoke(operation: "getNodeProcessorSocketCount",
                                 mode: .Idempotent,
                                 write: { ostr in
                                     ostr.write(iceP_name)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: Swift.Int32 = try istr.read()
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as NodeNotExistException {
                                         throw error
                                     } catch let error as NodeUnreachableException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Get the number of physical processor sockets for the machine running the node with the given name.
    /// Note that this method will return 1 on operating systems where this can't be automatically determined and
    /// where the IceGrid.Node.ProcessorSocketCount property for the node is not set.
    ///
    /// - parameter _: `Swift.String` The node name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Int32>` - The result of the operation
    func getNodeProcessorSocketCountAsync(_ iceP_name: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Int32> {
        return _impl._invokeAsync(operation: "getNodeProcessorSocketCount",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_name)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: Swift.Int32 = try istr.read()
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as NodeNotExistException {
                                          throw error
                                      } catch let error as NodeUnreachableException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Shutdown an IceGrid node.
    ///
    /// - parameter _: `Swift.String` The node name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - NodeNotExistException - Raised if the node doesn't exist.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    func shutdownNode(_ iceP_name: Swift.String, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "shutdownNode",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_name)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as NodeNotExistException {
                                  throw error
                              } catch let error as NodeUnreachableException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Shutdown an IceGrid node.
    ///
    /// - parameter _: `Swift.String` The node name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func shutdownNodeAsync(_ iceP_name: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "shutdownNode",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_name)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as NodeNotExistException {
                                          throw error
                                      } catch let error as NodeUnreachableException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get the hostname of this node.
    ///
    /// - parameter _: `Swift.String` The node name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String` - The node hostname.
    ///
    /// - throws:
    ///
    ///   - NodeNotExistException - Raised if the node doesn't exist.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    func getNodeHostname(_ iceP_name: Swift.String, context: Ice.Context? = nil) throws -> Swift.String {
        return try _impl._invoke(operation: "getNodeHostname",
                                 mode: .Idempotent,
                                 write: { ostr in
                                     ostr.write(iceP_name)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: Swift.String = try istr.read()
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as NodeNotExistException {
                                         throw error
                                     } catch let error as NodeUnreachableException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Get the hostname of this node.
    ///
    /// - parameter _: `Swift.String` The node name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.String>` - The result of the operation
    func getNodeHostnameAsync(_ iceP_name: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.String> {
        return _impl._invokeAsync(operation: "getNodeHostname",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_name)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: Swift.String = try istr.read()
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as NodeNotExistException {
                                          throw error
                                      } catch let error as NodeUnreachableException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get all the IceGrid nodes currently registered.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.StringSeq` - The node names.
    func getAllNodeNames(context: Ice.Context? = nil) throws -> Ice.StringSeq {
        return try _impl._invoke(operation: "getAllNodeNames",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: Ice.StringSeq = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get all the IceGrid nodes currently registered.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Ice.StringSeq>` - The result of the operation
    func getAllNodeNamesAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Ice.StringSeq> {
        return _impl._invokeAsync(operation: "getAllNodeNames",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: Ice.StringSeq = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Ping an IceGrid registry to see if it is active.
    ///
    /// - parameter _: `Swift.String` The registry name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Bool` - true if the registry ping succeeded, false otherwise.
    ///
    /// - throws:
    ///
    ///   - RegistryNotExistException - Raised if the registry doesn't exist.
    func pingRegistry(_ iceP_name: Swift.String, context: Ice.Context? = nil) throws -> Swift.Bool {
        return try _impl._invoke(operation: "pingRegistry",
                                 mode: .Idempotent,
                                 write: { ostr in
                                     ostr.write(iceP_name)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: Swift.Bool = try istr.read()
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as RegistryNotExistException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Ping an IceGrid registry to see if it is active.
    ///
    /// - parameter _: `Swift.String` The registry name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Bool>` - The result of the operation
    func pingRegistryAsync(_ iceP_name: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Bool> {
        return _impl._invokeAsync(operation: "pingRegistry",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_name)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: Swift.Bool = try istr.read()
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as RegistryNotExistException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get the registry information for the registry with the given name.
    ///
    /// - parameter _: `Swift.String` The registry name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `RegistryInfo` - The registry information.
    ///
    /// - throws:
    ///
    ///   - RegistryNotExistException - Raised if the registry doesn't exist.
    ///
    ///   - RegistryUnreachableException - Raised if the registry could not be reached.
    func getRegistryInfo(_ iceP_name: Swift.String, context: Ice.Context? = nil) throws -> RegistryInfo {
        return try _impl._invoke(operation: "getRegistryInfo",
                                 mode: .Idempotent,
                                 write: { ostr in
                                     ostr.write(iceP_name)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: RegistryInfo = try istr.read()
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as RegistryNotExistException {
                                         throw error
                                     } catch let error as RegistryUnreachableException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Get the registry information for the registry with the given name.
    ///
    /// - parameter _: `Swift.String` The registry name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<RegistryInfo>` - The result of the operation
    func getRegistryInfoAsync(_ iceP_name: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<RegistryInfo> {
        return _impl._invokeAsync(operation: "getRegistryInfo",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_name)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: RegistryInfo = try istr.read()
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as RegistryNotExistException {
                                          throw error
                                      } catch let error as RegistryUnreachableException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get a proxy to the IceGrid registry's admin object.
    ///
    /// - parameter _: `Swift.String` The registry name
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.ObjectPrx?` - A proxy to the IceGrid registry's admin object. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - RegistryNotExistException - Raised if the registry doesn't exist.
    func getRegistryAdmin(_ iceP_name: Swift.String, context: Ice.Context? = nil) throws -> Ice.ObjectPrx? {
        return try _impl._invoke(operation: "getRegistryAdmin",
                                 mode: .Idempotent,
                                 write: { ostr in
                                     ostr.write(iceP_name)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as RegistryNotExistException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Get a proxy to the IceGrid registry's admin object.
    ///
    /// - parameter _: `Swift.String` The registry name
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Ice.ObjectPrx?>` - The result of the operation
    func getRegistryAdminAsync(_ iceP_name: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Ice.ObjectPrx?> {
        return _impl._invokeAsync(operation: "getRegistryAdmin",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_name)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as RegistryNotExistException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Shutdown an IceGrid registry.
    ///
    /// - parameter _: `Swift.String` The registry name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - RegistryNotExistException - Raised if the registry doesn't exist.
    ///
    ///   - RegistryUnreachableException - Raised if the registry could not be reached.
    func shutdownRegistry(_ iceP_name: Swift.String, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "shutdownRegistry",
                          mode: .Idempotent,
                          write: { ostr in
                              ostr.write(iceP_name)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as RegistryNotExistException {
                                  throw error
                              } catch let error as RegistryUnreachableException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Shutdown an IceGrid registry.
    ///
    /// - parameter _: `Swift.String` The registry name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func shutdownRegistryAsync(_ iceP_name: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "shutdownRegistry",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_name)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as RegistryNotExistException {
                                          throw error
                                      } catch let error as RegistryUnreachableException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get all the IceGrid registries currently registered.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.StringSeq` - The registry names.
    func getAllRegistryNames(context: Ice.Context? = nil) throws -> Ice.StringSeq {
        return try _impl._invoke(operation: "getAllRegistryNames",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: Ice.StringSeq = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get all the IceGrid registries currently registered.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Ice.StringSeq>` - The result of the operation
    func getAllRegistryNamesAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Ice.StringSeq> {
        return _impl._invokeAsync(operation: "getAllRegistryNames",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: Ice.StringSeq = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Shut down the IceGrid registry.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func shutdown(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "shutdown",
                          mode: .Normal,
                          context: context)
    }

    /// Shut down the IceGrid registry.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func shutdownAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "shutdown",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// This interface provides access to IceGrid log file contents.
///
/// FileIteratorPrx Methods:
///
///  - read: Read lines from the log file.
///
///  - readAsync: Read lines from the log file.
///
///  - destroy: Destroy the iterator.
///
///  - destroyAsync: Destroy the iterator.
public protocol FileIteratorPrx: Ice.ObjectPrx {}

private final class FileIteratorPrxI: Ice.ObjectPrxI, FileIteratorPrx {
    public override class func ice_staticId() -> Swift.String {
        return FileIteratorTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: FileIteratorPrx.Protocol) throws -> FileIteratorPrx {
    try communicator.makeProxyImpl(proxyString) as FileIteratorPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `FileIteratorPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `FileIteratorPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: FileIteratorPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> FileIteratorPrx? {
    return try FileIteratorPrxI.checkedCast(prx: prx, facet: facet, context: context) as FileIteratorPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `FileIteratorPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `FileIteratorPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: FileIteratorPrx.Protocol, facet: Swift.String? = nil) -> FileIteratorPrx {
    return FileIteratorPrxI.uncheckedCast(prx: prx, facet: facet) as FileIteratorPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `FileIteratorPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: FileIteratorPrx.Protocol) -> Swift.String {
    return FileIteratorTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `FileIteratorPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `FileIteratorPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `FileIteratorPrx?` - The extracted proxy
    func read(_ type: FileIteratorPrx.Protocol) throws -> FileIteratorPrx? {
        return try read() as FileIteratorPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `FileIteratorPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `FileIteratorPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: FileIteratorPrx.Protocol) throws -> FileIteratorPrx? {
        return try read(tag: tag) as FileIteratorPrxI?
    }
}

/// This interface provides access to IceGrid log file contents.
///
/// FileIteratorPrx Methods:
///
///  - read: Read lines from the log file.
///
///  - readAsync: Read lines from the log file.
///
///  - destroy: Destroy the iterator.
///
///  - destroyAsync: Destroy the iterator.
public extension FileIteratorPrx {
    /// Read lines from the log file.
    ///
    /// - parameter _: `Swift.Int32` Specifies the maximum number of bytes to be received. The server will ensure that the returned
    /// message doesn't exceed the given size.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: Swift.Bool, lines: Ice.StringSeq)`:
    ///
    ///   - returnValue: `Swift.Bool` - True if EOF is encountered.
    ///
    ///   - lines: `Ice.StringSeq` - The lines read from the file. If there was nothing to read from the file since the last call to
    /// read, an empty sequence is returned. The last line of the sequence is always incomplete (and therefore no
    /// '\n' should be added when writing the last line to the to the output device).
    ///
    /// - throws:
    ///
    ///   - FileNotAvailableException - Raised if there was a problem to read lines from the file.
    func read(_ iceP_size: Swift.Int32, context: Ice.Context? = nil) throws -> (returnValue: Swift.Bool, lines: Ice.StringSeq) {
        return try _impl._invoke(operation: "read",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_size)
                                 },
                                 read: { istr in
                                     let iceP_lines: Ice.StringSeq = try istr.read()
                                     let iceP_returnValue: Swift.Bool = try istr.read()
                                     return (iceP_returnValue, iceP_lines)
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as FileNotAvailableException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Read lines from the log file.
    ///
    /// - parameter _: `Swift.Int32` Specifies the maximum number of bytes to be received. The server will ensure that the returned
    /// message doesn't exceed the given size.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: Swift.Bool, lines: Ice.StringSeq)>` - The result of the operation
    func readAsync(_ iceP_size: Swift.Int32, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: Swift.Bool, lines: Ice.StringSeq)> {
        return _impl._invokeAsync(operation: "read",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_size)
                                  },
                                  read: { istr in
                                      let iceP_lines: Ice.StringSeq = try istr.read()
                                      let iceP_returnValue: Swift.Bool = try istr.read()
                                      return (iceP_returnValue, iceP_lines)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as FileNotAvailableException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Destroy the iterator.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func destroy(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "destroy",
                          mode: .Normal,
                          context: context)
    }

    /// Destroy the iterator.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func destroyAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "destroy",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// This interface allows applications to monitor changes the state of the registry.
///
/// RegistryObserverPrx Methods:
///
///  - registryInit: The registryInit operation is called after registration of an observer to indicate the state of the registries.
///
///  - registryInitAsync: The registryInit operation is called after registration of an observer to indicate the state of the registries.
///
///  - registryUp: The registryUp operation is called to notify an observer that a registry replica came up.
///
///  - registryUpAsync: The registryUp operation is called to notify an observer that a registry replica came up.
///
///  - registryDown: The registryDown operation is called to notify an observer that a registry replica went down.
///
///  - registryDownAsync: The registryDown operation is called to notify an observer that a registry replica went down.
public protocol RegistryObserverPrx: Ice.ObjectPrx {}

private final class RegistryObserverPrxI: Ice.ObjectPrxI, RegistryObserverPrx {
    public override class func ice_staticId() -> Swift.String {
        return RegistryObserverTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: RegistryObserverPrx.Protocol) throws -> RegistryObserverPrx {
    try communicator.makeProxyImpl(proxyString) as RegistryObserverPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `RegistryObserverPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `RegistryObserverPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: RegistryObserverPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> RegistryObserverPrx? {
    return try RegistryObserverPrxI.checkedCast(prx: prx, facet: facet, context: context) as RegistryObserverPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `RegistryObserverPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `RegistryObserverPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: RegistryObserverPrx.Protocol, facet: Swift.String? = nil) -> RegistryObserverPrx {
    return RegistryObserverPrxI.uncheckedCast(prx: prx, facet: facet) as RegistryObserverPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `RegistryObserverPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: RegistryObserverPrx.Protocol) -> Swift.String {
    return RegistryObserverTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `RegistryObserverPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `RegistryObserverPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `RegistryObserverPrx?` - The extracted proxy
    func read(_ type: RegistryObserverPrx.Protocol) throws -> RegistryObserverPrx? {
        return try read() as RegistryObserverPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `RegistryObserverPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `RegistryObserverPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: RegistryObserverPrx.Protocol) throws -> RegistryObserverPrx? {
        return try read(tag: tag) as RegistryObserverPrxI?
    }
}

/// This interface allows applications to monitor changes the state of the registry.
///
/// RegistryObserverPrx Methods:
///
///  - registryInit: The registryInit operation is called after registration of an observer to indicate the state of the registries.
///
///  - registryInitAsync: The registryInit operation is called after registration of an observer to indicate the state of the registries.
///
///  - registryUp: The registryUp operation is called to notify an observer that a registry replica came up.
///
///  - registryUpAsync: The registryUp operation is called to notify an observer that a registry replica came up.
///
///  - registryDown: The registryDown operation is called to notify an observer that a registry replica went down.
///
///  - registryDownAsync: The registryDown operation is called to notify an observer that a registry replica went down.
public extension RegistryObserverPrx {
    /// The registryInit operation is called after registration of an observer to indicate the state of
    /// the registries.
    ///
    /// - parameter _: `RegistryInfoSeq` The current state of the registries.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func registryInit(_ iceP_registries: RegistryInfoSeq, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "registryInit",
                          mode: .Normal,
                          write: { ostr in
                              RegistryInfoSeqHelper.write(to: ostr, value: iceP_registries)
                          },
                          context: context)
    }

    /// The registryInit operation is called after registration of an observer to indicate the state of
    /// the registries.
    ///
    /// - parameter _: `RegistryInfoSeq` The current state of the registries.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func registryInitAsync(_ iceP_registries: RegistryInfoSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "registryInit",
                                  mode: .Normal,
                                  write: { ostr in
                                      RegistryInfoSeqHelper.write(to: ostr, value: iceP_registries)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// The registryUp operation is called to notify an observer that a registry replica came up.
    ///
    /// - parameter _: `RegistryInfo` The registry state.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func registryUp(_ iceP_registryReplica: RegistryInfo, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "registryUp",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_registryReplica)
                          },
                          context: context)
    }

    /// The registryUp operation is called to notify an observer that a registry replica came up.
    ///
    /// - parameter _: `RegistryInfo` The registry state.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func registryUpAsync(_ iceP_registryReplica: RegistryInfo, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "registryUp",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_registryReplica)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// The registryDown operation is called to notify an observer that a registry replica went down.
    ///
    /// - parameter _: `Swift.String` The registry name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func registryDown(_ iceP_name: Swift.String, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "registryDown",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_name)
                          },
                          context: context)
    }

    /// The registryDown operation is called to notify an observer that a registry replica went down.
    ///
    /// - parameter _: `Swift.String` The registry name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func registryDownAsync(_ iceP_name: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "registryDown",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_name)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// The node observer interface. Observers should implement this interface to receive information about the state of
/// the IceGrid nodes.
///
/// NodeObserverPrx Methods:
///
///  - nodeInit: The nodeInit operation indicates the current state of nodes.
///
///  - nodeInitAsync: The nodeInit operation indicates the current state of nodes.
///
///  - nodeUp: The nodeUp operation is called to notify an observer that a node came up.
///
///  - nodeUpAsync: The nodeUp operation is called to notify an observer that a node came up.
///
///  - nodeDown: The nodeDown operation is called to notify an observer that a node went down.
///
///  - nodeDownAsync: The nodeDown operation is called to notify an observer that a node went down.
///
///  - updateServer: The updateServer operation is called to notify an observer that the state of a server changed.
///
///  - updateServerAsync: The updateServer operation is called to notify an observer that the state of a server changed.
///
///  - updateAdapter: The updateAdapter operation is called to notify an observer that the state of an adapter changed.
///
///  - updateAdapterAsync: The updateAdapter operation is called to notify an observer that the state of an adapter changed.
public protocol NodeObserverPrx: Ice.ObjectPrx {}

private final class NodeObserverPrxI: Ice.ObjectPrxI, NodeObserverPrx {
    public override class func ice_staticId() -> Swift.String {
        return NodeObserverTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: NodeObserverPrx.Protocol) throws -> NodeObserverPrx {
    try communicator.makeProxyImpl(proxyString) as NodeObserverPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `NodeObserverPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `NodeObserverPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: NodeObserverPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> NodeObserverPrx? {
    return try NodeObserverPrxI.checkedCast(prx: prx, facet: facet, context: context) as NodeObserverPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `NodeObserverPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `NodeObserverPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: NodeObserverPrx.Protocol, facet: Swift.String? = nil) -> NodeObserverPrx {
    return NodeObserverPrxI.uncheckedCast(prx: prx, facet: facet) as NodeObserverPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `NodeObserverPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: NodeObserverPrx.Protocol) -> Swift.String {
    return NodeObserverTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `NodeObserverPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `NodeObserverPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `NodeObserverPrx?` - The extracted proxy
    func read(_ type: NodeObserverPrx.Protocol) throws -> NodeObserverPrx? {
        return try read() as NodeObserverPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `NodeObserverPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `NodeObserverPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: NodeObserverPrx.Protocol) throws -> NodeObserverPrx? {
        return try read(tag: tag) as NodeObserverPrxI?
    }
}

/// The node observer interface. Observers should implement this interface to receive information about the state of
/// the IceGrid nodes.
///
/// NodeObserverPrx Methods:
///
///  - nodeInit: The nodeInit operation indicates the current state of nodes.
///
///  - nodeInitAsync: The nodeInit operation indicates the current state of nodes.
///
///  - nodeUp: The nodeUp operation is called to notify an observer that a node came up.
///
///  - nodeUpAsync: The nodeUp operation is called to notify an observer that a node came up.
///
///  - nodeDown: The nodeDown operation is called to notify an observer that a node went down.
///
///  - nodeDownAsync: The nodeDown operation is called to notify an observer that a node went down.
///
///  - updateServer: The updateServer operation is called to notify an observer that the state of a server changed.
///
///  - updateServerAsync: The updateServer operation is called to notify an observer that the state of a server changed.
///
///  - updateAdapter: The updateAdapter operation is called to notify an observer that the state of an adapter changed.
///
///  - updateAdapterAsync: The updateAdapter operation is called to notify an observer that the state of an adapter changed.
public extension NodeObserverPrx {
    /// The nodeInit operation indicates the current state of nodes. It is called after the
    /// registration of an observer.
    ///
    /// - parameter _: `NodeDynamicInfoSeq` The current state of the nodes.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func nodeInit(_ iceP_nodes: NodeDynamicInfoSeq, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "nodeInit",
                          mode: .Normal,
                          write: { ostr in
                              NodeDynamicInfoSeqHelper.write(to: ostr, value: iceP_nodes)
                          },
                          context: context)
    }

    /// The nodeInit operation indicates the current state of nodes. It is called after the
    /// registration of an observer.
    ///
    /// - parameter _: `NodeDynamicInfoSeq` The current state of the nodes.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func nodeInitAsync(_ iceP_nodes: NodeDynamicInfoSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "nodeInit",
                                  mode: .Normal,
                                  write: { ostr in
                                      NodeDynamicInfoSeqHelper.write(to: ostr, value: iceP_nodes)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// The nodeUp operation is called to notify an observer that a node came up.
    ///
    /// - parameter _: `NodeDynamicInfo` The node state.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func nodeUp(_ iceP_node: NodeDynamicInfo, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "nodeUp",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_node)
                          },
                          context: context)
    }

    /// The nodeUp operation is called to notify an observer that a node came up.
    ///
    /// - parameter _: `NodeDynamicInfo` The node state.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func nodeUpAsync(_ iceP_node: NodeDynamicInfo, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "nodeUp",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_node)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// The nodeDown operation is called to notify an observer that a node went down.
    ///
    /// - parameter _: `Swift.String` The node name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func nodeDown(_ iceP_name: Swift.String, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "nodeDown",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_name)
                          },
                          context: context)
    }

    /// The nodeDown operation is called to notify an observer that a node went down.
    ///
    /// - parameter _: `Swift.String` The node name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func nodeDownAsync(_ iceP_name: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "nodeDown",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_name)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// The updateServer operation is called to notify an observer that the state of a server changed.
    ///
    /// - parameter node: `Swift.String` The node hosting the server.
    ///
    /// - parameter updatedInfo: `ServerDynamicInfo` The new server state.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func updateServer(node iceP_node: Swift.String, updatedInfo iceP_updatedInfo: ServerDynamicInfo, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "updateServer",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_node)
                              ostr.write(iceP_updatedInfo)
                          },
                          context: context)
    }

    /// The updateServer operation is called to notify an observer that the state of a server changed.
    ///
    /// - parameter node: `Swift.String` The node hosting the server.
    ///
    /// - parameter updatedInfo: `ServerDynamicInfo` The new server state.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func updateServerAsync(node iceP_node: Swift.String, updatedInfo iceP_updatedInfo: ServerDynamicInfo, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "updateServer",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_node)
                                      ostr.write(iceP_updatedInfo)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// The updateAdapter operation is called to notify an observer that the state of an adapter
    /// changed.
    ///
    /// - parameter node: `Swift.String` The node hosting the adapter.
    ///
    /// - parameter updatedInfo: `AdapterDynamicInfo` The new adapter state.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func updateAdapter(node iceP_node: Swift.String, updatedInfo iceP_updatedInfo: AdapterDynamicInfo, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "updateAdapter",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_node)
                              ostr.write(iceP_updatedInfo)
                          },
                          context: context)
    }

    /// The updateAdapter operation is called to notify an observer that the state of an adapter
    /// changed.
    ///
    /// - parameter node: `Swift.String` The node hosting the adapter.
    ///
    /// - parameter updatedInfo: `AdapterDynamicInfo` The new adapter state.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func updateAdapterAsync(node iceP_node: Swift.String, updatedInfo iceP_updatedInfo: AdapterDynamicInfo, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "updateAdapter",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_node)
                                      ostr.write(iceP_updatedInfo)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// The database observer interface. Observers should implement this interface to receive information about the
/// state of the IceGrid registry database.
///
/// ApplicationObserverPrx Methods:
///
///  - applicationInit: applicationInit is called after the registration of an observer to indicate the state of the registry.
///
///  - applicationInitAsync: applicationInit is called after the registration of an observer to indicate the state of the registry.
///
///  - applicationAdded: The applicationAdded operation is called to notify an observer that an application was added.
///
///  - applicationAddedAsync: The applicationAdded operation is called to notify an observer that an application was added.
///
///  - applicationRemoved: The applicationRemoved operation is called to notify an observer that an application was removed.
///
///  - applicationRemovedAsync: The applicationRemoved operation is called to notify an observer that an application was removed.
///
///  - applicationUpdated: The applicationUpdated operation is called to notify an observer that an application was updated.
///
///  - applicationUpdatedAsync: The applicationUpdated operation is called to notify an observer that an application was updated.
public protocol ApplicationObserverPrx: Ice.ObjectPrx {}

private final class ApplicationObserverPrxI: Ice.ObjectPrxI, ApplicationObserverPrx {
    public override class func ice_staticId() -> Swift.String {
        return ApplicationObserverTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: ApplicationObserverPrx.Protocol) throws -> ApplicationObserverPrx {
    try communicator.makeProxyImpl(proxyString) as ApplicationObserverPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `ApplicationObserverPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `ApplicationObserverPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: ApplicationObserverPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> ApplicationObserverPrx? {
    return try ApplicationObserverPrxI.checkedCast(prx: prx, facet: facet, context: context) as ApplicationObserverPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `ApplicationObserverPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `ApplicationObserverPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: ApplicationObserverPrx.Protocol, facet: Swift.String? = nil) -> ApplicationObserverPrx {
    return ApplicationObserverPrxI.uncheckedCast(prx: prx, facet: facet) as ApplicationObserverPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `ApplicationObserverPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: ApplicationObserverPrx.Protocol) -> Swift.String {
    return ApplicationObserverTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `ApplicationObserverPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `ApplicationObserverPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `ApplicationObserverPrx?` - The extracted proxy
    func read(_ type: ApplicationObserverPrx.Protocol) throws -> ApplicationObserverPrx? {
        return try read() as ApplicationObserverPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `ApplicationObserverPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `ApplicationObserverPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: ApplicationObserverPrx.Protocol) throws -> ApplicationObserverPrx? {
        return try read(tag: tag) as ApplicationObserverPrxI?
    }
}

/// The database observer interface. Observers should implement this interface to receive information about the
/// state of the IceGrid registry database.
///
/// ApplicationObserverPrx Methods:
///
///  - applicationInit: applicationInit is called after the registration of an observer to indicate the state of the registry.
///
///  - applicationInitAsync: applicationInit is called after the registration of an observer to indicate the state of the registry.
///
///  - applicationAdded: The applicationAdded operation is called to notify an observer that an application was added.
///
///  - applicationAddedAsync: The applicationAdded operation is called to notify an observer that an application was added.
///
///  - applicationRemoved: The applicationRemoved operation is called to notify an observer that an application was removed.
///
///  - applicationRemovedAsync: The applicationRemoved operation is called to notify an observer that an application was removed.
///
///  - applicationUpdated: The applicationUpdated operation is called to notify an observer that an application was updated.
///
///  - applicationUpdatedAsync: The applicationUpdated operation is called to notify an observer that an application was updated.
public extension ApplicationObserverPrx {
    /// applicationInit is called after the registration of an observer to indicate the state of the
    /// registry.
    ///
    /// - parameter serial: `Swift.Int32` The current serial number of the registry database. This serial number allows observers to
    /// make sure that their internal state is synchronized with the registry.
    ///
    /// - parameter applications: `ApplicationInfoSeq` The applications currently registered with the registry.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func applicationInit(serial iceP_serial: Swift.Int32, applications iceP_applications: ApplicationInfoSeq, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "applicationInit",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_serial)
                              ApplicationInfoSeqHelper.write(to: ostr, value: iceP_applications)
                              ostr.writePendingValues()
                          },
                          context: context)
    }

    /// applicationInit is called after the registration of an observer to indicate the state of the
    /// registry.
    ///
    /// - parameter serial: `Swift.Int32` The current serial number of the registry database. This serial number allows observers to
    /// make sure that their internal state is synchronized with the registry.
    ///
    /// - parameter applications: `ApplicationInfoSeq` The applications currently registered with the registry.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func applicationInitAsync(serial iceP_serial: Swift.Int32, applications iceP_applications: ApplicationInfoSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "applicationInit",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_serial)
                                      ApplicationInfoSeqHelper.write(to: ostr, value: iceP_applications)
                                      ostr.writePendingValues()
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// The applicationAdded operation is called to notify an observer that an application was added.
    ///
    /// - parameter serial: `Swift.Int32` The new serial number of the registry database.
    ///
    /// - parameter desc: `ApplicationInfo` The descriptor of the new application.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func applicationAdded(serial iceP_serial: Swift.Int32, desc iceP_desc: ApplicationInfo, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "applicationAdded",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_serial)
                              ostr.write(iceP_desc)
                              ostr.writePendingValues()
                          },
                          context: context)
    }

    /// The applicationAdded operation is called to notify an observer that an application was added.
    ///
    /// - parameter serial: `Swift.Int32` The new serial number of the registry database.
    ///
    /// - parameter desc: `ApplicationInfo` The descriptor of the new application.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func applicationAddedAsync(serial iceP_serial: Swift.Int32, desc iceP_desc: ApplicationInfo, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "applicationAdded",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_serial)
                                      ostr.write(iceP_desc)
                                      ostr.writePendingValues()
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// The applicationRemoved operation is called to notify an observer that an application was
    /// removed.
    ///
    /// - parameter serial: `Swift.Int32` The new serial number of the registry database.
    ///
    /// - parameter name: `Swift.String` The name of the application that was removed.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func applicationRemoved(serial iceP_serial: Swift.Int32, name iceP_name: Swift.String, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "applicationRemoved",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_serial)
                              ostr.write(iceP_name)
                          },
                          context: context)
    }

    /// The applicationRemoved operation is called to notify an observer that an application was
    /// removed.
    ///
    /// - parameter serial: `Swift.Int32` The new serial number of the registry database.
    ///
    /// - parameter name: `Swift.String` The name of the application that was removed.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func applicationRemovedAsync(serial iceP_serial: Swift.Int32, name iceP_name: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "applicationRemoved",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_serial)
                                      ostr.write(iceP_name)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// The applicationUpdated operation is called to notify an observer that an application was
    /// updated.
    ///
    /// - parameter serial: `Swift.Int32` The new serial number of the registry database.
    ///
    /// - parameter desc: `ApplicationUpdateInfo` The descriptor of the update.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func applicationUpdated(serial iceP_serial: Swift.Int32, desc iceP_desc: ApplicationUpdateInfo, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "applicationUpdated",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_serial)
                              ostr.write(iceP_desc)
                              ostr.writePendingValues()
                          },
                          context: context)
    }

    /// The applicationUpdated operation is called to notify an observer that an application was
    /// updated.
    ///
    /// - parameter serial: `Swift.Int32` The new serial number of the registry database.
    ///
    /// - parameter desc: `ApplicationUpdateInfo` The descriptor of the update.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func applicationUpdatedAsync(serial iceP_serial: Swift.Int32, desc iceP_desc: ApplicationUpdateInfo, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "applicationUpdated",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_serial)
                                      ostr.write(iceP_desc)
                                      ostr.writePendingValues()
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// This interface allows applications to monitor the state of object adapters that are registered with IceGrid.
///
/// AdapterObserverPrx Methods:
///
///  - adapterInit: adapterInit is called after registration of an observer to indicate the state of the registry.
///
///  - adapterInitAsync: adapterInit is called after registration of an observer to indicate the state of the registry.
///
///  - adapterAdded: The adapterAdded operation is called to notify an observer when a dynamically-registered adapter was added.
///
///  - adapterAddedAsync: The adapterAdded operation is called to notify an observer when a dynamically-registered adapter was added.
///
///  - adapterUpdated: The adapterUpdated operation is called to notify an observer when a dynamically-registered adapter was updated.
///
///  - adapterUpdatedAsync: The adapterUpdated operation is called to notify an observer when a dynamically-registered adapter was updated.
///
///  - adapterRemoved: The adapterRemoved operation is called to notify an observer when a dynamically-registered adapter was removed.
///
///  - adapterRemovedAsync: The adapterRemoved operation is called to notify an observer when a dynamically-registered adapter was removed.
public protocol AdapterObserverPrx: Ice.ObjectPrx {}

private final class AdapterObserverPrxI: Ice.ObjectPrxI, AdapterObserverPrx {
    public override class func ice_staticId() -> Swift.String {
        return AdapterObserverTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: AdapterObserverPrx.Protocol) throws -> AdapterObserverPrx {
    try communicator.makeProxyImpl(proxyString) as AdapterObserverPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `AdapterObserverPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `AdapterObserverPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: AdapterObserverPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> AdapterObserverPrx? {
    return try AdapterObserverPrxI.checkedCast(prx: prx, facet: facet, context: context) as AdapterObserverPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `AdapterObserverPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `AdapterObserverPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: AdapterObserverPrx.Protocol, facet: Swift.String? = nil) -> AdapterObserverPrx {
    return AdapterObserverPrxI.uncheckedCast(prx: prx, facet: facet) as AdapterObserverPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `AdapterObserverPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: AdapterObserverPrx.Protocol) -> Swift.String {
    return AdapterObserverTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `AdapterObserverPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `AdapterObserverPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `AdapterObserverPrx?` - The extracted proxy
    func read(_ type: AdapterObserverPrx.Protocol) throws -> AdapterObserverPrx? {
        return try read() as AdapterObserverPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `AdapterObserverPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `AdapterObserverPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: AdapterObserverPrx.Protocol) throws -> AdapterObserverPrx? {
        return try read(tag: tag) as AdapterObserverPrxI?
    }
}

/// This interface allows applications to monitor the state of object adapters that are registered with IceGrid.
///
/// AdapterObserverPrx Methods:
///
///  - adapterInit: adapterInit is called after registration of an observer to indicate the state of the registry.
///
///  - adapterInitAsync: adapterInit is called after registration of an observer to indicate the state of the registry.
///
///  - adapterAdded: The adapterAdded operation is called to notify an observer when a dynamically-registered adapter was added.
///
///  - adapterAddedAsync: The adapterAdded operation is called to notify an observer when a dynamically-registered adapter was added.
///
///  - adapterUpdated: The adapterUpdated operation is called to notify an observer when a dynamically-registered adapter was updated.
///
///  - adapterUpdatedAsync: The adapterUpdated operation is called to notify an observer when a dynamically-registered adapter was updated.
///
///  - adapterRemoved: The adapterRemoved operation is called to notify an observer when a dynamically-registered adapter was removed.
///
///  - adapterRemovedAsync: The adapterRemoved operation is called to notify an observer when a dynamically-registered adapter was removed.
public extension AdapterObserverPrx {
    /// adapterInit is called after registration of an observer to indicate the state of the registry.
    ///
    /// - parameter _: `AdapterInfoSeq` The adapters that were dynamically registered with the registry (not through the deployment
    /// mechanism).
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func adapterInit(_ iceP_adpts: AdapterInfoSeq, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "adapterInit",
                          mode: .Normal,
                          write: { ostr in
                              AdapterInfoSeqHelper.write(to: ostr, value: iceP_adpts)
                          },
                          context: context)
    }

    /// adapterInit is called after registration of an observer to indicate the state of the registry.
    ///
    /// - parameter _: `AdapterInfoSeq` The adapters that were dynamically registered with the registry (not through the deployment
    /// mechanism).
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func adapterInitAsync(_ iceP_adpts: AdapterInfoSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "adapterInit",
                                  mode: .Normal,
                                  write: { ostr in
                                      AdapterInfoSeqHelper.write(to: ostr, value: iceP_adpts)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// The adapterAdded operation is called to notify an observer when a dynamically-registered
    /// adapter was added.
    ///
    /// - parameter _: `AdapterInfo` The details of the new adapter.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func adapterAdded(_ iceP_info: AdapterInfo, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "adapterAdded",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_info)
                          },
                          context: context)
    }

    /// The adapterAdded operation is called to notify an observer when a dynamically-registered
    /// adapter was added.
    ///
    /// - parameter _: `AdapterInfo` The details of the new adapter.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func adapterAddedAsync(_ iceP_info: AdapterInfo, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "adapterAdded",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_info)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// The adapterUpdated operation is called to notify an observer when a dynamically-registered adapter was
    /// updated.
    ///
    /// - parameter _: `AdapterInfo` The details of the updated adapter.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func adapterUpdated(_ iceP_info: AdapterInfo, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "adapterUpdated",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_info)
                          },
                          context: context)
    }

    /// The adapterUpdated operation is called to notify an observer when a dynamically-registered adapter was
    /// updated.
    ///
    /// - parameter _: `AdapterInfo` The details of the updated adapter.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func adapterUpdatedAsync(_ iceP_info: AdapterInfo, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "adapterUpdated",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_info)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// The adapterRemoved operation is called to notify an observer when a dynamically-registered adapter was
    /// removed.
    ///
    /// - parameter _: `Swift.String` The ID of the removed adapter.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func adapterRemoved(_ iceP_id: Swift.String, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "adapterRemoved",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_id)
                          },
                          context: context)
    }

    /// The adapterRemoved operation is called to notify an observer when a dynamically-registered adapter was
    /// removed.
    ///
    /// - parameter _: `Swift.String` The ID of the removed adapter.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func adapterRemovedAsync(_ iceP_id: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "adapterRemoved",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_id)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// This interface allows applications to monitor IceGrid well-known objects.
///
/// ObjectObserverPrx Methods:
///
///  - objectInit: objectInit is called after the registration of an observer to indicate the state of the registry.
///
///  - objectInitAsync: objectInit is called after the registration of an observer to indicate the state of the registry.
///
///  - objectAdded: The objectAdded operation is called to notify an observer when an object was added to the Admin interface.
///
///  - objectAddedAsync: The objectAdded operation is called to notify an observer when an object was added to the Admin interface.
///
///  - objectUpdated: objectUpdated is called to notify an observer when an object registered with the Admin interface was updated.
///
///  - objectUpdatedAsync: objectUpdated is called to notify an observer when an object registered with the Admin interface was updated.
///
///  - objectRemoved: objectRemoved is called to notify an observer when an object registered with the Admin interface was removed.
///
///  - objectRemovedAsync: objectRemoved is called to notify an observer when an object registered with the Admin interface was removed.
public protocol ObjectObserverPrx: Ice.ObjectPrx {}

private final class ObjectObserverPrxI: Ice.ObjectPrxI, ObjectObserverPrx {
    public override class func ice_staticId() -> Swift.String {
        return ObjectObserverTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: ObjectObserverPrx.Protocol) throws -> ObjectObserverPrx {
    try communicator.makeProxyImpl(proxyString) as ObjectObserverPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `ObjectObserverPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `ObjectObserverPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: ObjectObserverPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> ObjectObserverPrx? {
    return try ObjectObserverPrxI.checkedCast(prx: prx, facet: facet, context: context) as ObjectObserverPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `ObjectObserverPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `ObjectObserverPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: ObjectObserverPrx.Protocol, facet: Swift.String? = nil) -> ObjectObserverPrx {
    return ObjectObserverPrxI.uncheckedCast(prx: prx, facet: facet) as ObjectObserverPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `ObjectObserverPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: ObjectObserverPrx.Protocol) -> Swift.String {
    return ObjectObserverTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `ObjectObserverPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `ObjectObserverPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `ObjectObserverPrx?` - The extracted proxy
    func read(_ type: ObjectObserverPrx.Protocol) throws -> ObjectObserverPrx? {
        return try read() as ObjectObserverPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `ObjectObserverPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `ObjectObserverPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: ObjectObserverPrx.Protocol) throws -> ObjectObserverPrx? {
        return try read(tag: tag) as ObjectObserverPrxI?
    }
}

/// This interface allows applications to monitor IceGrid well-known objects.
///
/// ObjectObserverPrx Methods:
///
///  - objectInit: objectInit is called after the registration of an observer to indicate the state of the registry.
///
///  - objectInitAsync: objectInit is called after the registration of an observer to indicate the state of the registry.
///
///  - objectAdded: The objectAdded operation is called to notify an observer when an object was added to the Admin interface.
///
///  - objectAddedAsync: The objectAdded operation is called to notify an observer when an object was added to the Admin interface.
///
///  - objectUpdated: objectUpdated is called to notify an observer when an object registered with the Admin interface was updated.
///
///  - objectUpdatedAsync: objectUpdated is called to notify an observer when an object registered with the Admin interface was updated.
///
///  - objectRemoved: objectRemoved is called to notify an observer when an object registered with the Admin interface was removed.
///
///  - objectRemovedAsync: objectRemoved is called to notify an observer when an object registered with the Admin interface was removed.
public extension ObjectObserverPrx {
    /// objectInit is called after the registration of an observer to indicate the state of the
    /// registry.
    ///
    /// - parameter _: `ObjectInfoSeq` The objects registered with the Admin interface (not through the deployment
    /// mechanism).
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func objectInit(_ iceP_objects: ObjectInfoSeq, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "objectInit",
                          mode: .Normal,
                          write: { ostr in
                              ObjectInfoSeqHelper.write(to: ostr, value: iceP_objects)
                          },
                          context: context)
    }

    /// objectInit is called after the registration of an observer to indicate the state of the
    /// registry.
    ///
    /// - parameter _: `ObjectInfoSeq` The objects registered with the Admin interface (not through the deployment
    /// mechanism).
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func objectInitAsync(_ iceP_objects: ObjectInfoSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "objectInit",
                                  mode: .Normal,
                                  write: { ostr in
                                      ObjectInfoSeqHelper.write(to: ostr, value: iceP_objects)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// The objectAdded operation is called to notify an observer when an object was added to the
    /// Admin interface.
    ///
    /// - parameter _: `ObjectInfo` The details of the added object.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func objectAdded(_ iceP_info: ObjectInfo, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "objectAdded",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_info)
                          },
                          context: context)
    }

    /// The objectAdded operation is called to notify an observer when an object was added to the
    /// Admin interface.
    ///
    /// - parameter _: `ObjectInfo` The details of the added object.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func objectAddedAsync(_ iceP_info: ObjectInfo, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "objectAdded",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_info)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// objectUpdated is called to notify an observer when an object registered with the Admin
    /// interface was updated.
    ///
    /// - parameter _: `ObjectInfo` The details of the updated object.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func objectUpdated(_ iceP_info: ObjectInfo, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "objectUpdated",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_info)
                          },
                          context: context)
    }

    /// objectUpdated is called to notify an observer when an object registered with the Admin
    /// interface was updated.
    ///
    /// - parameter _: `ObjectInfo` The details of the updated object.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func objectUpdatedAsync(_ iceP_info: ObjectInfo, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "objectUpdated",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_info)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// objectRemoved is called to notify an observer when an object registered with the Admin
    /// interface was removed.
    ///
    /// - parameter _: `Ice.Identity` The identity of the removed object.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func objectRemoved(_ iceP_id: Ice.Identity, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "objectRemoved",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_id)
                          },
                          context: context)
    }

    /// objectRemoved is called to notify an observer when an object registered with the Admin
    /// interface was removed.
    ///
    /// - parameter _: `Ice.Identity` The identity of the removed object.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func objectRemovedAsync(_ iceP_id: Ice.Identity, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "objectRemoved",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_id)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// Used by administrative clients to view, update, and receive observer updates from the IceGrid registry. Admin
/// sessions are created either via the Registry object or via the registry admin
/// SessionManager object.
///
/// AdminSessionPrx Methods:
///
///  - keepAlive: Keep the session alive.
///
///  - keepAliveAsync: Keep the session alive.
///
///  - getAdmin: Get the admin interface.
///
///  - getAdminAsync: Get the admin interface.
///
///  - getAdminCallbackTemplate: Get a "template" proxy for admin callback objects.
///
///  - getAdminCallbackTemplateAsync: Get a "template" proxy for admin callback objects.
///
///  - setObservers: Set the observer proxies that receive notifications when the state of the registry or nodes changes.
///
///  - setObserversAsync: Set the observer proxies that receive notifications when the state of the registry or nodes changes.
///
///  - setObserversByIdentity: Set the observer identities that receive notifications the state of the registry or nodes changes.
///
///  - setObserversByIdentityAsync: Set the observer identities that receive notifications the state of the registry or nodes changes.
///
///  - startUpdate: Acquires an exclusive lock to start updating the registry applications.
///
///  - startUpdateAsync: Acquires an exclusive lock to start updating the registry applications.
///
///  - finishUpdate: Finish updating the registry and release the exclusive lock.
///
///  - finishUpdateAsync: Finish updating the registry and release the exclusive lock.
///
///  - getReplicaName: Get the name of the registry replica hosting this session.
///
///  - getReplicaNameAsync: Get the name of the registry replica hosting this session.
///
///  - openServerLog: Open the given server log file for reading.
///
///  - openServerLogAsync: Open the given server log file for reading.
///
///  - openServerStdErr: Open the given server stderr file for reading.
///
///  - openServerStdErrAsync: Open the given server stderr file for reading.
///
///  - openServerStdOut: Open the given server stdout file for reading.
///
///  - openServerStdOutAsync: Open the given server stdout file for reading.
///
///  - openNodeStdErr: Open the given node stderr file for reading.
///
///  - openNodeStdErrAsync: Open the given node stderr file for reading.
///
///  - openNodeStdOut: Open the given node stdout file for reading.
///
///  - openNodeStdOutAsync: Open the given node stdout file for reading.
///
///  - openRegistryStdErr: Open the given registry stderr file for reading.
///
///  - openRegistryStdErrAsync: Open the given registry stderr file for reading.
///
///  - openRegistryStdOut: Open the given registry stdout file for reading.
///
///  - openRegistryStdOutAsync: Open the given registry stdout file for reading.
public protocol AdminSessionPrx: Glacier2.SessionPrx {}

private final class AdminSessionPrxI: Ice.ObjectPrxI, AdminSessionPrx {
    public override class func ice_staticId() -> Swift.String {
        return AdminSessionTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: AdminSessionPrx.Protocol) throws -> AdminSessionPrx {
    try communicator.makeProxyImpl(proxyString) as AdminSessionPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `AdminSessionPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `AdminSessionPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: AdminSessionPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> AdminSessionPrx? {
    return try AdminSessionPrxI.checkedCast(prx: prx, facet: facet, context: context) as AdminSessionPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `AdminSessionPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `AdminSessionPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: AdminSessionPrx.Protocol, facet: Swift.String? = nil) -> AdminSessionPrx {
    return AdminSessionPrxI.uncheckedCast(prx: prx, facet: facet) as AdminSessionPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `AdminSessionPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: AdminSessionPrx.Protocol) -> Swift.String {
    return AdminSessionTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `AdminSessionPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `AdminSessionPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `AdminSessionPrx?` - The extracted proxy
    func read(_ type: AdminSessionPrx.Protocol) throws -> AdminSessionPrx? {
        return try read() as AdminSessionPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `AdminSessionPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `AdminSessionPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: AdminSessionPrx.Protocol) throws -> AdminSessionPrx? {
        return try read(tag: tag) as AdminSessionPrxI?
    }
}

/// Used by administrative clients to view, update, and receive observer updates from the IceGrid registry. Admin
/// sessions are created either via the Registry object or via the registry admin
/// SessionManager object.
///
/// AdminSessionPrx Methods:
///
///  - keepAlive: Keep the session alive.
///
///  - keepAliveAsync: Keep the session alive.
///
///  - getAdmin: Get the admin interface.
///
///  - getAdminAsync: Get the admin interface.
///
///  - getAdminCallbackTemplate: Get a "template" proxy for admin callback objects.
///
///  - getAdminCallbackTemplateAsync: Get a "template" proxy for admin callback objects.
///
///  - setObservers: Set the observer proxies that receive notifications when the state of the registry or nodes changes.
///
///  - setObserversAsync: Set the observer proxies that receive notifications when the state of the registry or nodes changes.
///
///  - setObserversByIdentity: Set the observer identities that receive notifications the state of the registry or nodes changes.
///
///  - setObserversByIdentityAsync: Set the observer identities that receive notifications the state of the registry or nodes changes.
///
///  - startUpdate: Acquires an exclusive lock to start updating the registry applications.
///
///  - startUpdateAsync: Acquires an exclusive lock to start updating the registry applications.
///
///  - finishUpdate: Finish updating the registry and release the exclusive lock.
///
///  - finishUpdateAsync: Finish updating the registry and release the exclusive lock.
///
///  - getReplicaName: Get the name of the registry replica hosting this session.
///
///  - getReplicaNameAsync: Get the name of the registry replica hosting this session.
///
///  - openServerLog: Open the given server log file for reading.
///
///  - openServerLogAsync: Open the given server log file for reading.
///
///  - openServerStdErr: Open the given server stderr file for reading.
///
///  - openServerStdErrAsync: Open the given server stderr file for reading.
///
///  - openServerStdOut: Open the given server stdout file for reading.
///
///  - openServerStdOutAsync: Open the given server stdout file for reading.
///
///  - openNodeStdErr: Open the given node stderr file for reading.
///
///  - openNodeStdErrAsync: Open the given node stderr file for reading.
///
///  - openNodeStdOut: Open the given node stdout file for reading.
///
///  - openNodeStdOutAsync: Open the given node stdout file for reading.
///
///  - openRegistryStdErr: Open the given registry stderr file for reading.
///
///  - openRegistryStdErrAsync: Open the given registry stderr file for reading.
///
///  - openRegistryStdOut: Open the given registry stdout file for reading.
///
///  - openRegistryStdOutAsync: Open the given registry stdout file for reading.
public extension AdminSessionPrx {
    /// Keep the session alive. This operation is provided for backwards compatibility. As of Ice 3.8, there is no
    /// need to call this operation and its implementation does nothing.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func keepAlive(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "keepAlive",
                          mode: .Idempotent,
                          context: context)
    }

    /// Keep the session alive. This operation is provided for backwards compatibility. As of Ice 3.8, there is no
    /// need to call this operation and its implementation does nothing.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func keepAliveAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "keepAlive",
                                  mode: .Idempotent,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get the admin interface. The admin object returned by this operation can only be accessed by the session.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `AdminPrx?` - The admin interface proxy. The returned proxy is never null.
    func getAdmin(context: Ice.Context? = nil) throws -> AdminPrx? {
        return try _impl._invoke(operation: "getAdmin",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: AdminPrx? = try istr.read(AdminPrx.self)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get the admin interface. The admin object returned by this operation can only be accessed by the session.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<AdminPrx?>` - The result of the operation
    func getAdminAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<AdminPrx?> {
        return _impl._invokeAsync(operation: "getAdmin",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: AdminPrx? = try istr.read(AdminPrx.self)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get a "template" proxy for admin callback objects. An Admin client uses this proxy to set the category of
    /// its callback objects, and the published endpoints of the object adapter hosting the admin callback objects.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.ObjectPrx?` - A template proxy. The returned proxy is null when the Admin session was established using Glacier2.
    func getAdminCallbackTemplate(context: Ice.Context? = nil) throws -> Ice.ObjectPrx? {
        return try _impl._invoke(operation: "getAdminCallbackTemplate",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get a "template" proxy for admin callback objects. An Admin client uses this proxy to set the category of
    /// its callback objects, and the published endpoints of the object adapter hosting the admin callback objects.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Ice.ObjectPrx?>` - The result of the operation
    func getAdminCallbackTemplateAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Ice.ObjectPrx?> {
        return _impl._invokeAsync(operation: "getAdminCallbackTemplate",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Set the observer proxies that receive notifications when the state of the registry or nodes changes.
    ///
    /// - parameter registryObs: `RegistryObserverPrx?` The registry observer.
    ///
    /// - parameter nodeObs: `NodeObserverPrx?` The node observer.
    ///
    /// - parameter appObs: `ApplicationObserverPrx?` The application observer.
    ///
    /// - parameter adptObs: `AdapterObserverPrx?` The adapter observer.
    ///
    /// - parameter objObs: `ObjectObserverPrx?` The object observer.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - ObserverAlreadyRegisteredException - Raised if an observer is already registered with this registry.
    func setObservers(registryObs iceP_registryObs: RegistryObserverPrx?, nodeObs iceP_nodeObs: NodeObserverPrx?, appObs iceP_appObs: ApplicationObserverPrx?, adptObs iceP_adptObs: AdapterObserverPrx?, objObs iceP_objObs: ObjectObserverPrx?, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "setObservers",
                          mode: .Idempotent,
                          write: { ostr in
                              ostr.write(iceP_registryObs)
                              ostr.write(iceP_nodeObs)
                              ostr.write(iceP_appObs)
                              ostr.write(iceP_adptObs)
                              ostr.write(iceP_objObs)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as ObserverAlreadyRegisteredException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Set the observer proxies that receive notifications when the state of the registry or nodes changes.
    ///
    /// - parameter registryObs: `RegistryObserverPrx?` The registry observer.
    ///
    /// - parameter nodeObs: `NodeObserverPrx?` The node observer.
    ///
    /// - parameter appObs: `ApplicationObserverPrx?` The application observer.
    ///
    /// - parameter adptObs: `AdapterObserverPrx?` The adapter observer.
    ///
    /// - parameter objObs: `ObjectObserverPrx?` The object observer.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func setObserversAsync(registryObs iceP_registryObs: RegistryObserverPrx?, nodeObs iceP_nodeObs: NodeObserverPrx?, appObs iceP_appObs: ApplicationObserverPrx?, adptObs iceP_adptObs: AdapterObserverPrx?, objObs iceP_objObs: ObjectObserverPrx?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "setObservers",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_registryObs)
                                      ostr.write(iceP_nodeObs)
                                      ostr.write(iceP_appObs)
                                      ostr.write(iceP_adptObs)
                                      ostr.write(iceP_objObs)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ObserverAlreadyRegisteredException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Set the observer identities that receive notifications the state of the registry or nodes changes. This
    /// operation should be used by clients that are using a bidirectional connection to communicate with the
    /// session.
    ///
    /// - parameter registryObs: `Ice.Identity` The registry observer identity.
    ///
    /// - parameter nodeObs: `Ice.Identity` The node observer identity.
    ///
    /// - parameter appObs: `Ice.Identity` The application observer.
    ///
    /// - parameter adptObs: `Ice.Identity` The adapter observer.
    ///
    /// - parameter objObs: `Ice.Identity` The object observer.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - ObserverAlreadyRegisteredException - Raised if an observer is already registered with this registry.
    func setObserversByIdentity(registryObs iceP_registryObs: Ice.Identity, nodeObs iceP_nodeObs: Ice.Identity, appObs iceP_appObs: Ice.Identity, adptObs iceP_adptObs: Ice.Identity, objObs iceP_objObs: Ice.Identity, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "setObserversByIdentity",
                          mode: .Idempotent,
                          write: { ostr in
                              ostr.write(iceP_registryObs)
                              ostr.write(iceP_nodeObs)
                              ostr.write(iceP_appObs)
                              ostr.write(iceP_adptObs)
                              ostr.write(iceP_objObs)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as ObserverAlreadyRegisteredException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Set the observer identities that receive notifications the state of the registry or nodes changes. This
    /// operation should be used by clients that are using a bidirectional connection to communicate with the
    /// session.
    ///
    /// - parameter registryObs: `Ice.Identity` The registry observer identity.
    ///
    /// - parameter nodeObs: `Ice.Identity` The node observer identity.
    ///
    /// - parameter appObs: `Ice.Identity` The application observer.
    ///
    /// - parameter adptObs: `Ice.Identity` The adapter observer.
    ///
    /// - parameter objObs: `Ice.Identity` The object observer.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func setObserversByIdentityAsync(registryObs iceP_registryObs: Ice.Identity, nodeObs iceP_nodeObs: Ice.Identity, appObs iceP_appObs: Ice.Identity, adptObs iceP_adptObs: Ice.Identity, objObs iceP_objObs: Ice.Identity, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "setObserversByIdentity",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_registryObs)
                                      ostr.write(iceP_nodeObs)
                                      ostr.write(iceP_appObs)
                                      ostr.write(iceP_adptObs)
                                      ostr.write(iceP_objObs)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ObserverAlreadyRegisteredException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Acquires an exclusive lock to start updating the registry applications.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Int32` - The current serial.
    ///
    /// - throws:
    ///
    ///   - AccessDeniedException - Raised if the exclusive lock can't be acquired. This might happen if the lock
    ///     is currently acquired by another session.
    func startUpdate(context: Ice.Context? = nil) throws -> Swift.Int32 {
        return try _impl._invoke(operation: "startUpdate",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: Swift.Int32 = try istr.read()
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as AccessDeniedException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Acquires an exclusive lock to start updating the registry applications.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Int32>` - The result of the operation
    func startUpdateAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Int32> {
        return _impl._invokeAsync(operation: "startUpdate",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_returnValue: Swift.Int32 = try istr.read()
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as AccessDeniedException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Finish updating the registry and release the exclusive lock.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - AccessDeniedException - Raised if the session doesn't hold the exclusive lock.
    func finishUpdate(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "finishUpdate",
                          mode: .Normal,
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as AccessDeniedException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Finish updating the registry and release the exclusive lock.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func finishUpdateAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "finishUpdate",
                                  mode: .Normal,
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as AccessDeniedException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get the name of the registry replica hosting this session.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String` - The replica name of the registry.
    func getReplicaName(context: Ice.Context? = nil) throws -> Swift.String {
        return try _impl._invoke(operation: "getReplicaName",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: Swift.String = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get the name of the registry replica hosting this session.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.String>` - The result of the operation
    func getReplicaNameAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.String> {
        return _impl._invokeAsync(operation: "getReplicaName",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: Swift.String = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Open the given server log file for reading. The file can be read with the returned file iterator.
    ///
    /// - parameter id: `Swift.String` The server id.
    ///
    /// - parameter path: `Swift.String` The path of the log file. A log file can be opened only if it's declared in the server or
    /// service deployment descriptor.
    ///
    /// - parameter count: `Swift.Int32` Specifies where to start reading the file. If negative, the file is read from the begining. If
    /// 0 or positive, the file is read from the last count lines.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `FileIteratorPrx?` - An iterator to read the file. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if the server couldn't be deployed on the node.
    ///
    ///   - FileNotAvailableException - Raised if the file can't be read.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    ///
    ///   - ServerNotExistException - Raised if the server doesn't exist.
    func openServerLog(id iceP_id: Swift.String, path iceP_path: Swift.String, count iceP_count: Swift.Int32, context: Ice.Context? = nil) throws -> FileIteratorPrx? {
        return try _impl._invoke(operation: "openServerLog",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_id)
                                     ostr.write(iceP_path)
                                     ostr.write(iceP_count)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: FileIteratorPrx? = try istr.read(FileIteratorPrx.self)
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as ServerNotExistException {
                                         throw error
                                     } catch let error as FileNotAvailableException {
                                         throw error
                                     } catch let error as DeploymentException {
                                         throw error
                                     } catch let error as NodeUnreachableException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Open the given server log file for reading. The file can be read with the returned file iterator.
    ///
    /// - parameter id: `Swift.String` The server id.
    ///
    /// - parameter path: `Swift.String` The path of the log file. A log file can be opened only if it's declared in the server or
    /// service deployment descriptor.
    ///
    /// - parameter count: `Swift.Int32` Specifies where to start reading the file. If negative, the file is read from the begining. If
    /// 0 or positive, the file is read from the last count lines.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<FileIteratorPrx?>` - The result of the operation
    func openServerLogAsync(id iceP_id: Swift.String, path iceP_path: Swift.String, count iceP_count: Swift.Int32, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<FileIteratorPrx?> {
        return _impl._invokeAsync(operation: "openServerLog",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_id)
                                      ostr.write(iceP_path)
                                      ostr.write(iceP_count)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: FileIteratorPrx? = try istr.read(FileIteratorPrx.self)
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ServerNotExistException {
                                          throw error
                                      } catch let error as FileNotAvailableException {
                                          throw error
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch let error as NodeUnreachableException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Open the given server stderr file for reading. The file can be read with the returned file iterator.
    ///
    /// - parameter id: `Swift.String` The server id.
    ///
    /// - parameter count: `Swift.Int32` Specifies where to start reading the file. If negative, the file is read from the begining. If
    /// 0 or positive, the file is read from the last count lines.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `FileIteratorPrx?` - An iterator to read the file. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if the server couldn't be deployed on the node.
    ///
    ///   - FileNotAvailableException - Raised if the file can't be read.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    ///
    ///   - ServerNotExistException - Raised if the server doesn't exist.
    func openServerStdErr(id iceP_id: Swift.String, count iceP_count: Swift.Int32, context: Ice.Context? = nil) throws -> FileIteratorPrx? {
        return try _impl._invoke(operation: "openServerStdErr",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_id)
                                     ostr.write(iceP_count)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: FileIteratorPrx? = try istr.read(FileIteratorPrx.self)
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as ServerNotExistException {
                                         throw error
                                     } catch let error as FileNotAvailableException {
                                         throw error
                                     } catch let error as DeploymentException {
                                         throw error
                                     } catch let error as NodeUnreachableException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Open the given server stderr file for reading. The file can be read with the returned file iterator.
    ///
    /// - parameter id: `Swift.String` The server id.
    ///
    /// - parameter count: `Swift.Int32` Specifies where to start reading the file. If negative, the file is read from the begining. If
    /// 0 or positive, the file is read from the last count lines.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<FileIteratorPrx?>` - The result of the operation
    func openServerStdErrAsync(id iceP_id: Swift.String, count iceP_count: Swift.Int32, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<FileIteratorPrx?> {
        return _impl._invokeAsync(operation: "openServerStdErr",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_id)
                                      ostr.write(iceP_count)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: FileIteratorPrx? = try istr.read(FileIteratorPrx.self)
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ServerNotExistException {
                                          throw error
                                      } catch let error as FileNotAvailableException {
                                          throw error
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch let error as NodeUnreachableException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Open the given server stdout file for reading. The file can be read with the returned file iterator.
    ///
    /// - parameter id: `Swift.String` The server id.
    ///
    /// - parameter count: `Swift.Int32` Specifies where to start reading the file. If negative, the file is read from the begining.
    /// If 0 or positive, the file is read from the last count lines.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `FileIteratorPrx?` - An iterator to read the file. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if the server couldn't be deployed on the node.
    ///
    ///   - FileNotAvailableException - Raised if the file can't be read.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    ///
    ///   - ServerNotExistException - Raised if the server doesn't exist.
    func openServerStdOut(id iceP_id: Swift.String, count iceP_count: Swift.Int32, context: Ice.Context? = nil) throws -> FileIteratorPrx? {
        return try _impl._invoke(operation: "openServerStdOut",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_id)
                                     ostr.write(iceP_count)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: FileIteratorPrx? = try istr.read(FileIteratorPrx.self)
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as ServerNotExistException {
                                         throw error
                                     } catch let error as FileNotAvailableException {
                                         throw error
                                     } catch let error as DeploymentException {
                                         throw error
                                     } catch let error as NodeUnreachableException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Open the given server stdout file for reading. The file can be read with the returned file iterator.
    ///
    /// - parameter id: `Swift.String` The server id.
    ///
    /// - parameter count: `Swift.Int32` Specifies where to start reading the file. If negative, the file is read from the begining.
    /// If 0 or positive, the file is read from the last count lines.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<FileIteratorPrx?>` - The result of the operation
    func openServerStdOutAsync(id iceP_id: Swift.String, count iceP_count: Swift.Int32, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<FileIteratorPrx?> {
        return _impl._invokeAsync(operation: "openServerStdOut",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_id)
                                      ostr.write(iceP_count)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: FileIteratorPrx? = try istr.read(FileIteratorPrx.self)
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ServerNotExistException {
                                          throw error
                                      } catch let error as FileNotAvailableException {
                                          throw error
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch let error as NodeUnreachableException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Open the given node stderr file for reading. The file can be read with the returned file iterator.
    ///
    /// - parameter name: `Swift.String` The node name.
    ///
    /// - parameter count: `Swift.Int32` Specifies where to start reading the file. If negative, the file is read from the begining. If
    /// 0 or positive, the file is read from the last count lines.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `FileIteratorPrx?` - An iterator to read the file. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - FileNotAvailableException - Raised if the file can't be read.
    ///
    ///   - NodeNotExistException - Raised if the node doesn't exist.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    func openNodeStdErr(name iceP_name: Swift.String, count iceP_count: Swift.Int32, context: Ice.Context? = nil) throws -> FileIteratorPrx? {
        return try _impl._invoke(operation: "openNodeStdErr",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_name)
                                     ostr.write(iceP_count)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: FileIteratorPrx? = try istr.read(FileIteratorPrx.self)
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as NodeNotExistException {
                                         throw error
                                     } catch let error as FileNotAvailableException {
                                         throw error
                                     } catch let error as NodeUnreachableException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Open the given node stderr file for reading. The file can be read with the returned file iterator.
    ///
    /// - parameter name: `Swift.String` The node name.
    ///
    /// - parameter count: `Swift.Int32` Specifies where to start reading the file. If negative, the file is read from the begining. If
    /// 0 or positive, the file is read from the last count lines.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<FileIteratorPrx?>` - The result of the operation
    func openNodeStdErrAsync(name iceP_name: Swift.String, count iceP_count: Swift.Int32, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<FileIteratorPrx?> {
        return _impl._invokeAsync(operation: "openNodeStdErr",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_name)
                                      ostr.write(iceP_count)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: FileIteratorPrx? = try istr.read(FileIteratorPrx.self)
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as NodeNotExistException {
                                          throw error
                                      } catch let error as FileNotAvailableException {
                                          throw error
                                      } catch let error as NodeUnreachableException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Open the given node stdout file for reading. The file can be read with the returned file iterator.
    ///
    /// - parameter name: `Swift.String` The node name.
    ///
    /// - parameter count: `Swift.Int32` Specifies where to start reading the file. If negative, the file is read from the begining. If
    /// 0 or positive, the file is read from the last count lines.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `FileIteratorPrx?` - An iterator to read the file. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - FileNotAvailableException - Raised if the file can't be read.
    ///
    ///   - NodeNotExistException - Raised if the node doesn't exist.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    func openNodeStdOut(name iceP_name: Swift.String, count iceP_count: Swift.Int32, context: Ice.Context? = nil) throws -> FileIteratorPrx? {
        return try _impl._invoke(operation: "openNodeStdOut",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_name)
                                     ostr.write(iceP_count)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: FileIteratorPrx? = try istr.read(FileIteratorPrx.self)
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as NodeNotExistException {
                                         throw error
                                     } catch let error as FileNotAvailableException {
                                         throw error
                                     } catch let error as NodeUnreachableException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Open the given node stdout file for reading. The file can be read with the returned file iterator.
    ///
    /// - parameter name: `Swift.String` The node name.
    ///
    /// - parameter count: `Swift.Int32` Specifies where to start reading the file. If negative, the file is read from the begining. If
    /// 0 or positive, the file is read from the last count lines.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<FileIteratorPrx?>` - The result of the operation
    func openNodeStdOutAsync(name iceP_name: Swift.String, count iceP_count: Swift.Int32, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<FileIteratorPrx?> {
        return _impl._invokeAsync(operation: "openNodeStdOut",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_name)
                                      ostr.write(iceP_count)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: FileIteratorPrx? = try istr.read(FileIteratorPrx.self)
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as NodeNotExistException {
                                          throw error
                                      } catch let error as FileNotAvailableException {
                                          throw error
                                      } catch let error as NodeUnreachableException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Open the given registry stderr file for reading. The file can be read with the returned file iterator.
    ///
    /// - parameter name: `Swift.String` The registry name.
    ///
    /// - parameter count: `Swift.Int32` Specifies where to start reading the file. If negative, the file is read from the begining. If
    /// 0 or positive, the file is read from the last count lines.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `FileIteratorPrx?` - An iterator to read the file. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - FileNotAvailableException - Raised if the file can't be read.
    ///
    ///   - RegistryNotExistException - Raised if the registry doesn't exist.
    ///
    ///   - RegistryUnreachableException - Raised if the registry could not be reached.
    func openRegistryStdErr(name iceP_name: Swift.String, count iceP_count: Swift.Int32, context: Ice.Context? = nil) throws -> FileIteratorPrx? {
        return try _impl._invoke(operation: "openRegistryStdErr",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_name)
                                     ostr.write(iceP_count)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: FileIteratorPrx? = try istr.read(FileIteratorPrx.self)
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as RegistryNotExistException {
                                         throw error
                                     } catch let error as RegistryUnreachableException {
                                         throw error
                                     } catch let error as FileNotAvailableException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Open the given registry stderr file for reading. The file can be read with the returned file iterator.
    ///
    /// - parameter name: `Swift.String` The registry name.
    ///
    /// - parameter count: `Swift.Int32` Specifies where to start reading the file. If negative, the file is read from the begining. If
    /// 0 or positive, the file is read from the last count lines.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<FileIteratorPrx?>` - The result of the operation
    func openRegistryStdErrAsync(name iceP_name: Swift.String, count iceP_count: Swift.Int32, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<FileIteratorPrx?> {
        return _impl._invokeAsync(operation: "openRegistryStdErr",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_name)
                                      ostr.write(iceP_count)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: FileIteratorPrx? = try istr.read(FileIteratorPrx.self)
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as RegistryNotExistException {
                                          throw error
                                      } catch let error as RegistryUnreachableException {
                                          throw error
                                      } catch let error as FileNotAvailableException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Open the given registry stdout file for reading. The file can be read with the returned file iterator.
    ///
    /// - parameter name: `Swift.String` The registry name.
    ///
    /// - parameter count: `Swift.Int32` Specifies where to start reading the file. If negative, the file is read from the begining. If
    /// 0 or positive, the file is read from the last count lines.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `FileIteratorPrx?` - An iterator to read the file. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - FileNotAvailableException - Raised if the file can't be read.
    ///
    ///   - RegistryNotExistException - Raised if the registry doesn't exist.
    ///
    ///   - RegistryUnreachableException - Raised if the registry could not be reached.
    func openRegistryStdOut(name iceP_name: Swift.String, count iceP_count: Swift.Int32, context: Ice.Context? = nil) throws -> FileIteratorPrx? {
        return try _impl._invoke(operation: "openRegistryStdOut",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_name)
                                     ostr.write(iceP_count)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: FileIteratorPrx? = try istr.read(FileIteratorPrx.self)
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as RegistryNotExistException {
                                         throw error
                                     } catch let error as RegistryUnreachableException {
                                         throw error
                                     } catch let error as FileNotAvailableException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Open the given registry stdout file for reading. The file can be read with the returned file iterator.
    ///
    /// - parameter name: `Swift.String` The registry name.
    ///
    /// - parameter count: `Swift.Int32` Specifies where to start reading the file. If negative, the file is read from the begining. If
    /// 0 or positive, the file is read from the last count lines.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<FileIteratorPrx?>` - The result of the operation
    func openRegistryStdOutAsync(name iceP_name: Swift.String, count iceP_count: Swift.Int32, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<FileIteratorPrx?> {
        return _impl._invokeAsync(operation: "openRegistryStdOut",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_name)
                                      ostr.write(iceP_count)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: FileIteratorPrx? = try istr.read(FileIteratorPrx.self)
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as RegistryNotExistException {
                                          throw error
                                      } catch let error as RegistryUnreachableException {
                                          throw error
                                      } catch let error as FileNotAvailableException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}


/// Dispatcher for `Admin` servants.
public struct AdminDisp: Ice.Dispatcher {
    public let servant: Admin
    private static let defaultObject = Ice.ObjectI<AdminTraits>()

    public init(_ servant: Admin) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        switch request.current.operation {
        case "addApplication":
            servant._iceD_addApplication(request)
        case "addObject":
            servant._iceD_addObject(request)
        case "addObjectWithType":
            servant._iceD_addObjectWithType(request)
        case "enableServer":
            servant._iceD_enableServer(request)
        case "getAdapterInfo":
            servant._iceD_getAdapterInfo(request)
        case "getAllAdapterIds":
            servant._iceD_getAllAdapterIds(request)
        case "getAllApplicationNames":
            servant._iceD_getAllApplicationNames(request)
        case "getAllNodeNames":
            servant._iceD_getAllNodeNames(request)
        case "getAllObjectInfos":
            servant._iceD_getAllObjectInfos(request)
        case "getAllRegistryNames":
            servant._iceD_getAllRegistryNames(request)
        case "getAllServerIds":
            servant._iceD_getAllServerIds(request)
        case "getApplicationInfo":
            servant._iceD_getApplicationInfo(request)
        case "getDefaultApplicationDescriptor":
            servant._iceD_getDefaultApplicationDescriptor(request)
        case "getNodeAdmin":
            servant._iceD_getNodeAdmin(request)
        case "getNodeHostname":
            servant._iceD_getNodeHostname(request)
        case "getNodeInfo":
            servant._iceD_getNodeInfo(request)
        case "getNodeLoad":
            servant._iceD_getNodeLoad(request)
        case "getNodeProcessorSocketCount":
            servant._iceD_getNodeProcessorSocketCount(request)
        case "getObjectInfo":
            servant._iceD_getObjectInfo(request)
        case "getObjectInfosByType":
            servant._iceD_getObjectInfosByType(request)
        case "getRegistryAdmin":
            servant._iceD_getRegistryAdmin(request)
        case "getRegistryInfo":
            servant._iceD_getRegistryInfo(request)
        case "getServerAdmin":
            servant._iceD_getServerAdmin(request)
        case "getServerAdminCategory":
            servant._iceD_getServerAdminCategory(request)
        case "getServerInfo":
            servant._iceD_getServerInfo(request)
        case "getServerPid":
            servant._iceD_getServerPid(request)
        case "getServerState":
            servant._iceD_getServerState(request)
        case "ice_id":
            (servant as? Ice.Object ?? AdminDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            (servant as? Ice.Object ?? AdminDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            (servant as? Ice.Object ?? AdminDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            (servant as? Ice.Object ?? AdminDisp.defaultObject)._iceD_ice_ping(request)
        case "instantiateServer":
            servant._iceD_instantiateServer(request)
        case "isServerEnabled":
            servant._iceD_isServerEnabled(request)
        case "pingNode":
            servant._iceD_pingNode(request)
        case "pingRegistry":
            servant._iceD_pingRegistry(request)
        case "removeAdapter":
            servant._iceD_removeAdapter(request)
        case "removeApplication":
            servant._iceD_removeApplication(request)
        case "removeObject":
            servant._iceD_removeObject(request)
        case "sendSignal":
            servant._iceD_sendSignal(request)
        case "shutdown":
            servant._iceD_shutdown(request)
        case "shutdownNode":
            servant._iceD_shutdownNode(request)
        case "shutdownRegistry":
            servant._iceD_shutdownRegistry(request)
        case "startServer":
            servant._iceD_startServer(request)
        case "stopServer":
            servant._iceD_stopServer(request)
        case "syncApplication":
            servant._iceD_syncApplication(request)
        case "syncApplicationWithoutRestart":
            servant._iceD_syncApplicationWithoutRestart(request)
        case "updateApplication":
            servant._iceD_updateApplication(request)
        case "updateApplicationWithoutRestart":
            servant._iceD_updateApplicationWithoutRestart(request)
        case "updateObject":
            servant._iceD_updateObject(request)
        default:
            PromiseKit.Promise(error: Ice.OperationNotExistException())
        }
    }
}

/// The IceGrid administrative interface. Allowing access to this interface is a security risk!
/// Please see the IceGrid documentation for further information.
public protocol Admin {
    /// Add an application to IceGrid.
    ///
    /// - parameter descriptor: `ApplicationDescriptor` The application descriptor.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - AccessDeniedException - Raised if the session doesn't hold the exclusive lock or if another session is
    ///     holding the lock.
    ///
    ///   - DeploymentException - Raised if application deployment failed.
    func addApplication(descriptor: ApplicationDescriptor, current: Ice.Current) throws

    /// Synchronize a deployed application with the given application descriptor. This operation will replace the
    /// current descriptor with this new descriptor.
    ///
    /// - parameter descriptor: `ApplicationDescriptor` The application descriptor.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - AccessDeniedException - Raised if the session doesn't hold the exclusive lock or if another session is
    ///     holding the lock.
    ///
    ///   - ApplicationNotExistException - Raised if the application doesn't exist.
    ///
    ///   - DeploymentException - Raised if application deployment failed.
    func syncApplication(descriptor: ApplicationDescriptor, current: Ice.Current) throws

    /// Update a deployed application with the given update application descriptor.
    ///
    /// - parameter descriptor: `ApplicationUpdateDescriptor` The update descriptor.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - AccessDeniedException - Raised if the session doesn't hold the exclusive lock or if another session is
    ///     holding the lock.
    ///
    ///   - ApplicationNotExistException - Raised if the application doesn't exist.
    ///
    ///   - DeploymentException - Raised if application deployment failed.
    func updateApplication(descriptor: ApplicationUpdateDescriptor, current: Ice.Current) throws

    /// Synchronize a deployed application with the given application descriptor. This operation will replace the
    /// current descriptor with this new descriptor only if no server restarts are necessary for the update of the
    /// application. If some servers need to be restarted, the synchronization is rejected with a
    /// DeploymentException.
    ///
    /// - parameter descriptor: `ApplicationDescriptor` The application descriptor.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - AccessDeniedException - Raised if the session doesn't hold the exclusive lock or if another session is
    ///     holding the lock.
    ///
    ///   - ApplicationNotExistException - Raised if the application doesn't exist.
    ///
    ///   - DeploymentException - Raised if application deployment failed.
    func syncApplicationWithoutRestart(descriptor: ApplicationDescriptor, current: Ice.Current) throws

    /// Update a deployed application with the given update application descriptor only if no server restarts are
    /// necessary for the update of the application. If some servers need to be restarted, the synchronization is
    /// rejected with a DeploymentException.
    ///
    /// - parameter descriptor: `ApplicationUpdateDescriptor` The update descriptor.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - AccessDeniedException - Raised if the session doesn't hold the exclusive lock or if another session is
    ///     holding the lock.
    ///
    ///   - ApplicationNotExistException - Raised if the application doesn't exist.
    ///
    ///   - DeploymentException - Raised if application deployment failed.
    func updateApplicationWithoutRestart(descriptor: ApplicationUpdateDescriptor, current: Ice.Current) throws

    /// Remove an application from IceGrid.
    ///
    /// - parameter name: `Swift.String` The application name.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - AccessDeniedException - Raised if the session doesn't hold the exclusive lock or if another session is
    ///     holding the lock.
    ///
    ///   - ApplicationNotExistException - Raised if the application doesn't exist.
    ///
    ///   - DeploymentException - Raised if application deployment failed.
    func removeApplication(name: Swift.String, current: Ice.Current) throws

    /// Instantiate a server template from an application on the given node.
    ///
    /// - parameter application: `Swift.String` The application name.
    ///
    /// - parameter node: `Swift.String` The name of the node where the server will be deployed.
    ///
    /// - parameter desc: `ServerInstanceDescriptor` The descriptor of the server instance to deploy.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - AccessDeniedException - Raised if the session doesn't hold the exclusive lock or if another session is
    ///     holding the lock.
    ///
    ///   - ApplicationNotExistException - Raised if the application doesn't exist.
    ///
    ///   - DeploymentException - Raised if server instantiation failed.
    func instantiateServer(application: Swift.String, node: Swift.String, desc: ServerInstanceDescriptor, current: Ice.Current) throws

    /// Get an application descriptor.
    ///
    /// - parameter name: `Swift.String` The application name.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `ApplicationInfo` - The application descriptor.
    ///
    /// - throws:
    ///
    ///   - ApplicationNotExistException - Raised if the application doesn't exist.
    func getApplicationInfo(name: Swift.String, current: Ice.Current) throws -> ApplicationInfo

    /// Get the default application descriptor.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `ApplicationDescriptor` - The default application descriptor.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if the default application descriptor can't be accessed or is invalid.
    func getDefaultApplicationDescriptor(current: Ice.Current) throws -> ApplicationDescriptor

    /// Get all the IceGrid applications currently registered.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.StringSeq` - The application names.
    func getAllApplicationNames(current: Ice.Current) throws -> Ice.StringSeq

    /// Get the server information for the server with the given id.
    ///
    /// - parameter id: `Swift.String` The server id.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `ServerInfo` - The server information.
    ///
    /// - throws:
    ///
    ///   - ServerNotExistException - Raised if the server doesn't exist.
    func getServerInfo(id: Swift.String, current: Ice.Current) throws -> ServerInfo

    /// Get a server's state.
    ///
    /// - parameter id: `Swift.String` The server id.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `ServerState` - The server state.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if the server couldn't be deployed on the node.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    ///
    ///   - ServerNotExistException - Raised if the server doesn't exist.
    func getServerState(id: Swift.String, current: Ice.Current) throws -> ServerState

    /// Get a server's system process id. The process id is operating system dependent.
    ///
    /// - parameter id: `Swift.String` The server id.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Int32` - The server's process id.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if the server couldn't be deployed on the node.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    ///
    ///   - ServerNotExistException - Raised if the server doesn't exist.
    func getServerPid(id: Swift.String, current: Ice.Current) throws -> Swift.Int32

    /// Get the category for server admin objects. You can manufacture a server admin proxy from the admin proxy by
    /// changing its identity: use the server ID as name and the returned category as category.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String` - The category for server admin objects.
    func getServerAdminCategory(current: Ice.Current) throws -> Swift.String

    /// Get a proxy to the server's admin object.
    ///
    /// - parameter id: `Swift.String` The server id.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.ObjectPrx?` - A proxy to the server's admin object. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if the server couldn't be deployed on the node.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    ///
    ///   - ServerNotExistException - Raised if the server doesn't exist.
    func getServerAdmin(id: Swift.String, current: Ice.Current) throws -> Ice.ObjectPrx?

    /// Enable or disable a server. A disabled server can't be started on demand or administratively. The enable
    /// state of the server is not persistent: if the node is shut down and restarted, the server will be enabled by
    /// default.
    ///
    /// - parameter id: `Swift.String` The server id.
    ///
    /// - parameter enabled: `Swift.Bool` True to enable the server, false to disable it.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if the server couldn't be deployed on the node.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    ///
    ///   - ServerNotExistException - Raised if the server doesn't exist.
    func enableServer(id: Swift.String, enabled: Swift.Bool, current: Ice.Current) throws

    /// Check if the server is enabled or disabled.
    ///
    /// - parameter id: `Swift.String` The server id.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Bool` - True if the server is enabled.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if the server couldn't be deployed on the node.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    ///
    ///   - ServerNotExistException - Raised if the server doesn't exist.
    func isServerEnabled(id: Swift.String, current: Ice.Current) throws -> Swift.Bool

    /// Start a server and wait for its activation.
    ///
    /// - parameter id: `Swift.String` The server id.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func startServerAsync(id: Swift.String, current: Ice.Current) -> PromiseKit.Promise<Swift.Void>

    /// Stop a server.
    ///
    /// - parameter id: `Swift.String` The server id.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func stopServerAsync(id: Swift.String, current: Ice.Current) -> PromiseKit.Promise<Swift.Void>

    /// Send signal to a server.
    ///
    /// - parameter id: `Swift.String` The server id.
    ///
    /// - parameter signal: `Swift.String` The signal, for example SIGTERM or 15.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - BadSignalException - Raised if the signal is not recognized by the target server.
    ///
    ///   - DeploymentException - Raised if the server couldn't be deployed on the node.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    ///
    ///   - ServerNotExistException - Raised if the server doesn't exist.
    func sendSignal(id: Swift.String, signal: Swift.String, current: Ice.Current) throws

    /// Get all the server ids registered with IceGrid.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.StringSeq` - The server ids.
    func getAllServerIds(current: Ice.Current) throws -> Ice.StringSeq

    /// Get the adapter information for the replica group or adapter with the given id.
    ///
    /// - parameter id: `Swift.String` The adapter id.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `AdapterInfoSeq` - A sequence of adapter information structures. If the given id refers to an adapter, this sequence
    /// will contain only one element. If the given id refers to a replica group, the sequence will contain the
    /// adapter information of each member of the replica group.
    ///
    /// - throws:
    ///
    ///   - AdapterNotExistException - Raised if the adapter or replica group doesn't exist.
    func getAdapterInfo(id: Swift.String, current: Ice.Current) throws -> AdapterInfoSeq

    /// Remove the adapter with the given id.
    ///
    /// - parameter id: `Swift.String` The adapter id.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - AdapterNotExistException - Raised if the adapter doesn't exist.
    ///
    ///   - DeploymentException - Raised if application deployment failed.
    func removeAdapter(id: Swift.String, current: Ice.Current) throws

    /// Get all the adapter ids registered with IceGrid.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.StringSeq` - The adapter ids.
    func getAllAdapterIds(current: Ice.Current) throws -> Ice.StringSeq

    /// Add an object to the object registry. IceGrid will get the object type by calling ice_id on the
    /// given proxy. The object must be reachable.
    ///
    /// - parameter obj: `Ice.ObjectPrx?` The object to be added to the registry.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if the object can't be added. This might be raised if the invocation on
    ///     the proxy to get the object type failed.
    ///
    ///   - ObjectExistsException - Raised if the object is already registered.
    func addObject(obj: Ice.ObjectPrx?, current: Ice.Current) throws

    /// Update an object in the object registry. Only objects added with this interface can be updated with this
    /// operation. Objects added with deployment descriptors should be updated with the deployment mechanism.
    ///
    /// - parameter obj: `Ice.ObjectPrx?` The object to be updated to the registry.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if the object can't be updated. This might happen if the object was added
    ///     with a deployment descriptor.
    ///
    ///   - ObjectNotRegisteredException - Raised if the object isn't registered with the registry.
    func updateObject(obj: Ice.ObjectPrx?, current: Ice.Current) throws

    /// Add an object to the object registry and explicitly specify its type.
    ///
    /// - parameter obj: `Ice.ObjectPrx?` The object to be added to the registry. The proxy is never null.
    ///
    /// - parameter type: `Swift.String` The object type.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if application deployment failed.
    ///
    ///   - ObjectExistsException - Raised if the object is already registered.
    func addObjectWithType(obj: Ice.ObjectPrx?, type: Swift.String, current: Ice.Current) throws

    /// Remove an object from the object registry. Only objects added with this interface can be removed with this
    /// operation. Objects added with deployment descriptors should be removed with the deployment mechanism.
    ///
    /// - parameter id: `Ice.Identity` The identity of the object to be removed from the registry.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if the object can't be removed. This might happen if the object was added
    ///     with a deployment descriptor.
    ///
    ///   - ObjectNotRegisteredException - Raised if the object isn't registered with the registry.
    func removeObject(id: Ice.Identity, current: Ice.Current) throws

    /// Get the object info for the object with the given identity.
    ///
    /// - parameter id: `Ice.Identity` The identity of the object.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `ObjectInfo` - The object info.
    ///
    /// - throws:
    ///
    ///   - ObjectNotRegisteredException - Raised if the object isn't registered with the registry.
    func getObjectInfo(id: Ice.Identity, current: Ice.Current) throws -> ObjectInfo

    /// Get the object info of all the registered objects with the given type.
    ///
    /// - parameter type: `Swift.String` The type of the object.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `ObjectInfoSeq` - The object infos.
    func getObjectInfosByType(type: Swift.String, current: Ice.Current) throws -> ObjectInfoSeq

    /// Get the object info of all the registered objects whose stringified identities match the given expression.
    ///
    /// - parameter expr: `Swift.String` The expression to match against the stringified identities of registered objects. The expression
    /// may contain a trailing wildcard (*) character.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `ObjectInfoSeq` - All the object infos with a stringified identity matching the given expression.
    func getAllObjectInfos(expr: Swift.String, current: Ice.Current) throws -> ObjectInfoSeq

    /// Ping an IceGrid node to see if it is active.
    ///
    /// - parameter name: `Swift.String` The node name.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Bool` - true if the node ping succeeded, false otherwise.
    ///
    /// - throws:
    ///
    ///   - NodeNotExistException - Raised if the node doesn't exist.
    func pingNode(name: Swift.String, current: Ice.Current) throws -> Swift.Bool

    /// Get the load averages of the node.
    ///
    /// - parameter name: `Swift.String` The node name.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `LoadInfo` - The node load information.
    ///
    /// - throws:
    ///
    ///   - NodeNotExistException - Raised if the node doesn't exist.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    func getNodeLoad(name: Swift.String, current: Ice.Current) throws -> LoadInfo

    /// Get the node information for the node with the given name.
    ///
    /// - parameter name: `Swift.String` The node name.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `NodeInfo` - The node information.
    ///
    /// - throws:
    ///
    ///   - NodeNotExistException - Raised if the node doesn't exist.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    func getNodeInfo(name: Swift.String, current: Ice.Current) throws -> NodeInfo

    /// Get a proxy to the IceGrid node's admin object.
    ///
    /// - parameter name: `Swift.String` The IceGrid node name
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.ObjectPrx?` - A proxy to the IceGrid node's admin object. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - NodeNotExistException - Raised if the node doesn't exist.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    func getNodeAdmin(name: Swift.String, current: Ice.Current) throws -> Ice.ObjectPrx?

    /// Get the number of physical processor sockets for the machine running the node with the given name.
    /// Note that this method will return 1 on operating systems where this can't be automatically determined and
    /// where the IceGrid.Node.ProcessorSocketCount property for the node is not set.
    ///
    /// - parameter name: `Swift.String` The node name.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Int32` - The number of processor sockets or 1 if the number of sockets can't determined.
    ///
    /// - throws:
    ///
    ///   - NodeNotExistException - Raised if the node doesn't exist.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    func getNodeProcessorSocketCount(name: Swift.String, current: Ice.Current) throws -> Swift.Int32

    /// Shutdown an IceGrid node.
    ///
    /// - parameter name: `Swift.String` The node name.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - NodeNotExistException - Raised if the node doesn't exist.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    func shutdownNode(name: Swift.String, current: Ice.Current) throws

    /// Get the hostname of this node.
    ///
    /// - parameter name: `Swift.String` The node name.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String` - The node hostname.
    ///
    /// - throws:
    ///
    ///   - NodeNotExistException - Raised if the node doesn't exist.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    func getNodeHostname(name: Swift.String, current: Ice.Current) throws -> Swift.String

    /// Get all the IceGrid nodes currently registered.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.StringSeq` - The node names.
    func getAllNodeNames(current: Ice.Current) throws -> Ice.StringSeq

    /// Ping an IceGrid registry to see if it is active.
    ///
    /// - parameter name: `Swift.String` The registry name.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Bool` - true if the registry ping succeeded, false otherwise.
    ///
    /// - throws:
    ///
    ///   - RegistryNotExistException - Raised if the registry doesn't exist.
    func pingRegistry(name: Swift.String, current: Ice.Current) throws -> Swift.Bool

    /// Get the registry information for the registry with the given name.
    ///
    /// - parameter name: `Swift.String` The registry name.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `RegistryInfo` - The registry information.
    ///
    /// - throws:
    ///
    ///   - RegistryNotExistException - Raised if the registry doesn't exist.
    ///
    ///   - RegistryUnreachableException - Raised if the registry could not be reached.
    func getRegistryInfo(name: Swift.String, current: Ice.Current) throws -> RegistryInfo

    /// Get a proxy to the IceGrid registry's admin object.
    ///
    /// - parameter name: `Swift.String` The registry name
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.ObjectPrx?` - A proxy to the IceGrid registry's admin object. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - RegistryNotExistException - Raised if the registry doesn't exist.
    func getRegistryAdmin(name: Swift.String, current: Ice.Current) throws -> Ice.ObjectPrx?

    /// Shutdown an IceGrid registry.
    ///
    /// - parameter name: `Swift.String` The registry name.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - RegistryNotExistException - Raised if the registry doesn't exist.
    ///
    ///   - RegistryUnreachableException - Raised if the registry could not be reached.
    func shutdownRegistry(name: Swift.String, current: Ice.Current) throws

    /// Get all the IceGrid registries currently registered.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.StringSeq` - The registry names.
    func getAllRegistryNames(current: Ice.Current) throws -> Ice.StringSeq

    /// Shut down the IceGrid registry.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func shutdown(current: Ice.Current) throws
}


/// Dispatcher for `FileIterator` servants.
public struct FileIteratorDisp: Ice.Dispatcher {
    public let servant: FileIterator
    private static let defaultObject = Ice.ObjectI<FileIteratorTraits>()

    public init(_ servant: FileIterator) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        switch request.current.operation {
        case "destroy":
            servant._iceD_destroy(request)
        case "ice_id":
            (servant as? Ice.Object ?? FileIteratorDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            (servant as? Ice.Object ?? FileIteratorDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            (servant as? Ice.Object ?? FileIteratorDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            (servant as? Ice.Object ?? FileIteratorDisp.defaultObject)._iceD_ice_ping(request)
        case "read":
            servant._iceD_read(request)
        default:
            PromiseKit.Promise(error: Ice.OperationNotExistException())
        }
    }
}

/// This interface provides access to IceGrid log file contents.
public protocol FileIterator {
    /// Read lines from the log file.
    ///
    /// - parameter size: `Swift.Int32` Specifies the maximum number of bytes to be received. The server will ensure that the returned
    /// message doesn't exceed the given size.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: Swift.Bool, lines: Ice.StringSeq)`:
    ///
    ///   - returnValue: `Swift.Bool` - True if EOF is encountered.
    ///
    ///   - lines: `Ice.StringSeq` - The lines read from the file. If there was nothing to read from the file since the last call to
    /// read, an empty sequence is returned. The last line of the sequence is always incomplete (and therefore no
    /// '\n' should be added when writing the last line to the to the output device).
    ///
    /// - throws:
    ///
    ///   - FileNotAvailableException - Raised if there was a problem to read lines from the file.
    func read(size: Swift.Int32, current: Ice.Current) throws -> (returnValue: Swift.Bool, lines: Ice.StringSeq)

    /// Destroy the iterator.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func destroy(current: Ice.Current) throws
}


/// Dispatcher for `RegistryObserver` servants.
public struct RegistryObserverDisp: Ice.Dispatcher {
    public let servant: RegistryObserver
    private static let defaultObject = Ice.ObjectI<RegistryObserverTraits>()

    public init(_ servant: RegistryObserver) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        switch request.current.operation {
        case "ice_id":
            (servant as? Ice.Object ?? RegistryObserverDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            (servant as? Ice.Object ?? RegistryObserverDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            (servant as? Ice.Object ?? RegistryObserverDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            (servant as? Ice.Object ?? RegistryObserverDisp.defaultObject)._iceD_ice_ping(request)
        case "registryDown":
            servant._iceD_registryDown(request)
        case "registryInit":
            servant._iceD_registryInit(request)
        case "registryUp":
            servant._iceD_registryUp(request)
        default:
            PromiseKit.Promise(error: Ice.OperationNotExistException())
        }
    }
}

/// This interface allows applications to monitor changes the state of the registry.
public protocol RegistryObserver {
    /// The registryInit operation is called after registration of an observer to indicate the state of
    /// the registries.
    ///
    /// - parameter registries: `RegistryInfoSeq` The current state of the registries.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func registryInit(registries: RegistryInfoSeq, current: Ice.Current) throws

    /// The registryUp operation is called to notify an observer that a registry replica came up.
    ///
    /// - parameter registryReplica: `RegistryInfo` The registry state.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func registryUp(registryReplica: RegistryInfo, current: Ice.Current) throws

    /// The registryDown operation is called to notify an observer that a registry replica went down.
    ///
    /// - parameter name: `Swift.String` The registry name.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func registryDown(name: Swift.String, current: Ice.Current) throws
}


/// Dispatcher for `NodeObserver` servants.
public struct NodeObserverDisp: Ice.Dispatcher {
    public let servant: NodeObserver
    private static let defaultObject = Ice.ObjectI<NodeObserverTraits>()

    public init(_ servant: NodeObserver) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        switch request.current.operation {
        case "ice_id":
            (servant as? Ice.Object ?? NodeObserverDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            (servant as? Ice.Object ?? NodeObserverDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            (servant as? Ice.Object ?? NodeObserverDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            (servant as? Ice.Object ?? NodeObserverDisp.defaultObject)._iceD_ice_ping(request)
        case "nodeDown":
            servant._iceD_nodeDown(request)
        case "nodeInit":
            servant._iceD_nodeInit(request)
        case "nodeUp":
            servant._iceD_nodeUp(request)
        case "updateAdapter":
            servant._iceD_updateAdapter(request)
        case "updateServer":
            servant._iceD_updateServer(request)
        default:
            PromiseKit.Promise(error: Ice.OperationNotExistException())
        }
    }
}

/// The node observer interface. Observers should implement this interface to receive information about the state of
/// the IceGrid nodes.
public protocol NodeObserver {
    /// The nodeInit operation indicates the current state of nodes. It is called after the
    /// registration of an observer.
    ///
    /// - parameter nodes: `NodeDynamicInfoSeq` The current state of the nodes.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func nodeInit(nodes: NodeDynamicInfoSeq, current: Ice.Current) throws

    /// The nodeUp operation is called to notify an observer that a node came up.
    ///
    /// - parameter node: `NodeDynamicInfo` The node state.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func nodeUp(node: NodeDynamicInfo, current: Ice.Current) throws

    /// The nodeDown operation is called to notify an observer that a node went down.
    ///
    /// - parameter name: `Swift.String` The node name.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func nodeDown(name: Swift.String, current: Ice.Current) throws

    /// The updateServer operation is called to notify an observer that the state of a server changed.
    ///
    /// - parameter node: `Swift.String` The node hosting the server.
    ///
    /// - parameter updatedInfo: `ServerDynamicInfo` The new server state.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func updateServer(node: Swift.String, updatedInfo: ServerDynamicInfo, current: Ice.Current) throws

    /// The updateAdapter operation is called to notify an observer that the state of an adapter
    /// changed.
    ///
    /// - parameter node: `Swift.String` The node hosting the adapter.
    ///
    /// - parameter updatedInfo: `AdapterDynamicInfo` The new adapter state.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func updateAdapter(node: Swift.String, updatedInfo: AdapterDynamicInfo, current: Ice.Current) throws
}


/// Dispatcher for `ApplicationObserver` servants.
public struct ApplicationObserverDisp: Ice.Dispatcher {
    public let servant: ApplicationObserver
    private static let defaultObject = Ice.ObjectI<ApplicationObserverTraits>()

    public init(_ servant: ApplicationObserver) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        switch request.current.operation {
        case "applicationAdded":
            servant._iceD_applicationAdded(request)
        case "applicationInit":
            servant._iceD_applicationInit(request)
        case "applicationRemoved":
            servant._iceD_applicationRemoved(request)
        case "applicationUpdated":
            servant._iceD_applicationUpdated(request)
        case "ice_id":
            (servant as? Ice.Object ?? ApplicationObserverDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            (servant as? Ice.Object ?? ApplicationObserverDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            (servant as? Ice.Object ?? ApplicationObserverDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            (servant as? Ice.Object ?? ApplicationObserverDisp.defaultObject)._iceD_ice_ping(request)
        default:
            PromiseKit.Promise(error: Ice.OperationNotExistException())
        }
    }
}

/// The database observer interface. Observers should implement this interface to receive information about the
/// state of the IceGrid registry database.
public protocol ApplicationObserver {
    /// applicationInit is called after the registration of an observer to indicate the state of the
    /// registry.
    ///
    /// - parameter serial: `Swift.Int32` The current serial number of the registry database. This serial number allows observers to
    /// make sure that their internal state is synchronized with the registry.
    ///
    /// - parameter applications: `ApplicationInfoSeq` The applications currently registered with the registry.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func applicationInit(serial: Swift.Int32, applications: ApplicationInfoSeq, current: Ice.Current) throws

    /// The applicationAdded operation is called to notify an observer that an application was added.
    ///
    /// - parameter serial: `Swift.Int32` The new serial number of the registry database.
    ///
    /// - parameter desc: `ApplicationInfo` The descriptor of the new application.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func applicationAdded(serial: Swift.Int32, desc: ApplicationInfo, current: Ice.Current) throws

    /// The applicationRemoved operation is called to notify an observer that an application was
    /// removed.
    ///
    /// - parameter serial: `Swift.Int32` The new serial number of the registry database.
    ///
    /// - parameter name: `Swift.String` The name of the application that was removed.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func applicationRemoved(serial: Swift.Int32, name: Swift.String, current: Ice.Current) throws

    /// The applicationUpdated operation is called to notify an observer that an application was
    /// updated.
    ///
    /// - parameter serial: `Swift.Int32` The new serial number of the registry database.
    ///
    /// - parameter desc: `ApplicationUpdateInfo` The descriptor of the update.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func applicationUpdated(serial: Swift.Int32, desc: ApplicationUpdateInfo, current: Ice.Current) throws
}


/// Dispatcher for `AdapterObserver` servants.
public struct AdapterObserverDisp: Ice.Dispatcher {
    public let servant: AdapterObserver
    private static let defaultObject = Ice.ObjectI<AdapterObserverTraits>()

    public init(_ servant: AdapterObserver) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        switch request.current.operation {
        case "adapterAdded":
            servant._iceD_adapterAdded(request)
        case "adapterInit":
            servant._iceD_adapterInit(request)
        case "adapterRemoved":
            servant._iceD_adapterRemoved(request)
        case "adapterUpdated":
            servant._iceD_adapterUpdated(request)
        case "ice_id":
            (servant as? Ice.Object ?? AdapterObserverDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            (servant as? Ice.Object ?? AdapterObserverDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            (servant as? Ice.Object ?? AdapterObserverDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            (servant as? Ice.Object ?? AdapterObserverDisp.defaultObject)._iceD_ice_ping(request)
        default:
            PromiseKit.Promise(error: Ice.OperationNotExistException())
        }
    }
}

/// This interface allows applications to monitor the state of object adapters that are registered with IceGrid.
public protocol AdapterObserver {
    /// adapterInit is called after registration of an observer to indicate the state of the registry.
    ///
    /// - parameter adpts: `AdapterInfoSeq` The adapters that were dynamically registered with the registry (not through the deployment
    /// mechanism).
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func adapterInit(adpts: AdapterInfoSeq, current: Ice.Current) throws

    /// The adapterAdded operation is called to notify an observer when a dynamically-registered
    /// adapter was added.
    ///
    /// - parameter info: `AdapterInfo` The details of the new adapter.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func adapterAdded(info: AdapterInfo, current: Ice.Current) throws

    /// The adapterUpdated operation is called to notify an observer when a dynamically-registered adapter was
    /// updated.
    ///
    /// - parameter info: `AdapterInfo` The details of the updated adapter.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func adapterUpdated(info: AdapterInfo, current: Ice.Current) throws

    /// The adapterRemoved operation is called to notify an observer when a dynamically-registered adapter was
    /// removed.
    ///
    /// - parameter id: `Swift.String` The ID of the removed adapter.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func adapterRemoved(id: Swift.String, current: Ice.Current) throws
}


/// Dispatcher for `ObjectObserver` servants.
public struct ObjectObserverDisp: Ice.Dispatcher {
    public let servant: ObjectObserver
    private static let defaultObject = Ice.ObjectI<ObjectObserverTraits>()

    public init(_ servant: ObjectObserver) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        switch request.current.operation {
        case "ice_id":
            (servant as? Ice.Object ?? ObjectObserverDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            (servant as? Ice.Object ?? ObjectObserverDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            (servant as? Ice.Object ?? ObjectObserverDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            (servant as? Ice.Object ?? ObjectObserverDisp.defaultObject)._iceD_ice_ping(request)
        case "objectAdded":
            servant._iceD_objectAdded(request)
        case "objectInit":
            servant._iceD_objectInit(request)
        case "objectRemoved":
            servant._iceD_objectRemoved(request)
        case "objectUpdated":
            servant._iceD_objectUpdated(request)
        default:
            PromiseKit.Promise(error: Ice.OperationNotExistException())
        }
    }
}

/// This interface allows applications to monitor IceGrid well-known objects.
public protocol ObjectObserver {
    /// objectInit is called after the registration of an observer to indicate the state of the
    /// registry.
    ///
    /// - parameter objects: `ObjectInfoSeq` The objects registered with the Admin interface (not through the deployment
    /// mechanism).
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func objectInit(objects: ObjectInfoSeq, current: Ice.Current) throws

    /// The objectAdded operation is called to notify an observer when an object was added to the
    /// Admin interface.
    ///
    /// - parameter info: `ObjectInfo` The details of the added object.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func objectAdded(info: ObjectInfo, current: Ice.Current) throws

    /// objectUpdated is called to notify an observer when an object registered with the Admin
    /// interface was updated.
    ///
    /// - parameter info: `ObjectInfo` The details of the updated object.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func objectUpdated(info: ObjectInfo, current: Ice.Current) throws

    /// objectRemoved is called to notify an observer when an object registered with the Admin
    /// interface was removed.
    ///
    /// - parameter id: `Ice.Identity` The identity of the removed object.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func objectRemoved(id: Ice.Identity, current: Ice.Current) throws
}


/// Dispatcher for `AdminSession` servants.
public struct AdminSessionDisp: Ice.Dispatcher {
    public let servant: AdminSession
    private static let defaultObject = Ice.ObjectI<AdminSessionTraits>()

    public init(_ servant: AdminSession) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        switch request.current.operation {
        case "destroy":
            servant._iceD_destroy(request)
        case "finishUpdate":
            servant._iceD_finishUpdate(request)
        case "getAdmin":
            servant._iceD_getAdmin(request)
        case "getAdminCallbackTemplate":
            servant._iceD_getAdminCallbackTemplate(request)
        case "getReplicaName":
            servant._iceD_getReplicaName(request)
        case "ice_id":
            (servant as? Ice.Object ?? AdminSessionDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            (servant as? Ice.Object ?? AdminSessionDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            (servant as? Ice.Object ?? AdminSessionDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            (servant as? Ice.Object ?? AdminSessionDisp.defaultObject)._iceD_ice_ping(request)
        case "keepAlive":
            servant._iceD_keepAlive(request)
        case "openNodeStdErr":
            servant._iceD_openNodeStdErr(request)
        case "openNodeStdOut":
            servant._iceD_openNodeStdOut(request)
        case "openRegistryStdErr":
            servant._iceD_openRegistryStdErr(request)
        case "openRegistryStdOut":
            servant._iceD_openRegistryStdOut(request)
        case "openServerLog":
            servant._iceD_openServerLog(request)
        case "openServerStdErr":
            servant._iceD_openServerStdErr(request)
        case "openServerStdOut":
            servant._iceD_openServerStdOut(request)
        case "setObservers":
            servant._iceD_setObservers(request)
        case "setObserversByIdentity":
            servant._iceD_setObserversByIdentity(request)
        case "startUpdate":
            servant._iceD_startUpdate(request)
        default:
            PromiseKit.Promise(error: Ice.OperationNotExistException())
        }
    }
}

/// Used by administrative clients to view, update, and receive observer updates from the IceGrid registry. Admin
/// sessions are created either via the Registry object or via the registry admin
/// SessionManager object.
public protocol AdminSession: Glacier2.Session {
    /// Keep the session alive. This operation is provided for backwards compatibility. As of Ice 3.8, there is no
    /// need to call this operation and its implementation does nothing.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func keepAlive(current: Ice.Current) throws

    /// Get the admin interface. The admin object returned by this operation can only be accessed by the session.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `AdminPrx?` - The admin interface proxy. The returned proxy is never null.
    func getAdmin(current: Ice.Current) throws -> AdminPrx?

    /// Get a "template" proxy for admin callback objects. An Admin client uses this proxy to set the category of
    /// its callback objects, and the published endpoints of the object adapter hosting the admin callback objects.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.ObjectPrx?` - A template proxy. The returned proxy is null when the Admin session was established using Glacier2.
    func getAdminCallbackTemplate(current: Ice.Current) throws -> Ice.ObjectPrx?

    /// Set the observer proxies that receive notifications when the state of the registry or nodes changes.
    ///
    /// - parameter registryObs: `RegistryObserverPrx?` The registry observer.
    ///
    /// - parameter nodeObs: `NodeObserverPrx?` The node observer.
    ///
    /// - parameter appObs: `ApplicationObserverPrx?` The application observer.
    ///
    /// - parameter adptObs: `AdapterObserverPrx?` The adapter observer.
    ///
    /// - parameter objObs: `ObjectObserverPrx?` The object observer.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - ObserverAlreadyRegisteredException - Raised if an observer is already registered with this registry.
    func setObservers(registryObs: RegistryObserverPrx?, nodeObs: NodeObserverPrx?, appObs: ApplicationObserverPrx?, adptObs: AdapterObserverPrx?, objObs: ObjectObserverPrx?, current: Ice.Current) throws

    /// Set the observer identities that receive notifications the state of the registry or nodes changes. This
    /// operation should be used by clients that are using a bidirectional connection to communicate with the
    /// session.
    ///
    /// - parameter registryObs: `Ice.Identity` The registry observer identity.
    ///
    /// - parameter nodeObs: `Ice.Identity` The node observer identity.
    ///
    /// - parameter appObs: `Ice.Identity` The application observer.
    ///
    /// - parameter adptObs: `Ice.Identity` The adapter observer.
    ///
    /// - parameter objObs: `Ice.Identity` The object observer.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - ObserverAlreadyRegisteredException - Raised if an observer is already registered with this registry.
    func setObserversByIdentity(registryObs: Ice.Identity, nodeObs: Ice.Identity, appObs: Ice.Identity, adptObs: Ice.Identity, objObs: Ice.Identity, current: Ice.Current) throws

    /// Acquires an exclusive lock to start updating the registry applications.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Int32` - The current serial.
    ///
    /// - throws:
    ///
    ///   - AccessDeniedException - Raised if the exclusive lock can't be acquired. This might happen if the lock
    ///     is currently acquired by another session.
    func startUpdate(current: Ice.Current) throws -> Swift.Int32

    /// Finish updating the registry and release the exclusive lock.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - AccessDeniedException - Raised if the session doesn't hold the exclusive lock.
    func finishUpdate(current: Ice.Current) throws

    /// Get the name of the registry replica hosting this session.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String` - The replica name of the registry.
    func getReplicaName(current: Ice.Current) throws -> Swift.String

    /// Open the given server log file for reading. The file can be read with the returned file iterator.
    ///
    /// - parameter id: `Swift.String` The server id.
    ///
    /// - parameter path: `Swift.String` The path of the log file. A log file can be opened only if it's declared in the server or
    /// service deployment descriptor.
    ///
    /// - parameter count: `Swift.Int32` Specifies where to start reading the file. If negative, the file is read from the begining. If
    /// 0 or positive, the file is read from the last count lines.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `FileIteratorPrx?` - An iterator to read the file. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if the server couldn't be deployed on the node.
    ///
    ///   - FileNotAvailableException - Raised if the file can't be read.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    ///
    ///   - ServerNotExistException - Raised if the server doesn't exist.
    func openServerLog(id: Swift.String, path: Swift.String, count: Swift.Int32, current: Ice.Current) throws -> FileIteratorPrx?

    /// Open the given server stderr file for reading. The file can be read with the returned file iterator.
    ///
    /// - parameter id: `Swift.String` The server id.
    ///
    /// - parameter count: `Swift.Int32` Specifies where to start reading the file. If negative, the file is read from the begining. If
    /// 0 or positive, the file is read from the last count lines.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `FileIteratorPrx?` - An iterator to read the file. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if the server couldn't be deployed on the node.
    ///
    ///   - FileNotAvailableException - Raised if the file can't be read.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    ///
    ///   - ServerNotExistException - Raised if the server doesn't exist.
    func openServerStdErr(id: Swift.String, count: Swift.Int32, current: Ice.Current) throws -> FileIteratorPrx?

    /// Open the given server stdout file for reading. The file can be read with the returned file iterator.
    ///
    /// - parameter id: `Swift.String` The server id.
    ///
    /// - parameter count: `Swift.Int32` Specifies where to start reading the file. If negative, the file is read from the begining.
    /// If 0 or positive, the file is read from the last count lines.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `FileIteratorPrx?` - An iterator to read the file. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if the server couldn't be deployed on the node.
    ///
    ///   - FileNotAvailableException - Raised if the file can't be read.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    ///
    ///   - ServerNotExistException - Raised if the server doesn't exist.
    func openServerStdOut(id: Swift.String, count: Swift.Int32, current: Ice.Current) throws -> FileIteratorPrx?

    /// Open the given node stderr file for reading. The file can be read with the returned file iterator.
    ///
    /// - parameter name: `Swift.String` The node name.
    ///
    /// - parameter count: `Swift.Int32` Specifies where to start reading the file. If negative, the file is read from the begining. If
    /// 0 or positive, the file is read from the last count lines.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `FileIteratorPrx?` - An iterator to read the file. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - FileNotAvailableException - Raised if the file can't be read.
    ///
    ///   - NodeNotExistException - Raised if the node doesn't exist.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    func openNodeStdErr(name: Swift.String, count: Swift.Int32, current: Ice.Current) throws -> FileIteratorPrx?

    /// Open the given node stdout file for reading. The file can be read with the returned file iterator.
    ///
    /// - parameter name: `Swift.String` The node name.
    ///
    /// - parameter count: `Swift.Int32` Specifies where to start reading the file. If negative, the file is read from the begining. If
    /// 0 or positive, the file is read from the last count lines.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `FileIteratorPrx?` - An iterator to read the file. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - FileNotAvailableException - Raised if the file can't be read.
    ///
    ///   - NodeNotExistException - Raised if the node doesn't exist.
    ///
    ///   - NodeUnreachableException - Raised if the node could not be reached.
    func openNodeStdOut(name: Swift.String, count: Swift.Int32, current: Ice.Current) throws -> FileIteratorPrx?

    /// Open the given registry stderr file for reading. The file can be read with the returned file iterator.
    ///
    /// - parameter name: `Swift.String` The registry name.
    ///
    /// - parameter count: `Swift.Int32` Specifies where to start reading the file. If negative, the file is read from the begining. If
    /// 0 or positive, the file is read from the last count lines.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `FileIteratorPrx?` - An iterator to read the file. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - FileNotAvailableException - Raised if the file can't be read.
    ///
    ///   - RegistryNotExistException - Raised if the registry doesn't exist.
    ///
    ///   - RegistryUnreachableException - Raised if the registry could not be reached.
    func openRegistryStdErr(name: Swift.String, count: Swift.Int32, current: Ice.Current) throws -> FileIteratorPrx?

    /// Open the given registry stdout file for reading. The file can be read with the returned file iterator.
    ///
    /// - parameter name: `Swift.String` The registry name.
    ///
    /// - parameter count: `Swift.Int32` Specifies where to start reading the file. If negative, the file is read from the begining. If
    /// 0 or positive, the file is read from the last count lines.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `FileIteratorPrx?` - An iterator to read the file. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - FileNotAvailableException - Raised if the file can't be read.
    ///
    ///   - RegistryNotExistException - Raised if the registry doesn't exist.
    ///
    ///   - RegistryUnreachableException - Raised if the registry could not be reached.
    func openRegistryStdOut(name: Swift.String, count: Swift.Int32, current: Ice.Current) throws -> FileIteratorPrx?
}

/// The IceGrid administrative interface. Allowing access to this interface is a security risk!
/// Please see the IceGrid documentation for further information.
///
/// Admin Methods:
///
///  - addApplication: Add an application to IceGrid.
///
///  - syncApplication: Synchronize a deployed application with the given application descriptor.
///
///  - updateApplication: Update a deployed application with the given update application descriptor.
///
///  - syncApplicationWithoutRestart: Synchronize a deployed application with the given application descriptor.
///
///  - updateApplicationWithoutRestart: Update a deployed application with the given update application descriptor only if no server restarts are necessary for the update of the application.
///
///  - removeApplication: Remove an application from IceGrid.
///
///  - instantiateServer: Instantiate a server template from an application on the given node.
///
///  - getApplicationInfo: Get an application descriptor.
///
///  - getDefaultApplicationDescriptor: Get the default application descriptor.
///
///  - getAllApplicationNames: Get all the IceGrid applications currently registered.
///
///  - getServerInfo: Get the server information for the server with the given id.
///
///  - getServerState: Get a server's state.
///
///  - getServerPid: Get a server's system process id.
///
///  - getServerAdminCategory: Get the category for server admin objects.
///
///  - getServerAdmin: Get a proxy to the server's admin object.
///
///  - enableServer: Enable or disable a server.
///
///  - isServerEnabled: Check if the server is enabled or disabled.
///
///  - startServer: Start a server and wait for its activation.
///
///  - stopServer: Stop a server.
///
///  - sendSignal: Send signal to a server.
///
///  - getAllServerIds: Get all the server ids registered with IceGrid.
///
///  - getAdapterInfo: Get the adapter information for the replica group or adapter with the given id.
///
///  - removeAdapter: Remove the adapter with the given id.
///
///  - getAllAdapterIds: Get all the adapter ids registered with IceGrid.
///
///  - addObject: Add an object to the object registry.
///
///  - updateObject: Update an object in the object registry.
///
///  - addObjectWithType: Add an object to the object registry and explicitly specify its type.
///
///  - removeObject: Remove an object from the object registry.
///
///  - getObjectInfo: Get the object info for the object with the given identity.
///
///  - getObjectInfosByType: Get the object info of all the registered objects with the given type.
///
///  - getAllObjectInfos: Get the object info of all the registered objects whose stringified identities match the given expression.
///
///  - pingNode: Ping an IceGrid node to see if it is active.
///
///  - getNodeLoad: Get the load averages of the node.
///
///  - getNodeInfo: Get the node information for the node with the given name.
///
///  - getNodeAdmin: Get a proxy to the IceGrid node's admin object.
///
///  - getNodeProcessorSocketCount: Get the number of physical processor sockets for the machine running the node with the given name.
///
///  - shutdownNode: Shutdown an IceGrid node.
///
///  - getNodeHostname: Get the hostname of this node.
///
///  - getAllNodeNames: Get all the IceGrid nodes currently registered.
///
///  - pingRegistry: Ping an IceGrid registry to see if it is active.
///
///  - getRegistryInfo: Get the registry information for the registry with the given name.
///
///  - getRegistryAdmin: Get a proxy to the IceGrid registry's admin object.
///
///  - shutdownRegistry: Shutdown an IceGrid registry.
///
///  - getAllRegistryNames: Get all the IceGrid registries currently registered.
///
///  - shutdown: Shut down the IceGrid registry.
extension Admin {
    public func _iceD_addApplication(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_descriptor: ApplicationDescriptor = try istr.read()
            try istr.readPendingValues()

            try self.addApplication(descriptor: iceP_descriptor, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_syncApplication(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_descriptor: ApplicationDescriptor = try istr.read()
            try istr.readPendingValues()

            try self.syncApplication(descriptor: iceP_descriptor, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_updateApplication(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_descriptor: ApplicationUpdateDescriptor = try istr.read()
            try istr.readPendingValues()

            try self.updateApplication(descriptor: iceP_descriptor, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_syncApplicationWithoutRestart(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_descriptor: ApplicationDescriptor = try istr.read()
            try istr.readPendingValues()

            try self.syncApplicationWithoutRestart(descriptor: iceP_descriptor, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_updateApplicationWithoutRestart(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_descriptor: ApplicationUpdateDescriptor = try istr.read()
            try istr.readPendingValues()

            try self.updateApplicationWithoutRestart(descriptor: iceP_descriptor, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_removeApplication(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_name: Swift.String = try istr.read()

            try self.removeApplication(name: iceP_name, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_instantiateServer(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_application: Swift.String = try istr.read()
            let iceP_node: Swift.String = try istr.read()
            let iceP_desc: ServerInstanceDescriptor = try istr.read()

            try self.instantiateServer(application: iceP_application, node: iceP_node, desc: iceP_desc, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_getApplicationInfo(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_name: Swift.String = try istr.read()

            let iceP_returnValue = try self.getApplicationInfo(name: iceP_name, current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_getDefaultApplicationDescriptor(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            _ = try request.inputStream.skipEmptyEncapsulation()

            let iceP_returnValue = try self.getDefaultApplicationDescriptor(current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_getAllApplicationNames(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            _ = try request.inputStream.skipEmptyEncapsulation()

            let iceP_returnValue = try self.getAllApplicationNames(current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_getServerInfo(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_id: Swift.String = try istr.read()

            let iceP_returnValue = try self.getServerInfo(id: iceP_id, current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_getServerState(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_id: Swift.String = try istr.read()

            let iceP_returnValue = try self.getServerState(id: iceP_id, current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_getServerPid(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_id: Swift.String = try istr.read()

            let iceP_returnValue = try self.getServerPid(id: iceP_id, current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_getServerAdminCategory(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            _ = try request.inputStream.skipEmptyEncapsulation()

            let iceP_returnValue = try self.getServerAdminCategory(current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_getServerAdmin(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_id: Swift.String = try istr.read()

            let iceP_returnValue = try self.getServerAdmin(id: iceP_id, current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_enableServer(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_id: Swift.String = try istr.read()
            let iceP_enabled: Swift.Bool = try istr.read()

            try self.enableServer(id: iceP_id, enabled: iceP_enabled, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_isServerEnabled(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_id: Swift.String = try istr.read()

            let iceP_returnValue = try self.isServerEnabled(id: iceP_id, current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_startServer(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_id: Swift.String = try istr.read()
            return self.startServerAsync(
                id: iceP_id, current: request.current
            ).map(on: nil) {
                request.current.makeEmptyOutgoingResponse()
            }
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_stopServer(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_id: Swift.String = try istr.read()
            return self.stopServerAsync(
                id: iceP_id, current: request.current
            ).map(on: nil) {
                request.current.makeEmptyOutgoingResponse()
            }
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_sendSignal(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_id: Swift.String = try istr.read()
            let iceP_signal: Swift.String = try istr.read()

            try self.sendSignal(id: iceP_id, signal: iceP_signal, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_getAllServerIds(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            _ = try request.inputStream.skipEmptyEncapsulation()

            let iceP_returnValue = try self.getAllServerIds(current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_getAdapterInfo(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_id: Swift.String = try istr.read()

            let iceP_returnValue = try self.getAdapterInfo(id: iceP_id, current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            AdapterInfoSeqHelper.write(to: ostr, value: iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_removeAdapter(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_id: Swift.String = try istr.read()

            try self.removeAdapter(id: iceP_id, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_getAllAdapterIds(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            _ = try request.inputStream.skipEmptyEncapsulation()

            let iceP_returnValue = try self.getAllAdapterIds(current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_addObject(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_obj: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)

            try self.addObject(obj: iceP_obj, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_updateObject(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_obj: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)

            try self.updateObject(obj: iceP_obj, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_addObjectWithType(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_obj: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
            let iceP_type: Swift.String = try istr.read()

            try self.addObjectWithType(obj: iceP_obj, type: iceP_type, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_removeObject(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_id: Ice.Identity = try istr.read()

            try self.removeObject(id: iceP_id, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_getObjectInfo(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_id: Ice.Identity = try istr.read()

            let iceP_returnValue = try self.getObjectInfo(id: iceP_id, current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_getObjectInfosByType(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_type: Swift.String = try istr.read()

            let iceP_returnValue = try self.getObjectInfosByType(type: iceP_type, current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ObjectInfoSeqHelper.write(to: ostr, value: iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_getAllObjectInfos(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_expr: Swift.String = try istr.read()

            let iceP_returnValue = try self.getAllObjectInfos(expr: iceP_expr, current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ObjectInfoSeqHelper.write(to: ostr, value: iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_pingNode(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_name: Swift.String = try istr.read()

            let iceP_returnValue = try self.pingNode(name: iceP_name, current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_getNodeLoad(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_name: Swift.String = try istr.read()

            let iceP_returnValue = try self.getNodeLoad(name: iceP_name, current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_getNodeInfo(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_name: Swift.String = try istr.read()

            let iceP_returnValue = try self.getNodeInfo(name: iceP_name, current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_getNodeAdmin(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_name: Swift.String = try istr.read()

            let iceP_returnValue = try self.getNodeAdmin(name: iceP_name, current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_getNodeProcessorSocketCount(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_name: Swift.String = try istr.read()

            let iceP_returnValue = try self.getNodeProcessorSocketCount(name: iceP_name, current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_shutdownNode(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_name: Swift.String = try istr.read()

            try self.shutdownNode(name: iceP_name, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_getNodeHostname(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_name: Swift.String = try istr.read()

            let iceP_returnValue = try self.getNodeHostname(name: iceP_name, current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_getAllNodeNames(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            _ = try request.inputStream.skipEmptyEncapsulation()

            let iceP_returnValue = try self.getAllNodeNames(current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_pingRegistry(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_name: Swift.String = try istr.read()

            let iceP_returnValue = try self.pingRegistry(name: iceP_name, current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_getRegistryInfo(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_name: Swift.String = try istr.read()

            let iceP_returnValue = try self.getRegistryInfo(name: iceP_name, current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_getRegistryAdmin(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_name: Swift.String = try istr.read()

            let iceP_returnValue = try self.getRegistryAdmin(name: iceP_name, current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_shutdownRegistry(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_name: Swift.String = try istr.read()

            try self.shutdownRegistry(name: iceP_name, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_getAllRegistryNames(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            _ = try request.inputStream.skipEmptyEncapsulation()

            let iceP_returnValue = try self.getAllRegistryNames(current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_shutdown(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            _ = try request.inputStream.skipEmptyEncapsulation()

            try self.shutdown(current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }
}

/// This interface provides access to IceGrid log file contents.
///
/// FileIterator Methods:
///
///  - read: Read lines from the log file.
///
///  - destroy: Destroy the iterator.
extension FileIterator {
    public func _iceD_read(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_size: Swift.Int32 = try istr.read()

            let (iceP_returnValue, iceP_lines) = try self.read(size: iceP_size, current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_lines)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_destroy(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            _ = try request.inputStream.skipEmptyEncapsulation()

            try self.destroy(current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }
}

/// This interface allows applications to monitor changes the state of the registry.
///
/// RegistryObserver Methods:
///
///  - registryInit: The registryInit operation is called after registration of an observer to indicate the state of the registries.
///
///  - registryUp: The registryUp operation is called to notify an observer that a registry replica came up.
///
///  - registryDown: The registryDown operation is called to notify an observer that a registry replica went down.
extension RegistryObserver {
    public func _iceD_registryInit(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_registries: RegistryInfoSeq = try RegistryInfoSeqHelper.read(from: istr)

            try self.registryInit(registries: iceP_registries, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_registryUp(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_registryReplica: RegistryInfo = try istr.read()

            try self.registryUp(registryReplica: iceP_registryReplica, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_registryDown(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_name: Swift.String = try istr.read()

            try self.registryDown(name: iceP_name, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }
}

/// The node observer interface. Observers should implement this interface to receive information about the state of
/// the IceGrid nodes.
///
/// NodeObserver Methods:
///
///  - nodeInit: The nodeInit operation indicates the current state of nodes.
///
///  - nodeUp: The nodeUp operation is called to notify an observer that a node came up.
///
///  - nodeDown: The nodeDown operation is called to notify an observer that a node went down.
///
///  - updateServer: The updateServer operation is called to notify an observer that the state of a server changed.
///
///  - updateAdapter: The updateAdapter operation is called to notify an observer that the state of an adapter changed.
extension NodeObserver {
    public func _iceD_nodeInit(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_nodes: NodeDynamicInfoSeq = try NodeDynamicInfoSeqHelper.read(from: istr)

            try self.nodeInit(nodes: iceP_nodes, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_nodeUp(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_node: NodeDynamicInfo = try istr.read()

            try self.nodeUp(node: iceP_node, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_nodeDown(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_name: Swift.String = try istr.read()

            try self.nodeDown(name: iceP_name, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_updateServer(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_node: Swift.String = try istr.read()
            let iceP_updatedInfo: ServerDynamicInfo = try istr.read()

            try self.updateServer(node: iceP_node, updatedInfo: iceP_updatedInfo, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_updateAdapter(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_node: Swift.String = try istr.read()
            let iceP_updatedInfo: AdapterDynamicInfo = try istr.read()

            try self.updateAdapter(node: iceP_node, updatedInfo: iceP_updatedInfo, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }
}

/// The database observer interface. Observers should implement this interface to receive information about the
/// state of the IceGrid registry database.
///
/// ApplicationObserver Methods:
///
///  - applicationInit: applicationInit is called after the registration of an observer to indicate the state of the registry.
///
///  - applicationAdded: The applicationAdded operation is called to notify an observer that an application was added.
///
///  - applicationRemoved: The applicationRemoved operation is called to notify an observer that an application was removed.
///
///  - applicationUpdated: The applicationUpdated operation is called to notify an observer that an application was updated.
extension ApplicationObserver {
    public func _iceD_applicationInit(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_serial: Swift.Int32 = try istr.read()
            let iceP_applications: ApplicationInfoSeq = try ApplicationInfoSeqHelper.read(from: istr)
            try istr.readPendingValues()

            try self.applicationInit(serial: iceP_serial, applications: iceP_applications, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_applicationAdded(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_serial: Swift.Int32 = try istr.read()
            let iceP_desc: ApplicationInfo = try istr.read()
            try istr.readPendingValues()

            try self.applicationAdded(serial: iceP_serial, desc: iceP_desc, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_applicationRemoved(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_serial: Swift.Int32 = try istr.read()
            let iceP_name: Swift.String = try istr.read()

            try self.applicationRemoved(serial: iceP_serial, name: iceP_name, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_applicationUpdated(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_serial: Swift.Int32 = try istr.read()
            let iceP_desc: ApplicationUpdateInfo = try istr.read()
            try istr.readPendingValues()

            try self.applicationUpdated(serial: iceP_serial, desc: iceP_desc, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }
}

/// This interface allows applications to monitor the state of object adapters that are registered with IceGrid.
///
/// AdapterObserver Methods:
///
///  - adapterInit: adapterInit is called after registration of an observer to indicate the state of the registry.
///
///  - adapterAdded: The adapterAdded operation is called to notify an observer when a dynamically-registered adapter was added.
///
///  - adapterUpdated: The adapterUpdated operation is called to notify an observer when a dynamically-registered adapter was updated.
///
///  - adapterRemoved: The adapterRemoved operation is called to notify an observer when a dynamically-registered adapter was removed.
extension AdapterObserver {
    public func _iceD_adapterInit(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_adpts: AdapterInfoSeq = try AdapterInfoSeqHelper.read(from: istr)

            try self.adapterInit(adpts: iceP_adpts, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_adapterAdded(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_info: AdapterInfo = try istr.read()

            try self.adapterAdded(info: iceP_info, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_adapterUpdated(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_info: AdapterInfo = try istr.read()

            try self.adapterUpdated(info: iceP_info, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_adapterRemoved(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_id: Swift.String = try istr.read()

            try self.adapterRemoved(id: iceP_id, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }
}

/// This interface allows applications to monitor IceGrid well-known objects.
///
/// ObjectObserver Methods:
///
///  - objectInit: objectInit is called after the registration of an observer to indicate the state of the registry.
///
///  - objectAdded: The objectAdded operation is called to notify an observer when an object was added to the Admin interface.
///
///  - objectUpdated: objectUpdated is called to notify an observer when an object registered with the Admin interface was updated.
///
///  - objectRemoved: objectRemoved is called to notify an observer when an object registered with the Admin interface was removed.
extension ObjectObserver {
    public func _iceD_objectInit(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_objects: ObjectInfoSeq = try ObjectInfoSeqHelper.read(from: istr)

            try self.objectInit(objects: iceP_objects, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_objectAdded(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_info: ObjectInfo = try istr.read()

            try self.objectAdded(info: iceP_info, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_objectUpdated(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_info: ObjectInfo = try istr.read()

            try self.objectUpdated(info: iceP_info, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_objectRemoved(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_id: Ice.Identity = try istr.read()

            try self.objectRemoved(id: iceP_id, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }
}

/// Used by administrative clients to view, update, and receive observer updates from the IceGrid registry. Admin
/// sessions are created either via the Registry object or via the registry admin
/// SessionManager object.
///
/// AdminSession Methods:
///
///  - keepAlive: Keep the session alive.
///
///  - getAdmin: Get the admin interface.
///
///  - getAdminCallbackTemplate: Get a "template" proxy for admin callback objects.
///
///  - setObservers: Set the observer proxies that receive notifications when the state of the registry or nodes changes.
///
///  - setObserversByIdentity: Set the observer identities that receive notifications the state of the registry or nodes changes.
///
///  - startUpdate: Acquires an exclusive lock to start updating the registry applications.
///
///  - finishUpdate: Finish updating the registry and release the exclusive lock.
///
///  - getReplicaName: Get the name of the registry replica hosting this session.
///
///  - openServerLog: Open the given server log file for reading.
///
///  - openServerStdErr: Open the given server stderr file for reading.
///
///  - openServerStdOut: Open the given server stdout file for reading.
///
///  - openNodeStdErr: Open the given node stderr file for reading.
///
///  - openNodeStdOut: Open the given node stdout file for reading.
///
///  - openRegistryStdErr: Open the given registry stderr file for reading.
///
///  - openRegistryStdOut: Open the given registry stdout file for reading.
extension AdminSession {
    public func _iceD_keepAlive(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            _ = try request.inputStream.skipEmptyEncapsulation()

            try self.keepAlive(current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_getAdmin(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            _ = try request.inputStream.skipEmptyEncapsulation()

            let iceP_returnValue = try self.getAdmin(current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_getAdminCallbackTemplate(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            _ = try request.inputStream.skipEmptyEncapsulation()

            let iceP_returnValue = try self.getAdminCallbackTemplate(current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_setObservers(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_registryObs: RegistryObserverPrx? = try istr.read(RegistryObserverPrx.self)
            let iceP_nodeObs: NodeObserverPrx? = try istr.read(NodeObserverPrx.self)
            let iceP_appObs: ApplicationObserverPrx? = try istr.read(ApplicationObserverPrx.self)
            let iceP_adptObs: AdapterObserverPrx? = try istr.read(AdapterObserverPrx.self)
            let iceP_objObs: ObjectObserverPrx? = try istr.read(ObjectObserverPrx.self)

            try self.setObservers(registryObs: iceP_registryObs, nodeObs: iceP_nodeObs, appObs: iceP_appObs, adptObs: iceP_adptObs, objObs: iceP_objObs, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_setObserversByIdentity(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_registryObs: Ice.Identity = try istr.read()
            let iceP_nodeObs: Ice.Identity = try istr.read()
            let iceP_appObs: Ice.Identity = try istr.read()
            let iceP_adptObs: Ice.Identity = try istr.read()
            let iceP_objObs: Ice.Identity = try istr.read()

            try self.setObserversByIdentity(registryObs: iceP_registryObs, nodeObs: iceP_nodeObs, appObs: iceP_appObs, adptObs: iceP_adptObs, objObs: iceP_objObs, current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_startUpdate(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            _ = try request.inputStream.skipEmptyEncapsulation()

            let iceP_returnValue = try self.startUpdate(current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_finishUpdate(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            _ = try request.inputStream.skipEmptyEncapsulation()

            try self.finishUpdate(current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_getReplicaName(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            _ = try request.inputStream.skipEmptyEncapsulation()

            let iceP_returnValue = try self.getReplicaName(current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_openServerLog(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_id: Swift.String = try istr.read()
            let iceP_path: Swift.String = try istr.read()
            let iceP_count: Swift.Int32 = try istr.read()

            let iceP_returnValue = try self.openServerLog(id: iceP_id, path: iceP_path, count: iceP_count, current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_openServerStdErr(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_id: Swift.String = try istr.read()
            let iceP_count: Swift.Int32 = try istr.read()

            let iceP_returnValue = try self.openServerStdErr(id: iceP_id, count: iceP_count, current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_openServerStdOut(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_id: Swift.String = try istr.read()
            let iceP_count: Swift.Int32 = try istr.read()

            let iceP_returnValue = try self.openServerStdOut(id: iceP_id, count: iceP_count, current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_openNodeStdErr(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_name: Swift.String = try istr.read()
            let iceP_count: Swift.Int32 = try istr.read()

            let iceP_returnValue = try self.openNodeStdErr(name: iceP_name, count: iceP_count, current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_openNodeStdOut(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_name: Swift.String = try istr.read()
            let iceP_count: Swift.Int32 = try istr.read()

            let iceP_returnValue = try self.openNodeStdOut(name: iceP_name, count: iceP_count, current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_openRegistryStdErr(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_name: Swift.String = try istr.read()
            let iceP_count: Swift.Int32 = try istr.read()

            let iceP_returnValue = try self.openRegistryStdErr(name: iceP_name, count: iceP_count, current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }

    public func _iceD_openRegistryStdOut(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_name: Swift.String = try istr.read()
            let iceP_count: Swift.Int32 = try istr.read()

            let iceP_returnValue = try self.openRegistryStdOut(name: iceP_name, count: iceP_count, current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }
}
