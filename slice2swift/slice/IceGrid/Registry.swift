//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Registry.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice

/// Determines which load sampling interval to use.
public enum LoadSample: Swift.UInt8 {
    /// LoadSample1 Sample every minute.
    case LoadSample1 = 0
    /// LoadSample5 Sample every five minutes.
    case LoadSample5 = 1
    /// LoadSample15 Sample every fifteen minutes.
    case LoadSample15 = 2
    public init() {
        self = .LoadSample1
    }
}

/// An `Ice.InputStream` extension to read `LoadSample` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - returns: `LoadSample` - The enumarated value.
    func read() throws -> LoadSample {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 2)
        guard let val = LoadSample(rawValue: rawValue) else {
            throw Ice.MarshalException("invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LoadSample` - The enumerated value.
    func read(tag: Swift.Int32) throws -> LoadSample? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as LoadSample
    }
}

/// An `Ice.OutputStream` extension to write `LoadSample` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// parameter _: `LoadSample` - The enumerator to write.
    func write(_ v: LoadSample) {
        write(enum: v.rawValue, maxValue: 2)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// parameter _: `LoadSample` - The enumerator to write.
    func write(tag: Swift.Int32, value: LoadSample?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 2)
    }
}

/// Traits for Slice interface`Query`.
public struct QueryTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::Query"]
    public static let staticId = "::IceGrid::Query"
}

/// Traits for Slice interface`Registry`.
public struct RegistryTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::Registry"]
    public static let staticId = "::IceGrid::Registry"
}

/// Traits for Slice interface`Locator`.
public struct LocatorTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Locator", "::Ice::Object", "::IceGrid::Locator"]
    public static let staticId = "::IceGrid::Locator"
}

/// The IceGrid query interface. This interface is accessible to Ice clients who wish to look up well-known
/// objects.
///
/// QueryPrx Methods:
///
///  - findObjectById: Find a well-known object by identity.
///
///  - findObjectByIdAsync: Find a well-known object by identity.
///
///  - findObjectByType: Find a well-known object by type.
///
///  - findObjectByTypeAsync: Find a well-known object by type.
///
///  - findObjectByTypeOnLeastLoadedNode: Find a well-known object by type on the least-loaded node.
///
///  - findObjectByTypeOnLeastLoadedNodeAsync: Find a well-known object by type on the least-loaded node.
///
///  - findAllObjectsByType: Find all the well-known objects with the given type.
///
///  - findAllObjectsByTypeAsync: Find all the well-known objects with the given type.
///
///  - findAllReplicas: Find all the object replicas associated with the given proxy.
///
///  - findAllReplicasAsync: Find all the object replicas associated with the given proxy.
public protocol QueryPrx: Ice.ObjectPrx {}

private final class QueryPrxI: Ice.ObjectPrxI, QueryPrx {
    public override class func ice_staticId() -> Swift.String {
        return QueryTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: QueryPrx.Protocol) throws -> QueryPrx {
    try communicator.makeProxyImpl(proxyString) as QueryPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `QueryPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `QueryPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: QueryPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> QueryPrx? {
    return try await QueryPrxI.checkedCast(prx: prx, facet: facet, context: context) as QueryPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `QueryPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `QueryPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: QueryPrx.Protocol, facet: Swift.String? = nil) -> QueryPrx {
    return QueryPrxI.uncheckedCast(prx: prx, facet: facet) as QueryPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `QueryPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: QueryPrx.Protocol) -> Swift.String {
    return QueryTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `QueryPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `QueryPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `QueryPrx?` - The extracted proxy
    func read(_ type: QueryPrx.Protocol) throws -> QueryPrx? {
        return try read() as QueryPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `QueryPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `QueryPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: QueryPrx.Protocol) throws -> QueryPrx? {
        return try read(tag: tag) as QueryPrxI?
    }
}

/// The IceGrid query interface. This interface is accessible to Ice clients who wish to look up well-known
/// objects.
///
/// QueryPrx Methods:
///
///  - findObjectById: Find a well-known object by identity.
///
///  - findObjectByIdAsync: Find a well-known object by identity.
///
///  - findObjectByType: Find a well-known object by type.
///
///  - findObjectByTypeAsync: Find a well-known object by type.
///
///  - findObjectByTypeOnLeastLoadedNode: Find a well-known object by type on the least-loaded node.
///
///  - findObjectByTypeOnLeastLoadedNodeAsync: Find a well-known object by type on the least-loaded node.
///
///  - findAllObjectsByType: Find all the well-known objects with the given type.
///
///  - findAllObjectsByTypeAsync: Find all the well-known objects with the given type.
///
///  - findAllReplicas: Find all the object replicas associated with the given proxy.
///
///  - findAllReplicasAsync: Find all the object replicas associated with the given proxy.
public extension QueryPrx {
    /// Find a well-known object by identity.
    ///
    /// - parameter _: `Ice.Identity` The identity.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.ObjectPrx?` - The proxy or null if no such object has been found.
    func findObjectById(_ iceP_id: Ice.Identity, context: Ice.Context? = nil) async throws -> Ice.ObjectPrx? {
        return try await _impl._invoke(operation: "findObjectById",
                                       mode: .Idempotent,
                                       write: { ostr in
                                           ostr.write(iceP_id)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    /// Find a well-known object by type. If there are several objects registered for the given type, the object is
    /// randomly selected.
    ///
    /// - parameter _: `Swift.String` The object type.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.ObjectPrx?` - The proxy or null, if no such object has been found.
    func findObjectByType(_ iceP_type: Swift.String, context: Ice.Context? = nil) async throws -> Ice.ObjectPrx? {
        return try await _impl._invoke(operation: "findObjectByType",
                                       mode: .Idempotent,
                                       write: { ostr in
                                           ostr.write(iceP_type)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    /// Find a well-known object by type on the least-loaded node. If the registry does not know which node hosts
    /// the object (for example, because the object was registered with a direct proxy), the registry assumes the
    /// object is hosted on a node that has a load average of 1.0.
    ///
    /// - parameter type: `Swift.String` The object type.
    ///
    /// - parameter sample: `LoadSample` The sampling interval.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.ObjectPrx?` - The proxy or null, if no such object has been found.
    func findObjectByTypeOnLeastLoadedNode(type iceP_type: Swift.String, sample iceP_sample: LoadSample, context: Ice.Context? = nil) async throws -> Ice.ObjectPrx? {
        return try await _impl._invoke(operation: "findObjectByTypeOnLeastLoadedNode",
                                       mode: .Idempotent,
                                       write: { ostr in
                                           ostr.write(iceP_type)
                                           ostr.write(iceP_sample)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    /// Find all the well-known objects with the given type.
    ///
    /// - parameter _: `Swift.String` The object type.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.ObjectProxySeq` - The proxies or an empty sequence, if no such objects have been found.
    func findAllObjectsByType(_ iceP_type: Swift.String, context: Ice.Context? = nil) async throws -> Ice.ObjectProxySeq {
        return try await _impl._invoke(operation: "findAllObjectsByType",
                                       mode: .Idempotent,
                                       write: { ostr in
                                           ostr.write(iceP_type)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Ice.ObjectProxySeq = try Ice.ObjectProxySeqHelper.read(from: istr)
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    /// Find all the object replicas associated with the given proxy. If the given proxy is not an indirect proxy
    /// from a replica group, an empty sequence is returned.
    ///
    /// - parameter _: `Ice.ObjectPrx?` The object proxy.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.ObjectProxySeq` - The proxies of each object replica or an empty sequence, if the given proxy is not from a replica
    /// group.
    func findAllReplicas(_ iceP_proxy: Ice.ObjectPrx?, context: Ice.Context? = nil) async throws -> Ice.ObjectProxySeq {
        return try await _impl._invoke(operation: "findAllReplicas",
                                       mode: .Idempotent,
                                       write: { ostr in
                                           ostr.write(iceP_proxy)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Ice.ObjectProxySeq = try Ice.ObjectProxySeqHelper.read(from: istr)
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}

/// The IceGrid registry allows clients create sessions directly with the registry.
///
/// RegistryPrx Methods:
///
///  - createSession: Create a client session.
///
///  - createSessionAsync: Create a client session.
///
///  - createAdminSession: Create an administrative session.
///
///  - createAdminSessionAsync: Create an administrative session.
///
///  - createSessionFromSecureConnection: Create a client session from a secure connection.
///
///  - createSessionFromSecureConnectionAsync: Create a client session from a secure connection.
///
///  - createAdminSessionFromSecureConnection: Create an administrative session from a secure connection.
///
///  - createAdminSessionFromSecureConnectionAsync: Create an administrative session from a secure connection.
///
///  - getSessionTimeout: Get the idle timeout used by IceGrid for its side of the connection.
///
///  - getSessionTimeoutAsync: Get the idle timeout used by IceGrid for its side of the connection.
///
///  - getACMTimeout: Get the idle timeout used by IceGrid for its side of the connection.
///
///  - getACMTimeoutAsync: Get the idle timeout used by IceGrid for its side of the connection.
public protocol RegistryPrx: Ice.ObjectPrx {}

private final class RegistryPrxI: Ice.ObjectPrxI, RegistryPrx {
    public override class func ice_staticId() -> Swift.String {
        return RegistryTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: RegistryPrx.Protocol) throws -> RegistryPrx {
    try communicator.makeProxyImpl(proxyString) as RegistryPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `RegistryPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `RegistryPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: RegistryPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> RegistryPrx? {
    return try await RegistryPrxI.checkedCast(prx: prx, facet: facet, context: context) as RegistryPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `RegistryPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `RegistryPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: RegistryPrx.Protocol, facet: Swift.String? = nil) -> RegistryPrx {
    return RegistryPrxI.uncheckedCast(prx: prx, facet: facet) as RegistryPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `RegistryPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: RegistryPrx.Protocol) -> Swift.String {
    return RegistryTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `RegistryPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `RegistryPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `RegistryPrx?` - The extracted proxy
    func read(_ type: RegistryPrx.Protocol) throws -> RegistryPrx? {
        return try read() as RegistryPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `RegistryPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `RegistryPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: RegistryPrx.Protocol) throws -> RegistryPrx? {
        return try read(tag: tag) as RegistryPrxI?
    }
}

/// The IceGrid registry allows clients create sessions directly with the registry.
///
/// RegistryPrx Methods:
///
///  - createSession: Create a client session.
///
///  - createSessionAsync: Create a client session.
///
///  - createAdminSession: Create an administrative session.
///
///  - createAdminSessionAsync: Create an administrative session.
///
///  - createSessionFromSecureConnection: Create a client session from a secure connection.
///
///  - createSessionFromSecureConnectionAsync: Create a client session from a secure connection.
///
///  - createAdminSessionFromSecureConnection: Create an administrative session from a secure connection.
///
///  - createAdminSessionFromSecureConnectionAsync: Create an administrative session from a secure connection.
///
///  - getSessionTimeout: Get the idle timeout used by IceGrid for its side of the connection.
///
///  - getSessionTimeoutAsync: Get the idle timeout used by IceGrid for its side of the connection.
///
///  - getACMTimeout: Get the idle timeout used by IceGrid for its side of the connection.
///
///  - getACMTimeoutAsync: Get the idle timeout used by IceGrid for its side of the connection.
public extension RegistryPrx {
    /// Create a client session.
    ///
    /// - parameter userId: `Swift.String` The user id.
    ///
    /// - parameter password: `Swift.String` The password for the given user id.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `SessionPrx?` - A proxy for the newly created session. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - PermissionDeniedException - Raised if the password for the given user id is not correct, or if the
    ///     user is not allowed access.
    func createSession(userId iceP_userId: Swift.String, password iceP_password: Swift.String, context: Ice.Context? = nil) async throws -> SessionPrx? {
        return try await _impl._invoke(operation: "createSession",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_userId)
                                           ostr.write(iceP_password)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: SessionPrx? = try istr.read(SessionPrx.self)
                                           return iceP_returnValue
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as PermissionDeniedException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    /// Create an administrative session.
    ///
    /// - parameter userId: `Swift.String` The user id.
    ///
    /// - parameter password: `Swift.String` The password for the given user id.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `AdminSessionPrx?` - A proxy for the newly created session. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - PermissionDeniedException - Raised if the password for the given user id is not correct, or if the
    ///     user is not allowed access.
    func createAdminSession(userId iceP_userId: Swift.String, password iceP_password: Swift.String, context: Ice.Context? = nil) async throws -> AdminSessionPrx? {
        return try await _impl._invoke(operation: "createAdminSession",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_userId)
                                           ostr.write(iceP_password)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: AdminSessionPrx? = try istr.read(AdminSessionPrx.self)
                                           return iceP_returnValue
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as PermissionDeniedException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    /// Create a client session from a secure connection.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `SessionPrx?` - A proxy for the newly created session. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - PermissionDeniedException - Raised if the password for the given user id is not correct, or if the
    ///     user is not allowed access.
    func createSessionFromSecureConnection(context: Ice.Context? = nil) async throws -> SessionPrx? {
        return try await _impl._invoke(operation: "createSessionFromSecureConnection",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: SessionPrx? = try istr.read(SessionPrx.self)
                                           return iceP_returnValue
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as PermissionDeniedException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    /// Create an administrative session from a secure connection.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `AdminSessionPrx?` - A proxy for the newly created session. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - PermissionDeniedException - Raised if the password for the given user id is not correct, or if the
    ///     user is not allowed access.
    func createAdminSessionFromSecureConnection(context: Ice.Context? = nil) async throws -> AdminSessionPrx? {
        return try await _impl._invoke(operation: "createAdminSessionFromSecureConnection",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: AdminSessionPrx? = try istr.read(AdminSessionPrx.self)
                                           return iceP_returnValue
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as PermissionDeniedException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    /// Get the idle timeout used by IceGrid for its side of the connection.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Int32` - The idle timeout (in seconds).
    func getSessionTimeout(context: Ice.Context? = nil) async throws -> Swift.Int32 {
        return try await _impl._invoke(operation: "getSessionTimeout",
                                       mode: .Idempotent,
                                       read: { istr in
                                           let iceP_returnValue: Swift.Int32 = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    /// Get the idle timeout used by IceGrid for its side of the connection.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Int32` - The idle timeout (in seconds).
    func getACMTimeout(context: Ice.Context? = nil) async throws -> Swift.Int32 {
        return try await _impl._invoke(operation: "getACMTimeout",
                                       mode: .Idempotent,
                                       read: { istr in
                                           let iceP_returnValue: Swift.Int32 = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}

/// The IceGrid locator interface provides access to the Query and Registry object of the IceGrid
/// registry.
///
/// LocatorPrx Methods:
///
///  - getLocalRegistry: Get the proxy of the registry object hosted by this IceGrid registry.
///
///  - getLocalRegistryAsync: Get the proxy of the registry object hosted by this IceGrid registry.
///
///  - getLocalQuery: Get the proxy of the query object hosted by this IceGrid registry.
///
///  - getLocalQueryAsync: Get the proxy of the query object hosted by this IceGrid registry.
public protocol LocatorPrx: Ice.LocatorPrx {}

private final class LocatorPrxI: Ice.ObjectPrxI, LocatorPrx {
    public override class func ice_staticId() -> Swift.String {
        return LocatorTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: LocatorPrx.Protocol) throws -> LocatorPrx {
    try communicator.makeProxyImpl(proxyString) as LocatorPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `LocatorPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `LocatorPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: LocatorPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> LocatorPrx? {
    return try await LocatorPrxI.checkedCast(prx: prx, facet: facet, context: context) as LocatorPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `LocatorPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `LocatorPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: LocatorPrx.Protocol, facet: Swift.String? = nil) -> LocatorPrx {
    return LocatorPrxI.uncheckedCast(prx: prx, facet: facet) as LocatorPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `LocatorPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: LocatorPrx.Protocol) -> Swift.String {
    return LocatorTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `LocatorPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `LocatorPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `LocatorPrx?` - The extracted proxy
    func read(_ type: LocatorPrx.Protocol) throws -> LocatorPrx? {
        return try read() as LocatorPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `LocatorPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `LocatorPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: LocatorPrx.Protocol) throws -> LocatorPrx? {
        return try read(tag: tag) as LocatorPrxI?
    }
}

/// The IceGrid locator interface provides access to the Query and Registry object of the IceGrid
/// registry.
///
/// LocatorPrx Methods:
///
///  - getLocalRegistry: Get the proxy of the registry object hosted by this IceGrid registry.
///
///  - getLocalRegistryAsync: Get the proxy of the registry object hosted by this IceGrid registry.
///
///  - getLocalQuery: Get the proxy of the query object hosted by this IceGrid registry.
///
///  - getLocalQueryAsync: Get the proxy of the query object hosted by this IceGrid registry.
public extension LocatorPrx {
    /// Get the proxy of the registry object hosted by this IceGrid registry.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `RegistryPrx?` - The proxy of the registry object. The returned proxy is never null.
    func getLocalRegistry(context: Ice.Context? = nil) async throws -> RegistryPrx? {
        return try await _impl._invoke(operation: "getLocalRegistry",
                                       mode: .Idempotent,
                                       read: { istr in
                                           let iceP_returnValue: RegistryPrx? = try istr.read(RegistryPrx.self)
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    /// Get the proxy of the query object hosted by this IceGrid registry.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `QueryPrx?` - The proxy of the query object. The returned proxy is never null.
    func getLocalQuery(context: Ice.Context? = nil) async throws -> QueryPrx? {
        return try await _impl._invoke(operation: "getLocalQuery",
                                       mode: .Idempotent,
                                       read: { istr in
                                           let iceP_returnValue: QueryPrx? = try istr.read(QueryPrx.self)
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}


/// Dispatcher for `Query` servants.
public struct QueryDisp: Ice.Dispatcher {
    public let servant: Query
    private static let defaultObject = Ice.ObjectI<QueryTraits>()

    public init(_ servant: Query) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "findAllObjectsByType":
            try await servant._iceD_findAllObjectsByType(request)
        case "findAllReplicas":
            try await servant._iceD_findAllReplicas(request)
        case "findObjectById":
            try await servant._iceD_findObjectById(request)
        case "findObjectByType":
            try await servant._iceD_findObjectByType(request)
        case "findObjectByTypeOnLeastLoadedNode":
            try await servant._iceD_findObjectByTypeOnLeastLoadedNode(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? QueryDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? QueryDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? QueryDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? QueryDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

/// The IceGrid query interface. This interface is accessible to Ice clients who wish to look up well-known
/// objects.
public protocol Query {
    /// Find a well-known object by identity.
    ///
    /// - parameter id: `Ice.Identity` The identity.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.ObjectPrx?` - The proxy or null if no such object has been found.
    func findObjectById(id: Ice.Identity, current: Ice.Current) async throws -> Ice.ObjectPrx?

    /// Find a well-known object by type. If there are several objects registered for the given type, the object is
    /// randomly selected.
    ///
    /// - parameter type: `Swift.String` The object type.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.ObjectPrx?` - The proxy or null, if no such object has been found.
    func findObjectByType(type: Swift.String, current: Ice.Current) async throws -> Ice.ObjectPrx?

    /// Find a well-known object by type on the least-loaded node. If the registry does not know which node hosts
    /// the object (for example, because the object was registered with a direct proxy), the registry assumes the
    /// object is hosted on a node that has a load average of 1.0.
    ///
    /// - parameter type: `Swift.String` The object type.
    ///
    /// - parameter sample: `LoadSample` The sampling interval.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.ObjectPrx?` - The proxy or null, if no such object has been found.
    func findObjectByTypeOnLeastLoadedNode(type: Swift.String, sample: LoadSample, current: Ice.Current) async throws -> Ice.ObjectPrx?

    /// Find all the well-known objects with the given type.
    ///
    /// - parameter type: `Swift.String` The object type.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.ObjectProxySeq` - The proxies or an empty sequence, if no such objects have been found.
    func findAllObjectsByType(type: Swift.String, current: Ice.Current) async throws -> Ice.ObjectProxySeq

    /// Find all the object replicas associated with the given proxy. If the given proxy is not an indirect proxy
    /// from a replica group, an empty sequence is returned.
    ///
    /// - parameter proxy: `Ice.ObjectPrx?` The object proxy.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.ObjectProxySeq` - The proxies of each object replica or an empty sequence, if the given proxy is not from a replica
    /// group.
    func findAllReplicas(proxy: Ice.ObjectPrx?, current: Ice.Current) async throws -> Ice.ObjectProxySeq
}


/// Dispatcher for `Registry` servants.
public struct RegistryDisp: Ice.Dispatcher {
    public let servant: Registry
    private static let defaultObject = Ice.ObjectI<RegistryTraits>()

    public init(_ servant: Registry) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "createAdminSession":
            try await servant._iceD_createAdminSession(request)
        case "createAdminSessionFromSecureConnection":
            try await servant._iceD_createAdminSessionFromSecureConnection(request)
        case "createSession":
            try await servant._iceD_createSession(request)
        case "createSessionFromSecureConnection":
            try await servant._iceD_createSessionFromSecureConnection(request)
        case "getACMTimeout":
            try await servant._iceD_getACMTimeout(request)
        case "getSessionTimeout":
            try await servant._iceD_getSessionTimeout(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? RegistryDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? RegistryDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? RegistryDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? RegistryDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

/// The IceGrid registry allows clients create sessions directly with the registry.
public protocol Registry {
    /// Create a client session.
    ///
    /// - parameter userId: `Swift.String` The user id.
    ///
    /// - parameter password: `Swift.String` The password for the given user id.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `SessionPrx?` - A proxy for the newly created session. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - PermissionDeniedException - Raised if the password for the given user id is not correct, or if the
    ///     user is not allowed access.
    func createSession(userId: Swift.String, password: Swift.String, current: Ice.Current) async throws -> SessionPrx?

    /// Create an administrative session.
    ///
    /// - parameter userId: `Swift.String` The user id.
    ///
    /// - parameter password: `Swift.String` The password for the given user id.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `AdminSessionPrx?` - A proxy for the newly created session. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - PermissionDeniedException - Raised if the password for the given user id is not correct, or if the
    ///     user is not allowed access.
    func createAdminSession(userId: Swift.String, password: Swift.String, current: Ice.Current) async throws -> AdminSessionPrx?

    /// Create a client session from a secure connection.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `SessionPrx?` - A proxy for the newly created session. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - PermissionDeniedException - Raised if the password for the given user id is not correct, or if the
    ///     user is not allowed access.
    func createSessionFromSecureConnection(current: Ice.Current) async throws -> SessionPrx?

    /// Create an administrative session from a secure connection.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `AdminSessionPrx?` - A proxy for the newly created session. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - PermissionDeniedException - Raised if the password for the given user id is not correct, or if the
    ///     user is not allowed access.
    func createAdminSessionFromSecureConnection(current: Ice.Current) async throws -> AdminSessionPrx?

    /// Get the idle timeout used by IceGrid for its side of the connection.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Int32` - The idle timeout (in seconds).
    func getSessionTimeout(current: Ice.Current) async throws -> Swift.Int32

    /// Get the idle timeout used by IceGrid for its side of the connection.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Int32` - The idle timeout (in seconds).
    func getACMTimeout(current: Ice.Current) async throws -> Swift.Int32
}


/// Dispatcher for `Locator` servants.
public struct LocatorDisp: Ice.Dispatcher {
    public let servant: Locator
    private static let defaultObject = Ice.ObjectI<LocatorTraits>()

    public init(_ servant: Locator) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "findAdapterById":
            try await servant._iceD_findAdapterById(request)
        case "findObjectById":
            try await servant._iceD_findObjectById(request)
        case "getLocalQuery":
            try await servant._iceD_getLocalQuery(request)
        case "getLocalRegistry":
            try await servant._iceD_getLocalRegistry(request)
        case "getRegistry":
            try await servant._iceD_getRegistry(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? LocatorDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? LocatorDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? LocatorDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? LocatorDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

/// The IceGrid locator interface provides access to the Query and Registry object of the IceGrid
/// registry.
public protocol Locator: Ice.Locator {
    /// Get the proxy of the registry object hosted by this IceGrid registry.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `RegistryPrx?` - The proxy of the registry object. The returned proxy is never null.
    func getLocalRegistry(current: Ice.Current) async throws -> RegistryPrx?

    /// Get the proxy of the query object hosted by this IceGrid registry.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `QueryPrx?` - The proxy of the query object. The returned proxy is never null.
    func getLocalQuery(current: Ice.Current) async throws -> QueryPrx?
}

/// The IceGrid query interface. This interface is accessible to Ice clients who wish to look up well-known
/// objects.
///
/// Query Methods:
///
///  - findObjectById: Find a well-known object by identity.
///
///  - findObjectByType: Find a well-known object by type.
///
///  - findObjectByTypeOnLeastLoadedNode: Find a well-known object by type on the least-loaded node.
///
///  - findAllObjectsByType: Find all the well-known objects with the given type.
///
///  - findAllReplicas: Find all the object replicas associated with the given proxy.
extension Query {
    public func _iceD_findObjectById(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_id: Ice.Identity = try istr.read()
        let result = try await self.findObjectById(id: iceP_id, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_findObjectByType(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_type: Swift.String = try istr.read()
        let result = try await self.findObjectByType(type: iceP_type, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_findObjectByTypeOnLeastLoadedNode(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_type: Swift.String = try istr.read()
        let iceP_sample: LoadSample = try istr.read()
        let result = try await self.findObjectByTypeOnLeastLoadedNode(type: iceP_type, sample: iceP_sample, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_findAllObjectsByType(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_type: Swift.String = try istr.read()
        let result = try await self.findAllObjectsByType(type: iceP_type, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            Ice.ObjectProxySeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_findAllReplicas(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_proxy: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
        let result = try await self.findAllReplicas(proxy: iceP_proxy, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            Ice.ObjectProxySeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }
}

/// The IceGrid registry allows clients create sessions directly with the registry.
///
/// Registry Methods:
///
///  - createSession: Create a client session.
///
///  - createAdminSession: Create an administrative session.
///
///  - createSessionFromSecureConnection: Create a client session from a secure connection.
///
///  - createAdminSessionFromSecureConnection: Create an administrative session from a secure connection.
///
///  - getSessionTimeout: Get the idle timeout used by IceGrid for its side of the connection.
///
///  - getACMTimeout: Get the idle timeout used by IceGrid for its side of the connection.
extension Registry {
    public func _iceD_createSession(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_userId: Swift.String = try istr.read()
        let iceP_password: Swift.String = try istr.read()
        let result = try await self.createSession(userId: iceP_userId, password: iceP_password, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_createAdminSession(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_userId: Swift.String = try istr.read()
        let iceP_password: Swift.String = try istr.read()
        let result = try await self.createAdminSession(userId: iceP_userId, password: iceP_password, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_createSessionFromSecureConnection(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.createSessionFromSecureConnection(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_createAdminSessionFromSecureConnection(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.createAdminSessionFromSecureConnection(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_getSessionTimeout(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getSessionTimeout(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_getACMTimeout(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getACMTimeout(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }
}

/// The IceGrid locator interface provides access to the Query and Registry object of the IceGrid
/// registry.
///
/// Locator Methods:
///
///  - getLocalRegistry: Get the proxy of the registry object hosted by this IceGrid registry.
///
///  - getLocalQuery: Get the proxy of the query object hosted by this IceGrid registry.
extension Locator {
    public func _iceD_getLocalRegistry(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getLocalRegistry(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_getLocalQuery(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getLocalQuery(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }
}
