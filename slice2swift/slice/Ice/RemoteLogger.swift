//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `RemoteLogger.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation

/// An enumeration representing the different types of log messages.
public enum LogMessageType: Swift.UInt8 {
    /// PrintMessage The RemoteLogger received a print message.
    case PrintMessage = 0
    /// TraceMessage The RemoteLogger received a trace message.
    case TraceMessage = 1
    /// WarningMessage The RemoteLogger received a warning message.
    case WarningMessage = 2
    /// ErrorMessage The RemoteLogger received an error message.
    case ErrorMessage = 3
    public init() {
        self = .PrintMessage
    }
}

/// An `Ice.InputStream` extension to read `LogMessageType` enumerated values from the stream.
public extension InputStream {
    /// Read an enumerated value.
    ///
    /// - returns: `LogMessageType` - The enumarated value.
    func read() throws -> LogMessageType {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 3)
        guard let val = LogMessageType(rawValue: rawValue) else {
            throw MarshalException("invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LogMessageType` - The enumerated value.
    func read(tag: Swift.Int32) throws -> LogMessageType? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as LogMessageType
    }
}

/// An `Ice.OutputStream` extension to write `LogMessageType` enumerated values to the stream.
public extension OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// parameter _: `LogMessageType` - The enumerator to write.
    func write(_ v: LogMessageType) {
        write(enum: v.rawValue, maxValue: 3)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// parameter _: `LogMessageType` - The enumerator to write.
    func write(tag: Swift.Int32, value: LogMessageType?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 3)
    }
}

/// A sequence of LogMessageType
public typealias LogMessageTypeSeq = [LogMessageType]

/// Helper class to read and write `LogMessageTypeSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LogMessageTypeSeqHelper {
    /// Read a `LogMessageTypeSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `LogMessageTypeSeq` - The sequence read from the stream.
    public static func read(from istr: InputStream) throws -> LogMessageTypeSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = LogMessageTypeSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: LogMessageType = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `LogMessageTypeSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LogMessageTypeSeq` - The sequence read from the stream.
    public static func read(from istr: InputStream, tag: Swift.Int32) throws -> LogMessageTypeSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `LogMessageTypeSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `LogMessageTypeSeq` - The sequence value to write to the stream.
    public static func write(to ostr: OutputStream, value v: LogMessageTypeSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `LogMessageTypeSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LogMessageTypeSeq` The sequence value to write to the stream.
    public static func write(to ostr: OutputStream,  tag: Swift.Int32, value v: LogMessageTypeSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// A complete log message.
public struct LogMessage: Swift.Hashable {
    /// The type of message sent to the RemoteLogger.
    public var `type`: LogMessageType = .PrintMessage
    /// The date and time when the RemoteLogger received this message, expressed as the number of microseconds
    /// since the Unix Epoch (00:00:00 UTC on 1 January 1970)
    public var timestamp: Swift.Int64 = 0
    /// For a message of type trace, the trace category of this log message; otherwise, the empty string.
    public var traceCategory: Swift.String = ""
    /// The log message itself.
    public var message: Swift.String = ""

    public init() {}

    public init(`type`: LogMessageType, timestamp: Swift.Int64, traceCategory: Swift.String, message: Swift.String) {
        self.`type` = `type`
        self.timestamp = timestamp
        self.traceCategory = traceCategory
        self.message = message
    }
}

/// An `Ice.InputStream` extension to read `LogMessage` structured values from the stream.
public extension InputStream {
    /// Read a `LogMessage` structured value from the stream.
    ///
    /// - returns: `LogMessage` - The structured value read from the stream.
    func read() throws -> LogMessage {
        var v = LogMessage()
        v.`type` = try self.read()
        v.timestamp = try self.read()
        v.traceCategory = try self.read()
        v.message = try self.read()
        return v
    }

    /// Read an optional `LogMessage?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LogMessage?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> LogMessage? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as LogMessage
    }
}

/// An `Ice.OutputStream` extension to write `LogMessage` structured values from the stream.
public extension OutputStream {
    /// Write a `LogMessage` structured value to the stream.
    ///
    /// - parameter _: `LogMessage` - The value to write to the stream.
    func write(_ v: LogMessage) {
        self.write(v.`type`)
        self.write(v.timestamp)
        self.write(v.traceCategory)
        self.write(v.message)
    }

    /// Write an optional `LogMessage?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LogMessage?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: LogMessage?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// A sequence of LogMessage.
public typealias LogMessageSeq = [LogMessage]

/// Helper class to read and write `LogMessageSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LogMessageSeqHelper {
    /// Read a `LogMessageSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `LogMessageSeq` - The sequence read from the stream.
    public static func read(from istr: InputStream) throws -> LogMessageSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 11)
        var v = LogMessageSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: LogMessage = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `LogMessageSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LogMessageSeq` - The sequence read from the stream.
    public static func read(from istr: InputStream, tag: Swift.Int32) throws -> LogMessageSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `LogMessageSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `LogMessageSeq` - The sequence value to write to the stream.
    public static func write(to ostr: OutputStream, value v: LogMessageSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `LogMessageSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LogMessageSeq` The sequence value to write to the stream.
    public static func write(to ostr: OutputStream,  tag: Swift.Int32, value v: LogMessageSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice interface`RemoteLogger`.
public struct RemoteLoggerTraits: SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Ice::RemoteLogger"]
    public static let staticId = "::Ice::RemoteLogger"
}

/// :nodoc:
public class RemoteLoggerAlreadyAttachedException_TypeResolver: UserExceptionTypeResolver {
    public override func type() -> UserException.Type {
        return RemoteLoggerAlreadyAttachedException.self
    }
}

public extension ClassResolver {
    @objc static func Ice_RemoteLoggerAlreadyAttachedException() -> UserExceptionTypeResolver {
        return RemoteLoggerAlreadyAttachedException_TypeResolver()
    }
}

/// Thrown when the provided RemoteLogger was previously attached to a LoggerAdmin.
open class RemoteLoggerAlreadyAttachedException: UserException, @unchecked Sendable {
    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Ice::RemoteLoggerAlreadyAttachedException" }

    open override func _iceWriteImpl(to ostr: OutputStream) {
        ostr.startSlice(typeId: RemoteLoggerAlreadyAttachedException.ice_staticId(), compactId: -1, last: true)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }
}

/// Traits for Slice interface`LoggerAdmin`.
public struct LoggerAdminTraits: SliceTraits {
    public static let staticIds = ["::Ice::LoggerAdmin", "::Ice::Object"]
    public static let staticId = "::Ice::LoggerAdmin"
}

/// The Ice remote logger interface. An application can implement a RemoteLogger to receive the log messages sent
/// to the local RemoteLogger of another Ice application.
///
/// RemoteLoggerPrx Methods:
///
///  - `init`: init is called by attachRemoteLogger when a RemoteLogger proxy is attached.
///
///  - initAsync: init is called by attachRemoteLogger when a RemoteLogger proxy is attached.
///
///  - log: Log a LogMessage.
///
///  - logAsync: Log a LogMessage.
public protocol RemoteLoggerPrx: ObjectPrx {}

internal final class RemoteLoggerPrxI: ObjectPrxI, RemoteLoggerPrx {
    public override class func ice_staticId() -> Swift.String {
        return RemoteLoggerTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: RemoteLoggerPrx.Protocol) throws -> RemoteLoggerPrx {
    try communicator.makeProxyImpl(proxyString) as RemoteLoggerPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `RemoteLoggerPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `RemoteLoggerPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: ObjectPrx, type: RemoteLoggerPrx.Protocol, facet: Swift.String? = nil, context: Context? = nil) async throws -> RemoteLoggerPrx? {
    return try await RemoteLoggerPrxI.checkedCast(prx: prx, facet: facet, context: context) as RemoteLoggerPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `RemoteLoggerPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `RemoteLoggerPrx` - A proxy with the requested type
public func uncheckedCast(prx: ObjectPrx, type: RemoteLoggerPrx.Protocol, facet: Swift.String? = nil) -> RemoteLoggerPrx {
    return RemoteLoggerPrxI.uncheckedCast(prx: prx, facet: facet) as RemoteLoggerPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `RemoteLoggerPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: RemoteLoggerPrx.Protocol) -> Swift.String {
    return RemoteLoggerTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `RemoteLoggerPrx`.
public extension InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `RemoteLoggerPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `RemoteLoggerPrx?` - The extracted proxy
    func read(_ type: RemoteLoggerPrx.Protocol) throws -> RemoteLoggerPrx? {
        return try read() as RemoteLoggerPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `RemoteLoggerPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `RemoteLoggerPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: RemoteLoggerPrx.Protocol) throws -> RemoteLoggerPrx? {
        return try read(tag: tag) as RemoteLoggerPrxI?
    }
}

/// The Ice remote logger interface. An application can implement a RemoteLogger to receive the log messages sent
/// to the local RemoteLogger of another Ice application.
///
/// RemoteLoggerPrx Methods:
///
///  - `init`: init is called by attachRemoteLogger when a RemoteLogger proxy is attached.
///
///  - initAsync: init is called by attachRemoteLogger when a RemoteLogger proxy is attached.
///
///  - log: Log a LogMessage.
///
///  - logAsync: Log a LogMessage.
public extension RemoteLoggerPrx {
    /// init is called by attachRemoteLogger when a RemoteLogger proxy is attached.
    ///
    /// - parameter prefix: `Swift.String` The prefix of the associated local Logger.
    ///
    /// - parameter logMessages: `LogMessageSeq` Old log messages generated before "now".
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func `init`(prefix iceP_prefix: Swift.String, logMessages iceP_logMessages: LogMessageSeq, context: Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "init",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_prefix)
                                           LogMessageSeqHelper.write(to: ostr, value: iceP_logMessages)
                                       },
                                       context: context)
    }

    /// Log a LogMessage. Note that log may be called by LoggerAdmin before init.
    ///
    /// - parameter _: `LogMessage` The message to log.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func log(_ iceP_message: LogMessage, context: Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "log",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_message)
                                       },
                                       context: context)
    }
}

/// The interface of the admin object that allows an Ice application the attach its
/// RemoteLogger to the RemoteLogger of this admin object's Ice communicator.
///
/// LoggerAdminPrx Methods:
///
///  - attachRemoteLogger: Attaches a RemoteLogger object to the local logger.
///
///  - attachRemoteLoggerAsync: Attaches a RemoteLogger object to the local logger.
///
///  - detachRemoteLogger: Detaches a RemoteLogger object from the local logger.
///
///  - detachRemoteLoggerAsync: Detaches a RemoteLogger object from the local logger.
///
///  - getLog: Retrieves log messages recently logged.
///
///  - getLogAsync: Retrieves log messages recently logged.
public protocol LoggerAdminPrx: ObjectPrx {}

internal final class LoggerAdminPrxI: ObjectPrxI, LoggerAdminPrx {
    public override class func ice_staticId() -> Swift.String {
        return LoggerAdminTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: LoggerAdminPrx.Protocol) throws -> LoggerAdminPrx {
    try communicator.makeProxyImpl(proxyString) as LoggerAdminPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `LoggerAdminPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `LoggerAdminPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: ObjectPrx, type: LoggerAdminPrx.Protocol, facet: Swift.String? = nil, context: Context? = nil) async throws -> LoggerAdminPrx? {
    return try await LoggerAdminPrxI.checkedCast(prx: prx, facet: facet, context: context) as LoggerAdminPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `LoggerAdminPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `LoggerAdminPrx` - A proxy with the requested type
public func uncheckedCast(prx: ObjectPrx, type: LoggerAdminPrx.Protocol, facet: Swift.String? = nil) -> LoggerAdminPrx {
    return LoggerAdminPrxI.uncheckedCast(prx: prx, facet: facet) as LoggerAdminPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `LoggerAdminPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: LoggerAdminPrx.Protocol) -> Swift.String {
    return LoggerAdminTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `LoggerAdminPrx`.
public extension InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `LoggerAdminPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `LoggerAdminPrx?` - The extracted proxy
    func read(_ type: LoggerAdminPrx.Protocol) throws -> LoggerAdminPrx? {
        return try read() as LoggerAdminPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `LoggerAdminPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `LoggerAdminPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: LoggerAdminPrx.Protocol) throws -> LoggerAdminPrx? {
        return try read(tag: tag) as LoggerAdminPrxI?
    }
}

/// The interface of the admin object that allows an Ice application the attach its
/// RemoteLogger to the RemoteLogger of this admin object's Ice communicator.
///
/// LoggerAdminPrx Methods:
///
///  - attachRemoteLogger: Attaches a RemoteLogger object to the local logger.
///
///  - attachRemoteLoggerAsync: Attaches a RemoteLogger object to the local logger.
///
///  - detachRemoteLogger: Detaches a RemoteLogger object from the local logger.
///
///  - detachRemoteLoggerAsync: Detaches a RemoteLogger object from the local logger.
///
///  - getLog: Retrieves log messages recently logged.
///
///  - getLogAsync: Retrieves log messages recently logged.
public extension LoggerAdminPrx {
    /// Attaches a RemoteLogger object to the local logger. attachRemoteLogger calls init on the provided
    /// RemoteLogger proxy.
    ///
    /// - parameter prx: `RemoteLoggerPrx?` A proxy to the remote logger.
    ///
    /// - parameter messageTypes: `LogMessageTypeSeq` The list of message types that the remote logger wishes to receive. An empty list means
    /// no filtering (send all message types).
    ///
    /// - parameter traceCategories: `StringSeq` The categories of traces that the remote logger wishes to receive. This parameter is
    /// ignored if messageTypes is not empty and does not include trace. An empty list means no filtering (send all
    /// trace categories).
    ///
    /// - parameter messageMax: `Swift.Int32` The maximum number of log messages (of all types) to be provided to init. A negative
    /// value requests all messages available.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - RemoteLoggerAlreadyAttachedException - Raised if this remote logger is already attached to this admin
    ///     object.
    func attachRemoteLogger(prx iceP_prx: RemoteLoggerPrx?, messageTypes iceP_messageTypes: LogMessageTypeSeq, traceCategories iceP_traceCategories: StringSeq, messageMax iceP_messageMax: Swift.Int32, context: Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "attachRemoteLogger",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_prx)
                                           LogMessageTypeSeqHelper.write(to: ostr, value: iceP_messageTypes)
                                           ostr.write(iceP_traceCategories)
                                           ostr.write(iceP_messageMax)
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as RemoteLoggerAlreadyAttachedException {
                                               throw error
                                           } catch is UserException {}
                                       },
                                       context: context)
    }

    /// Detaches a RemoteLogger object from the local logger.
    ///
    /// - parameter _: `RemoteLoggerPrx?` A proxy to the remote logger.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Bool` - True if the provided remote logger proxy was detached, and false otherwise.
    func detachRemoteLogger(_ iceP_prx: RemoteLoggerPrx?, context: Context? = nil) async throws -> Swift.Bool {
        return try await _impl._invoke(operation: "detachRemoteLogger",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_prx)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Swift.Bool = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    /// Retrieves log messages recently logged.
    ///
    /// - parameter messageTypes: `LogMessageTypeSeq` The list of message types that the caller wishes to receive. An empty list means no
    /// filtering (send all message types).
    ///
    /// - parameter traceCategories: `StringSeq` The categories of traces that caller wish to receive. This parameter is ignored if
    /// messageTypes is not empty and does not include trace. An empty list means no filtering (send all trace
    /// categories).
    ///
    /// - parameter messageMax: `Swift.Int32` The maximum number of log messages (of all types) to be returned. A negative value
    /// requests all messages available.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: LogMessageSeq, prefix: Swift.String)`:
    ///
    ///   - returnValue: `LogMessageSeq` - The Log messages.
    ///
    ///   - prefix: `Swift.String` - The prefix of the associated local logger.
    func getLog(messageTypes iceP_messageTypes: LogMessageTypeSeq, traceCategories iceP_traceCategories: StringSeq, messageMax iceP_messageMax: Swift.Int32, context: Context? = nil) async throws -> (returnValue: LogMessageSeq, prefix: Swift.String) {
        return try await _impl._invoke(operation: "getLog",
                                       mode: .Normal,
                                       write: { ostr in
                                           LogMessageTypeSeqHelper.write(to: ostr, value: iceP_messageTypes)
                                           ostr.write(iceP_traceCategories)
                                           ostr.write(iceP_messageMax)
                                       },
                                       read: { istr in
                                           let iceP_prefix: Swift.String = try istr.read()
                                           let iceP_returnValue: LogMessageSeq = try LogMessageSeqHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_prefix)
                                       },
                                       context: context)
    }
}


/// Dispatcher for `RemoteLogger` servants.
public struct RemoteLoggerDisp: Ice.Dispatcher {
    public let servant: RemoteLogger
    private static let defaultObject = ObjectI<RemoteLoggerTraits>()

    public init(_ servant: RemoteLogger) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "ice_id":
            try await (servant as? Ice.Object ?? RemoteLoggerDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? RemoteLoggerDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? RemoteLoggerDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? RemoteLoggerDisp.defaultObject)._iceD_ice_ping(request)
        case "init":
            try await servant._iceD_init(request)
        case "log":
            try await servant._iceD_log(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

/// The Ice remote logger interface. An application can implement a RemoteLogger to receive the log messages sent
/// to the local RemoteLogger of another Ice application.
public protocol RemoteLogger {
    /// init is called by attachRemoteLogger when a RemoteLogger proxy is attached.
    ///
    /// - parameter prefix: `Swift.String` The prefix of the associated local Logger.
    ///
    /// - parameter logMessages: `LogMessageSeq` Old log messages generated before "now".
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func `init`(prefix: Swift.String, logMessages: LogMessageSeq, current: Current) async throws

    /// Log a LogMessage. Note that log may be called by LoggerAdmin before init.
    ///
    /// - parameter message: `LogMessage` The message to log.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func log(message: LogMessage, current: Current) async throws
}


/// Dispatcher for `LoggerAdmin` servants.
public struct LoggerAdminDisp: Ice.Dispatcher {
    public let servant: LoggerAdmin
    private static let defaultObject = ObjectI<LoggerAdminTraits>()

    public init(_ servant: LoggerAdmin) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "attachRemoteLogger":
            try await servant._iceD_attachRemoteLogger(request)
        case "detachRemoteLogger":
            try await servant._iceD_detachRemoteLogger(request)
        case "getLog":
            try await servant._iceD_getLog(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? LoggerAdminDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? LoggerAdminDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? LoggerAdminDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? LoggerAdminDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

/// The interface of the admin object that allows an Ice application the attach its
/// RemoteLogger to the RemoteLogger of this admin object's Ice communicator.
public protocol LoggerAdmin {
    /// Attaches a RemoteLogger object to the local logger. attachRemoteLogger calls init on the provided
    /// RemoteLogger proxy.
    ///
    /// - parameter prx: `RemoteLoggerPrx?` A proxy to the remote logger.
    ///
    /// - parameter messageTypes: `LogMessageTypeSeq` The list of message types that the remote logger wishes to receive. An empty list means
    /// no filtering (send all message types).
    ///
    /// - parameter traceCategories: `StringSeq` The categories of traces that the remote logger wishes to receive. This parameter is
    /// ignored if messageTypes is not empty and does not include trace. An empty list means no filtering (send all
    /// trace categories).
    ///
    /// - parameter messageMax: `Swift.Int32` The maximum number of log messages (of all types) to be provided to init. A negative
    /// value requests all messages available.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - RemoteLoggerAlreadyAttachedException - Raised if this remote logger is already attached to this admin
    ///     object.
    func attachRemoteLogger(prx: RemoteLoggerPrx?, messageTypes: LogMessageTypeSeq, traceCategories: StringSeq, messageMax: Swift.Int32, current: Current) async throws

    /// Detaches a RemoteLogger object from the local logger.
    ///
    /// - parameter prx: `RemoteLoggerPrx?` A proxy to the remote logger.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Bool` - True if the provided remote logger proxy was detached, and false otherwise.
    func detachRemoteLogger(prx: RemoteLoggerPrx?, current: Current) async throws -> Swift.Bool

    /// Retrieves log messages recently logged.
    ///
    /// - parameter messageTypes: `LogMessageTypeSeq` The list of message types that the caller wishes to receive. An empty list means no
    /// filtering (send all message types).
    ///
    /// - parameter traceCategories: `StringSeq` The categories of traces that caller wish to receive. This parameter is ignored if
    /// messageTypes is not empty and does not include trace. An empty list means no filtering (send all trace
    /// categories).
    ///
    /// - parameter messageMax: `Swift.Int32` The maximum number of log messages (of all types) to be returned. A negative value
    /// requests all messages available.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: LogMessageSeq, prefix: Swift.String)`:
    ///
    ///   - returnValue: `LogMessageSeq` - The Log messages.
    ///
    ///   - prefix: `Swift.String` - The prefix of the associated local logger.
    func getLog(messageTypes: LogMessageTypeSeq, traceCategories: StringSeq, messageMax: Swift.Int32, current: Current) async throws -> (returnValue: LogMessageSeq, prefix: Swift.String)
}

/// The Ice remote logger interface. An application can implement a RemoteLogger to receive the log messages sent
/// to the local RemoteLogger of another Ice application.
///
/// RemoteLogger Methods:
///
///  - `init`: init is called by attachRemoteLogger when a RemoteLogger proxy is attached.
///
///  - log: Log a LogMessage.
extension RemoteLogger {
    public func _iceD_init(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_prefix: Swift.String = try istr.read()
        let iceP_logMessages: LogMessageSeq = try LogMessageSeqHelper.read(from: istr)
        try await self.`init`(prefix: iceP_prefix, logMessages: iceP_logMessages, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_log(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_message: LogMessage = try istr.read()
        try await self.log(message: iceP_message, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}

/// The interface of the admin object that allows an Ice application the attach its
/// RemoteLogger to the RemoteLogger of this admin object's Ice communicator.
///
/// LoggerAdmin Methods:
///
///  - attachRemoteLogger: Attaches a RemoteLogger object to the local logger.
///
///  - detachRemoteLogger: Detaches a RemoteLogger object from the local logger.
///
///  - getLog: Retrieves log messages recently logged.
extension LoggerAdmin {
    public func _iceD_attachRemoteLogger(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_prx: RemoteLoggerPrx? = try istr.read(RemoteLoggerPrx.self)
        let iceP_messageTypes: LogMessageTypeSeq = try LogMessageTypeSeqHelper.read(from: istr)
        let iceP_traceCategories: StringSeq = try istr.read()
        let iceP_messageMax: Swift.Int32 = try istr.read()
        try await self.attachRemoteLogger(prx: iceP_prx, messageTypes: iceP_messageTypes, traceCategories: iceP_traceCategories, messageMax: iceP_messageMax, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_detachRemoteLogger(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_prx: RemoteLoggerPrx? = try istr.read(RemoteLoggerPrx.self)
        let result = try await self.detachRemoteLogger(prx: iceP_prx, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_getLog(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_messageTypes: LogMessageTypeSeq = try LogMessageTypeSeqHelper.read(from: istr)
        let iceP_traceCategories: StringSeq = try istr.read()
        let iceP_messageMax: Swift.Int32 = try istr.read()
        let result = try await self.getLog(messageTypes: iceP_messageTypes, traceCategories: iceP_traceCategories, messageMax: iceP_messageMax, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_prefix) = value
            ostr.write(iceP_prefix)
            LogMessageSeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }
}
