//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Locator.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation

/// :nodoc:
public class AdapterNotFoundException_TypeResolver: UserExceptionTypeResolver {
    public override func type() -> UserException.Type {
        return AdapterNotFoundException.self
    }
}

public extension ClassResolver {
    @objc static func Ice_AdapterNotFoundException() -> UserExceptionTypeResolver {
        return AdapterNotFoundException_TypeResolver()
    }
}

/// This exception is raised if an adapter cannot be found.
open class AdapterNotFoundException: UserException, @unchecked Sendable {
    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Ice::AdapterNotFoundException" }

    open override func _iceWriteImpl(to ostr: OutputStream) {
        ostr.startSlice(typeId: AdapterNotFoundException.ice_staticId(), compactId: -1, last: true)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }
}

/// :nodoc:
public class InvalidReplicaGroupIdException_TypeResolver: UserExceptionTypeResolver {
    public override func type() -> UserException.Type {
        return InvalidReplicaGroupIdException.self
    }
}

public extension ClassResolver {
    @objc static func Ice_InvalidReplicaGroupIdException() -> UserExceptionTypeResolver {
        return InvalidReplicaGroupIdException_TypeResolver()
    }
}

/// This exception is raised if the replica group provided by the server is invalid.
open class InvalidReplicaGroupIdException: UserException, @unchecked Sendable {
    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Ice::InvalidReplicaGroupIdException" }

    open override func _iceWriteImpl(to ostr: OutputStream) {
        ostr.startSlice(typeId: InvalidReplicaGroupIdException.ice_staticId(), compactId: -1, last: true)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }
}

/// :nodoc:
public class AdapterAlreadyActiveException_TypeResolver: UserExceptionTypeResolver {
    public override func type() -> UserException.Type {
        return AdapterAlreadyActiveException.self
    }
}

public extension ClassResolver {
    @objc static func Ice_AdapterAlreadyActiveException() -> UserExceptionTypeResolver {
        return AdapterAlreadyActiveException_TypeResolver()
    }
}

/// This exception is raised if a server tries to set endpoints for an adapter that is already active.
open class AdapterAlreadyActiveException: UserException, @unchecked Sendable {
    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Ice::AdapterAlreadyActiveException" }

    open override func _iceWriteImpl(to ostr: OutputStream) {
        ostr.startSlice(typeId: AdapterAlreadyActiveException.ice_staticId(), compactId: -1, last: true)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }
}

/// :nodoc:
public class ObjectNotFoundException_TypeResolver: UserExceptionTypeResolver {
    public override func type() -> UserException.Type {
        return ObjectNotFoundException.self
    }
}

public extension ClassResolver {
    @objc static func Ice_ObjectNotFoundException() -> UserExceptionTypeResolver {
        return ObjectNotFoundException_TypeResolver()
    }
}

/// This exception is raised if an object cannot be found.
open class ObjectNotFoundException: UserException, @unchecked Sendable {
    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Ice::ObjectNotFoundException" }

    open override func _iceWriteImpl(to ostr: OutputStream) {
        ostr.startSlice(typeId: ObjectNotFoundException.ice_staticId(), compactId: -1, last: true)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }
}

/// :nodoc:
public class ServerNotFoundException_TypeResolver: UserExceptionTypeResolver {
    public override func type() -> UserException.Type {
        return ServerNotFoundException.self
    }
}

public extension ClassResolver {
    @objc static func Ice_ServerNotFoundException() -> UserExceptionTypeResolver {
        return ServerNotFoundException_TypeResolver()
    }
}

/// This exception is raised if a server cannot be found.
open class ServerNotFoundException: UserException, @unchecked Sendable {
    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Ice::ServerNotFoundException" }

    open override func _iceWriteImpl(to ostr: OutputStream) {
        ostr.startSlice(typeId: ServerNotFoundException.ice_staticId(), compactId: -1, last: true)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }
}

/// Traits for Slice interface`Locator`.
public struct LocatorTraits: SliceTraits {
    public static let staticIds = ["::Ice::Locator", "::Ice::Object"]
    public static let staticId = "::Ice::Locator"
}

/// Traits for Slice interface`LocatorRegistry`.
public struct LocatorRegistryTraits: SliceTraits {
    public static let staticIds = ["::Ice::LocatorRegistry", "::Ice::Object"]
    public static let staticId = "::Ice::LocatorRegistry"
}

/// Traits for Slice interface`LocatorFinder`.
public struct LocatorFinderTraits: SliceTraits {
    public static let staticIds = ["::Ice::LocatorFinder", "::Ice::Object"]
    public static let staticId = "::Ice::LocatorFinder"
}

/// The Ice locator interface. This interface is used by clients to lookup adapters and objects. It is also used by
/// servers to get the locator registry proxy. The Locator interface is intended to be used
/// by Ice internals and by locator implementations. Regular user code should not attempt to use any functionality
/// of this interface directly.
///
/// LocatorPrx Methods:
///
///  - findObjectById: Find an object by identity and return a proxy that contains the adapter ID or endpoints which can be used to access the object.
///
///  - findObjectByIdAsync: Find an object by identity and return a proxy that contains the adapter ID or endpoints which can be used to access the object.
///
///  - findAdapterById: Find an adapter by id and return a proxy that contains its endpoints.
///
///  - findAdapterByIdAsync: Find an adapter by id and return a proxy that contains its endpoints.
///
///  - getRegistry: Get the locator registry.
///
///  - getRegistryAsync: Get the locator registry.
public protocol LocatorPrx: ObjectPrx {}

internal final class LocatorPrxI: ObjectPrxI, LocatorPrx {
    public override class func ice_staticId() -> Swift.String {
        return LocatorTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: LocatorPrx.Protocol) throws -> LocatorPrx {
    try communicator.makeProxyImpl(proxyString) as LocatorPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `LocatorPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `LocatorPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: ObjectPrx, type: LocatorPrx.Protocol, facet: Swift.String? = nil, context: Context? = nil) async throws -> LocatorPrx? {
    return try await LocatorPrxI.checkedCast(prx: prx, facet: facet, context: context) as LocatorPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `LocatorPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `LocatorPrx` - A proxy with the requested type
public func uncheckedCast(prx: ObjectPrx, type: LocatorPrx.Protocol, facet: Swift.String? = nil) -> LocatorPrx {
    return LocatorPrxI.uncheckedCast(prx: prx, facet: facet) as LocatorPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `LocatorPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: LocatorPrx.Protocol) -> Swift.String {
    return LocatorTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `LocatorPrx`.
public extension InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `LocatorPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `LocatorPrx?` - The extracted proxy
    func read(_ type: LocatorPrx.Protocol) throws -> LocatorPrx? {
        return try read() as LocatorPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `LocatorPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `LocatorPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: LocatorPrx.Protocol) throws -> LocatorPrx? {
        return try read(tag: tag) as LocatorPrxI?
    }
}

/// The Ice locator interface. This interface is used by clients to lookup adapters and objects. It is also used by
/// servers to get the locator registry proxy. The Locator interface is intended to be used
/// by Ice internals and by locator implementations. Regular user code should not attempt to use any functionality
/// of this interface directly.
///
/// LocatorPrx Methods:
///
///  - findObjectById: Find an object by identity and return a proxy that contains the adapter ID or endpoints which can be used to access the object.
///
///  - findObjectByIdAsync: Find an object by identity and return a proxy that contains the adapter ID or endpoints which can be used to access the object.
///
///  - findAdapterById: Find an adapter by id and return a proxy that contains its endpoints.
///
///  - findAdapterByIdAsync: Find an adapter by id and return a proxy that contains its endpoints.
///
///  - getRegistry: Get the locator registry.
///
///  - getRegistryAsync: Get the locator registry.
public extension LocatorPrx {
    /// Find an object by identity and return a proxy that contains the adapter ID or endpoints which can be used to
    /// access the object.
    ///
    /// - parameter _: `Identity` The identity.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `ObjectPrx?` - The proxy, or null if the object is not active.
    ///
    /// - throws:
    ///
    ///   - ObjectNotFoundException - Raised if the object cannot be found.
    func findObjectById(_ iceP_id: Identity, context: Context? = nil) async throws -> ObjectPrx? {
        return try await _impl._invoke(operation: "findObjectById",
                                       mode: .Idempotent,
                                       write: { ostr in
                                           ostr.write(iceP_id)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: ObjectPrx? = try istr.read(ObjectPrx.self)
                                           return iceP_returnValue
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as ObjectNotFoundException {
                                               throw error
                                           } catch is UserException {}
                                       },
                                       context: context)
    }

    /// Find an adapter by id and return a proxy that contains its endpoints.
    ///
    /// - parameter _: `Swift.String` The adapter id.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `ObjectPrx?` - The adapter proxy, or null if the adapter is not active.
    ///
    /// - throws:
    ///
    ///   - AdapterNotFoundException - Raised if the adapter cannot be found.
    func findAdapterById(_ iceP_id: Swift.String, context: Context? = nil) async throws -> ObjectPrx? {
        return try await _impl._invoke(operation: "findAdapterById",
                                       mode: .Idempotent,
                                       write: { ostr in
                                           ostr.write(iceP_id)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: ObjectPrx? = try istr.read(ObjectPrx.self)
                                           return iceP_returnValue
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as AdapterNotFoundException {
                                               throw error
                                           } catch is UserException {}
                                       },
                                       context: context)
    }

    /// Get the locator registry.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `LocatorRegistryPrx?` - The locator registry.
    func getRegistry(context: Context? = nil) async throws -> LocatorRegistryPrx? {
        return try await _impl._invoke(operation: "getRegistry",
                                       mode: .Idempotent,
                                       read: { istr in
                                           let iceP_returnValue: LocatorRegistryPrx? = try istr.read(LocatorRegistryPrx.self)
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}

/// The Ice locator registry interface. This interface is used by servers to register adapter endpoints with the
/// locator.  The LocatorRegistry interface is intended to be used by Ice internals and by
/// locator implementations. Regular user code should not attempt to use any functionality of this interface
/// directly.
///
/// LocatorRegistryPrx Methods:
///
///  - setAdapterDirectProxy: Set the adapter endpoints with the locator registry.
///
///  - setAdapterDirectProxyAsync: Set the adapter endpoints with the locator registry.
///
///  - setReplicatedAdapterDirectProxy: Set the adapter endpoints with the locator registry.
///
///  - setReplicatedAdapterDirectProxyAsync: Set the adapter endpoints with the locator registry.
///
///  - setServerProcessProxy: Set the process proxy for a server.
///
///  - setServerProcessProxyAsync: Set the process proxy for a server.
public protocol LocatorRegistryPrx: ObjectPrx {}

internal final class LocatorRegistryPrxI: ObjectPrxI, LocatorRegistryPrx {
    public override class func ice_staticId() -> Swift.String {
        return LocatorRegistryTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: LocatorRegistryPrx.Protocol) throws -> LocatorRegistryPrx {
    try communicator.makeProxyImpl(proxyString) as LocatorRegistryPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `LocatorRegistryPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `LocatorRegistryPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: ObjectPrx, type: LocatorRegistryPrx.Protocol, facet: Swift.String? = nil, context: Context? = nil) async throws -> LocatorRegistryPrx? {
    return try await LocatorRegistryPrxI.checkedCast(prx: prx, facet: facet, context: context) as LocatorRegistryPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `LocatorRegistryPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `LocatorRegistryPrx` - A proxy with the requested type
public func uncheckedCast(prx: ObjectPrx, type: LocatorRegistryPrx.Protocol, facet: Swift.String? = nil) -> LocatorRegistryPrx {
    return LocatorRegistryPrxI.uncheckedCast(prx: prx, facet: facet) as LocatorRegistryPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `LocatorRegistryPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: LocatorRegistryPrx.Protocol) -> Swift.String {
    return LocatorRegistryTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `LocatorRegistryPrx`.
public extension InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `LocatorRegistryPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `LocatorRegistryPrx?` - The extracted proxy
    func read(_ type: LocatorRegistryPrx.Protocol) throws -> LocatorRegistryPrx? {
        return try read() as LocatorRegistryPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `LocatorRegistryPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `LocatorRegistryPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: LocatorRegistryPrx.Protocol) throws -> LocatorRegistryPrx? {
        return try read(tag: tag) as LocatorRegistryPrxI?
    }
}

/// The Ice locator registry interface. This interface is used by servers to register adapter endpoints with the
/// locator.  The LocatorRegistry interface is intended to be used by Ice internals and by
/// locator implementations. Regular user code should not attempt to use any functionality of this interface
/// directly.
///
/// LocatorRegistryPrx Methods:
///
///  - setAdapterDirectProxy: Set the adapter endpoints with the locator registry.
///
///  - setAdapterDirectProxyAsync: Set the adapter endpoints with the locator registry.
///
///  - setReplicatedAdapterDirectProxy: Set the adapter endpoints with the locator registry.
///
///  - setReplicatedAdapterDirectProxyAsync: Set the adapter endpoints with the locator registry.
///
///  - setServerProcessProxy: Set the process proxy for a server.
///
///  - setServerProcessProxyAsync: Set the process proxy for a server.
public extension LocatorRegistryPrx {
    /// Set the adapter endpoints with the locator registry.
    ///
    /// - parameter id: `Swift.String` The adapter id.
    ///
    /// - parameter proxy: `ObjectPrx?` The adapter proxy (a dummy direct proxy created by the adapter). The direct proxy contains the
    /// adapter endpoints. The proxy can be null, typically during adapter deactivation.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - AdapterAlreadyActiveException - Raised if an adapter with the same id is already active.
    ///
    ///   - AdapterNotFoundException - Raised if the adapter cannot be found, or if the locator only allows
    ///     registered adapters to set their active proxy and the adapter is not registered with the locator.
    func setAdapterDirectProxy(id iceP_id: Swift.String, proxy iceP_proxy: ObjectPrx?, context: Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "setAdapterDirectProxy",
                                       mode: .Idempotent,
                                       write: { ostr in
                                           ostr.write(iceP_id)
                                           ostr.write(iceP_proxy)
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as AdapterNotFoundException {
                                               throw error
                                           } catch let error as AdapterAlreadyActiveException {
                                               throw error
                                           } catch is UserException {}
                                       },
                                       context: context)
    }

    /// Set the adapter endpoints with the locator registry.
    ///
    /// - parameter adapterId: `Swift.String` The adapter id.
    ///
    /// - parameter replicaGroupId: `Swift.String` The replica group id.
    ///
    /// - parameter proxy: `ObjectPrx?` The adapter proxy (a dummy direct proxy created by the adapter). The direct proxy contains the
    /// adapter endpoints. The proxy can be null, typically during adapter deactivation.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - AdapterAlreadyActiveException - Raised if an adapter with the same id is already active.
    ///
    ///   - AdapterNotFoundException - Raised if the adapter cannot be found, or if the locator only allows
    ///     registered adapters to set their active proxy and the adapter is not registered with the locator.
    ///
    ///   - InvalidReplicaGroupIdException - Raised if the given replica group doesn't match the one registered
    ///     with the locator registry for this object adapter.
    func setReplicatedAdapterDirectProxy(adapterId iceP_adapterId: Swift.String, replicaGroupId iceP_replicaGroupId: Swift.String, proxy iceP_proxy: ObjectPrx?, context: Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "setReplicatedAdapterDirectProxy",
                                       mode: .Idempotent,
                                       write: { ostr in
                                           ostr.write(iceP_adapterId)
                                           ostr.write(iceP_replicaGroupId)
                                           ostr.write(iceP_proxy)
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as AdapterNotFoundException {
                                               throw error
                                           } catch let error as InvalidReplicaGroupIdException {
                                               throw error
                                           } catch let error as AdapterAlreadyActiveException {
                                               throw error
                                           } catch is UserException {}
                                       },
                                       context: context)
    }

    /// Set the process proxy for a server.
    ///
    /// - parameter id: `Swift.String` The server id.
    ///
    /// - parameter proxy: `ProcessPrx?` The process proxy. The proxy is never null.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - ServerNotFoundException - Raised if the server cannot be found.
    func setServerProcessProxy(id iceP_id: Swift.String, proxy iceP_proxy: ProcessPrx?, context: Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "setServerProcessProxy",
                                       mode: .Idempotent,
                                       write: { ostr in
                                           ostr.write(iceP_id)
                                           ostr.write(iceP_proxy)
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as ServerNotFoundException {
                                               throw error
                                           } catch is UserException {}
                                       },
                                       context: context)
    }
}

/// This interface should be implemented by services implementing the Ice::Locator interface. It should
/// be advertised through an Ice object with the identity `Ice/LocatorFinder'. This allows clients to
/// retrieve the locator proxy with just the endpoint information of the service.
///
/// LocatorFinderPrx Methods:
///
///  - getLocator: Get the locator proxy implemented by the process hosting this finder object.
///
///  - getLocatorAsync: Get the locator proxy implemented by the process hosting this finder object.
public protocol LocatorFinderPrx: ObjectPrx {}

internal final class LocatorFinderPrxI: ObjectPrxI, LocatorFinderPrx {
    public override class func ice_staticId() -> Swift.String {
        return LocatorFinderTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: LocatorFinderPrx.Protocol) throws -> LocatorFinderPrx {
    try communicator.makeProxyImpl(proxyString) as LocatorFinderPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `LocatorFinderPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `LocatorFinderPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: ObjectPrx, type: LocatorFinderPrx.Protocol, facet: Swift.String? = nil, context: Context? = nil) async throws -> LocatorFinderPrx? {
    return try await LocatorFinderPrxI.checkedCast(prx: prx, facet: facet, context: context) as LocatorFinderPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `LocatorFinderPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `LocatorFinderPrx` - A proxy with the requested type
public func uncheckedCast(prx: ObjectPrx, type: LocatorFinderPrx.Protocol, facet: Swift.String? = nil) -> LocatorFinderPrx {
    return LocatorFinderPrxI.uncheckedCast(prx: prx, facet: facet) as LocatorFinderPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `LocatorFinderPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: LocatorFinderPrx.Protocol) -> Swift.String {
    return LocatorFinderTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `LocatorFinderPrx`.
public extension InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `LocatorFinderPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `LocatorFinderPrx?` - The extracted proxy
    func read(_ type: LocatorFinderPrx.Protocol) throws -> LocatorFinderPrx? {
        return try read() as LocatorFinderPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `LocatorFinderPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `LocatorFinderPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: LocatorFinderPrx.Protocol) throws -> LocatorFinderPrx? {
        return try read(tag: tag) as LocatorFinderPrxI?
    }
}

/// This interface should be implemented by services implementing the Ice::Locator interface. It should
/// be advertised through an Ice object with the identity `Ice/LocatorFinder'. This allows clients to
/// retrieve the locator proxy with just the endpoint information of the service.
///
/// LocatorFinderPrx Methods:
///
///  - getLocator: Get the locator proxy implemented by the process hosting this finder object.
///
///  - getLocatorAsync: Get the locator proxy implemented by the process hosting this finder object.
public extension LocatorFinderPrx {
    /// Get the locator proxy implemented by the process hosting this finder object. The proxy might point to
    /// several replicas. This proxy is never null.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `LocatorPrx?` - The locator proxy.
    func getLocator(context: Context? = nil) async throws -> LocatorPrx? {
        return try await _impl._invoke(operation: "getLocator",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: LocatorPrx? = try istr.read(LocatorPrx.self)
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}


/// Dispatcher for `Locator` servants.
public struct LocatorDisp: Ice.Dispatcher {
    public let servant: Locator
    private static let defaultObject = ObjectI<LocatorTraits>()

    public init(_ servant: Locator) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "findAdapterById":
            try await servant._iceD_findAdapterById(request)
        case "findObjectById":
            try await servant._iceD_findObjectById(request)
        case "getRegistry":
            try await servant._iceD_getRegistry(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? LocatorDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? LocatorDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? LocatorDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? LocatorDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

/// The Ice locator interface. This interface is used by clients to lookup adapters and objects. It is also used by
/// servers to get the locator registry proxy. The Locator interface is intended to be used
/// by Ice internals and by locator implementations. Regular user code should not attempt to use any functionality
/// of this interface directly.
public protocol Locator {
    /// Find an object by identity and return a proxy that contains the adapter ID or endpoints which can be used to
    /// access the object.
    ///
    /// - parameter id: `Identity` The identity.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `ObjectPrx?` - The proxy, or null if the object is not active.
    ///
    /// - throws:
    ///
    ///   - ObjectNotFoundException - Raised if the object cannot be found.
    func findObjectById(id: Identity, current: Current) async throws -> ObjectPrx?

    /// Find an adapter by id and return a proxy that contains its endpoints.
    ///
    /// - parameter id: `Swift.String` The adapter id.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `ObjectPrx?` - The adapter proxy, or null if the adapter is not active.
    ///
    /// - throws:
    ///
    ///   - AdapterNotFoundException - Raised if the adapter cannot be found.
    func findAdapterById(id: Swift.String, current: Current) async throws -> ObjectPrx?

    /// Get the locator registry.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `LocatorRegistryPrx?` - The locator registry.
    func getRegistry(current: Current) async throws -> LocatorRegistryPrx?
}


/// Dispatcher for `LocatorRegistry` servants.
public struct LocatorRegistryDisp: Ice.Dispatcher {
    public let servant: LocatorRegistry
    private static let defaultObject = ObjectI<LocatorRegistryTraits>()

    public init(_ servant: LocatorRegistry) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "ice_id":
            try await (servant as? Ice.Object ?? LocatorRegistryDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? LocatorRegistryDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? LocatorRegistryDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? LocatorRegistryDisp.defaultObject)._iceD_ice_ping(request)
        case "setAdapterDirectProxy":
            try await servant._iceD_setAdapterDirectProxy(request)
        case "setReplicatedAdapterDirectProxy":
            try await servant._iceD_setReplicatedAdapterDirectProxy(request)
        case "setServerProcessProxy":
            try await servant._iceD_setServerProcessProxy(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

/// The Ice locator registry interface. This interface is used by servers to register adapter endpoints with the
/// locator.  The LocatorRegistry interface is intended to be used by Ice internals and by
/// locator implementations. Regular user code should not attempt to use any functionality of this interface
/// directly.
public protocol LocatorRegistry {
    /// Set the adapter endpoints with the locator registry.
    ///
    /// - parameter id: `Swift.String` The adapter id.
    ///
    /// - parameter proxy: `ObjectPrx?` The adapter proxy (a dummy direct proxy created by the adapter). The direct proxy contains the
    /// adapter endpoints. The proxy can be null, typically during adapter deactivation.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - AdapterAlreadyActiveException - Raised if an adapter with the same id is already active.
    ///
    ///   - AdapterNotFoundException - Raised if the adapter cannot be found, or if the locator only allows
    ///     registered adapters to set their active proxy and the adapter is not registered with the locator.
    func setAdapterDirectProxy(id: Swift.String, proxy: ObjectPrx?, current: Current) async throws

    /// Set the adapter endpoints with the locator registry.
    ///
    /// - parameter adapterId: `Swift.String` The adapter id.
    ///
    /// - parameter replicaGroupId: `Swift.String` The replica group id.
    ///
    /// - parameter proxy: `ObjectPrx?` The adapter proxy (a dummy direct proxy created by the adapter). The direct proxy contains the
    /// adapter endpoints. The proxy can be null, typically during adapter deactivation.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - AdapterAlreadyActiveException - Raised if an adapter with the same id is already active.
    ///
    ///   - AdapterNotFoundException - Raised if the adapter cannot be found, or if the locator only allows
    ///     registered adapters to set their active proxy and the adapter is not registered with the locator.
    ///
    ///   - InvalidReplicaGroupIdException - Raised if the given replica group doesn't match the one registered
    ///     with the locator registry for this object adapter.
    func setReplicatedAdapterDirectProxy(adapterId: Swift.String, replicaGroupId: Swift.String, proxy: ObjectPrx?, current: Current) async throws

    /// Set the process proxy for a server.
    ///
    /// - parameter id: `Swift.String` The server id.
    ///
    /// - parameter proxy: `ProcessPrx?` The process proxy. The proxy is never null.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - ServerNotFoundException - Raised if the server cannot be found.
    func setServerProcessProxy(id: Swift.String, proxy: ProcessPrx?, current: Current) async throws
}


/// Dispatcher for `LocatorFinder` servants.
public struct LocatorFinderDisp: Ice.Dispatcher {
    public let servant: LocatorFinder
    private static let defaultObject = ObjectI<LocatorFinderTraits>()

    public init(_ servant: LocatorFinder) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "getLocator":
            try await servant._iceD_getLocator(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? LocatorFinderDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? LocatorFinderDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? LocatorFinderDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? LocatorFinderDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

/// This interface should be implemented by services implementing the Ice::Locator interface. It should
/// be advertised through an Ice object with the identity `Ice/LocatorFinder'. This allows clients to
/// retrieve the locator proxy with just the endpoint information of the service.
public protocol LocatorFinder {
    /// Get the locator proxy implemented by the process hosting this finder object. The proxy might point to
    /// several replicas. This proxy is never null.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `LocatorPrx?` - The locator proxy.
    func getLocator(current: Current) async throws -> LocatorPrx?
}

/// The Ice locator interface. This interface is used by clients to lookup adapters and objects. It is also used by
/// servers to get the locator registry proxy. The Locator interface is intended to be used
/// by Ice internals and by locator implementations. Regular user code should not attempt to use any functionality
/// of this interface directly.
///
/// Locator Methods:
///
///  - findObjectById: Find an object by identity and return a proxy that contains the adapter ID or endpoints which can be used to access the object.
///
///  - findAdapterById: Find an adapter by id and return a proxy that contains its endpoints.
///
///  - getRegistry: Get the locator registry.
extension Locator {
    public func _iceD_findObjectById(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_id: Identity = try istr.read()
        let result = try await self.findObjectById(id: iceP_id, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_findAdapterById(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_id: Swift.String = try istr.read()
        let result = try await self.findAdapterById(id: iceP_id, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_getRegistry(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getRegistry(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }
}

/// The Ice locator registry interface. This interface is used by servers to register adapter endpoints with the
/// locator.  The LocatorRegistry interface is intended to be used by Ice internals and by
/// locator implementations. Regular user code should not attempt to use any functionality of this interface
/// directly.
///
/// LocatorRegistry Methods:
///
///  - setAdapterDirectProxy: Set the adapter endpoints with the locator registry.
///
///  - setReplicatedAdapterDirectProxy: Set the adapter endpoints with the locator registry.
///
///  - setServerProcessProxy: Set the process proxy for a server.
extension LocatorRegistry {
    public func _iceD_setAdapterDirectProxy(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_id: Swift.String = try istr.read()
        let iceP_proxy: ObjectPrx? = try istr.read(ObjectPrx.self)
        try await self.setAdapterDirectProxy(id: iceP_id, proxy: iceP_proxy, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_setReplicatedAdapterDirectProxy(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_adapterId: Swift.String = try istr.read()
        let iceP_replicaGroupId: Swift.String = try istr.read()
        let iceP_proxy: ObjectPrx? = try istr.read(ObjectPrx.self)
        try await self.setReplicatedAdapterDirectProxy(adapterId: iceP_adapterId, replicaGroupId: iceP_replicaGroupId, proxy: iceP_proxy, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_setServerProcessProxy(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_id: Swift.String = try istr.read()
        let iceP_proxy: ProcessPrx? = try istr.read(ProcessPrx.self)
        try await self.setServerProcessProxy(id: iceP_id, proxy: iceP_proxy, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}

/// This interface should be implemented by services implementing the Ice::Locator interface. It should
/// be advertised through an Ice object with the identity `Ice/LocatorFinder'. This allows clients to
/// retrieve the locator proxy with just the endpoint information of the service.
///
/// LocatorFinder Methods:
///
///  - getLocator: Get the locator proxy implemented by the process hosting this finder object.
extension LocatorFinder {
    public func _iceD_getLocator(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getLocator(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }
}
