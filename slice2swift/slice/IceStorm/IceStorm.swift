//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `IceStorm.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice

/// Information on the topic links.
public struct LinkInfo {
    /// The linked topic. It is never null.
    public var theTopic: TopicPrx? = nil
    /// The name of the linked topic.
    public var name: Swift.String = ""
    /// The cost of traversing this link.
    public var cost: Swift.Int32 = 0

    public init() {}

    public init(theTopic: TopicPrx?, name: Swift.String, cost: Swift.Int32) {
        self.theTopic = theTopic
        self.name = name
        self.cost = cost
    }
}

/// An `Ice.InputStream` extension to read `LinkInfo` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `LinkInfo` structured value from the stream.
    ///
    /// - returns: `LinkInfo` - The structured value read from the stream.
    func read() throws -> LinkInfo {
        var v = LinkInfo()
        v.theTopic = try self.read(TopicPrx.self)
        v.name = try self.read()
        v.cost = try self.read()
        return v
    }

    /// Read an optional `LinkInfo?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LinkInfo?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> LinkInfo? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as LinkInfo
    }
}

/// An `Ice.OutputStream` extension to write `LinkInfo` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `LinkInfo` structured value to the stream.
    ///
    /// - parameter _: `LinkInfo` - The value to write to the stream.
    func write(_ v: LinkInfo) {
        self.write(v.theTopic)
        self.write(v.name)
        self.write(v.cost)
    }

    /// Write an optional `LinkInfo?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LinkInfo?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: LinkInfo?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// A sequence of LinkInfo objects.
public typealias LinkInfoSeq = [LinkInfo]

/// Helper class to read and write `LinkInfoSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LinkInfoSeqHelper {
    /// Read a `LinkInfoSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `LinkInfoSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LinkInfoSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 7)
        var v = LinkInfoSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: LinkInfo = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `LinkInfoSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LinkInfoSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LinkInfoSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `LinkInfoSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `LinkInfoSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LinkInfoSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `LinkInfoSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LinkInfoSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: LinkInfoSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// This dictionary represents quality of service parameters.
public typealias QoS = [Swift.String: Swift.String]

/// Helper class to read and write `QoS` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct QoSHelper {
    /// Read a `QoS` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `QoS` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> QoS {
        let sz = try Swift.Int(istr.readSize())
        var v = QoS()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: Swift.String = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `QoS?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `QoS` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> QoS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `QoS` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `QoS` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: QoS) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `QoS?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `QoS` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: QoS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// :nodoc:
public class LinkExists_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return LinkExists.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceStorm_LinkExists() -> Ice.UserExceptionTypeResolver {
        return LinkExists_TypeResolver()
    }
}

/// This exception indicates that an attempt was made to create a link that already exists.
open class LinkExists: Ice.UserException, @unchecked Sendable {
    /// The name of the linked topic.
    public var name: Swift.String = ""

    public required init() {}

    public init(name: Swift.String) {
        self.name = name
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::IceStorm::LinkExists" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: LinkExists.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.name)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.name = try istr.read()
        try istr.endSlice()
    }
}

/// :nodoc:
public class NoSuchLink_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return NoSuchLink.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceStorm_NoSuchLink() -> Ice.UserExceptionTypeResolver {
        return NoSuchLink_TypeResolver()
    }
}

/// This exception indicates that an attempt was made to remove a link that does not exist.
open class NoSuchLink: Ice.UserException, @unchecked Sendable {
    /// The name of the link that does not exist.
    public var name: Swift.String = ""

    public required init() {}

    public init(name: Swift.String) {
        self.name = name
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::IceStorm::NoSuchLink" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: NoSuchLink.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.name)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.name = try istr.read()
        try istr.endSlice()
    }
}

/// :nodoc:
public class AlreadySubscribed_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return AlreadySubscribed.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceStorm_AlreadySubscribed() -> Ice.UserExceptionTypeResolver {
        return AlreadySubscribed_TypeResolver()
    }
}

/// This exception indicates that an attempt was made to subscribe a proxy for which a subscription already exists.
open class AlreadySubscribed: Ice.UserException, @unchecked Sendable {
    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::IceStorm::AlreadySubscribed" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: AlreadySubscribed.ice_staticId(), compactId: -1, last: true)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }
}

/// :nodoc:
public class InvalidSubscriber_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return InvalidSubscriber.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceStorm_InvalidSubscriber() -> Ice.UserExceptionTypeResolver {
        return InvalidSubscriber_TypeResolver()
    }
}

/// This exception indicates that an attempt was made to subscribe a proxy that is null.
open class InvalidSubscriber: Ice.UserException, @unchecked Sendable {
    /// The reason for the failure.
    public var reason: Swift.String = ""

    public required init() {}

    public init(reason: Swift.String) {
        self.reason = reason
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::IceStorm::InvalidSubscriber" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: InvalidSubscriber.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.reason)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.reason = try istr.read()
        try istr.endSlice()
    }
}

/// :nodoc:
public class BadQoS_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return BadQoS.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceStorm_BadQoS() -> Ice.UserExceptionTypeResolver {
        return BadQoS_TypeResolver()
    }
}

/// This exception indicates that a subscription failed due to an invalid QoS.
open class BadQoS: Ice.UserException, @unchecked Sendable {
    /// The reason for the failure.
    public var reason: Swift.String = ""

    public required init() {}

    public init(reason: Swift.String) {
        self.reason = reason
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::IceStorm::BadQoS" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: BadQoS.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.reason)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.reason = try istr.read()
        try istr.endSlice()
    }
}

/// Traits for Slice interface`Topic`.
public struct TopicTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceStorm::Topic"]
    public static let staticId = "::IceStorm::Topic"
}

/// Mapping of topic name to topic proxy.
public typealias TopicDict = [Swift.String: TopicPrx?]

/// Helper class to read and write `TopicDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct TopicDictHelper {
    /// Read a `TopicDict` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `TopicDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> TopicDict {
        let sz = try Swift.Int(istr.readSize())
        var v = TopicDict()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: TopicPrx? = try istr.read(TopicPrx.self)
            v[key] = value
        }
        return v
    }
    /// Read an optional `TopicDict?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `TopicDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> TopicDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `TopicDict` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `TopicDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: TopicDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `TopicDict?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `TopicDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: TopicDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// :nodoc:
public class TopicExists_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return TopicExists.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceStorm_TopicExists() -> Ice.UserExceptionTypeResolver {
        return TopicExists_TypeResolver()
    }
}

/// This exception indicates that an attempt was made to create a topic that already exists.
open class TopicExists: Ice.UserException, @unchecked Sendable {
    /// The name of the topic that already exists.
    public var name: Swift.String = ""

    public required init() {}

    public init(name: Swift.String) {
        self.name = name
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::IceStorm::TopicExists" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: TopicExists.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.name)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.name = try istr.read()
        try istr.endSlice()
    }
}

/// :nodoc:
public class NoSuchTopic_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return NoSuchTopic.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceStorm_NoSuchTopic() -> Ice.UserExceptionTypeResolver {
        return NoSuchTopic_TypeResolver()
    }
}

/// This exception indicates that an attempt was made to retrieve a topic that does not exist.
open class NoSuchTopic: Ice.UserException, @unchecked Sendable {
    /// The name of the topic that does not exist.
    public var name: Swift.String = ""

    public required init() {}

    public init(name: Swift.String) {
        self.name = name
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::IceStorm::NoSuchTopic" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: NoSuchTopic.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.name)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.name = try istr.read()
        try istr.endSlice()
    }
}

/// Traits for Slice interface`TopicManager`.
public struct TopicManagerTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceStorm::TopicManager"]
    public static let staticId = "::IceStorm::TopicManager"
}

/// Traits for Slice interface`Finder`.
public struct FinderTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceStorm::Finder"]
    public static let staticId = "::IceStorm::Finder"
}

/// Publishers publish information on a particular topic. A topic logically represents a type. A
///
/// TopicPrx Methods:
///
///  - getName: Get the name of this topic.
///
///  - getNameAsync: Get the name of this topic.
///
///  - getPublisher: Get a proxy to a publisher object for this topic.
///
///  - getPublisherAsync: Get a proxy to a publisher object for this topic.
///
///  - getNonReplicatedPublisher: Get a non-replicated proxy to a publisher object for this topic.
///
///  - getNonReplicatedPublisherAsync: Get a non-replicated proxy to a publisher object for this topic.
///
///  - subscribeAndGetPublisher: Subscribe with the given qos to this topic.
///
///  - subscribeAndGetPublisherAsync: Subscribe with the given qos to this topic.
///
///  - unsubscribe: Unsubscribe the given subscriber.
///
///  - unsubscribeAsync: Unsubscribe the given subscriber.
///
///  - link: Create a link to the given topic.
///
///  - linkAsync: Create a link to the given topic.
///
///  - unlink: Destroy the link from this topic to the given topic linkTo.
///
///  - unlinkAsync: Destroy the link from this topic to the given topic linkTo.
///
///  - getLinkInfoSeq: Retrieve information on the current links.
///
///  - getLinkInfoSeqAsync: Retrieve information on the current links.
///
///  - getSubscribers: Retrieve the list of subscribers for this topic.
///
///  - getSubscribersAsync: Retrieve the list of subscribers for this topic.
///
///  - destroy: Destroy the topic.
///
///  - destroyAsync: Destroy the topic.
public protocol TopicPrx: Ice.ObjectPrx {}

private final class TopicPrxI: Ice.ObjectPrxI, TopicPrx {
    public override class func ice_staticId() -> Swift.String {
        return TopicTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: TopicPrx.Protocol) throws -> TopicPrx {
    try communicator.makeProxyImpl(proxyString) as TopicPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `TopicPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `TopicPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: TopicPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> TopicPrx? {
    return try await TopicPrxI.checkedCast(prx: prx, facet: facet, context: context) as TopicPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `TopicPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `TopicPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: TopicPrx.Protocol, facet: Swift.String? = nil) -> TopicPrx {
    return TopicPrxI.uncheckedCast(prx: prx, facet: facet) as TopicPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `TopicPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: TopicPrx.Protocol) -> Swift.String {
    return TopicTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `TopicPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `TopicPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `TopicPrx?` - The extracted proxy
    func read(_ type: TopicPrx.Protocol) throws -> TopicPrx? {
        return try read() as TopicPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `TopicPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `TopicPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: TopicPrx.Protocol) throws -> TopicPrx? {
        return try read(tag: tag) as TopicPrxI?
    }
}

/// Publishers publish information on a particular topic. A topic logically represents a type. A
///
/// TopicPrx Methods:
///
///  - getName: Get the name of this topic.
///
///  - getNameAsync: Get the name of this topic.
///
///  - getPublisher: Get a proxy to a publisher object for this topic.
///
///  - getPublisherAsync: Get a proxy to a publisher object for this topic.
///
///  - getNonReplicatedPublisher: Get a non-replicated proxy to a publisher object for this topic.
///
///  - getNonReplicatedPublisherAsync: Get a non-replicated proxy to a publisher object for this topic.
///
///  - subscribeAndGetPublisher: Subscribe with the given qos to this topic.
///
///  - subscribeAndGetPublisherAsync: Subscribe with the given qos to this topic.
///
///  - unsubscribe: Unsubscribe the given subscriber.
///
///  - unsubscribeAsync: Unsubscribe the given subscriber.
///
///  - link: Create a link to the given topic.
///
///  - linkAsync: Create a link to the given topic.
///
///  - unlink: Destroy the link from this topic to the given topic linkTo.
///
///  - unlinkAsync: Destroy the link from this topic to the given topic linkTo.
///
///  - getLinkInfoSeq: Retrieve information on the current links.
///
///  - getLinkInfoSeqAsync: Retrieve information on the current links.
///
///  - getSubscribers: Retrieve the list of subscribers for this topic.
///
///  - getSubscribersAsync: Retrieve the list of subscribers for this topic.
///
///  - destroy: Destroy the topic.
///
///  - destroyAsync: Destroy the topic.
public extension TopicPrx {
    /// Get the name of this topic.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String` - The name of the topic.
    func getName(context: Ice.Context? = nil) async throws -> Swift.String {
        return try await _impl._invoke(operation: "getName",
                                       mode: .Idempotent,
                                       read: { istr in
                                           let iceP_returnValue: Swift.String = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    /// Get a proxy to a publisher object for this topic. To publish data to a topic, the publisher calls getPublisher
    /// and then creates a proxy with the publisher type from this proxy. If a replicated IceStorm
    /// deployment is used this call may return a replicated proxy. The returned proxy is never null.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.ObjectPrx?` - A proxy to publish data on this topic.
    func getPublisher(context: Ice.Context? = nil) async throws -> Ice.ObjectPrx? {
        return try await _impl._invoke(operation: "getPublisher",
                                       mode: .Idempotent,
                                       read: { istr in
                                           let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    /// Get a non-replicated proxy to a publisher object for this topic. To publish data to a topic, the publisher
    /// calls getPublisher and then creates a proxy with the publisher type from this proxy. The returned proxy is
    /// never null.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.ObjectPrx?` - A proxy to publish data on this topic.
    func getNonReplicatedPublisher(context: Ice.Context? = nil) async throws -> Ice.ObjectPrx? {
        return try await _impl._invoke(operation: "getNonReplicatedPublisher",
                                       mode: .Idempotent,
                                       read: { istr in
                                           let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    /// Subscribe with the given qos to this topic.  A per-subscriber publisher object is returned.
    ///
    /// - parameter theQoS: `QoS` The quality of service parameters for this subscription.
    ///
    /// - parameter subscriber: `Ice.ObjectPrx?` The subscriber's proxy. This proxy is never null.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.ObjectPrx?` - The per-subscriber publisher object. The returned object is never null.
    ///
    /// - throws:
    ///
    ///   - AlreadySubscribed - Raised if the subscriber object is already subscribed.
    ///
    ///   - BadQoS - Raised if the requested quality of service is unavailable or invalid.
    ///
    ///   - InvalidSubscriber - Raised if the subscriber object is null.
    func subscribeAndGetPublisher(theQoS iceP_theQoS: QoS, subscriber iceP_subscriber: Ice.ObjectPrx?, context: Ice.Context? = nil) async throws -> Ice.ObjectPrx? {
        return try await _impl._invoke(operation: "subscribeAndGetPublisher",
                                       mode: .Normal,
                                       write: { ostr in
                                           QoSHelper.write(to: ostr, value: iceP_theQoS)
                                           ostr.write(iceP_subscriber)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                           return iceP_returnValue
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as AlreadySubscribed {
                                               throw error
                                           } catch let error as InvalidSubscriber {
                                               throw error
                                           } catch let error as BadQoS {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    /// Unsubscribe the given subscriber.
    ///
    /// - parameter _: `Ice.ObjectPrx?` The proxy of an existing subscriber. This proxy is never null.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func unsubscribe(_ iceP_subscriber: Ice.ObjectPrx?, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "unsubscribe",
                                       mode: .Idempotent,
                                       write: { ostr in
                                           ostr.write(iceP_subscriber)
                                       },
                                       context: context)
    }

    /// Create a link to the given topic. All events originating on this topic will also be sent to
    /// linkTo.
    ///
    /// - parameter linkTo: `TopicPrx?` The topic to link to. This proxy is never null.
    ///
    /// - parameter cost: `Swift.Int32` The cost to the linked topic.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - LinkExists - Raised if a link to the same topic already exists.
    func link(linkTo iceP_linkTo: TopicPrx?, cost iceP_cost: Swift.Int32, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "link",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_linkTo)
                                           ostr.write(iceP_cost)
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as LinkExists {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    /// Destroy the link from this topic to the given topic linkTo.
    ///
    /// - parameter _: `TopicPrx?` The topic to destroy the link to. This proxy is never null.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - NoSuchLink - Raised if a link to the topic does not exist.
    func unlink(_ iceP_linkTo: TopicPrx?, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "unlink",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_linkTo)
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as NoSuchLink {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    /// Retrieve information on the current links.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `LinkInfoSeq` - A sequence of LinkInfo objects.
    func getLinkInfoSeq(context: Ice.Context? = nil) async throws -> LinkInfoSeq {
        return try await _impl._invoke(operation: "getLinkInfoSeq",
                                       mode: .Idempotent,
                                       read: { istr in
                                           let iceP_returnValue: LinkInfoSeq = try LinkInfoSeqHelper.read(from: istr)
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    /// Retrieve the list of subscribers for this topic.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.IdentitySeq` - The sequence of Ice identities for the subscriber objects.
    func getSubscribers(context: Ice.Context? = nil) async throws -> Ice.IdentitySeq {
        return try await _impl._invoke(operation: "getSubscribers",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: Ice.IdentitySeq = try Ice.IdentitySeqHelper.read(from: istr)
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    /// Destroy the topic.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func destroy(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "destroy",
                                       mode: .Normal,
                                       context: context)
    }
}

/// A topic manager manages topics, and subscribers to topics.
///
/// TopicManagerPrx Methods:
///
///  - create: Create a new topic.
///
///  - createAsync: Create a new topic.
///
///  - retrieve: Retrieve a topic by name.
///
///  - retrieveAsync: Retrieve a topic by name.
///
///  - retrieveAll: Retrieve all topics managed by this topic manager.
///
///  - retrieveAllAsync: Retrieve all topics managed by this topic manager.
public protocol TopicManagerPrx: Ice.ObjectPrx {}

private final class TopicManagerPrxI: Ice.ObjectPrxI, TopicManagerPrx {
    public override class func ice_staticId() -> Swift.String {
        return TopicManagerTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: TopicManagerPrx.Protocol) throws -> TopicManagerPrx {
    try communicator.makeProxyImpl(proxyString) as TopicManagerPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `TopicManagerPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `TopicManagerPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: TopicManagerPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> TopicManagerPrx? {
    return try await TopicManagerPrxI.checkedCast(prx: prx, facet: facet, context: context) as TopicManagerPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `TopicManagerPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `TopicManagerPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: TopicManagerPrx.Protocol, facet: Swift.String? = nil) -> TopicManagerPrx {
    return TopicManagerPrxI.uncheckedCast(prx: prx, facet: facet) as TopicManagerPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `TopicManagerPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: TopicManagerPrx.Protocol) -> Swift.String {
    return TopicManagerTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `TopicManagerPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `TopicManagerPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `TopicManagerPrx?` - The extracted proxy
    func read(_ type: TopicManagerPrx.Protocol) throws -> TopicManagerPrx? {
        return try read() as TopicManagerPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `TopicManagerPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `TopicManagerPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: TopicManagerPrx.Protocol) throws -> TopicManagerPrx? {
        return try read(tag: tag) as TopicManagerPrxI?
    }
}

/// A topic manager manages topics, and subscribers to topics.
///
/// TopicManagerPrx Methods:
///
///  - create: Create a new topic.
///
///  - createAsync: Create a new topic.
///
///  - retrieve: Retrieve a topic by name.
///
///  - retrieveAsync: Retrieve a topic by name.
///
///  - retrieveAll: Retrieve all topics managed by this topic manager.
///
///  - retrieveAllAsync: Retrieve all topics managed by this topic manager.
public extension TopicManagerPrx {
    /// Create a new topic. The topic name must be unique.
    ///
    /// - parameter _: `Swift.String` The name of the topic.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `TopicPrx?` - A proxy to the topic instance. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - TopicExists - Raised if a topic with the same name already exists.
    func create(_ iceP_name: Swift.String, context: Ice.Context? = nil) async throws -> TopicPrx? {
        return try await _impl._invoke(operation: "create",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_name)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: TopicPrx? = try istr.read(TopicPrx.self)
                                           return iceP_returnValue
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as TopicExists {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    /// Retrieve a topic by name.
    ///
    /// - parameter _: `Swift.String` The name of the topic.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `TopicPrx?` - A proxy to the topic instance. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - NoSuchTopic - Raised if the topic does not exist.
    func retrieve(_ iceP_name: Swift.String, context: Ice.Context? = nil) async throws -> TopicPrx? {
        return try await _impl._invoke(operation: "retrieve",
                                       mode: .Idempotent,
                                       write: { ostr in
                                           ostr.write(iceP_name)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: TopicPrx? = try istr.read(TopicPrx.self)
                                           return iceP_returnValue
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as NoSuchTopic {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    /// Retrieve all topics managed by this topic manager.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `TopicDict` - A dictionary of string, topic proxy pairs.
    func retrieveAll(context: Ice.Context? = nil) async throws -> TopicDict {
        return try await _impl._invoke(operation: "retrieveAll",
                                       mode: .Idempotent,
                                       read: { istr in
                                           let iceP_returnValue: TopicDict = try TopicDictHelper.read(from: istr)
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}

/// This interface is advertised by the IceStorm service through the Ice object with the identity `IceStorm/Finder'.
/// This allows clients to retrieve the topic manager with just the endpoint information of the IceStorm service.
///
/// FinderPrx Methods:
///
///  - getTopicManager: Get the topic manager proxy.
///
///  - getTopicManagerAsync: Get the topic manager proxy.
public protocol FinderPrx: Ice.ObjectPrx {}

private final class FinderPrxI: Ice.ObjectPrxI, FinderPrx {
    public override class func ice_staticId() -> Swift.String {
        return FinderTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: FinderPrx.Protocol) throws -> FinderPrx {
    try communicator.makeProxyImpl(proxyString) as FinderPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `FinderPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `FinderPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: FinderPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> FinderPrx? {
    return try await FinderPrxI.checkedCast(prx: prx, facet: facet, context: context) as FinderPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `FinderPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `FinderPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: FinderPrx.Protocol, facet: Swift.String? = nil) -> FinderPrx {
    return FinderPrxI.uncheckedCast(prx: prx, facet: facet) as FinderPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `FinderPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: FinderPrx.Protocol) -> Swift.String {
    return FinderTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `FinderPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `FinderPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `FinderPrx?` - The extracted proxy
    func read(_ type: FinderPrx.Protocol) throws -> FinderPrx? {
        return try read() as FinderPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `FinderPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `FinderPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: FinderPrx.Protocol) throws -> FinderPrx? {
        return try read(tag: tag) as FinderPrxI?
    }
}

/// This interface is advertised by the IceStorm service through the Ice object with the identity `IceStorm/Finder'.
/// This allows clients to retrieve the topic manager with just the endpoint information of the IceStorm service.
///
/// FinderPrx Methods:
///
///  - getTopicManager: Get the topic manager proxy.
///
///  - getTopicManagerAsync: Get the topic manager proxy.
public extension FinderPrx {
    /// Get the topic manager proxy. The proxy might point to several replicas.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `TopicManagerPrx?` - The topic manager proxy. The returned proxy is never null.
    func getTopicManager(context: Ice.Context? = nil) async throws -> TopicManagerPrx? {
        return try await _impl._invoke(operation: "getTopicManager",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: TopicManagerPrx? = try istr.read(TopicManagerPrx.self)
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}


/// Dispatcher for `Topic` servants.
public struct TopicDisp: Ice.Dispatcher {
    public let servant: Topic
    private static let defaultObject = Ice.ObjectI<TopicTraits>()

    public init(_ servant: Topic) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "destroy":
            try await servant._iceD_destroy(request)
        case "getLinkInfoSeq":
            try await servant._iceD_getLinkInfoSeq(request)
        case "getName":
            try await servant._iceD_getName(request)
        case "getNonReplicatedPublisher":
            try await servant._iceD_getNonReplicatedPublisher(request)
        case "getPublisher":
            try await servant._iceD_getPublisher(request)
        case "getSubscribers":
            try await servant._iceD_getSubscribers(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? TopicDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? TopicDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? TopicDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? TopicDisp.defaultObject)._iceD_ice_ping(request)
        case "link":
            try await servant._iceD_link(request)
        case "subscribeAndGetPublisher":
            try await servant._iceD_subscribeAndGetPublisher(request)
        case "unlink":
            try await servant._iceD_unlink(request)
        case "unsubscribe":
            try await servant._iceD_unsubscribe(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

/// Publishers publish information on a particular topic. A topic logically represents a type. A
public protocol Topic {
    /// Get the name of this topic.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String` - The name of the topic.
    func getName(current: Ice.Current) async throws -> Swift.String

    /// Get a proxy to a publisher object for this topic. To publish data to a topic, the publisher calls getPublisher
    /// and then creates a proxy with the publisher type from this proxy. If a replicated IceStorm
    /// deployment is used this call may return a replicated proxy. The returned proxy is never null.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.ObjectPrx?` - A proxy to publish data on this topic.
    func getPublisher(current: Ice.Current) async throws -> Ice.ObjectPrx?

    /// Get a non-replicated proxy to a publisher object for this topic. To publish data to a topic, the publisher
    /// calls getPublisher and then creates a proxy with the publisher type from this proxy. The returned proxy is
    /// never null.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.ObjectPrx?` - A proxy to publish data on this topic.
    func getNonReplicatedPublisher(current: Ice.Current) async throws -> Ice.ObjectPrx?

    /// Subscribe with the given qos to this topic.  A per-subscriber publisher object is returned.
    ///
    /// - parameter theQoS: `QoS` The quality of service parameters for this subscription.
    ///
    /// - parameter subscriber: `Ice.ObjectPrx?` The subscriber's proxy. This proxy is never null.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.ObjectPrx?` - The per-subscriber publisher object. The returned object is never null.
    ///
    /// - throws:
    ///
    ///   - AlreadySubscribed - Raised if the subscriber object is already subscribed.
    ///
    ///   - BadQoS - Raised if the requested quality of service is unavailable or invalid.
    ///
    ///   - InvalidSubscriber - Raised if the subscriber object is null.
    func subscribeAndGetPublisher(theQoS: QoS, subscriber: Ice.ObjectPrx?, current: Ice.Current) async throws -> Ice.ObjectPrx?

    /// Unsubscribe the given subscriber.
    ///
    /// - parameter subscriber: `Ice.ObjectPrx?` The proxy of an existing subscriber. This proxy is never null.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func unsubscribe(subscriber: Ice.ObjectPrx?, current: Ice.Current) async throws

    /// Create a link to the given topic. All events originating on this topic will also be sent to
    /// linkTo.
    ///
    /// - parameter linkTo: `TopicPrx?` The topic to link to. This proxy is never null.
    ///
    /// - parameter cost: `Swift.Int32` The cost to the linked topic.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - LinkExists - Raised if a link to the same topic already exists.
    func link(linkTo: TopicPrx?, cost: Swift.Int32, current: Ice.Current) async throws

    /// Destroy the link from this topic to the given topic linkTo.
    ///
    /// - parameter linkTo: `TopicPrx?` The topic to destroy the link to. This proxy is never null.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - NoSuchLink - Raised if a link to the topic does not exist.
    func unlink(linkTo: TopicPrx?, current: Ice.Current) async throws

    /// Retrieve information on the current links.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `LinkInfoSeq` - A sequence of LinkInfo objects.
    func getLinkInfoSeq(current: Ice.Current) async throws -> LinkInfoSeq

    /// Retrieve the list of subscribers for this topic.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.IdentitySeq` - The sequence of Ice identities for the subscriber objects.
    func getSubscribers(current: Ice.Current) async throws -> Ice.IdentitySeq

    /// Destroy the topic.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func destroy(current: Ice.Current) async throws
}


/// Dispatcher for `TopicManager` servants.
public struct TopicManagerDisp: Ice.Dispatcher {
    public let servant: TopicManager
    private static let defaultObject = Ice.ObjectI<TopicManagerTraits>()

    public init(_ servant: TopicManager) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "create":
            try await servant._iceD_create(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? TopicManagerDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? TopicManagerDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? TopicManagerDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? TopicManagerDisp.defaultObject)._iceD_ice_ping(request)
        case "retrieve":
            try await servant._iceD_retrieve(request)
        case "retrieveAll":
            try await servant._iceD_retrieveAll(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

/// A topic manager manages topics, and subscribers to topics.
public protocol TopicManager {
    /// Create a new topic. The topic name must be unique.
    ///
    /// - parameter name: `Swift.String` The name of the topic.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `TopicPrx?` - A proxy to the topic instance. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - TopicExists - Raised if a topic with the same name already exists.
    func create(name: Swift.String, current: Ice.Current) async throws -> TopicPrx?

    /// Retrieve a topic by name.
    ///
    /// - parameter name: `Swift.String` The name of the topic.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `TopicPrx?` - A proxy to the topic instance. The returned proxy is never null.
    ///
    /// - throws:
    ///
    ///   - NoSuchTopic - Raised if the topic does not exist.
    func retrieve(name: Swift.String, current: Ice.Current) async throws -> TopicPrx?

    /// Retrieve all topics managed by this topic manager.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `TopicDict` - A dictionary of string, topic proxy pairs.
    func retrieveAll(current: Ice.Current) async throws -> TopicDict
}


/// Dispatcher for `Finder` servants.
public struct FinderDisp: Ice.Dispatcher {
    public let servant: Finder
    private static let defaultObject = Ice.ObjectI<FinderTraits>()

    public init(_ servant: Finder) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "getTopicManager":
            try await servant._iceD_getTopicManager(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? FinderDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? FinderDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? FinderDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? FinderDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

/// This interface is advertised by the IceStorm service through the Ice object with the identity `IceStorm/Finder'.
/// This allows clients to retrieve the topic manager with just the endpoint information of the IceStorm service.
public protocol Finder {
    /// Get the topic manager proxy. The proxy might point to several replicas.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `TopicManagerPrx?` - The topic manager proxy. The returned proxy is never null.
    func getTopicManager(current: Ice.Current) async throws -> TopicManagerPrx?
}

/// Publishers publish information on a particular topic. A topic logically represents a type. A
///
/// Topic Methods:
///
///  - getName: Get the name of this topic.
///
///  - getPublisher: Get a proxy to a publisher object for this topic.
///
///  - getNonReplicatedPublisher: Get a non-replicated proxy to a publisher object for this topic.
///
///  - subscribeAndGetPublisher: Subscribe with the given qos to this topic.
///
///  - unsubscribe: Unsubscribe the given subscriber.
///
///  - link: Create a link to the given topic.
///
///  - unlink: Destroy the link from this topic to the given topic linkTo.
///
///  - getLinkInfoSeq: Retrieve information on the current links.
///
///  - getSubscribers: Retrieve the list of subscribers for this topic.
///
///  - destroy: Destroy the topic.
extension Topic {
    public func _iceD_getName(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getName(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_getPublisher(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getPublisher(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_getNonReplicatedPublisher(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getNonReplicatedPublisher(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_subscribeAndGetPublisher(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_theQoS: QoS = try QoSHelper.read(from: istr)
        let iceP_subscriber: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
        let result = try await self.subscribeAndGetPublisher(theQoS: iceP_theQoS, subscriber: iceP_subscriber, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_unsubscribe(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_subscriber: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
        try await self.unsubscribe(subscriber: iceP_subscriber, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_link(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_linkTo: TopicPrx? = try istr.read(TopicPrx.self)
        let iceP_cost: Swift.Int32 = try istr.read()
        try await self.link(linkTo: iceP_linkTo, cost: iceP_cost, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_unlink(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_linkTo: TopicPrx? = try istr.read(TopicPrx.self)
        try await self.unlink(linkTo: iceP_linkTo, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_getLinkInfoSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getLinkInfoSeq(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            LinkInfoSeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_getSubscribers(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getSubscribers(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            Ice.IdentitySeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_destroy(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.destroy(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}

/// A topic manager manages topics, and subscribers to topics.
///
/// TopicManager Methods:
///
///  - create: Create a new topic.
///
///  - retrieve: Retrieve a topic by name.
///
///  - retrieveAll: Retrieve all topics managed by this topic manager.
extension TopicManager {
    public func _iceD_create(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_name: Swift.String = try istr.read()
        let result = try await self.create(name: iceP_name, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_retrieve(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_name: Swift.String = try istr.read()
        let result = try await self.retrieve(name: iceP_name, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_retrieveAll(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.retrieveAll(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            TopicDictHelper.write(to: ostr, value: iceP_returnValue)
        }
    }
}

/// This interface is advertised by the IceStorm service through the Ice object with the identity `IceStorm/Finder'.
/// This allows clients to retrieve the topic manager with just the endpoint information of the IceStorm service.
///
/// Finder Methods:
///
///  - getTopicManager: Get the topic manager proxy.
extension Finder {
    public func _iceD_getTopicManager(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getTopicManager(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }
}
