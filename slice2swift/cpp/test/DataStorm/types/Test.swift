//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice

public struct StructValue: Swift.Hashable {
    public var firstName: Swift.String = ""
    public var lastName: Swift.String = ""
    public var age: Swift.Int32 = 0

    public init() {}

    public init(firstName: Swift.String, lastName: Swift.String, age: Swift.Int32) {
        self.firstName = firstName
        self.lastName = lastName
        self.age = age
    }
}

/// An `Ice.InputStream` extension to read `StructValue` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `StructValue` structured value from the stream.
    ///
    /// - returns: `StructValue` - The structured value read from the stream.
    func read() throws -> StructValue {
        var v = StructValue()
        v.firstName = try self.read()
        v.lastName = try self.read()
        v.age = try self.read()
        return v
    }

    /// Read an optional `StructValue?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StructValue?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> StructValue? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as StructValue
    }
}

/// An `Ice.OutputStream` extension to write `StructValue` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `StructValue` structured value to the stream.
    ///
    /// - parameter _: `StructValue` - The value to write to the stream.
    func write(_ v: StructValue) {
        self.write(v.firstName)
        self.write(v.lastName)
        self.write(v.age)
    }

    /// Write an optional `StructValue?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StructValue?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: StructValue?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// :nodoc:
public class Base_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Base.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Base() -> Ice.ValueTypeResolver {
        return Base_TypeResolver()
    }
}

open class Base: Ice.Value {
    public var b: Swift.String = ""

    public required init() {}

    public init(b: Swift.String) {
        self.b = b
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::Base" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.b = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Base.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.b)
        ostr.endSlice()
    }
}

/// :nodoc:
public class Extended_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Extended.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Extended() -> Ice.ValueTypeResolver {
        return Extended_TypeResolver()
    }
}

open class Extended: Base {
    public var e: Swift.Int32 = 0

    public required init() {
        super.init()
    }

    public init(b: Swift.String, e: Swift.Int32) {
        self.e = e
        super.init(b: b)
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::Extended" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.e = try istr.read()
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Extended.ice_staticId(), compactId: -1, last: false)
        ostr.write(self.e)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}
