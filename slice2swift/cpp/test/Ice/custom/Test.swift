//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice
import PromiseKit

public typealias BoolSeq = [Swift.Bool]

public typealias BoolList = [Swift.Bool]

public typealias BoolListList = [BoolList]

/// Helper class to read and write `BoolListList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct BoolListListHelper {
    /// Read a `BoolListList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `BoolListList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> BoolListList {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = BoolListList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: BoolList = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `BoolListList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `BoolListList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> BoolListList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `BoolListList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `BoolListList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: BoolListList) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `BoolListList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `BoolListList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: BoolListList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias BoolListSeq = [BoolList]

/// Helper class to read and write `BoolListSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct BoolListSeqHelper {
    /// Read a `BoolListSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `BoolListSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> BoolListSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = BoolListSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: BoolList = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `BoolListSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `BoolListSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> BoolListSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `BoolListSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `BoolListSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: BoolListSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `BoolListSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `BoolListSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: BoolListSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias BoolSeqList = [BoolSeq]

/// Helper class to read and write `BoolSeqList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct BoolSeqListHelper {
    /// Read a `BoolSeqList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `BoolSeqList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> BoolSeqList {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = BoolSeqList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: BoolSeq = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `BoolSeqList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `BoolSeqList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> BoolSeqList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `BoolSeqList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `BoolSeqList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: BoolSeqList) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `BoolSeqList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `BoolSeqList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: BoolSeqList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias BoolDequeList = [BoolSeq]

/// Helper class to read and write `BoolDequeList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct BoolDequeListHelper {
    /// Read a `BoolDequeList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `BoolDequeList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> BoolDequeList {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = BoolDequeList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: BoolSeq = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `BoolDequeList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `BoolDequeList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> BoolDequeList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `BoolDequeList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `BoolDequeList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: BoolDequeList) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `BoolDequeList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `BoolDequeList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: BoolDequeList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ByteSeq = Foundation.Data

public typealias ByteList = Foundation.Data

public typealias ByteListList = [ByteList]

/// Helper class to read and write `ByteListList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ByteListListHelper {
    /// Read a `ByteListList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ByteListList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ByteListList {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = ByteListList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: ByteList = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `ByteListList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ByteListList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ByteListList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ByteListList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ByteListList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ByteListList) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `ByteListList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ByteListList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ByteListList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ByteListSeq = [ByteList]

/// Helper class to read and write `ByteListSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ByteListSeqHelper {
    /// Read a `ByteListSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ByteListSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ByteListSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = ByteListSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: ByteList = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `ByteListSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ByteListSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ByteListSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ByteListSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ByteListSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ByteListSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `ByteListSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ByteListSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ByteListSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ByteSeqList = [ByteSeq]

/// Helper class to read and write `ByteSeqList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ByteSeqListHelper {
    /// Read a `ByteSeqList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ByteSeqList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ByteSeqList {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = ByteSeqList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: ByteSeq = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `ByteSeqList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ByteSeqList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ByteSeqList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ByteSeqList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ByteSeqList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ByteSeqList) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `ByteSeqList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ByteSeqList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ByteSeqList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringSeq = [Swift.String]

public typealias StringList = [Swift.String]

public typealias StringListList = [StringList]

/// Helper class to read and write `StringListList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringListListHelper {
    /// Read a `StringListList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringListList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringListList {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = StringListList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: StringList = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `StringListList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringListList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringListList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringListList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringListList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringListList) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `StringListList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringListList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: StringListList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringListSeq = [StringList]

/// Helper class to read and write `StringListSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringListSeqHelper {
    /// Read a `StringListSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringListSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringListSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = StringListSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: StringList = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `StringListSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringListSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringListSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringListSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringListSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringListSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `StringListSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringListSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: StringListSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringSeqList = [StringSeq]

/// Helper class to read and write `StringSeqList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringSeqListHelper {
    /// Read a `StringSeqList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringSeqList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringSeqList {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = StringSeqList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: StringSeq = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `StringSeqList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringSeqList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringSeqList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringSeqList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringSeqList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringSeqList) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `StringSeqList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringSeqList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: StringSeqList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public struct Fixed: Swift.Hashable {
    public var s: Swift.Int16 = 0

    public init() {}

    public init(s: Swift.Int16) {
        self.s = s
    }
}

/// An `Ice.InputStream` extension to read `Fixed` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `Fixed` structured value from the stream.
    ///
    /// - returns: `Fixed` - The structured value read from the stream.
    func read() throws -> Fixed {
        var v = Fixed()
        v.s = try self.read()
        return v
    }

    /// Read an optional `Fixed?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `Fixed?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> Fixed? {
        guard try readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try skipSize()
        return try read() as Fixed
    }
}

/// An `Ice.OutputStream` extension to write `Fixed` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `Fixed` structured value to the stream.
    ///
    /// - parameter _: `Fixed` - The value to write to the stream.
    func write(_ v: Fixed) {
        self.write(v.s)
    }

    /// Write an optional `Fixed?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `Fixed?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: Fixed?) {
        if let v = value {
            if writeOptional(tag: tag, format: .VSize) {
                write(size: 2)
                write(v)
            }
        }
    }
}

public typealias FixedSeq = [Fixed]

/// Helper class to read and write `FixedSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct FixedSeqHelper {
    /// Read a `FixedSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `FixedSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> FixedSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = FixedSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: Fixed = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `FixedSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `FixedSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> FixedSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Wite a `FixedSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `FixedSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: FixedSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `FixedSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `FixedSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: FixedSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 2) {
            write(to: ostr, value: val)
        }
    }
}

public typealias FixedList = [Fixed]

/// Helper class to read and write `FixedList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct FixedListHelper {
    /// Read a `FixedList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `FixedList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> FixedList {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = FixedList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: Fixed = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `FixedList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `FixedList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> FixedList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Wite a `FixedList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `FixedList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: FixedList) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `FixedList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `FixedList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: FixedList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 2) {
            write(to: ostr, value: val)
        }
    }
}

public typealias FixedListList = [FixedList]

/// Helper class to read and write `FixedListList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct FixedListListHelper {
    /// Read a `FixedListList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `FixedListList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> FixedListList {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = FixedListList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: FixedList = try FixedListHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `FixedListList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `FixedListList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> FixedListList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `FixedListList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `FixedListList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: FixedListList) {
        ostr.write(size: v.count)
        for item in v {
            FixedListHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `FixedListList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `FixedListList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: FixedListList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias FixedListSeq = [FixedList]

/// Helper class to read and write `FixedListSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct FixedListSeqHelper {
    /// Read a `FixedListSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `FixedListSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> FixedListSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = FixedListSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: FixedList = try FixedListHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `FixedListSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `FixedListSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> FixedListSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `FixedListSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `FixedListSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: FixedListSeq) {
        ostr.write(size: v.count)
        for item in v {
            FixedListHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `FixedListSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `FixedListSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: FixedListSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias FixedSeqList = [FixedSeq]

/// Helper class to read and write `FixedSeqList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct FixedSeqListHelper {
    /// Read a `FixedSeqList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `FixedSeqList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> FixedSeqList {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = FixedSeqList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: FixedSeq = try FixedSeqHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `FixedSeqList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `FixedSeqList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> FixedSeqList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `FixedSeqList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `FixedSeqList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: FixedSeqList) {
        ostr.write(size: v.count)
        for item in v {
            FixedSeqHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `FixedSeqList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `FixedSeqList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: FixedSeqList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public struct Variable: Swift.Hashable {
    public var s: Swift.String = ""
    public var bl: BoolList = BoolList()
    public var ss: StringSeq = StringSeq()

    public init() {}

    public init(s: Swift.String, bl: BoolList, ss: StringSeq) {
        self.s = s
        self.bl = bl
        self.ss = ss
    }
}

/// An `Ice.InputStream` extension to read `Variable` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `Variable` structured value from the stream.
    ///
    /// - returns: `Variable` - The structured value read from the stream.
    func read() throws -> Variable {
        var v = Variable()
        v.s = try self.read()
        v.bl = try self.read()
        v.ss = try self.read()
        return v
    }

    /// Read an optional `Variable?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `Variable?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> Variable? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as Variable
    }
}

/// An `Ice.OutputStream` extension to write `Variable` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `Variable` structured value to the stream.
    ///
    /// - parameter _: `Variable` - The value to write to the stream.
    func write(_ v: Variable) {
        self.write(v.s)
        self.write(v.bl)
        self.write(v.ss)
    }

    /// Write an optional `Variable?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `Variable?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: Variable?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public typealias VariableSeq = [Variable]

/// Helper class to read and write `VariableSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct VariableSeqHelper {
    /// Read a `VariableSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `VariableSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> VariableSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 3)
        var v = VariableSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: Variable = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `VariableSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `VariableSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> VariableSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `VariableSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `VariableSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: VariableSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `VariableSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `VariableSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: VariableSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias VariableList = [Variable]

/// Helper class to read and write `VariableList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct VariableListHelper {
    /// Read a `VariableList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `VariableList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> VariableList {
        let sz = try istr.readAndCheckSeqSize(minSize: 3)
        var v = VariableList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: Variable = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `VariableList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `VariableList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> VariableList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `VariableList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `VariableList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: VariableList) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `VariableList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `VariableList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: VariableList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias VariableListList = [VariableList]

/// Helper class to read and write `VariableListList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct VariableListListHelper {
    /// Read a `VariableListList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `VariableListList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> VariableListList {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = VariableListList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: VariableList = try VariableListHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `VariableListList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `VariableListList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> VariableListList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `VariableListList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `VariableListList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: VariableListList) {
        ostr.write(size: v.count)
        for item in v {
            VariableListHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `VariableListList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `VariableListList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: VariableListList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias VariableListSeq = [VariableList]

/// Helper class to read and write `VariableListSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct VariableListSeqHelper {
    /// Read a `VariableListSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `VariableListSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> VariableListSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = VariableListSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: VariableList = try VariableListHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `VariableListSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `VariableListSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> VariableListSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `VariableListSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `VariableListSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: VariableListSeq) {
        ostr.write(size: v.count)
        for item in v {
            VariableListHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `VariableListSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `VariableListSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: VariableListSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias VariableSeqList = [VariableSeq]

/// Helper class to read and write `VariableSeqList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct VariableSeqListHelper {
    /// Read a `VariableSeqList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `VariableSeqList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> VariableSeqList {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = VariableSeqList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: VariableSeq = try VariableSeqHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `VariableSeqList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `VariableSeqList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> VariableSeqList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `VariableSeqList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `VariableSeqList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: VariableSeqList) {
        ostr.write(size: v.count)
        for item in v {
            VariableSeqHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `VariableSeqList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `VariableSeqList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: VariableSeqList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringStringDict = [Swift.String: Swift.String]

/// Helper class to read and write `StringStringDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringStringDictHelper {
    /// Read a `StringStringDict` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringStringDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringStringDict {
        let sz = try Swift.Int(istr.readSize())
        var v = StringStringDict()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: Swift.String = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `StringStringDict?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringStringDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringStringDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringStringDict` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringStringDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringStringDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `StringStringDict?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringStringDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: StringStringDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringStringDictSeq = [StringStringDict]

/// Helper class to read and write `StringStringDictSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringStringDictSeqHelper {
    /// Read a `StringStringDictSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringStringDictSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringStringDictSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = StringStringDictSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: StringStringDict = try StringStringDictHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `StringStringDictSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringStringDictSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringStringDictSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringStringDictSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringStringDictSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringStringDictSeq) {
        ostr.write(size: v.count)
        for item in v {
            StringStringDictHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `StringStringDictSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringStringDictSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: StringStringDictSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringStringDictList = [StringStringDict]

/// Helper class to read and write `StringStringDictList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringStringDictListHelper {
    /// Read a `StringStringDictList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringStringDictList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringStringDictList {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = StringStringDictList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: StringStringDict = try StringStringDictHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `StringStringDictList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringStringDictList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringStringDictList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringStringDictList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringStringDictList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringStringDictList) {
        ostr.write(size: v.count)
        for item in v {
            StringStringDictHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `StringStringDictList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringStringDictList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: StringStringDictList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringStringDictListList = [StringStringDictList]

/// Helper class to read and write `StringStringDictListList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringStringDictListListHelper {
    /// Read a `StringStringDictListList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringStringDictListList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringStringDictListList {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = StringStringDictListList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: StringStringDictList = try StringStringDictListHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `StringStringDictListList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringStringDictListList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringStringDictListList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringStringDictListList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringStringDictListList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringStringDictListList) {
        ostr.write(size: v.count)
        for item in v {
            StringStringDictListHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `StringStringDictListList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringStringDictListList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: StringStringDictListList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringStringDictListSeq = [StringStringDictList]

/// Helper class to read and write `StringStringDictListSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringStringDictListSeqHelper {
    /// Read a `StringStringDictListSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringStringDictListSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringStringDictListSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = StringStringDictListSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: StringStringDictList = try StringStringDictListHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `StringStringDictListSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringStringDictListSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringStringDictListSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringStringDictListSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringStringDictListSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringStringDictListSeq) {
        ostr.write(size: v.count)
        for item in v {
            StringStringDictListHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `StringStringDictListSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringStringDictListSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: StringStringDictListSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringStringDictSeqList = [StringStringDictSeq]

/// Helper class to read and write `StringStringDictSeqList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringStringDictSeqListHelper {
    /// Read a `StringStringDictSeqList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringStringDictSeqList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringStringDictSeqList {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = StringStringDictSeqList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: StringStringDictSeq = try StringStringDictSeqHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `StringStringDictSeqList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringStringDictSeqList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringStringDictSeqList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringStringDictSeqList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringStringDictSeqList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringStringDictSeqList) {
        ostr.write(size: v.count)
        for item in v {
            StringStringDictSeqHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `StringStringDictSeqList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringStringDictSeqList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: StringStringDictSeqList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public enum E: Swift.UInt8 {
    /// E1
    case E1 = 0
    /// E2
    case E2 = 1
    /// E3
    case E3 = 2
    public init() {
        self = .E1
    }
}

/// An `Ice.InputStream` extension to read `E` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - returns: `E` - The enumarated value.
    func read() throws -> E {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 2)
        guard let val = E(rawValue: rawValue) else {
            throw Ice.MarshalException(reason: "invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `E` - The enumerated value.
    func read(tag: Swift.Int32) throws -> E? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as E
    }
}

/// An `Ice.OutputStream` extension to write `E` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// parameter _: `E` - The enumerator to write.
    func write(_ v: E) {
        write(enum: v.rawValue, maxValue: 2)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// parameter _: `E` - The enumerator to write.
    func write(tag: Swift.Int32, value: E?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 2)
    }
}

public typealias ESeq = [E]

/// Helper class to read and write `ESeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ESeqHelper {
    /// Read a `ESeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ESeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ESeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = ESeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: E = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `ESeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ESeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ESeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ESeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ESeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ESeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `ESeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ESeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ESeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias EList = [E]

/// Helper class to read and write `EList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct EListHelper {
    /// Read a `EList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `EList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> EList {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = EList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: E = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `EList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `EList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> EList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `EList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `EList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: EList) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `EList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `EList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: EList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias EListList = [EList]

/// Helper class to read and write `EListList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct EListListHelper {
    /// Read a `EListList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `EListList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> EListList {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = EListList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: EList = try EListHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `EListList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `EListList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> EListList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `EListList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `EListList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: EListList) {
        ostr.write(size: v.count)
        for item in v {
            EListHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `EListList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `EListList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: EListList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias EListSeq = [EList]

/// Helper class to read and write `EListSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct EListSeqHelper {
    /// Read a `EListSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `EListSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> EListSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = EListSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: EList = try EListHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `EListSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `EListSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> EListSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `EListSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `EListSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: EListSeq) {
        ostr.write(size: v.count)
        for item in v {
            EListHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `EListSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `EListSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: EListSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ESeqList = [ESeq]

/// Helper class to read and write `ESeqList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ESeqListHelper {
    /// Read a `ESeqList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ESeqList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ESeqList {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = ESeqList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: ESeq = try ESeqHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `ESeqList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ESeqList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ESeqList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ESeqList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ESeqList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ESeqList) {
        ostr.write(size: v.count)
        for item in v {
            ESeqHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `ESeqList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ESeqList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ESeqList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice class`C`.
public struct CTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::C"]
    public static let staticId = "::Test::C"
}

public typealias CSeq = [C?]

/// Helper class to read and write `CSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct CSeqHelper {
    /// Read a `CSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `CSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> CSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = CSeq(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(C.self) { p.pointee = $0 }
            }
        }
        return v
    }
    /// Read an optional `CSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `CSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> CSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `CSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `CSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: CSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `CSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `CSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: CSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias CList = [C?]

/// Helper class to read and write `CList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct CListHelper {
    /// Read a `CList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `CList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> CList {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = CList(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(C.self) { p.pointee = $0 }
            }
        }
        return v
    }
    /// Read an optional `CList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `CList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> CList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `CList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `CList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: CList) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `CList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `CList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: CList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias CListList = [CList]

/// Helper class to read and write `CListList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct CListListHelper {
    /// Read a `CListList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `CListList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> CListList {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = CListList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: CList = try CListHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `CListList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `CListList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> CListList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `CListList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `CListList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: CListList) {
        ostr.write(size: v.count)
        for item in v {
            CListHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `CListList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `CListList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: CListList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias CListSeq = [CList]

/// Helper class to read and write `CListSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct CListSeqHelper {
    /// Read a `CListSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `CListSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> CListSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = CListSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: CList = try CListHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `CListSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `CListSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> CListSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `CListSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `CListSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: CListSeq) {
        ostr.write(size: v.count)
        for item in v {
            CListHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `CListSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `CListSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: CListSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias CSeqList = [CSeq]

/// Helper class to read and write `CSeqList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct CSeqListHelper {
    /// Read a `CSeqList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `CSeqList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> CSeqList {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = CSeqList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: CSeq = try CSeqHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `CSeqList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `CSeqList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> CSeqList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `CSeqList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `CSeqList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: CSeqList) {
        ostr.write(size: v.count)
        for item in v {
            CSeqHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `CSeqList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `CSeqList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: CSeqList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice interface`D`.
public struct DTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::D"]
    public static let staticId = "::Test::D"
}

public typealias DPrxSeq = [DPrx?]

/// Helper class to read and write `DPrxSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct DPrxSeqHelper {
    /// Read a `DPrxSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `DPrxSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> DPrxSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = DPrxSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: DPrx? = try istr.read(DPrx.self)
            v.append(j)
        }
        return v
    }
    /// Read an optional `DPrxSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `DPrxSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> DPrxSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `DPrxSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `DPrxSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: DPrxSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `DPrxSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `DPrxSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: DPrxSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias DPrxList = [DPrx?]

/// Helper class to read and write `DPrxList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct DPrxListHelper {
    /// Read a `DPrxList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `DPrxList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> DPrxList {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = DPrxList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: DPrx? = try istr.read(DPrx.self)
            v.append(j)
        }
        return v
    }
    /// Read an optional `DPrxList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `DPrxList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> DPrxList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `DPrxList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `DPrxList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: DPrxList) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `DPrxList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `DPrxList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: DPrxList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias DPrxListList = [DPrxList]

/// Helper class to read and write `DPrxListList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct DPrxListListHelper {
    /// Read a `DPrxListList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `DPrxListList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> DPrxListList {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = DPrxListList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: DPrxList = try DPrxListHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `DPrxListList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `DPrxListList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> DPrxListList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `DPrxListList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `DPrxListList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: DPrxListList) {
        ostr.write(size: v.count)
        for item in v {
            DPrxListHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `DPrxListList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `DPrxListList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: DPrxListList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias DPrxListSeq = [DPrxList]

/// Helper class to read and write `DPrxListSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct DPrxListSeqHelper {
    /// Read a `DPrxListSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `DPrxListSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> DPrxListSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = DPrxListSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: DPrxList = try DPrxListHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `DPrxListSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `DPrxListSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> DPrxListSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `DPrxListSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `DPrxListSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: DPrxListSeq) {
        ostr.write(size: v.count)
        for item in v {
            DPrxListHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `DPrxListSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `DPrxListSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: DPrxListSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias DPrxSeqList = [DPrxSeq]

/// Helper class to read and write `DPrxSeqList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct DPrxSeqListHelper {
    /// Read a `DPrxSeqList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `DPrxSeqList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> DPrxSeqList {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = DPrxSeqList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: DPrxSeq = try DPrxSeqHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `DPrxSeqList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `DPrxSeqList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> DPrxSeqList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `DPrxSeqList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `DPrxSeqList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: DPrxSeqList) {
        ostr.write(size: v.count)
        for item in v {
            DPrxSeqHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `DPrxSeqList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `DPrxSeqList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: DPrxSeqList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias DoubleSeq = [Swift.Double]

public typealias IntStringDict = [Swift.Int32: Swift.String]

/// Helper class to read and write `IntStringDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct IntStringDictHelper {
    /// Read a `IntStringDict` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `IntStringDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> IntStringDict {
        let sz = try Swift.Int(istr.readSize())
        var v = IntStringDict()
        for _ in 0 ..< sz {
            let key: Swift.Int32 = try istr.read()
            let value: Swift.String = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `IntStringDict?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `IntStringDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> IntStringDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `IntStringDict` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `IntStringDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: IntStringDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `IntStringDict?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `IntStringDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: IntStringDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias LongLongDict = [Swift.Int64: Swift.Int64]

/// Helper class to read and write `LongLongDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LongLongDictHelper {
    /// Read a `LongLongDict` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `LongLongDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LongLongDict {
        let sz = try Swift.Int(istr.readSize())
        var v = LongLongDict()
        for _ in 0 ..< sz {
            let key: Swift.Int64 = try istr.read()
            let value: Swift.Int64 = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `LongLongDict?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LongLongDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LongLongDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Wite a `LongLongDict` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `LongLongDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LongLongDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `LongLongDict?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LongLongDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: LongLongDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 16) {
            write(to: ostr, value: val)
        }
    }
}

public typealias StringIntDict = [Swift.String: Swift.Int32]

/// Helper class to read and write `StringIntDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringIntDictHelper {
    /// Read a `StringIntDict` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringIntDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringIntDict {
        let sz = try Swift.Int(istr.readSize())
        var v = StringIntDict()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: Swift.Int32 = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `StringIntDict?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringIntDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringIntDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringIntDict` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringIntDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringIntDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `StringIntDict?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringIntDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: StringIntDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice class`DictClass`.
public struct DictClassTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::DictClass"]
    public static let staticId = "::Test::DictClass"
}

public typealias BoolBuffer = [Swift.Bool]

public typealias ShortBuffer = [Swift.Int16]

public typealias IntBuffer = [Swift.Int32]

public typealias LongBuffer = [Swift.Int64]

public typealias FloatBuffer = [Swift.Float]

public typealias DoubleBuffer = [Swift.Double]

public typealias ByteBuffer = Foundation.Data

public struct BufferStruct {
    public var byteBuf: ByteBuffer = ByteBuffer()
    public var boolBuf: BoolBuffer = BoolBuffer()
    public var shortBuf: ShortBuffer = ShortBuffer()
    public var intBuf: IntBuffer = IntBuffer()
    public var longBuf: LongBuffer = LongBuffer()
    public var floatBuf: FloatBuffer = FloatBuffer()
    public var doubleBuf: DoubleBuffer = DoubleBuffer()

    public init() {}

    public init(byteBuf: ByteBuffer, boolBuf: BoolBuffer, shortBuf: ShortBuffer, intBuf: IntBuffer, longBuf: LongBuffer, floatBuf: FloatBuffer, doubleBuf: DoubleBuffer) {
        self.byteBuf = byteBuf
        self.boolBuf = boolBuf
        self.shortBuf = shortBuf
        self.intBuf = intBuf
        self.longBuf = longBuf
        self.floatBuf = floatBuf
        self.doubleBuf = doubleBuf
    }
}

/// An `Ice.InputStream` extension to read `BufferStruct` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `BufferStruct` structured value from the stream.
    ///
    /// - returns: `BufferStruct` - The structured value read from the stream.
    func read() throws -> BufferStruct {
        var v = BufferStruct()
        v.byteBuf = try self.read()
        v.boolBuf = try self.read()
        v.shortBuf = try self.read()
        v.intBuf = try self.read()
        v.longBuf = try self.read()
        v.floatBuf = try self.read()
        v.doubleBuf = try self.read()
        return v
    }

    /// Read an optional `BufferStruct?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `BufferStruct?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> BufferStruct? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as BufferStruct
    }
}

/// An `Ice.OutputStream` extension to write `BufferStruct` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `BufferStruct` structured value to the stream.
    ///
    /// - parameter _: `BufferStruct` - The value to write to the stream.
    func write(_ v: BufferStruct) {
        self.write(v.byteBuf)
        self.write(v.boolBuf)
        self.write(v.shortBuf)
        self.write(v.intBuf)
        self.write(v.longBuf)
        self.write(v.floatBuf)
        self.write(v.doubleBuf)
    }

    /// Write an optional `BufferStruct?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `BufferStruct?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: BufferStruct?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// Traits for Slice interface`TestIntf`.
public struct TestIntfTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::TestIntf"]
    public static let staticId = "::Test::TestIntf"
}

/// DPrx overview.
public protocol DPrx: Ice.ObjectPrx {}

private final class DPrxI: Ice.ObjectPrxI, DPrx {
    public override class func ice_staticId() -> Swift.String {
        return DTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `DPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `DPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: DPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> DPrx? {
    return try DPrxI.checkedCast(prx: prx, facet: facet, context: context) as DPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `DPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `DPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: DPrx.Protocol, facet: Swift.String? = nil) -> DPrx {
    return DPrxI.uncheckedCast(prx: prx, facet: facet) as DPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `DPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: DPrx.Protocol) -> Swift.String {
    return DTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `DPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `DPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `DPrx?` - The extracted proxy
    func read(_ type: DPrx.Protocol) throws -> DPrx? {
        return try read() as DPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `DPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `DPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: DPrx.Protocol) throws -> DPrx? {
        return try read(tag: tag) as DPrxI?
    }
}

/// DPrx overview.
public extension DPrx {}

/// TestIntfPrx overview.
///
/// TestIntfPrx Methods:
///
///  - opDoubleArray: 
///
///  - opDoubleArrayAsync: 
///
///  - opBoolArray: 
///
///  - opBoolArrayAsync: 
///
///  - opByteArray: 
///
///  - opByteArrayAsync: 
///
///  - opVariableArray: 
///
///  - opVariableArrayAsync: 
///
///  - opBoolSeq: 
///
///  - opBoolSeqAsync: 
///
///  - opBoolList: 
///
///  - opBoolListAsync: 
///
///  - opBoolDequeList: 
///
///  - opBoolDequeListAsync: 
///
///  - opBoolDequeListArray: 
///
///  - opBoolDequeListArrayAsync: 
///
///  - opByteSeq: 
///
///  - opByteSeqAsync: 
///
///  - opByteList: 
///
///  - opByteListAsync: 
///
///  - opMyByteSeq: 
///
///  - opMyByteSeqAsync: 
///
///  - opStringSeq: 
///
///  - opStringSeqAsync: 
///
///  - opStringList: 
///
///  - opStringListAsync: 
///
///  - opFixedSeq: 
///
///  - opFixedSeqAsync: 
///
///  - opFixedList: 
///
///  - opFixedListAsync: 
///
///  - opVariableSeq: 
///
///  - opVariableSeqAsync: 
///
///  - opVariableList: 
///
///  - opVariableListAsync: 
///
///  - opStringStringDictSeq: 
///
///  - opStringStringDictSeqAsync: 
///
///  - opStringStringDictList: 
///
///  - opStringStringDictListAsync: 
///
///  - opESeq: 
///
///  - opESeqAsync: 
///
///  - opEList: 
///
///  - opEListAsync: 
///
///  - opDPrxSeq: 
///
///  - opDPrxSeqAsync: 
///
///  - opDPrxList: 
///
///  - opDPrxListAsync: 
///
///  - opCSeq: 
///
///  - opCSeqAsync: 
///
///  - opCList: 
///
///  - opCListAsync: 
///
///  - opOutArrayByteSeq: 
///
///  - opOutArrayByteSeqAsync: 
///
///  - opIntStringDict: 
///
///  - opIntStringDictAsync: 
///
///  - opVarDict: 
///
///  - opVarDictAsync: 
///
///  - opShortBuffer: 
///
///  - opShortBufferAsync: 
///
///  - opBoolBuffer: 
///
///  - opBoolBufferAsync: 
///
///  - opBufferStruct: 
///
///  - opBufferStructAsync: 
///
///  - shutdown: 
///
///  - shutdownAsync: 
public protocol TestIntfPrx: Ice.ObjectPrx {}

private final class TestIntfPrxI: Ice.ObjectPrxI, TestIntfPrx {
    public override class func ice_staticId() -> Swift.String {
        return TestIntfTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `TestIntfPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `TestIntfPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: TestIntfPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> TestIntfPrx? {
    return try TestIntfPrxI.checkedCast(prx: prx, facet: facet, context: context) as TestIntfPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `TestIntfPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `TestIntfPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: TestIntfPrx.Protocol, facet: Swift.String? = nil) -> TestIntfPrx {
    return TestIntfPrxI.uncheckedCast(prx: prx, facet: facet) as TestIntfPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `TestIntfPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: TestIntfPrx.Protocol) -> Swift.String {
    return TestIntfTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `TestIntfPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `TestIntfPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `TestIntfPrx?` - The extracted proxy
    func read(_ type: TestIntfPrx.Protocol) throws -> TestIntfPrx? {
        return try read() as TestIntfPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `TestIntfPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `TestIntfPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: TestIntfPrx.Protocol) throws -> TestIntfPrx? {
        return try read(tag: tag) as TestIntfPrxI?
    }
}

/// TestIntfPrx overview.
///
/// TestIntfPrx Methods:
///
///  - opDoubleArray: 
///
///  - opDoubleArrayAsync: 
///
///  - opBoolArray: 
///
///  - opBoolArrayAsync: 
///
///  - opByteArray: 
///
///  - opByteArrayAsync: 
///
///  - opVariableArray: 
///
///  - opVariableArrayAsync: 
///
///  - opBoolSeq: 
///
///  - opBoolSeqAsync: 
///
///  - opBoolList: 
///
///  - opBoolListAsync: 
///
///  - opBoolDequeList: 
///
///  - opBoolDequeListAsync: 
///
///  - opBoolDequeListArray: 
///
///  - opBoolDequeListArrayAsync: 
///
///  - opByteSeq: 
///
///  - opByteSeqAsync: 
///
///  - opByteList: 
///
///  - opByteListAsync: 
///
///  - opMyByteSeq: 
///
///  - opMyByteSeqAsync: 
///
///  - opStringSeq: 
///
///  - opStringSeqAsync: 
///
///  - opStringList: 
///
///  - opStringListAsync: 
///
///  - opFixedSeq: 
///
///  - opFixedSeqAsync: 
///
///  - opFixedList: 
///
///  - opFixedListAsync: 
///
///  - opVariableSeq: 
///
///  - opVariableSeqAsync: 
///
///  - opVariableList: 
///
///  - opVariableListAsync: 
///
///  - opStringStringDictSeq: 
///
///  - opStringStringDictSeqAsync: 
///
///  - opStringStringDictList: 
///
///  - opStringStringDictListAsync: 
///
///  - opESeq: 
///
///  - opESeqAsync: 
///
///  - opEList: 
///
///  - opEListAsync: 
///
///  - opDPrxSeq: 
///
///  - opDPrxSeqAsync: 
///
///  - opDPrxList: 
///
///  - opDPrxListAsync: 
///
///  - opCSeq: 
///
///  - opCSeqAsync: 
///
///  - opCList: 
///
///  - opCListAsync: 
///
///  - opOutArrayByteSeq: 
///
///  - opOutArrayByteSeqAsync: 
///
///  - opIntStringDict: 
///
///  - opIntStringDictAsync: 
///
///  - opVarDict: 
///
///  - opVarDictAsync: 
///
///  - opShortBuffer: 
///
///  - opShortBufferAsync: 
///
///  - opBoolBuffer: 
///
///  - opBoolBufferAsync: 
///
///  - opBufferStruct: 
///
///  - opBufferStructAsync: 
///
///  - shutdown: 
///
///  - shutdownAsync: 
public extension TestIntfPrx {
    ///
    /// - parameter _: `DoubleSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: DoubleSeq, outSeq: DoubleSeq)`:
    ///
    ///   - returnValue: `DoubleSeq`
    ///
    ///   - outSeq: `DoubleSeq`
    func opDoubleArray(_ iceP_inSeq: DoubleSeq, context: Ice.Context? = nil) throws -> (returnValue: DoubleSeq, outSeq: DoubleSeq) {
        return try _impl._invoke(operation: "opDoubleArray",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_inSeq)
                                 },
                                 read: { istr in
                                     let iceP_outSeq: DoubleSeq = try istr.read()
                                     let iceP_returnValue: DoubleSeq = try istr.read()
                                     return (iceP_returnValue, iceP_outSeq)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `DoubleSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: DoubleSeq, outSeq: DoubleSeq)>` - The result of the operation
    func opDoubleArrayAsync(_ iceP_inSeq: DoubleSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: DoubleSeq, outSeq: DoubleSeq)> {
        return _impl._invokeAsync(operation: "opDoubleArray",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_inSeq)
                                  },
                                  read: { istr in
                                      let iceP_outSeq: DoubleSeq = try istr.read()
                                      let iceP_returnValue: DoubleSeq = try istr.read()
                                      return (iceP_returnValue, iceP_outSeq)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `BoolSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: BoolSeq, outSeq: BoolSeq)`:
    ///
    ///   - returnValue: `BoolSeq`
    ///
    ///   - outSeq: `BoolSeq`
    func opBoolArray(_ iceP_inSeq: BoolSeq, context: Ice.Context? = nil) throws -> (returnValue: BoolSeq, outSeq: BoolSeq) {
        return try _impl._invoke(operation: "opBoolArray",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_inSeq)
                                 },
                                 read: { istr in
                                     let iceP_outSeq: BoolSeq = try istr.read()
                                     let iceP_returnValue: BoolSeq = try istr.read()
                                     return (iceP_returnValue, iceP_outSeq)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `BoolSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: BoolSeq, outSeq: BoolSeq)>` - The result of the operation
    func opBoolArrayAsync(_ iceP_inSeq: BoolSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: BoolSeq, outSeq: BoolSeq)> {
        return _impl._invokeAsync(operation: "opBoolArray",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_inSeq)
                                  },
                                  read: { istr in
                                      let iceP_outSeq: BoolSeq = try istr.read()
                                      let iceP_returnValue: BoolSeq = try istr.read()
                                      return (iceP_returnValue, iceP_outSeq)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `ByteList`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: ByteList, outSeq: ByteList)`:
    ///
    ///   - returnValue: `ByteList`
    ///
    ///   - outSeq: `ByteList`
    func opByteArray(_ iceP_inSeq: ByteList, context: Ice.Context? = nil) throws -> (returnValue: ByteList, outSeq: ByteList) {
        return try _impl._invoke(operation: "opByteArray",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_inSeq)
                                 },
                                 read: { istr in
                                     let iceP_outSeq: ByteList = try istr.read()
                                     let iceP_returnValue: ByteList = try istr.read()
                                     return (iceP_returnValue, iceP_outSeq)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `ByteList`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: ByteList, outSeq: ByteList)>` - The result of the operation
    func opByteArrayAsync(_ iceP_inSeq: ByteList, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: ByteList, outSeq: ByteList)> {
        return _impl._invokeAsync(operation: "opByteArray",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_inSeq)
                                  },
                                  read: { istr in
                                      let iceP_outSeq: ByteList = try istr.read()
                                      let iceP_returnValue: ByteList = try istr.read()
                                      return (iceP_returnValue, iceP_outSeq)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `VariableList`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: VariableList, outSeq: VariableList)`:
    ///
    ///   - returnValue: `VariableList`
    ///
    ///   - outSeq: `VariableList`
    func opVariableArray(_ iceP_inSeq: VariableList, context: Ice.Context? = nil) throws -> (returnValue: VariableList, outSeq: VariableList) {
        return try _impl._invoke(operation: "opVariableArray",
                                 mode: .Normal,
                                 write: { ostr in
                                     VariableListHelper.write(to: ostr, value: iceP_inSeq)
                                 },
                                 read: { istr in
                                     let iceP_outSeq: VariableList = try VariableListHelper.read(from: istr)
                                     let iceP_returnValue: VariableList = try VariableListHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_outSeq)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `VariableList`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: VariableList, outSeq: VariableList)>` - The result of the operation
    func opVariableArrayAsync(_ iceP_inSeq: VariableList, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: VariableList, outSeq: VariableList)> {
        return _impl._invokeAsync(operation: "opVariableArray",
                                  mode: .Normal,
                                  write: { ostr in
                                      VariableListHelper.write(to: ostr, value: iceP_inSeq)
                                  },
                                  read: { istr in
                                      let iceP_outSeq: VariableList = try VariableListHelper.read(from: istr)
                                      let iceP_returnValue: VariableList = try VariableListHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_outSeq)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `BoolSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: BoolSeq, outSeq: BoolSeq)`:
    ///
    ///   - returnValue: `BoolSeq`
    ///
    ///   - outSeq: `BoolSeq`
    func opBoolSeq(_ iceP_inSeq: BoolSeq, context: Ice.Context? = nil) throws -> (returnValue: BoolSeq, outSeq: BoolSeq) {
        return try _impl._invoke(operation: "opBoolSeq",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_inSeq)
                                 },
                                 read: { istr in
                                     let iceP_outSeq: BoolSeq = try istr.read()
                                     let iceP_returnValue: BoolSeq = try istr.read()
                                     return (iceP_returnValue, iceP_outSeq)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `BoolSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: BoolSeq, outSeq: BoolSeq)>` - The result of the operation
    func opBoolSeqAsync(_ iceP_inSeq: BoolSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: BoolSeq, outSeq: BoolSeq)> {
        return _impl._invokeAsync(operation: "opBoolSeq",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_inSeq)
                                  },
                                  read: { istr in
                                      let iceP_outSeq: BoolSeq = try istr.read()
                                      let iceP_returnValue: BoolSeq = try istr.read()
                                      return (iceP_returnValue, iceP_outSeq)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `BoolList`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: BoolList, outSeq: BoolList)`:
    ///
    ///   - returnValue: `BoolList`
    ///
    ///   - outSeq: `BoolList`
    func opBoolList(_ iceP_inSeq: BoolList, context: Ice.Context? = nil) throws -> (returnValue: BoolList, outSeq: BoolList) {
        return try _impl._invoke(operation: "opBoolList",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_inSeq)
                                 },
                                 read: { istr in
                                     let iceP_outSeq: BoolList = try istr.read()
                                     let iceP_returnValue: BoolList = try istr.read()
                                     return (iceP_returnValue, iceP_outSeq)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `BoolList`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: BoolList, outSeq: BoolList)>` - The result of the operation
    func opBoolListAsync(_ iceP_inSeq: BoolList, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: BoolList, outSeq: BoolList)> {
        return _impl._invokeAsync(operation: "opBoolList",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_inSeq)
                                  },
                                  read: { istr in
                                      let iceP_outSeq: BoolList = try istr.read()
                                      let iceP_returnValue: BoolList = try istr.read()
                                      return (iceP_returnValue, iceP_outSeq)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `BoolDequeList`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: BoolDequeList, outSeq: BoolDequeList)`:
    ///
    ///   - returnValue: `BoolDequeList`
    ///
    ///   - outSeq: `BoolDequeList`
    func opBoolDequeList(_ iceP_inSeq: BoolDequeList, context: Ice.Context? = nil) throws -> (returnValue: BoolDequeList, outSeq: BoolDequeList) {
        return try _impl._invoke(operation: "opBoolDequeList",
                                 mode: .Normal,
                                 write: { ostr in
                                     BoolDequeListHelper.write(to: ostr, value: iceP_inSeq)
                                 },
                                 read: { istr in
                                     let iceP_outSeq: BoolDequeList = try BoolDequeListHelper.read(from: istr)
                                     let iceP_returnValue: BoolDequeList = try BoolDequeListHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_outSeq)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `BoolDequeList`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: BoolDequeList, outSeq: BoolDequeList)>` - The result of the operation
    func opBoolDequeListAsync(_ iceP_inSeq: BoolDequeList, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: BoolDequeList, outSeq: BoolDequeList)> {
        return _impl._invokeAsync(operation: "opBoolDequeList",
                                  mode: .Normal,
                                  write: { ostr in
                                      BoolDequeListHelper.write(to: ostr, value: iceP_inSeq)
                                  },
                                  read: { istr in
                                      let iceP_outSeq: BoolDequeList = try BoolDequeListHelper.read(from: istr)
                                      let iceP_returnValue: BoolDequeList = try BoolDequeListHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_outSeq)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `BoolDequeList`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: BoolDequeList, outSeq: BoolDequeList)`:
    ///
    ///   - returnValue: `BoolDequeList`
    ///
    ///   - outSeq: `BoolDequeList`
    func opBoolDequeListArray(_ iceP_inSeq: BoolDequeList, context: Ice.Context? = nil) throws -> (returnValue: BoolDequeList, outSeq: BoolDequeList) {
        return try _impl._invoke(operation: "opBoolDequeListArray",
                                 mode: .Normal,
                                 write: { ostr in
                                     BoolDequeListHelper.write(to: ostr, value: iceP_inSeq)
                                 },
                                 read: { istr in
                                     let iceP_outSeq: BoolDequeList = try BoolDequeListHelper.read(from: istr)
                                     let iceP_returnValue: BoolDequeList = try BoolDequeListHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_outSeq)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `BoolDequeList`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: BoolDequeList, outSeq: BoolDequeList)>` - The result of the operation
    func opBoolDequeListArrayAsync(_ iceP_inSeq: BoolDequeList, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: BoolDequeList, outSeq: BoolDequeList)> {
        return _impl._invokeAsync(operation: "opBoolDequeListArray",
                                  mode: .Normal,
                                  write: { ostr in
                                      BoolDequeListHelper.write(to: ostr, value: iceP_inSeq)
                                  },
                                  read: { istr in
                                      let iceP_outSeq: BoolDequeList = try BoolDequeListHelper.read(from: istr)
                                      let iceP_returnValue: BoolDequeList = try BoolDequeListHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_outSeq)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `ByteSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: ByteSeq, outSeq: ByteSeq)`:
    ///
    ///   - returnValue: `ByteSeq`
    ///
    ///   - outSeq: `ByteSeq`
    func opByteSeq(_ iceP_inSeq: ByteSeq, context: Ice.Context? = nil) throws -> (returnValue: ByteSeq, outSeq: ByteSeq) {
        return try _impl._invoke(operation: "opByteSeq",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_inSeq)
                                 },
                                 read: { istr in
                                     let iceP_outSeq: ByteSeq = try istr.read()
                                     let iceP_returnValue: ByteSeq = try istr.read()
                                     return (iceP_returnValue, iceP_outSeq)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `ByteSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: ByteSeq, outSeq: ByteSeq)>` - The result of the operation
    func opByteSeqAsync(_ iceP_inSeq: ByteSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: ByteSeq, outSeq: ByteSeq)> {
        return _impl._invokeAsync(operation: "opByteSeq",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_inSeq)
                                  },
                                  read: { istr in
                                      let iceP_outSeq: ByteSeq = try istr.read()
                                      let iceP_returnValue: ByteSeq = try istr.read()
                                      return (iceP_returnValue, iceP_outSeq)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `ByteList`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: ByteList, outSeq: ByteList)`:
    ///
    ///   - returnValue: `ByteList`
    ///
    ///   - outSeq: `ByteList`
    func opByteList(_ iceP_inSeq: ByteList, context: Ice.Context? = nil) throws -> (returnValue: ByteList, outSeq: ByteList) {
        return try _impl._invoke(operation: "opByteList",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_inSeq)
                                 },
                                 read: { istr in
                                     let iceP_outSeq: ByteList = try istr.read()
                                     let iceP_returnValue: ByteList = try istr.read()
                                     return (iceP_returnValue, iceP_outSeq)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `ByteList`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: ByteList, outSeq: ByteList)>` - The result of the operation
    func opByteListAsync(_ iceP_inSeq: ByteList, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: ByteList, outSeq: ByteList)> {
        return _impl._invokeAsync(operation: "opByteList",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_inSeq)
                                  },
                                  read: { istr in
                                      let iceP_outSeq: ByteList = try istr.read()
                                      let iceP_returnValue: ByteList = try istr.read()
                                      return (iceP_returnValue, iceP_outSeq)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `ByteSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: ByteSeq, outSeq: ByteSeq)`:
    ///
    ///   - returnValue: `ByteSeq`
    ///
    ///   - outSeq: `ByteSeq`
    func opMyByteSeq(_ iceP_inSeq: ByteSeq, context: Ice.Context? = nil) throws -> (returnValue: ByteSeq, outSeq: ByteSeq) {
        return try _impl._invoke(operation: "opMyByteSeq",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_inSeq)
                                 },
                                 read: { istr in
                                     let iceP_outSeq: ByteSeq = try istr.read()
                                     let iceP_returnValue: ByteSeq = try istr.read()
                                     return (iceP_returnValue, iceP_outSeq)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `ByteSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: ByteSeq, outSeq: ByteSeq)>` - The result of the operation
    func opMyByteSeqAsync(_ iceP_inSeq: ByteSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: ByteSeq, outSeq: ByteSeq)> {
        return _impl._invokeAsync(operation: "opMyByteSeq",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_inSeq)
                                  },
                                  read: { istr in
                                      let iceP_outSeq: ByteSeq = try istr.read()
                                      let iceP_returnValue: ByteSeq = try istr.read()
                                      return (iceP_returnValue, iceP_outSeq)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `StringSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: StringSeq, outSeq: StringSeq)`:
    ///
    ///   - returnValue: `StringSeq`
    ///
    ///   - outSeq: `StringSeq`
    func opStringSeq(_ iceP_inSeq: StringSeq, context: Ice.Context? = nil) throws -> (returnValue: StringSeq, outSeq: StringSeq) {
        return try _impl._invoke(operation: "opStringSeq",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_inSeq)
                                 },
                                 read: { istr in
                                     let iceP_outSeq: StringSeq = try istr.read()
                                     let iceP_returnValue: StringSeq = try istr.read()
                                     return (iceP_returnValue, iceP_outSeq)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `StringSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: StringSeq, outSeq: StringSeq)>` - The result of the operation
    func opStringSeqAsync(_ iceP_inSeq: StringSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: StringSeq, outSeq: StringSeq)> {
        return _impl._invokeAsync(operation: "opStringSeq",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_inSeq)
                                  },
                                  read: { istr in
                                      let iceP_outSeq: StringSeq = try istr.read()
                                      let iceP_returnValue: StringSeq = try istr.read()
                                      return (iceP_returnValue, iceP_outSeq)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `StringList`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: StringList, outSeq: StringList)`:
    ///
    ///   - returnValue: `StringList`
    ///
    ///   - outSeq: `StringList`
    func opStringList(_ iceP_inSeq: StringList, context: Ice.Context? = nil) throws -> (returnValue: StringList, outSeq: StringList) {
        return try _impl._invoke(operation: "opStringList",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_inSeq)
                                 },
                                 read: { istr in
                                     let iceP_outSeq: StringList = try istr.read()
                                     let iceP_returnValue: StringList = try istr.read()
                                     return (iceP_returnValue, iceP_outSeq)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `StringList`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: StringList, outSeq: StringList)>` - The result of the operation
    func opStringListAsync(_ iceP_inSeq: StringList, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: StringList, outSeq: StringList)> {
        return _impl._invokeAsync(operation: "opStringList",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_inSeq)
                                  },
                                  read: { istr in
                                      let iceP_outSeq: StringList = try istr.read()
                                      let iceP_returnValue: StringList = try istr.read()
                                      return (iceP_returnValue, iceP_outSeq)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `FixedSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: FixedSeq, outSeq: FixedSeq)`:
    ///
    ///   - returnValue: `FixedSeq`
    ///
    ///   - outSeq: `FixedSeq`
    func opFixedSeq(_ iceP_inSeq: FixedSeq, context: Ice.Context? = nil) throws -> (returnValue: FixedSeq, outSeq: FixedSeq) {
        return try _impl._invoke(operation: "opFixedSeq",
                                 mode: .Normal,
                                 write: { ostr in
                                     FixedSeqHelper.write(to: ostr, value: iceP_inSeq)
                                 },
                                 read: { istr in
                                     let iceP_outSeq: FixedSeq = try FixedSeqHelper.read(from: istr)
                                     let iceP_returnValue: FixedSeq = try FixedSeqHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_outSeq)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `FixedSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: FixedSeq, outSeq: FixedSeq)>` - The result of the operation
    func opFixedSeqAsync(_ iceP_inSeq: FixedSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: FixedSeq, outSeq: FixedSeq)> {
        return _impl._invokeAsync(operation: "opFixedSeq",
                                  mode: .Normal,
                                  write: { ostr in
                                      FixedSeqHelper.write(to: ostr, value: iceP_inSeq)
                                  },
                                  read: { istr in
                                      let iceP_outSeq: FixedSeq = try FixedSeqHelper.read(from: istr)
                                      let iceP_returnValue: FixedSeq = try FixedSeqHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_outSeq)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `FixedList`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: FixedList, outSeq: FixedList)`:
    ///
    ///   - returnValue: `FixedList`
    ///
    ///   - outSeq: `FixedList`
    func opFixedList(_ iceP_inSeq: FixedList, context: Ice.Context? = nil) throws -> (returnValue: FixedList, outSeq: FixedList) {
        return try _impl._invoke(operation: "opFixedList",
                                 mode: .Normal,
                                 write: { ostr in
                                     FixedListHelper.write(to: ostr, value: iceP_inSeq)
                                 },
                                 read: { istr in
                                     let iceP_outSeq: FixedList = try FixedListHelper.read(from: istr)
                                     let iceP_returnValue: FixedList = try FixedListHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_outSeq)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `FixedList`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: FixedList, outSeq: FixedList)>` - The result of the operation
    func opFixedListAsync(_ iceP_inSeq: FixedList, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: FixedList, outSeq: FixedList)> {
        return _impl._invokeAsync(operation: "opFixedList",
                                  mode: .Normal,
                                  write: { ostr in
                                      FixedListHelper.write(to: ostr, value: iceP_inSeq)
                                  },
                                  read: { istr in
                                      let iceP_outSeq: FixedList = try FixedListHelper.read(from: istr)
                                      let iceP_returnValue: FixedList = try FixedListHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_outSeq)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `VariableSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: VariableSeq, outSeq: VariableSeq)`:
    ///
    ///   - returnValue: `VariableSeq`
    ///
    ///   - outSeq: `VariableSeq`
    func opVariableSeq(_ iceP_inSeq: VariableSeq, context: Ice.Context? = nil) throws -> (returnValue: VariableSeq, outSeq: VariableSeq) {
        return try _impl._invoke(operation: "opVariableSeq",
                                 mode: .Normal,
                                 write: { ostr in
                                     VariableSeqHelper.write(to: ostr, value: iceP_inSeq)
                                 },
                                 read: { istr in
                                     let iceP_outSeq: VariableSeq = try VariableSeqHelper.read(from: istr)
                                     let iceP_returnValue: VariableSeq = try VariableSeqHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_outSeq)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `VariableSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: VariableSeq, outSeq: VariableSeq)>` - The result of the operation
    func opVariableSeqAsync(_ iceP_inSeq: VariableSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: VariableSeq, outSeq: VariableSeq)> {
        return _impl._invokeAsync(operation: "opVariableSeq",
                                  mode: .Normal,
                                  write: { ostr in
                                      VariableSeqHelper.write(to: ostr, value: iceP_inSeq)
                                  },
                                  read: { istr in
                                      let iceP_outSeq: VariableSeq = try VariableSeqHelper.read(from: istr)
                                      let iceP_returnValue: VariableSeq = try VariableSeqHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_outSeq)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `VariableList`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: VariableList, outSeq: VariableList)`:
    ///
    ///   - returnValue: `VariableList`
    ///
    ///   - outSeq: `VariableList`
    func opVariableList(_ iceP_inSeq: VariableList, context: Ice.Context? = nil) throws -> (returnValue: VariableList, outSeq: VariableList) {
        return try _impl._invoke(operation: "opVariableList",
                                 mode: .Normal,
                                 write: { ostr in
                                     VariableListHelper.write(to: ostr, value: iceP_inSeq)
                                 },
                                 read: { istr in
                                     let iceP_outSeq: VariableList = try VariableListHelper.read(from: istr)
                                     let iceP_returnValue: VariableList = try VariableListHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_outSeq)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `VariableList`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: VariableList, outSeq: VariableList)>` - The result of the operation
    func opVariableListAsync(_ iceP_inSeq: VariableList, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: VariableList, outSeq: VariableList)> {
        return _impl._invokeAsync(operation: "opVariableList",
                                  mode: .Normal,
                                  write: { ostr in
                                      VariableListHelper.write(to: ostr, value: iceP_inSeq)
                                  },
                                  read: { istr in
                                      let iceP_outSeq: VariableList = try VariableListHelper.read(from: istr)
                                      let iceP_returnValue: VariableList = try VariableListHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_outSeq)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `StringStringDictSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: StringStringDictSeq, outSeq: StringStringDictSeq)`:
    ///
    ///   - returnValue: `StringStringDictSeq`
    ///
    ///   - outSeq: `StringStringDictSeq`
    func opStringStringDictSeq(_ iceP_inSeq: StringStringDictSeq, context: Ice.Context? = nil) throws -> (returnValue: StringStringDictSeq, outSeq: StringStringDictSeq) {
        return try _impl._invoke(operation: "opStringStringDictSeq",
                                 mode: .Normal,
                                 write: { ostr in
                                     StringStringDictSeqHelper.write(to: ostr, value: iceP_inSeq)
                                 },
                                 read: { istr in
                                     let iceP_outSeq: StringStringDictSeq = try StringStringDictSeqHelper.read(from: istr)
                                     let iceP_returnValue: StringStringDictSeq = try StringStringDictSeqHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_outSeq)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `StringStringDictSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: StringStringDictSeq, outSeq: StringStringDictSeq)>` - The result of the operation
    func opStringStringDictSeqAsync(_ iceP_inSeq: StringStringDictSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: StringStringDictSeq, outSeq: StringStringDictSeq)> {
        return _impl._invokeAsync(operation: "opStringStringDictSeq",
                                  mode: .Normal,
                                  write: { ostr in
                                      StringStringDictSeqHelper.write(to: ostr, value: iceP_inSeq)
                                  },
                                  read: { istr in
                                      let iceP_outSeq: StringStringDictSeq = try StringStringDictSeqHelper.read(from: istr)
                                      let iceP_returnValue: StringStringDictSeq = try StringStringDictSeqHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_outSeq)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `StringStringDictList`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: StringStringDictList, outSeq: StringStringDictList)`:
    ///
    ///   - returnValue: `StringStringDictList`
    ///
    ///   - outSeq: `StringStringDictList`
    func opStringStringDictList(_ iceP_inSeq: StringStringDictList, context: Ice.Context? = nil) throws -> (returnValue: StringStringDictList, outSeq: StringStringDictList) {
        return try _impl._invoke(operation: "opStringStringDictList",
                                 mode: .Normal,
                                 write: { ostr in
                                     StringStringDictListHelper.write(to: ostr, value: iceP_inSeq)
                                 },
                                 read: { istr in
                                     let iceP_outSeq: StringStringDictList = try StringStringDictListHelper.read(from: istr)
                                     let iceP_returnValue: StringStringDictList = try StringStringDictListHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_outSeq)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `StringStringDictList`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: StringStringDictList, outSeq: StringStringDictList)>` - The result of the operation
    func opStringStringDictListAsync(_ iceP_inSeq: StringStringDictList, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: StringStringDictList, outSeq: StringStringDictList)> {
        return _impl._invokeAsync(operation: "opStringStringDictList",
                                  mode: .Normal,
                                  write: { ostr in
                                      StringStringDictListHelper.write(to: ostr, value: iceP_inSeq)
                                  },
                                  read: { istr in
                                      let iceP_outSeq: StringStringDictList = try StringStringDictListHelper.read(from: istr)
                                      let iceP_returnValue: StringStringDictList = try StringStringDictListHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_outSeq)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `ESeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: ESeq, outSeq: ESeq)`:
    ///
    ///   - returnValue: `ESeq`
    ///
    ///   - outSeq: `ESeq`
    func opESeq(_ iceP_inSeq: ESeq, context: Ice.Context? = nil) throws -> (returnValue: ESeq, outSeq: ESeq) {
        return try _impl._invoke(operation: "opESeq",
                                 mode: .Normal,
                                 write: { ostr in
                                     ESeqHelper.write(to: ostr, value: iceP_inSeq)
                                 },
                                 read: { istr in
                                     let iceP_outSeq: ESeq = try ESeqHelper.read(from: istr)
                                     let iceP_returnValue: ESeq = try ESeqHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_outSeq)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `ESeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: ESeq, outSeq: ESeq)>` - The result of the operation
    func opESeqAsync(_ iceP_inSeq: ESeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: ESeq, outSeq: ESeq)> {
        return _impl._invokeAsync(operation: "opESeq",
                                  mode: .Normal,
                                  write: { ostr in
                                      ESeqHelper.write(to: ostr, value: iceP_inSeq)
                                  },
                                  read: { istr in
                                      let iceP_outSeq: ESeq = try ESeqHelper.read(from: istr)
                                      let iceP_returnValue: ESeq = try ESeqHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_outSeq)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `EList`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: EList, outSeq: EList)`:
    ///
    ///   - returnValue: `EList`
    ///
    ///   - outSeq: `EList`
    func opEList(_ iceP_inSeq: EList, context: Ice.Context? = nil) throws -> (returnValue: EList, outSeq: EList) {
        return try _impl._invoke(operation: "opEList",
                                 mode: .Normal,
                                 write: { ostr in
                                     EListHelper.write(to: ostr, value: iceP_inSeq)
                                 },
                                 read: { istr in
                                     let iceP_outSeq: EList = try EListHelper.read(from: istr)
                                     let iceP_returnValue: EList = try EListHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_outSeq)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `EList`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: EList, outSeq: EList)>` - The result of the operation
    func opEListAsync(_ iceP_inSeq: EList, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: EList, outSeq: EList)> {
        return _impl._invokeAsync(operation: "opEList",
                                  mode: .Normal,
                                  write: { ostr in
                                      EListHelper.write(to: ostr, value: iceP_inSeq)
                                  },
                                  read: { istr in
                                      let iceP_outSeq: EList = try EListHelper.read(from: istr)
                                      let iceP_returnValue: EList = try EListHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_outSeq)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `DPrxSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: DPrxSeq, outSeq: DPrxSeq)`:
    ///
    ///   - returnValue: `DPrxSeq`
    ///
    ///   - outSeq: `DPrxSeq`
    func opDPrxSeq(_ iceP_inSeq: DPrxSeq, context: Ice.Context? = nil) throws -> (returnValue: DPrxSeq, outSeq: DPrxSeq) {
        return try _impl._invoke(operation: "opDPrxSeq",
                                 mode: .Normal,
                                 write: { ostr in
                                     DPrxSeqHelper.write(to: ostr, value: iceP_inSeq)
                                 },
                                 read: { istr in
                                     let iceP_outSeq: DPrxSeq = try DPrxSeqHelper.read(from: istr)
                                     let iceP_returnValue: DPrxSeq = try DPrxSeqHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_outSeq)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `DPrxSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: DPrxSeq, outSeq: DPrxSeq)>` - The result of the operation
    func opDPrxSeqAsync(_ iceP_inSeq: DPrxSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: DPrxSeq, outSeq: DPrxSeq)> {
        return _impl._invokeAsync(operation: "opDPrxSeq",
                                  mode: .Normal,
                                  write: { ostr in
                                      DPrxSeqHelper.write(to: ostr, value: iceP_inSeq)
                                  },
                                  read: { istr in
                                      let iceP_outSeq: DPrxSeq = try DPrxSeqHelper.read(from: istr)
                                      let iceP_returnValue: DPrxSeq = try DPrxSeqHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_outSeq)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `DPrxList`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: DPrxList, outSeq: DPrxList)`:
    ///
    ///   - returnValue: `DPrxList`
    ///
    ///   - outSeq: `DPrxList`
    func opDPrxList(_ iceP_inSeq: DPrxList, context: Ice.Context? = nil) throws -> (returnValue: DPrxList, outSeq: DPrxList) {
        return try _impl._invoke(operation: "opDPrxList",
                                 mode: .Normal,
                                 write: { ostr in
                                     DPrxListHelper.write(to: ostr, value: iceP_inSeq)
                                 },
                                 read: { istr in
                                     let iceP_outSeq: DPrxList = try DPrxListHelper.read(from: istr)
                                     let iceP_returnValue: DPrxList = try DPrxListHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_outSeq)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `DPrxList`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: DPrxList, outSeq: DPrxList)>` - The result of the operation
    func opDPrxListAsync(_ iceP_inSeq: DPrxList, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: DPrxList, outSeq: DPrxList)> {
        return _impl._invokeAsync(operation: "opDPrxList",
                                  mode: .Normal,
                                  write: { ostr in
                                      DPrxListHelper.write(to: ostr, value: iceP_inSeq)
                                  },
                                  read: { istr in
                                      let iceP_outSeq: DPrxList = try DPrxListHelper.read(from: istr)
                                      let iceP_returnValue: DPrxList = try DPrxListHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_outSeq)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `CSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: CSeq, outSeq: CSeq)`:
    ///
    ///   - returnValue: `CSeq`
    ///
    ///   - outSeq: `CSeq`
    func opCSeq(_ iceP_inSeq: CSeq, context: Ice.Context? = nil) throws -> (returnValue: CSeq, outSeq: CSeq) {
        return try _impl._invoke(operation: "opCSeq",
                                 mode: .Normal,
                                 write: { ostr in
                                     CSeqHelper.write(to: ostr, value: iceP_inSeq)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     let iceP_outSeq: CSeq = try CSeqHelper.read(from: istr)
                                     let iceP_returnValue: CSeq = try CSeqHelper.read(from: istr)
                                     try istr.readPendingValues()
                                     return (iceP_returnValue, iceP_outSeq)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `CSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: CSeq, outSeq: CSeq)>` - The result of the operation
    func opCSeqAsync(_ iceP_inSeq: CSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: CSeq, outSeq: CSeq)> {
        return _impl._invokeAsync(operation: "opCSeq",
                                  mode: .Normal,
                                  write: { ostr in
                                      CSeqHelper.write(to: ostr, value: iceP_inSeq)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      let iceP_outSeq: CSeq = try CSeqHelper.read(from: istr)
                                      let iceP_returnValue: CSeq = try CSeqHelper.read(from: istr)
                                      try istr.readPendingValues()
                                      return (iceP_returnValue, iceP_outSeq)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `CList`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: CList, outSeq: CList)`:
    ///
    ///   - returnValue: `CList`
    ///
    ///   - outSeq: `CList`
    func opCList(_ iceP_inSeq: CList, context: Ice.Context? = nil) throws -> (returnValue: CList, outSeq: CList) {
        return try _impl._invoke(operation: "opCList",
                                 mode: .Normal,
                                 write: { ostr in
                                     CListHelper.write(to: ostr, value: iceP_inSeq)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     let iceP_outSeq: CList = try CListHelper.read(from: istr)
                                     let iceP_returnValue: CList = try CListHelper.read(from: istr)
                                     try istr.readPendingValues()
                                     return (iceP_returnValue, iceP_outSeq)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `CList`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: CList, outSeq: CList)>` - The result of the operation
    func opCListAsync(_ iceP_inSeq: CList, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: CList, outSeq: CList)> {
        return _impl._invokeAsync(operation: "opCList",
                                  mode: .Normal,
                                  write: { ostr in
                                      CListHelper.write(to: ostr, value: iceP_inSeq)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      let iceP_outSeq: CList = try CListHelper.read(from: istr)
                                      let iceP_returnValue: CList = try CListHelper.read(from: istr)
                                      try istr.readPendingValues()
                                      return (iceP_returnValue, iceP_outSeq)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `ByteSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `ByteSeq`
    func opOutArrayByteSeq(_ iceP_org: ByteSeq, context: Ice.Context? = nil) throws -> ByteSeq {
        return try _impl._invoke(operation: "opOutArrayByteSeq",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_org)
                                 },
                                 read: { istr in
                                     let iceP_copy: ByteSeq = try istr.read()
                                     return iceP_copy
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `ByteSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<ByteSeq>` - The result of the operation
    func opOutArrayByteSeqAsync(_ iceP_org: ByteSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<ByteSeq> {
        return _impl._invokeAsync(operation: "opOutArrayByteSeq",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_org)
                                  },
                                  read: { istr in
                                      let iceP_copy: ByteSeq = try istr.read()
                                      return iceP_copy
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `IntStringDict`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: IntStringDict, odict: IntStringDict)`:
    ///
    ///   - returnValue: `IntStringDict`
    ///
    ///   - odict: `IntStringDict`
    func opIntStringDict(_ iceP_idict: IntStringDict, context: Ice.Context? = nil) throws -> (returnValue: IntStringDict, odict: IntStringDict) {
        return try _impl._invoke(operation: "opIntStringDict",
                                 mode: .Normal,
                                 write: { ostr in
                                     IntStringDictHelper.write(to: ostr, value: iceP_idict)
                                 },
                                 read: { istr in
                                     let iceP_odict: IntStringDict = try IntStringDictHelper.read(from: istr)
                                     let iceP_returnValue: IntStringDict = try IntStringDictHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_odict)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `IntStringDict`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: IntStringDict, odict: IntStringDict)>` - The result of the operation
    func opIntStringDictAsync(_ iceP_idict: IntStringDict, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: IntStringDict, odict: IntStringDict)> {
        return _impl._invokeAsync(operation: "opIntStringDict",
                                  mode: .Normal,
                                  write: { ostr in
                                      IntStringDictHelper.write(to: ostr, value: iceP_idict)
                                  },
                                  read: { istr in
                                      let iceP_odict: IntStringDict = try IntStringDictHelper.read(from: istr)
                                      let iceP_returnValue: IntStringDict = try IntStringDictHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_odict)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `StringIntDict`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: LongLongDict, odict: StringIntDict)`:
    ///
    ///   - returnValue: `LongLongDict`
    ///
    ///   - odict: `StringIntDict`
    func opVarDict(_ iceP_idict: StringIntDict, context: Ice.Context? = nil) throws -> (returnValue: LongLongDict, odict: StringIntDict) {
        return try _impl._invoke(operation: "opVarDict",
                                 mode: .Normal,
                                 write: { ostr in
                                     StringIntDictHelper.write(to: ostr, value: iceP_idict)
                                 },
                                 read: { istr in
                                     let iceP_odict: StringIntDict = try StringIntDictHelper.read(from: istr)
                                     let iceP_returnValue: LongLongDict = try LongLongDictHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_odict)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `StringIntDict`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: LongLongDict, odict: StringIntDict)>` - The result of the operation
    func opVarDictAsync(_ iceP_idict: StringIntDict, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: LongLongDict, odict: StringIntDict)> {
        return _impl._invokeAsync(operation: "opVarDict",
                                  mode: .Normal,
                                  write: { ostr in
                                      StringIntDictHelper.write(to: ostr, value: iceP_idict)
                                  },
                                  read: { istr in
                                      let iceP_odict: StringIntDict = try StringIntDictHelper.read(from: istr)
                                      let iceP_returnValue: LongLongDict = try LongLongDictHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_odict)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `ShortBuffer`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: ShortBuffer, outS: ShortBuffer)`:
    ///
    ///   - returnValue: `ShortBuffer`
    ///
    ///   - outS: `ShortBuffer`
    func opShortBuffer(_ iceP_inS: ShortBuffer, context: Ice.Context? = nil) throws -> (returnValue: ShortBuffer, outS: ShortBuffer) {
        return try _impl._invoke(operation: "opShortBuffer",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_inS)
                                 },
                                 read: { istr in
                                     let iceP_outS: ShortBuffer = try istr.read()
                                     let iceP_returnValue: ShortBuffer = try istr.read()
                                     return (iceP_returnValue, iceP_outS)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `ShortBuffer`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: ShortBuffer, outS: ShortBuffer)>` - The result of the operation
    func opShortBufferAsync(_ iceP_inS: ShortBuffer, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: ShortBuffer, outS: ShortBuffer)> {
        return _impl._invokeAsync(operation: "opShortBuffer",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_inS)
                                  },
                                  read: { istr in
                                      let iceP_outS: ShortBuffer = try istr.read()
                                      let iceP_returnValue: ShortBuffer = try istr.read()
                                      return (iceP_returnValue, iceP_outS)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `BoolSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: BoolSeq, outS: BoolSeq)`:
    ///
    ///   - returnValue: `BoolSeq`
    ///
    ///   - outS: `BoolSeq`
    func opBoolBuffer(_ iceP_inS: BoolSeq, context: Ice.Context? = nil) throws -> (returnValue: BoolSeq, outS: BoolSeq) {
        return try _impl._invoke(operation: "opBoolBuffer",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_inS)
                                 },
                                 read: { istr in
                                     let iceP_outS: BoolSeq = try istr.read()
                                     let iceP_returnValue: BoolSeq = try istr.read()
                                     return (iceP_returnValue, iceP_outS)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `BoolSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: BoolSeq, outS: BoolSeq)>` - The result of the operation
    func opBoolBufferAsync(_ iceP_inS: BoolSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: BoolSeq, outS: BoolSeq)> {
        return _impl._invokeAsync(operation: "opBoolBuffer",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_inS)
                                  },
                                  read: { istr in
                                      let iceP_outS: BoolSeq = try istr.read()
                                      let iceP_returnValue: BoolSeq = try istr.read()
                                      return (iceP_returnValue, iceP_outS)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `BufferStruct`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `BufferStruct`
    func opBufferStruct(_ iceP_s: BufferStruct, context: Ice.Context? = nil) throws -> BufferStruct {
        return try _impl._invoke(operation: "opBufferStruct",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_s)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: BufferStruct = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `BufferStruct`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<BufferStruct>` - The result of the operation
    func opBufferStructAsync(_ iceP_s: BufferStruct, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<BufferStruct> {
        return _impl._invokeAsync(operation: "opBufferStruct",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_s)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: BufferStruct = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func shutdown(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "shutdown",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func shutdownAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "shutdown",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// :nodoc:
public class C_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return C.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_C() -> Ice.ValueTypeResolver {
        return C_TypeResolver()
    }
}

open class C: Ice.Value {
    public required init() {}

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return CTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return CTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CTraits.staticId, compactId: -1, last: true)
        ostr.endSlice()
    }
}

/// :nodoc:
public class DictClass_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return DictClass.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_DictClass() -> Ice.ValueTypeResolver {
        return DictClass_TypeResolver()
    }
}

open class DictClass: Ice.Value {
    public var isdict: IntStringDict = IntStringDict()

    public required init() {}

    public init(isdict: IntStringDict) {
        self.isdict = isdict
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return DictClassTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return DictClassTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.isdict = try IntStringDictHelper.read(from: istr)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: DictClassTraits.staticId, compactId: -1, last: true)
        IntStringDictHelper.write(to: ostr, value: self.isdict)
        ostr.endSlice()
    }
}


/// Dispatcher for `D` servants.
public struct DDisp: Ice.Disp {
    public let servant: D
    private static let defaultObject = Ice.ObjectI<DTraits>()

    public init(_ servant: D) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "ice_id":
            return try (servant as? Object ?? DDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? DDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? DDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? DDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol D {}


/// Dispatcher for `TestIntf` servants.
public struct TestIntfDisp: Ice.Disp {
    public let servant: TestIntf
    private static let defaultObject = Ice.ObjectI<TestIntfTraits>()

    public init(_ servant: TestIntf) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "ice_id":
            return try (servant as? Object ?? TestIntfDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? TestIntfDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? TestIntfDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? TestIntfDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "opBoolArray":
            return try servant._iceD_opBoolArray(incoming: request, current: current)
        case "opBoolBuffer":
            return try servant._iceD_opBoolBuffer(incoming: request, current: current)
        case "opBoolDequeList":
            return try servant._iceD_opBoolDequeList(incoming: request, current: current)
        case "opBoolDequeListArray":
            return try servant._iceD_opBoolDequeListArray(incoming: request, current: current)
        case "opBoolList":
            return try servant._iceD_opBoolList(incoming: request, current: current)
        case "opBoolSeq":
            return try servant._iceD_opBoolSeq(incoming: request, current: current)
        case "opBufferStruct":
            return try servant._iceD_opBufferStruct(incoming: request, current: current)
        case "opByteArray":
            return try servant._iceD_opByteArray(incoming: request, current: current)
        case "opByteList":
            return try servant._iceD_opByteList(incoming: request, current: current)
        case "opByteSeq":
            return try servant._iceD_opByteSeq(incoming: request, current: current)
        case "opCList":
            return try servant._iceD_opCList(incoming: request, current: current)
        case "opCSeq":
            return try servant._iceD_opCSeq(incoming: request, current: current)
        case "opDPrxList":
            return try servant._iceD_opDPrxList(incoming: request, current: current)
        case "opDPrxSeq":
            return try servant._iceD_opDPrxSeq(incoming: request, current: current)
        case "opDoubleArray":
            return try servant._iceD_opDoubleArray(incoming: request, current: current)
        case "opEList":
            return try servant._iceD_opEList(incoming: request, current: current)
        case "opESeq":
            return try servant._iceD_opESeq(incoming: request, current: current)
        case "opFixedList":
            return try servant._iceD_opFixedList(incoming: request, current: current)
        case "opFixedSeq":
            return try servant._iceD_opFixedSeq(incoming: request, current: current)
        case "opIntStringDict":
            return try servant._iceD_opIntStringDict(incoming: request, current: current)
        case "opMyByteSeq":
            return try servant._iceD_opMyByteSeq(incoming: request, current: current)
        case "opOutArrayByteSeq":
            return try servant._iceD_opOutArrayByteSeq(incoming: request, current: current)
        case "opShortBuffer":
            return try servant._iceD_opShortBuffer(incoming: request, current: current)
        case "opStringList":
            return try servant._iceD_opStringList(incoming: request, current: current)
        case "opStringSeq":
            return try servant._iceD_opStringSeq(incoming: request, current: current)
        case "opStringStringDictList":
            return try servant._iceD_opStringStringDictList(incoming: request, current: current)
        case "opStringStringDictSeq":
            return try servant._iceD_opStringStringDictSeq(incoming: request, current: current)
        case "opVarDict":
            return try servant._iceD_opVarDict(incoming: request, current: current)
        case "opVariableArray":
            return try servant._iceD_opVariableArray(incoming: request, current: current)
        case "opVariableList":
            return try servant._iceD_opVariableList(incoming: request, current: current)
        case "opVariableSeq":
            return try servant._iceD_opVariableSeq(incoming: request, current: current)
        case "shutdown":
            return try servant._iceD_shutdown(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol TestIntf {
    ///
    /// - parameter inSeq: `DoubleSeq`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: DoubleSeq, outSeq: DoubleSeq)`:
    ///
    ///   - returnValue: `DoubleSeq`
    ///
    ///   - outSeq: `DoubleSeq`
    func opDoubleArray(inSeq: DoubleSeq, current: Ice.Current) throws -> (returnValue: DoubleSeq, outSeq: DoubleSeq)

    ///
    /// - parameter inSeq: `BoolSeq`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: BoolSeq, outSeq: BoolSeq)`:
    ///
    ///   - returnValue: `BoolSeq`
    ///
    ///   - outSeq: `BoolSeq`
    func opBoolArray(inSeq: BoolSeq, current: Ice.Current) throws -> (returnValue: BoolSeq, outSeq: BoolSeq)

    ///
    /// - parameter inSeq: `ByteList`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: ByteList, outSeq: ByteList)`:
    ///
    ///   - returnValue: `ByteList`
    ///
    ///   - outSeq: `ByteList`
    func opByteArray(inSeq: ByteList, current: Ice.Current) throws -> (returnValue: ByteList, outSeq: ByteList)

    ///
    /// - parameter inSeq: `VariableList`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: VariableList, outSeq: VariableList)`:
    ///
    ///   - returnValue: `VariableList`
    ///
    ///   - outSeq: `VariableList`
    func opVariableArray(inSeq: VariableList, current: Ice.Current) throws -> (returnValue: VariableList, outSeq: VariableList)

    ///
    /// - parameter inSeq: `BoolSeq`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: BoolSeq, outSeq: BoolSeq)`:
    ///
    ///   - returnValue: `BoolSeq`
    ///
    ///   - outSeq: `BoolSeq`
    func opBoolSeq(inSeq: BoolSeq, current: Ice.Current) throws -> (returnValue: BoolSeq, outSeq: BoolSeq)

    ///
    /// - parameter inSeq: `BoolList`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: BoolList, outSeq: BoolList)`:
    ///
    ///   - returnValue: `BoolList`
    ///
    ///   - outSeq: `BoolList`
    func opBoolList(inSeq: BoolList, current: Ice.Current) throws -> (returnValue: BoolList, outSeq: BoolList)

    ///
    /// - parameter inSeq: `BoolDequeList`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: BoolDequeList, outSeq: BoolDequeList)`:
    ///
    ///   - returnValue: `BoolDequeList`
    ///
    ///   - outSeq: `BoolDequeList`
    func opBoolDequeList(inSeq: BoolDequeList, current: Ice.Current) throws -> (returnValue: BoolDequeList, outSeq: BoolDequeList)

    ///
    /// - parameter inSeq: `BoolDequeList`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: BoolDequeList, outSeq: BoolDequeList)`:
    ///
    ///   - returnValue: `BoolDequeList`
    ///
    ///   - outSeq: `BoolDequeList`
    func opBoolDequeListArray(inSeq: BoolDequeList, current: Ice.Current) throws -> (returnValue: BoolDequeList, outSeq: BoolDequeList)

    ///
    /// - parameter inSeq: `ByteSeq`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: ByteSeq, outSeq: ByteSeq)`:
    ///
    ///   - returnValue: `ByteSeq`
    ///
    ///   - outSeq: `ByteSeq`
    func opByteSeq(inSeq: ByteSeq, current: Ice.Current) throws -> (returnValue: ByteSeq, outSeq: ByteSeq)

    ///
    /// - parameter inSeq: `ByteList`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: ByteList, outSeq: ByteList)`:
    ///
    ///   - returnValue: `ByteList`
    ///
    ///   - outSeq: `ByteList`
    func opByteList(inSeq: ByteList, current: Ice.Current) throws -> (returnValue: ByteList, outSeq: ByteList)

    ///
    /// - parameter inSeq: `ByteSeq`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: ByteSeq, outSeq: ByteSeq)`:
    ///
    ///   - returnValue: `ByteSeq`
    ///
    ///   - outSeq: `ByteSeq`
    func opMyByteSeq(inSeq: ByteSeq, current: Ice.Current) throws -> (returnValue: ByteSeq, outSeq: ByteSeq)

    ///
    /// - parameter inSeq: `StringSeq`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: StringSeq, outSeq: StringSeq)`:
    ///
    ///   - returnValue: `StringSeq`
    ///
    ///   - outSeq: `StringSeq`
    func opStringSeq(inSeq: StringSeq, current: Ice.Current) throws -> (returnValue: StringSeq, outSeq: StringSeq)

    ///
    /// - parameter inSeq: `StringList`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: StringList, outSeq: StringList)`:
    ///
    ///   - returnValue: `StringList`
    ///
    ///   - outSeq: `StringList`
    func opStringList(inSeq: StringList, current: Ice.Current) throws -> (returnValue: StringList, outSeq: StringList)

    ///
    /// - parameter inSeq: `FixedSeq`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: FixedSeq, outSeq: FixedSeq)`:
    ///
    ///   - returnValue: `FixedSeq`
    ///
    ///   - outSeq: `FixedSeq`
    func opFixedSeq(inSeq: FixedSeq, current: Ice.Current) throws -> (returnValue: FixedSeq, outSeq: FixedSeq)

    ///
    /// - parameter inSeq: `FixedList`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: FixedList, outSeq: FixedList)`:
    ///
    ///   - returnValue: `FixedList`
    ///
    ///   - outSeq: `FixedList`
    func opFixedList(inSeq: FixedList, current: Ice.Current) throws -> (returnValue: FixedList, outSeq: FixedList)

    ///
    /// - parameter inSeq: `VariableSeq`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: VariableSeq, outSeq: VariableSeq)`:
    ///
    ///   - returnValue: `VariableSeq`
    ///
    ///   - outSeq: `VariableSeq`
    func opVariableSeq(inSeq: VariableSeq, current: Ice.Current) throws -> (returnValue: VariableSeq, outSeq: VariableSeq)

    ///
    /// - parameter inSeq: `VariableList`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: VariableList, outSeq: VariableList)`:
    ///
    ///   - returnValue: `VariableList`
    ///
    ///   - outSeq: `VariableList`
    func opVariableList(inSeq: VariableList, current: Ice.Current) throws -> (returnValue: VariableList, outSeq: VariableList)

    ///
    /// - parameter inSeq: `StringStringDictSeq`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: StringStringDictSeq, outSeq: StringStringDictSeq)`:
    ///
    ///   - returnValue: `StringStringDictSeq`
    ///
    ///   - outSeq: `StringStringDictSeq`
    func opStringStringDictSeq(inSeq: StringStringDictSeq, current: Ice.Current) throws -> (returnValue: StringStringDictSeq, outSeq: StringStringDictSeq)

    ///
    /// - parameter inSeq: `StringStringDictList`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: StringStringDictList, outSeq: StringStringDictList)`:
    ///
    ///   - returnValue: `StringStringDictList`
    ///
    ///   - outSeq: `StringStringDictList`
    func opStringStringDictList(inSeq: StringStringDictList, current: Ice.Current) throws -> (returnValue: StringStringDictList, outSeq: StringStringDictList)

    ///
    /// - parameter inSeq: `ESeq`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: ESeq, outSeq: ESeq)`:
    ///
    ///   - returnValue: `ESeq`
    ///
    ///   - outSeq: `ESeq`
    func opESeq(inSeq: ESeq, current: Ice.Current) throws -> (returnValue: ESeq, outSeq: ESeq)

    ///
    /// - parameter inSeq: `EList`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: EList, outSeq: EList)`:
    ///
    ///   - returnValue: `EList`
    ///
    ///   - outSeq: `EList`
    func opEList(inSeq: EList, current: Ice.Current) throws -> (returnValue: EList, outSeq: EList)

    ///
    /// - parameter inSeq: `DPrxSeq`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: DPrxSeq, outSeq: DPrxSeq)`:
    ///
    ///   - returnValue: `DPrxSeq`
    ///
    ///   - outSeq: `DPrxSeq`
    func opDPrxSeq(inSeq: DPrxSeq, current: Ice.Current) throws -> (returnValue: DPrxSeq, outSeq: DPrxSeq)

    ///
    /// - parameter inSeq: `DPrxList`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: DPrxList, outSeq: DPrxList)`:
    ///
    ///   - returnValue: `DPrxList`
    ///
    ///   - outSeq: `DPrxList`
    func opDPrxList(inSeq: DPrxList, current: Ice.Current) throws -> (returnValue: DPrxList, outSeq: DPrxList)

    ///
    /// - parameter inSeq: `CSeq`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: CSeq, outSeq: CSeq)`:
    ///
    ///   - returnValue: `CSeq`
    ///
    ///   - outSeq: `CSeq`
    func opCSeq(inSeq: CSeq, current: Ice.Current) throws -> (returnValue: CSeq, outSeq: CSeq)

    ///
    /// - parameter inSeq: `CList`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: CList, outSeq: CList)`:
    ///
    ///   - returnValue: `CList`
    ///
    ///   - outSeq: `CList`
    func opCList(inSeq: CList, current: Ice.Current) throws -> (returnValue: CList, outSeq: CList)

    ///
    /// - parameter org: `ByteSeq`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `ByteSeq`
    func opOutArrayByteSeq(org: ByteSeq, current: Ice.Current) throws -> ByteSeq

    ///
    /// - parameter idict: `IntStringDict`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: IntStringDict, odict: IntStringDict)`:
    ///
    ///   - returnValue: `IntStringDict`
    ///
    ///   - odict: `IntStringDict`
    func opIntStringDict(idict: IntStringDict, current: Ice.Current) throws -> (returnValue: IntStringDict, odict: IntStringDict)

    ///
    /// - parameter idict: `StringIntDict`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: LongLongDict, odict: StringIntDict)`:
    ///
    ///   - returnValue: `LongLongDict`
    ///
    ///   - odict: `StringIntDict`
    func opVarDict(idict: StringIntDict, current: Ice.Current) throws -> (returnValue: LongLongDict, odict: StringIntDict)

    ///
    /// - parameter inS: `ShortBuffer`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: ShortBuffer, outS: ShortBuffer)`:
    ///
    ///   - returnValue: `ShortBuffer`
    ///
    ///   - outS: `ShortBuffer`
    func opShortBuffer(inS: ShortBuffer, current: Ice.Current) throws -> (returnValue: ShortBuffer, outS: ShortBuffer)

    ///
    /// - parameter inS: `BoolSeq`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: BoolSeq, outS: BoolSeq)`:
    ///
    ///   - returnValue: `BoolSeq`
    ///
    ///   - outS: `BoolSeq`
    func opBoolBuffer(inS: BoolSeq, current: Ice.Current) throws -> (returnValue: BoolSeq, outS: BoolSeq)

    ///
    /// - parameter s: `BufferStruct`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `BufferStruct`
    func opBufferStruct(s: BufferStruct, current: Ice.Current) throws -> BufferStruct

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func shutdown(current: Ice.Current) throws
}

/// D overview.
public extension D {}

/// TestIntf overview.
///
/// TestIntf Methods:
///
///  - opDoubleArray: 
///
///  - opBoolArray: 
///
///  - opByteArray: 
///
///  - opVariableArray: 
///
///  - opBoolSeq: 
///
///  - opBoolList: 
///
///  - opBoolDequeList: 
///
///  - opBoolDequeListArray: 
///
///  - opByteSeq: 
///
///  - opByteList: 
///
///  - opMyByteSeq: 
///
///  - opStringSeq: 
///
///  - opStringList: 
///
///  - opFixedSeq: 
///
///  - opFixedList: 
///
///  - opVariableSeq: 
///
///  - opVariableList: 
///
///  - opStringStringDictSeq: 
///
///  - opStringStringDictList: 
///
///  - opESeq: 
///
///  - opEList: 
///
///  - opDPrxSeq: 
///
///  - opDPrxList: 
///
///  - opCSeq: 
///
///  - opCList: 
///
///  - opOutArrayByteSeq: 
///
///  - opIntStringDict: 
///
///  - opVarDict: 
///
///  - opShortBuffer: 
///
///  - opBoolBuffer: 
///
///  - opBufferStruct: 
///
///  - shutdown: 
public extension TestIntf {
    func _iceD_opDoubleArray(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_inSeq: DoubleSeq = try inS.read { istr in
            let iceP_inSeq: DoubleSeq = try istr.read()
            return iceP_inSeq
        }

        let (iceP_returnValue, iceP_outSeq) = try self.opDoubleArray(inSeq: iceP_inSeq, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_outSeq)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opBoolArray(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_inSeq: BoolSeq = try inS.read { istr in
            let iceP_inSeq: BoolSeq = try istr.read()
            return iceP_inSeq
        }

        let (iceP_returnValue, iceP_outSeq) = try self.opBoolArray(inSeq: iceP_inSeq, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_outSeq)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opByteArray(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_inSeq: ByteList = try inS.read { istr in
            let iceP_inSeq: ByteList = try istr.read()
            return iceP_inSeq
        }

        let (iceP_returnValue, iceP_outSeq) = try self.opByteArray(inSeq: iceP_inSeq, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_outSeq)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opVariableArray(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_inSeq: VariableList = try inS.read { istr in
            let iceP_inSeq: VariableList = try VariableListHelper.read(from: istr)
            return iceP_inSeq
        }

        let (iceP_returnValue, iceP_outSeq) = try self.opVariableArray(inSeq: iceP_inSeq, current: current)

        return inS.setResult{ ostr in
            VariableListHelper.write(to: ostr, value: iceP_outSeq)
            VariableListHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opBoolSeq(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_inSeq: BoolSeq = try inS.read { istr in
            let iceP_inSeq: BoolSeq = try istr.read()
            return iceP_inSeq
        }

        let (iceP_returnValue, iceP_outSeq) = try self.opBoolSeq(inSeq: iceP_inSeq, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_outSeq)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opBoolList(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_inSeq: BoolList = try inS.read { istr in
            let iceP_inSeq: BoolList = try istr.read()
            return iceP_inSeq
        }

        let (iceP_returnValue, iceP_outSeq) = try self.opBoolList(inSeq: iceP_inSeq, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_outSeq)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opBoolDequeList(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_inSeq: BoolDequeList = try inS.read { istr in
            let iceP_inSeq: BoolDequeList = try BoolDequeListHelper.read(from: istr)
            return iceP_inSeq
        }

        let (iceP_returnValue, iceP_outSeq) = try self.opBoolDequeList(inSeq: iceP_inSeq, current: current)

        return inS.setResult{ ostr in
            BoolDequeListHelper.write(to: ostr, value: iceP_outSeq)
            BoolDequeListHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opBoolDequeListArray(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_inSeq: BoolDequeList = try inS.read { istr in
            let iceP_inSeq: BoolDequeList = try BoolDequeListHelper.read(from: istr)
            return iceP_inSeq
        }

        let (iceP_returnValue, iceP_outSeq) = try self.opBoolDequeListArray(inSeq: iceP_inSeq, current: current)

        return inS.setResult{ ostr in
            BoolDequeListHelper.write(to: ostr, value: iceP_outSeq)
            BoolDequeListHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opByteSeq(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_inSeq: ByteSeq = try inS.read { istr in
            let iceP_inSeq: ByteSeq = try istr.read()
            return iceP_inSeq
        }

        let (iceP_returnValue, iceP_outSeq) = try self.opByteSeq(inSeq: iceP_inSeq, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_outSeq)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opByteList(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_inSeq: ByteList = try inS.read { istr in
            let iceP_inSeq: ByteList = try istr.read()
            return iceP_inSeq
        }

        let (iceP_returnValue, iceP_outSeq) = try self.opByteList(inSeq: iceP_inSeq, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_outSeq)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opMyByteSeq(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_inSeq: ByteSeq = try inS.read { istr in
            let iceP_inSeq: ByteSeq = try istr.read()
            return iceP_inSeq
        }

        let (iceP_returnValue, iceP_outSeq) = try self.opMyByteSeq(inSeq: iceP_inSeq, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_outSeq)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opStringSeq(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_inSeq: StringSeq = try inS.read { istr in
            let iceP_inSeq: StringSeq = try istr.read()
            return iceP_inSeq
        }

        let (iceP_returnValue, iceP_outSeq) = try self.opStringSeq(inSeq: iceP_inSeq, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_outSeq)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opStringList(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_inSeq: StringList = try inS.read { istr in
            let iceP_inSeq: StringList = try istr.read()
            return iceP_inSeq
        }

        let (iceP_returnValue, iceP_outSeq) = try self.opStringList(inSeq: iceP_inSeq, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_outSeq)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opFixedSeq(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_inSeq: FixedSeq = try inS.read { istr in
            let iceP_inSeq: FixedSeq = try FixedSeqHelper.read(from: istr)
            return iceP_inSeq
        }

        let (iceP_returnValue, iceP_outSeq) = try self.opFixedSeq(inSeq: iceP_inSeq, current: current)

        return inS.setResult{ ostr in
            FixedSeqHelper.write(to: ostr, value: iceP_outSeq)
            FixedSeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opFixedList(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_inSeq: FixedList = try inS.read { istr in
            let iceP_inSeq: FixedList = try FixedListHelper.read(from: istr)
            return iceP_inSeq
        }

        let (iceP_returnValue, iceP_outSeq) = try self.opFixedList(inSeq: iceP_inSeq, current: current)

        return inS.setResult{ ostr in
            FixedListHelper.write(to: ostr, value: iceP_outSeq)
            FixedListHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opVariableSeq(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_inSeq: VariableSeq = try inS.read { istr in
            let iceP_inSeq: VariableSeq = try VariableSeqHelper.read(from: istr)
            return iceP_inSeq
        }

        let (iceP_returnValue, iceP_outSeq) = try self.opVariableSeq(inSeq: iceP_inSeq, current: current)

        return inS.setResult{ ostr in
            VariableSeqHelper.write(to: ostr, value: iceP_outSeq)
            VariableSeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opVariableList(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_inSeq: VariableList = try inS.read { istr in
            let iceP_inSeq: VariableList = try VariableListHelper.read(from: istr)
            return iceP_inSeq
        }

        let (iceP_returnValue, iceP_outSeq) = try self.opVariableList(inSeq: iceP_inSeq, current: current)

        return inS.setResult{ ostr in
            VariableListHelper.write(to: ostr, value: iceP_outSeq)
            VariableListHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opStringStringDictSeq(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_inSeq: StringStringDictSeq = try inS.read { istr in
            let iceP_inSeq: StringStringDictSeq = try StringStringDictSeqHelper.read(from: istr)
            return iceP_inSeq
        }

        let (iceP_returnValue, iceP_outSeq) = try self.opStringStringDictSeq(inSeq: iceP_inSeq, current: current)

        return inS.setResult{ ostr in
            StringStringDictSeqHelper.write(to: ostr, value: iceP_outSeq)
            StringStringDictSeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opStringStringDictList(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_inSeq: StringStringDictList = try inS.read { istr in
            let iceP_inSeq: StringStringDictList = try StringStringDictListHelper.read(from: istr)
            return iceP_inSeq
        }

        let (iceP_returnValue, iceP_outSeq) = try self.opStringStringDictList(inSeq: iceP_inSeq, current: current)

        return inS.setResult{ ostr in
            StringStringDictListHelper.write(to: ostr, value: iceP_outSeq)
            StringStringDictListHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opESeq(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_inSeq: ESeq = try inS.read { istr in
            let iceP_inSeq: ESeq = try ESeqHelper.read(from: istr)
            return iceP_inSeq
        }

        let (iceP_returnValue, iceP_outSeq) = try self.opESeq(inSeq: iceP_inSeq, current: current)

        return inS.setResult{ ostr in
            ESeqHelper.write(to: ostr, value: iceP_outSeq)
            ESeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opEList(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_inSeq: EList = try inS.read { istr in
            let iceP_inSeq: EList = try EListHelper.read(from: istr)
            return iceP_inSeq
        }

        let (iceP_returnValue, iceP_outSeq) = try self.opEList(inSeq: iceP_inSeq, current: current)

        return inS.setResult{ ostr in
            EListHelper.write(to: ostr, value: iceP_outSeq)
            EListHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opDPrxSeq(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_inSeq: DPrxSeq = try inS.read { istr in
            let iceP_inSeq: DPrxSeq = try DPrxSeqHelper.read(from: istr)
            return iceP_inSeq
        }

        let (iceP_returnValue, iceP_outSeq) = try self.opDPrxSeq(inSeq: iceP_inSeq, current: current)

        return inS.setResult{ ostr in
            DPrxSeqHelper.write(to: ostr, value: iceP_outSeq)
            DPrxSeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opDPrxList(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_inSeq: DPrxList = try inS.read { istr in
            let iceP_inSeq: DPrxList = try DPrxListHelper.read(from: istr)
            return iceP_inSeq
        }

        let (iceP_returnValue, iceP_outSeq) = try self.opDPrxList(inSeq: iceP_inSeq, current: current)

        return inS.setResult{ ostr in
            DPrxListHelper.write(to: ostr, value: iceP_outSeq)
            DPrxListHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opCSeq(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_inSeq: CSeq = try inS.read { istr in
            let iceP_inSeq: CSeq = try CSeqHelper.read(from: istr)
            try istr.readPendingValues()
            return iceP_inSeq
        }

        let (iceP_returnValue, iceP_outSeq) = try self.opCSeq(inSeq: iceP_inSeq, current: current)

        return inS.setResult{ ostr in
            CSeqHelper.write(to: ostr, value: iceP_outSeq)
            CSeqHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_opCList(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_inSeq: CList = try inS.read { istr in
            let iceP_inSeq: CList = try CListHelper.read(from: istr)
            try istr.readPendingValues()
            return iceP_inSeq
        }

        let (iceP_returnValue, iceP_outSeq) = try self.opCList(inSeq: iceP_inSeq, current: current)

        return inS.setResult{ ostr in
            CListHelper.write(to: ostr, value: iceP_outSeq)
            CListHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_opOutArrayByteSeq(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_org: ByteSeq = try inS.read { istr in
            let iceP_org: ByteSeq = try istr.read()
            return iceP_org
        }

        let iceP_copy = try self.opOutArrayByteSeq(org: iceP_org, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_copy)
        }
    }

    func _iceD_opIntStringDict(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_idict: IntStringDict = try inS.read { istr in
            let iceP_idict: IntStringDict = try IntStringDictHelper.read(from: istr)
            return iceP_idict
        }

        let (iceP_returnValue, iceP_odict) = try self.opIntStringDict(idict: iceP_idict, current: current)

        return inS.setResult{ ostr in
            IntStringDictHelper.write(to: ostr, value: iceP_odict)
            IntStringDictHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opVarDict(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_idict: StringIntDict = try inS.read { istr in
            let iceP_idict: StringIntDict = try StringIntDictHelper.read(from: istr)
            return iceP_idict
        }

        let (iceP_returnValue, iceP_odict) = try self.opVarDict(idict: iceP_idict, current: current)

        return inS.setResult{ ostr in
            StringIntDictHelper.write(to: ostr, value: iceP_odict)
            LongLongDictHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opShortBuffer(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_inS: ShortBuffer = try inS.read { istr in
            let iceP_inS: ShortBuffer = try istr.read()
            return iceP_inS
        }

        let (iceP_returnValue, iceP_outS) = try self.opShortBuffer(inS: iceP_inS, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_outS)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opBoolBuffer(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_inS: BoolSeq = try inS.read { istr in
            let iceP_inS: BoolSeq = try istr.read()
            return iceP_inS
        }

        let (iceP_returnValue, iceP_outS) = try self.opBoolBuffer(inS: iceP_inS, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_outS)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opBufferStruct(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_s: BufferStruct = try inS.read { istr in
            let iceP_s: BufferStruct = try istr.read()
            return iceP_s
        }

        let iceP_returnValue = try self.opBufferStruct(s: iceP_s, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_shutdown(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.shutdown(current: current)

        return inS.setResult()
    }
}
