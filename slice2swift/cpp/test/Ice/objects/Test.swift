//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice

public struct S: Swift.Hashable {
    public var str: Swift.String = ""

    public init() {}

    public init(str: Swift.String) {
        self.str = str
    }
}

/// An `Ice.InputStream` extension to read `S` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `S` structured value from the stream.
    ///
    /// - returns: `S` - The structured value read from the stream.
    func read() throws -> S {
        var v = S()
        v.str = try self.read()
        return v
    }

    /// Read an optional `S?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `S?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> S? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as S
    }
}

/// An `Ice.OutputStream` extension to write `S` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `S` structured value to the stream.
    ///
    /// - parameter _: `S` - The value to write to the stream.
    func write(_ v: S) {
        self.write(v.str)
    }

    /// Write an optional `S?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `S?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: S?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// :nodoc:
public class BaseEx_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return BaseEx.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_BaseEx() -> Ice.UserExceptionTypeResolver {
        return BaseEx_TypeResolver()
    }
}

open class BaseEx: Ice.UserException {
    public var reason: Swift.String = ""

    public required init() {}

    public init(reason: Swift.String) {
        self.reason = reason
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Test::BaseEx" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: BaseEx.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.reason)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.reason = try istr.read()
        try istr.endSlice()
    }
}

/// Traits for Slice interface`I`.
public struct ITraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::I"]
    public static let staticId = "::Test::I"
}

/// Traits for Slice interface`J`.
public struct JTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::I", "::Test::J"]
    public static let staticId = "::Test::J"
}

public typealias BaseSeq = [Base?]

/// Helper class to read and write `BaseSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct BaseSeqHelper {
    /// Read a `BaseSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `BaseSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> BaseSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = BaseSeq(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(Base.self) { p.pointee = $0 }
            }
        }
        return v
    }
    /// Read an optional `BaseSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `BaseSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> BaseSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `BaseSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `BaseSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: BaseSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `BaseSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `BaseSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: BaseSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public enum CompactIdEnum: Swift.UInt8 {
    /// First
    case First = 1
    /// Second
    case Second = 2
    public init() {
        self = .First
    }
}

/// An `Ice.InputStream` extension to read `CompactIdEnum` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - returns: `CompactIdEnum` - The enumarated value.
    func read() throws -> CompactIdEnum {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 2)
        guard let val = CompactIdEnum(rawValue: rawValue) else {
            throw Ice.MarshalException("invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `CompactIdEnum` - The enumerated value.
    func read(tag: Swift.Int32) throws -> CompactIdEnum? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as CompactIdEnum
    }
}

/// An `Ice.OutputStream` extension to write `CompactIdEnum` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// parameter _: `CompactIdEnum` - The enumerator to write.
    func write(_ v: CompactIdEnum) {
        write(enum: v.rawValue, maxValue: 2)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// parameter _: `CompactIdEnum` - The enumerator to write.
    func write(tag: Swift.Int32, value: CompactIdEnum?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 2)
    }
}
public let CompactExtId: Swift.Int32 = 789


/// :nodoc:
public class InnerEx_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return InnerEx.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Inner_Ex() -> Ice.UserExceptionTypeResolver {
        return InnerEx_TypeResolver()
    }
}

open class InnerEx: Ice.UserException {
    public var reason: Swift.String = ""

    public required init() {}

    public init(reason: Swift.String) {
        self.reason = reason
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Test::Inner::Ex" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: InnerEx.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.reason)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.reason = try istr.read()
        try istr.endSlice()
    }
}

/// :nodoc:
public class InnerSubEx_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return InnerSubEx.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Inner_Sub_Ex() -> Ice.UserExceptionTypeResolver {
        return InnerSubEx_TypeResolver()
    }
}

open class InnerSubEx: Ice.UserException {
    public var reason: Swift.String = ""

    public required init() {}

    public init(reason: Swift.String) {
        self.reason = reason
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Test::Inner::Sub::Ex" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: InnerSubEx.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.reason)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.reason = try istr.read()
        try istr.endSlice()
    }
}

/// :nodoc:
public class EBase_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return EBase.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_EBase() -> Ice.UserExceptionTypeResolver {
        return EBase_TypeResolver()
    }
}

open class EBase: Ice.UserException {
    public var a1: A1? = nil
    public var a2: A1? = nil

    public required init() {}

    public init(a1: A1?, a2: A1?) {
        self.a1 = a1
        self.a2 = a2
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Test::EBase" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: EBase.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.a1)
        ostr.write(self.a2)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(A1.self) { self.a1 = $0 }
        try istr.read(A1.self) { self.a2 = $0 }
        try istr.endSlice()
    }

    open override func _usesClasses() -> Swift.Bool {
        return true
    }
}

/// :nodoc:
public class EDerived_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return EDerived.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_EDerived() -> Ice.UserExceptionTypeResolver {
        return EDerived_TypeResolver()
    }
}

open class EDerived: EBase {
    public var a3: A1? = nil
    public var a4: A1? = nil

    public required init() {
        super.init()
    }

    public init(a1: A1?, a2: A1?, a3: A1?, a4: A1?) {
        self.a3 = a3
        self.a4 = a4
        super.init(a1: a1, a2: a2)
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Test::EDerived" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: EDerived.ice_staticId(), compactId: -1, last: false)
        ostr.write(self.a3)
        ostr.write(self.a4)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(A1.self) { self.a3 = $0 }
        try istr.read(A1.self) { self.a4 = $0 }
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }
}

public typealias ValueSeq = [Ice.Value?]

/// Helper class to read and write `ValueSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ValueSeqHelper {
    /// Read a `ValueSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ValueSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ValueSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = ValueSeq(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read() { p.pointee = $0 }
            }
        }
        return v
    }
    /// Read an optional `ValueSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ValueSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ValueSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ValueSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ValueSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ValueSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `ValueSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ValueSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ValueSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ValueMap = [Swift.String: Ice.Value?]

/// Helper class to read and write `ValueMap` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ValueMapHelper {
    /// Read a `ValueMap` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ValueMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ValueMap {
        let sz = try Swift.Int(istr.readSize())
        var v = ValueMap()
        let e = Ice.DictEntryArray<Swift.String, Ice.Value?>(size: sz)
        for i in 0 ..< sz {
            let key: Swift.String = try istr.read()
            v[key] = nil as Ice.Value?
            Swift.withUnsafeMutablePointer(to: &v[key, default:nil]) {
                e.values[i] = Ice.DictEntry<Swift.String, Ice.Value?>(key: key, value: $0)
            }
            try istr.read() { e.values[i].value.pointee = $0 }
        }
        for i in 0..<sz {
            Swift.withUnsafeMutablePointer(to: &v[e.values[i].key, default:nil]) {
                e.values[i].value = $0
            }
        }
        return v
    }
    /// Read an optional `ValueMap?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ValueMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ValueMap? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ValueMap` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ValueMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ValueMap) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `ValueMap?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ValueMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: ValueMap?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public struct StructKey: Swift.Hashable {
    public var i: Swift.Int32 = 0
    public var s: Swift.String = ""

    public init() {}

    public init(i: Swift.Int32, s: Swift.String) {
        self.i = i
        self.s = s
    }
}

/// An `Ice.InputStream` extension to read `StructKey` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `StructKey` structured value from the stream.
    ///
    /// - returns: `StructKey` - The structured value read from the stream.
    func read() throws -> StructKey {
        var v = StructKey()
        v.i = try self.read()
        v.s = try self.read()
        return v
    }

    /// Read an optional `StructKey?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StructKey?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> StructKey? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as StructKey
    }
}

/// An `Ice.OutputStream` extension to write `StructKey` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `StructKey` structured value to the stream.
    ///
    /// - parameter _: `StructKey` - The value to write to the stream.
    func write(_ v: StructKey) {
        self.write(v.i)
        self.write(v.s)
    }

    /// Write an optional `StructKey?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StructKey?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: StructKey?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public typealias LMap = [StructKey: L?]

/// Helper class to read and write `LMap` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LMapHelper {
    /// Read a `LMap` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `LMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LMap {
        let sz = try Swift.Int(istr.readSize())
        var v = LMap()
        let e = Ice.DictEntryArray<StructKey, L?>(size: sz)
        for i in 0 ..< sz {
            let key: StructKey = try istr.read()
            v[key] = nil as L?
            Swift.withUnsafeMutablePointer(to: &v[key, default:nil]) {
                e.values[i] = Ice.DictEntry<StructKey, L?>(key: key, value: $0)
            }
            try istr.read(L.self) { e.values[i].value.pointee = $0 }
        }
        for i in 0..<sz {
            Swift.withUnsafeMutablePointer(to: &v[e.values[i].key, default:nil]) {
                e.values[i].value = $0
            }
        }
        return v
    }
    /// Read an optional `LMap?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LMap? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `LMap` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `LMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LMap) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `LMap?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: LMap?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice interface`Initial`.
public struct InitialTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Initial"]
    public static let staticId = "::Test::Initial"
}

/// Traits for Slice interface`TestIntf`.
public struct TestIntfTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::TestIntf"]
    public static let staticId = "::Test::TestIntf"
}

/// Traits for Slice interface`UnexpectedObjectExceptionTest`.
public struct UnexpectedObjectExceptionTestTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::UnexpectedObjectExceptionTest"]
    public static let staticId = "::Test::UnexpectedObjectExceptionTest"
}

/// :nodoc:
public class EOneMember_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return EOneMember.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_EOneMember() -> Ice.UserExceptionTypeResolver {
        return EOneMember_TypeResolver()
    }
}

open class EOneMember: Ice.UserException {
    public var e: Empty? = nil

    public required init() {}

    public init(e: Empty?) {
        self.e = e
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Test::EOneMember" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: EOneMember.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.e)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(Empty.self) { self.e = $0 }
        try istr.endSlice()
    }

    open override func _usesClasses() -> Swift.Bool {
        return true
    }
}

/// :nodoc:
public class ETwoMembers_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return ETwoMembers.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_ETwoMembers() -> Ice.UserExceptionTypeResolver {
        return ETwoMembers_TypeResolver()
    }
}

open class ETwoMembers: Ice.UserException {
    public var e1: Empty? = nil
    public var e2: Empty? = nil

    public required init() {}

    public init(e1: Empty?, e2: Empty?) {
        self.e1 = e1
        self.e2 = e2
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Test::ETwoMembers" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: ETwoMembers.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.e1)
        ostr.write(self.e2)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(Empty.self) { self.e1 = $0 }
        try istr.read(Empty.self) { self.e2 = $0 }
        try istr.endSlice()
    }

    open override func _usesClasses() -> Swift.Bool {
        return true
    }
}

public class SOneMember {
    public var e: Empty? = nil

    public init() {}

    public init(e: Empty?) {
        self.e = e
    }
}

/// An `Ice.InputStream` extension to read `SOneMember` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `SOneMember` structured value from the stream.
    ///
    /// - returns: `SOneMember` - The structured value read from the stream.
    func read() throws -> SOneMember {
        let v = SOneMember()
        try self.read(Empty.self) { v.e = $0 }
        return v
    }

    /// Read an optional `SOneMember?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `SOneMember?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> SOneMember? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as SOneMember
    }
}

/// An `Ice.OutputStream` extension to write `SOneMember` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `SOneMember` structured value to the stream.
    ///
    /// - parameter _: `SOneMember` - The value to write to the stream.
    func write(_ v: SOneMember) {
        self.write(v.e)
    }

    /// Write an optional `SOneMember?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `SOneMember?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: SOneMember?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public class STwoMembers {
    public var e1: Empty? = nil
    public var e2: Empty? = nil

    public init() {}

    public init(e1: Empty?, e2: Empty?) {
        self.e1 = e1
        self.e2 = e2
    }
}

/// An `Ice.InputStream` extension to read `STwoMembers` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `STwoMembers` structured value from the stream.
    ///
    /// - returns: `STwoMembers` - The structured value read from the stream.
    func read() throws -> STwoMembers {
        let v = STwoMembers()
        try self.read(Empty.self) { v.e1 = $0 }
        try self.read(Empty.self) { v.e2 = $0 }
        return v
    }

    /// Read an optional `STwoMembers?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `STwoMembers?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> STwoMembers? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as STwoMembers
    }
}

/// An `Ice.OutputStream` extension to write `STwoMembers` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `STwoMembers` structured value to the stream.
    ///
    /// - parameter _: `STwoMembers` - The value to write to the stream.
    func write(_ v: STwoMembers) {
        self.write(v.e1)
        self.write(v.e2)
    }

    /// Write an optional `STwoMembers?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `STwoMembers?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: STwoMembers?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public typealias DOneMember = [Swift.Int32: COneMember?]

/// Helper class to read and write `DOneMember` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct DOneMemberHelper {
    /// Read a `DOneMember` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `DOneMember` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> DOneMember {
        let sz = try Swift.Int(istr.readSize())
        var v = DOneMember()
        let e = Ice.DictEntryArray<Swift.Int32, COneMember?>(size: sz)
        for i in 0 ..< sz {
            let key: Swift.Int32 = try istr.read()
            v[key] = nil as COneMember?
            Swift.withUnsafeMutablePointer(to: &v[key, default:nil]) {
                e.values[i] = Ice.DictEntry<Swift.Int32, COneMember?>(key: key, value: $0)
            }
            try istr.read(COneMember.self) { e.values[i].value.pointee = $0 }
        }
        for i in 0..<sz {
            Swift.withUnsafeMutablePointer(to: &v[e.values[i].key, default:nil]) {
                e.values[i].value = $0
            }
        }
        return v
    }
    /// Read an optional `DOneMember?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `DOneMember` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> DOneMember? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `DOneMember` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `DOneMember` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: DOneMember) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `DOneMember?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `DOneMember` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: DOneMember?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias DTwoMembers = [Swift.Int32: CTwoMembers?]

/// Helper class to read and write `DTwoMembers` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct DTwoMembersHelper {
    /// Read a `DTwoMembers` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `DTwoMembers` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> DTwoMembers {
        let sz = try Swift.Int(istr.readSize())
        var v = DTwoMembers()
        let e = Ice.DictEntryArray<Swift.Int32, CTwoMembers?>(size: sz)
        for i in 0 ..< sz {
            let key: Swift.Int32 = try istr.read()
            v[key] = nil as CTwoMembers?
            Swift.withUnsafeMutablePointer(to: &v[key, default:nil]) {
                e.values[i] = Ice.DictEntry<Swift.Int32, CTwoMembers?>(key: key, value: $0)
            }
            try istr.read(CTwoMembers.self) { e.values[i].value.pointee = $0 }
        }
        for i in 0..<sz {
            Swift.withUnsafeMutablePointer(to: &v[e.values[i].key, default:nil]) {
                e.values[i].value = $0
            }
        }
        return v
    }
    /// Read an optional `DTwoMembers?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `DTwoMembers` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> DTwoMembers? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `DTwoMembers` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `DTwoMembers` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: DTwoMembers) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `DTwoMembers?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `DTwoMembers` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: DTwoMembers?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// IPrx overview.
public protocol IPrx: Ice.ObjectPrx {}

private final class IPrxI: Ice.ObjectPrxI, IPrx {
    public override class func ice_staticId() -> Swift.String {
        return ITraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: IPrx.Protocol) throws -> IPrx {
    try communicator.makeProxyImpl(proxyString) as IPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `IPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `IPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: IPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> IPrx? {
    return try IPrxI.checkedCast(prx: prx, facet: facet, context: context) as IPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `IPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `IPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: IPrx.Protocol, facet: Swift.String? = nil) -> IPrx {
    return IPrxI.uncheckedCast(prx: prx, facet: facet) as IPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `IPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: IPrx.Protocol) -> Swift.String {
    return ITraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `IPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `IPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `IPrx?` - The extracted proxy
    func read(_ type: IPrx.Protocol) throws -> IPrx? {
        return try read() as IPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `IPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `IPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: IPrx.Protocol) throws -> IPrx? {
        return try read(tag: tag) as IPrxI?
    }
}

/// IPrx overview.
public extension IPrx {}

/// JPrx overview.
public protocol JPrx: IPrx {}

private final class JPrxI: Ice.ObjectPrxI, JPrx {
    public override class func ice_staticId() -> Swift.String {
        return JTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: JPrx.Protocol) throws -> JPrx {
    try communicator.makeProxyImpl(proxyString) as JPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `JPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `JPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: JPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> JPrx? {
    return try JPrxI.checkedCast(prx: prx, facet: facet, context: context) as JPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `JPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `JPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: JPrx.Protocol, facet: Swift.String? = nil) -> JPrx {
    return JPrxI.uncheckedCast(prx: prx, facet: facet) as JPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `JPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: JPrx.Protocol) -> Swift.String {
    return JTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `JPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `JPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `JPrx?` - The extracted proxy
    func read(_ type: JPrx.Protocol) throws -> JPrx? {
        return try read() as JPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `JPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `JPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: JPrx.Protocol) throws -> JPrx? {
        return try read(tag: tag) as JPrxI?
    }
}

/// JPrx overview.
public extension JPrx {}

/// InitialPrx overview.
///
/// InitialPrx Methods:
///
///  - shutdown: 
///
///  - shutdownAsync: 
///
///  - getB1: 
///
///  - getB1Async: 
///
///  - getB2: 
///
///  - getB2Async: 
///
///  - getC: 
///
///  - getCAsync: 
///
///  - getD: 
///
///  - getDAsync: 
///
///  - getE: 
///
///  - getEAsync: 
///
///  - getF: 
///
///  - getFAsync: 
///
///  - setRecursive: 
///
///  - setRecursiveAsync: 
///
///  - setCycle: 
///
///  - setCycleAsync: 
///
///  - acceptsClassCycles: 
///
///  - acceptsClassCyclesAsync: 
///
///  - getMB: 
///
///  - getMBAsync: 
///
///  - getAMDMB: 
///
///  - getAMDMBAsync: 
///
///  - getAll: 
///
///  - getAllAsync: 
///
///  - getK: 
///
///  - getKAsync: 
///
///  - opValue: 
///
///  - opValueAsync: 
///
///  - opValueSeq: 
///
///  - opValueSeqAsync: 
///
///  - opValueMap: 
///
///  - opValueMapAsync: 
///
///  - getD1: 
///
///  - getD1Async: 
///
///  - throwEDerived: 
///
///  - throwEDerivedAsync: 
///
///  - setG: 
///
///  - setGAsync: 
///
///  - opBaseSeq: 
///
///  - opBaseSeqAsync: 
///
///  - getCompact: 
///
///  - getCompactAsync: 
///
///  - getInnerA: 
///
///  - getInnerAAsync: 
///
///  - getInnerSubA: 
///
///  - getInnerSubAAsync: 
///
///  - throwInnerEx: 
///
///  - throwInnerExAsync: 
///
///  - throwInnerSubEx: 
///
///  - throwInnerSubExAsync: 
///
///  - opM: 
///
///  - opMAsync: 
///
///  - opF1: 
///
///  - opF1Async: 
///
///  - opF2: 
///
///  - opF2Async: 
///
///  - hasF3: 
///
///  - hasF3Async: 
///
///  - opF3: 
///
///  - opF3Async: 
public protocol InitialPrx: Ice.ObjectPrx {}

private final class InitialPrxI: Ice.ObjectPrxI, InitialPrx {
    public override class func ice_staticId() -> Swift.String {
        return InitialTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: InitialPrx.Protocol) throws -> InitialPrx {
    try communicator.makeProxyImpl(proxyString) as InitialPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `InitialPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `InitialPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: InitialPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> InitialPrx? {
    return try InitialPrxI.checkedCast(prx: prx, facet: facet, context: context) as InitialPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `InitialPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `InitialPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: InitialPrx.Protocol, facet: Swift.String? = nil) -> InitialPrx {
    return InitialPrxI.uncheckedCast(prx: prx, facet: facet) as InitialPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `InitialPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: InitialPrx.Protocol) -> Swift.String {
    return InitialTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `InitialPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `InitialPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `InitialPrx?` - The extracted proxy
    func read(_ type: InitialPrx.Protocol) throws -> InitialPrx? {
        return try read() as InitialPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `InitialPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `InitialPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: InitialPrx.Protocol) throws -> InitialPrx? {
        return try read(tag: tag) as InitialPrxI?
    }
}

/// InitialPrx overview.
///
/// InitialPrx Methods:
///
///  - shutdown: 
///
///  - shutdownAsync: 
///
///  - getB1: 
///
///  - getB1Async: 
///
///  - getB2: 
///
///  - getB2Async: 
///
///  - getC: 
///
///  - getCAsync: 
///
///  - getD: 
///
///  - getDAsync: 
///
///  - getE: 
///
///  - getEAsync: 
///
///  - getF: 
///
///  - getFAsync: 
///
///  - setRecursive: 
///
///  - setRecursiveAsync: 
///
///  - setCycle: 
///
///  - setCycleAsync: 
///
///  - acceptsClassCycles: 
///
///  - acceptsClassCyclesAsync: 
///
///  - getMB: 
///
///  - getMBAsync: 
///
///  - getAMDMB: 
///
///  - getAMDMBAsync: 
///
///  - getAll: 
///
///  - getAllAsync: 
///
///  - getK: 
///
///  - getKAsync: 
///
///  - opValue: 
///
///  - opValueAsync: 
///
///  - opValueSeq: 
///
///  - opValueSeqAsync: 
///
///  - opValueMap: 
///
///  - opValueMapAsync: 
///
///  - getD1: 
///
///  - getD1Async: 
///
///  - throwEDerived: 
///
///  - throwEDerivedAsync: 
///
///  - setG: 
///
///  - setGAsync: 
///
///  - opBaseSeq: 
///
///  - opBaseSeqAsync: 
///
///  - getCompact: 
///
///  - getCompactAsync: 
///
///  - getInnerA: 
///
///  - getInnerAAsync: 
///
///  - getInnerSubA: 
///
///  - getInnerSubAAsync: 
///
///  - throwInnerEx: 
///
///  - throwInnerExAsync: 
///
///  - throwInnerSubEx: 
///
///  - throwInnerSubExAsync: 
///
///  - opM: 
///
///  - opMAsync: 
///
///  - opF1: 
///
///  - opF1Async: 
///
///  - opF2: 
///
///  - opF2Async: 
///
///  - hasF3: 
///
///  - hasF3Async: 
///
///  - opF3: 
///
///  - opF3Async: 
public extension InitialPrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func shutdown(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "shutdown",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `` - The result of the operation
    func shutdownAsync(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invokeAsync(operation: "shutdown",
                                            mode: .Normal,
                                            context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `B?`
    func getB1(context: Ice.Context? = nil) throws -> B? {
        return try _impl._invoke(operation: "getB1",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: B?
                                     try istr.read(B.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `B?` - The result of the operation
    func getB1Async(context: Ice.Context? = nil) async throws -> B? {
        return try await _impl._invokeAsync(operation: "getB1",
                                            mode: .Normal,
                                            read: { istr in
                                                var iceP_returnValue: B?
                                                try istr.read(B.self) { iceP_returnValue = $0 }
                                                try istr.readPendingValues()
                                                return iceP_returnValue
                                            },
                                            context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `B?`
    func getB2(context: Ice.Context? = nil) throws -> B? {
        return try _impl._invoke(operation: "getB2",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: B?
                                     try istr.read(B.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `B?` - The result of the operation
    func getB2Async(context: Ice.Context? = nil) async throws -> B? {
        return try await _impl._invokeAsync(operation: "getB2",
                                            mode: .Normal,
                                            read: { istr in
                                                var iceP_returnValue: B?
                                                try istr.read(B.self) { iceP_returnValue = $0 }
                                                try istr.readPendingValues()
                                                return iceP_returnValue
                                            },
                                            context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `C?`
    func getC(context: Ice.Context? = nil) throws -> C? {
        return try _impl._invoke(operation: "getC",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: C?
                                     try istr.read(C.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `C?` - The result of the operation
    func getCAsync(context: Ice.Context? = nil) async throws -> C? {
        return try await _impl._invokeAsync(operation: "getC",
                                            mode: .Normal,
                                            read: { istr in
                                                var iceP_returnValue: C?
                                                try istr.read(C.self) { iceP_returnValue = $0 }
                                                try istr.readPendingValues()
                                                return iceP_returnValue
                                            },
                                            context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `D?`
    func getD(context: Ice.Context? = nil) throws -> D? {
        return try _impl._invoke(operation: "getD",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: D?
                                     try istr.read(D.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `D?` - The result of the operation
    func getDAsync(context: Ice.Context? = nil) async throws -> D? {
        return try await _impl._invokeAsync(operation: "getD",
                                            mode: .Normal,
                                            read: { istr in
                                                var iceP_returnValue: D?
                                                try istr.read(D.self) { iceP_returnValue = $0 }
                                                try istr.readPendingValues()
                                                return iceP_returnValue
                                            },
                                            context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `E?`
    func getE(context: Ice.Context? = nil) throws -> E? {
        return try _impl._invoke(operation: "getE",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: E?
                                     try istr.read(E.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `E?` - The result of the operation
    func getEAsync(context: Ice.Context? = nil) async throws -> E? {
        return try await _impl._invokeAsync(operation: "getE",
                                            mode: .Normal,
                                            read: { istr in
                                                var iceP_returnValue: E?
                                                try istr.read(E.self) { iceP_returnValue = $0 }
                                                try istr.readPendingValues()
                                                return iceP_returnValue
                                            },
                                            context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `F?`
    func getF(context: Ice.Context? = nil) throws -> F? {
        return try _impl._invoke(operation: "getF",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: F?
                                     try istr.read(F.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `F?` - The result of the operation
    func getFAsync(context: Ice.Context? = nil) async throws -> F? {
        return try await _impl._invokeAsync(operation: "getF",
                                            mode: .Normal,
                                            read: { istr in
                                                var iceP_returnValue: F?
                                                try istr.read(F.self) { iceP_returnValue = $0 }
                                                try istr.readPendingValues()
                                                return iceP_returnValue
                                            },
                                            context: context)
    }

    ///
    /// - parameter _: `Recursive?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func setRecursive(_ iceP_p: Recursive?, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "setRecursive",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_p)
                              ostr.writePendingValues()
                          },
                          context: context)
    }

    ///
    /// - parameter _: `Recursive?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `` - The result of the operation
    func setRecursiveAsync(_ iceP_p: Recursive?, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invokeAsync(operation: "setRecursive",
                                            mode: .Normal,
                                            write: { ostr in
                                                ostr.write(iceP_p)
                                                ostr.writePendingValues()
                                            },
                                            context: context)
    }

    ///
    /// - parameter _: `Recursive?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func setCycle(_ iceP_r: Recursive?, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "setCycle",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_r)
                              ostr.writePendingValues()
                          },
                          context: context)
    }

    ///
    /// - parameter _: `Recursive?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `` - The result of the operation
    func setCycleAsync(_ iceP_r: Recursive?, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invokeAsync(operation: "setCycle",
                                            mode: .Normal,
                                            write: { ostr in
                                                ostr.write(iceP_r)
                                                ostr.writePendingValues()
                                            },
                                            context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Bool`
    func acceptsClassCycles(context: Ice.Context? = nil) throws -> Swift.Bool {
        return try _impl._invoke(operation: "acceptsClassCycles",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: Swift.Bool = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Bool` - The result of the operation
    func acceptsClassCyclesAsync(context: Ice.Context? = nil) async throws -> Swift.Bool {
        return try await _impl._invokeAsync(operation: "acceptsClassCycles",
                                            mode: .Normal,
                                            read: { istr in
                                                let iceP_returnValue: Swift.Bool = try istr.read()
                                                return iceP_returnValue
                                            },
                                            context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `B?`
    func getMB(context: Ice.Context? = nil) throws -> B? {
        return try _impl._invoke(operation: "getMB",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: B?
                                     try istr.read(B.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `B?` - The result of the operation
    func getMBAsync(context: Ice.Context? = nil) async throws -> B? {
        return try await _impl._invokeAsync(operation: "getMB",
                                            mode: .Normal,
                                            read: { istr in
                                                var iceP_returnValue: B?
                                                try istr.read(B.self) { iceP_returnValue = $0 }
                                                try istr.readPendingValues()
                                                return iceP_returnValue
                                            },
                                            context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `B?`
    func getAMDMB(context: Ice.Context? = nil) throws -> B? {
        return try _impl._invoke(operation: "getAMDMB",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: B?
                                     try istr.read(B.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `B?` - The result of the operation
    func getAMDMBAsync(context: Ice.Context? = nil) async throws -> B? {
        return try await _impl._invokeAsync(operation: "getAMDMB",
                                            mode: .Normal,
                                            read: { istr in
                                                var iceP_returnValue: B?
                                                try istr.read(B.self) { iceP_returnValue = $0 }
                                                try istr.readPendingValues()
                                                return iceP_returnValue
                                            },
                                            context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(b1: B?, b2: B?, theC: C?, theD: D?)`:
    ///
    ///   - b1: `B?`
    ///
    ///   - b2: `B?`
    ///
    ///   - theC: `C?`
    ///
    ///   - theD: `D?`
    func getAll(context: Ice.Context? = nil) throws -> (b1: B?, b2: B?, theC: C?, theD: D?) {
        return try _impl._invoke(operation: "getAll",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_b1: B?
                                     try istr.read(B.self) { iceP_b1 = $0 }
                                     var iceP_b2: B?
                                     try istr.read(B.self) { iceP_b2 = $0 }
                                     var iceP_theC: C?
                                     try istr.read(C.self) { iceP_theC = $0 }
                                     var iceP_theD: D?
                                     try istr.read(D.self) { iceP_theD = $0 }
                                     try istr.readPendingValues()
                                     return (iceP_b1, iceP_b2, iceP_theC, iceP_theD)
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(b1: B?, b2: B?, theC: C?, theD: D?)` - The result of the operation
    func getAllAsync(context: Ice.Context? = nil) async throws -> (b1: B?, b2: B?, theC: C?, theD: D?) {
        return try await _impl._invokeAsync(operation: "getAll",
                                            mode: .Normal,
                                            read: { istr in
                                                var iceP_b1: B?
                                                try istr.read(B.self) { iceP_b1 = $0 }
                                                var iceP_b2: B?
                                                try istr.read(B.self) { iceP_b2 = $0 }
                                                var iceP_theC: C?
                                                try istr.read(C.self) { iceP_theC = $0 }
                                                var iceP_theD: D?
                                                try istr.read(D.self) { iceP_theD = $0 }
                                                try istr.readPendingValues()
                                                return (iceP_b1, iceP_b2, iceP_theC, iceP_theD)
                                            },
                                            context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `K?`
    func getK(context: Ice.Context? = nil) throws -> K? {
        return try _impl._invoke(operation: "getK",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: K?
                                     try istr.read(K.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `K?` - The result of the operation
    func getKAsync(context: Ice.Context? = nil) async throws -> K? {
        return try await _impl._invokeAsync(operation: "getK",
                                            mode: .Normal,
                                            read: { istr in
                                                var iceP_returnValue: K?
                                                try istr.read(K.self) { iceP_returnValue = $0 }
                                                try istr.readPendingValues()
                                                return iceP_returnValue
                                            },
                                            context: context)
    }

    ///
    /// - parameter _: `Ice.Value?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: Ice.Value?, v2: Ice.Value?)`:
    ///
    ///   - returnValue: `Ice.Value?`
    ///
    ///   - v2: `Ice.Value?`
    func opValue(_ iceP_v1: Ice.Value?, context: Ice.Context? = nil) throws -> (returnValue: Ice.Value?, v2: Ice.Value?) {
        return try _impl._invoke(operation: "opValue",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_v1)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     var iceP_v2: Ice.Value?
                                     try istr.read() { iceP_v2 = $0 }
                                     var iceP_returnValue: Ice.Value?
                                     try istr.read() { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return (iceP_returnValue, iceP_v2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `Ice.Value?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: Ice.Value?, v2: Ice.Value?)` - The result of the operation
    func opValueAsync(_ iceP_v1: Ice.Value?, context: Ice.Context? = nil) async throws -> (returnValue: Ice.Value?, v2: Ice.Value?) {
        return try await _impl._invokeAsync(operation: "opValue",
                                            mode: .Normal,
                                            write: { ostr in
                                                ostr.write(iceP_v1)
                                                ostr.writePendingValues()
                                            },
                                            read: { istr in
                                                var iceP_v2: Ice.Value?
                                                try istr.read() { iceP_v2 = $0 }
                                                var iceP_returnValue: Ice.Value?
                                                try istr.read() { iceP_returnValue = $0 }
                                                try istr.readPendingValues()
                                                return (iceP_returnValue, iceP_v2)
                                            },
                                            context: context)
    }

    ///
    /// - parameter _: `ValueSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: ValueSeq, v2: ValueSeq)`:
    ///
    ///   - returnValue: `ValueSeq`
    ///
    ///   - v2: `ValueSeq`
    func opValueSeq(_ iceP_v1: ValueSeq, context: Ice.Context? = nil) throws -> (returnValue: ValueSeq, v2: ValueSeq) {
        return try _impl._invoke(operation: "opValueSeq",
                                 mode: .Normal,
                                 write: { ostr in
                                     ValueSeqHelper.write(to: ostr, value: iceP_v1)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     let iceP_v2: ValueSeq = try ValueSeqHelper.read(from: istr)
                                     let iceP_returnValue: ValueSeq = try ValueSeqHelper.read(from: istr)
                                     try istr.readPendingValues()
                                     return (iceP_returnValue, iceP_v2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `ValueSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: ValueSeq, v2: ValueSeq)` - The result of the operation
    func opValueSeqAsync(_ iceP_v1: ValueSeq, context: Ice.Context? = nil) async throws -> (returnValue: ValueSeq, v2: ValueSeq) {
        return try await _impl._invokeAsync(operation: "opValueSeq",
                                            mode: .Normal,
                                            write: { ostr in
                                                ValueSeqHelper.write(to: ostr, value: iceP_v1)
                                                ostr.writePendingValues()
                                            },
                                            read: { istr in
                                                let iceP_v2: ValueSeq = try ValueSeqHelper.read(from: istr)
                                                let iceP_returnValue: ValueSeq = try ValueSeqHelper.read(from: istr)
                                                try istr.readPendingValues()
                                                return (iceP_returnValue, iceP_v2)
                                            },
                                            context: context)
    }

    ///
    /// - parameter _: `ValueMap`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: ValueMap, v2: ValueMap)`:
    ///
    ///   - returnValue: `ValueMap`
    ///
    ///   - v2: `ValueMap`
    func opValueMap(_ iceP_v1: ValueMap, context: Ice.Context? = nil) throws -> (returnValue: ValueMap, v2: ValueMap) {
        return try _impl._invoke(operation: "opValueMap",
                                 mode: .Normal,
                                 write: { ostr in
                                     ValueMapHelper.write(to: ostr, value: iceP_v1)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     let iceP_v2: ValueMap = try ValueMapHelper.read(from: istr)
                                     let iceP_returnValue: ValueMap = try ValueMapHelper.read(from: istr)
                                     try istr.readPendingValues()
                                     return (iceP_returnValue, iceP_v2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `ValueMap`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: ValueMap, v2: ValueMap)` - The result of the operation
    func opValueMapAsync(_ iceP_v1: ValueMap, context: Ice.Context? = nil) async throws -> (returnValue: ValueMap, v2: ValueMap) {
        return try await _impl._invokeAsync(operation: "opValueMap",
                                            mode: .Normal,
                                            write: { ostr in
                                                ValueMapHelper.write(to: ostr, value: iceP_v1)
                                                ostr.writePendingValues()
                                            },
                                            read: { istr in
                                                let iceP_v2: ValueMap = try ValueMapHelper.read(from: istr)
                                                let iceP_returnValue: ValueMap = try ValueMapHelper.read(from: istr)
                                                try istr.readPendingValues()
                                                return (iceP_returnValue, iceP_v2)
                                            },
                                            context: context)
    }

    ///
    /// - parameter _: `D1?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `D1?`
    func getD1(_ iceP_d1: D1?, context: Ice.Context? = nil) throws -> D1? {
        return try _impl._invoke(operation: "getD1",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_d1)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     var iceP_returnValue: D1?
                                     try istr.read(D1.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `D1?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `D1?` - The result of the operation
    func getD1Async(_ iceP_d1: D1?, context: Ice.Context? = nil) async throws -> D1? {
        return try await _impl._invokeAsync(operation: "getD1",
                                            mode: .Normal,
                                            write: { ostr in
                                                ostr.write(iceP_d1)
                                                ostr.writePendingValues()
                                            },
                                            read: { istr in
                                                var iceP_returnValue: D1?
                                                try istr.read(D1.self) { iceP_returnValue = $0 }
                                                try istr.readPendingValues()
                                                return iceP_returnValue
                                            },
                                            context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func throwEDerived(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "throwEDerived",
                          mode: .Normal,
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as EDerived {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `` - The result of the operation
    func throwEDerivedAsync(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invokeAsync(operation: "throwEDerived",
                                            mode: .Normal,
                                            userException:{ ex in
                                                do  {
                                                    throw ex
                                                } catch let error as EDerived {
                                                    throw error
                                                } catch is Ice.UserException {}
                                            },
                                            context: context)
    }

    ///
    /// - parameter _: `G?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func setG(_ iceP_theG: G?, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "setG",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_theG)
                              ostr.writePendingValues()
                          },
                          context: context)
    }

    ///
    /// - parameter _: `G?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `` - The result of the operation
    func setGAsync(_ iceP_theG: G?, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invokeAsync(operation: "setG",
                                            mode: .Normal,
                                            write: { ostr in
                                                ostr.write(iceP_theG)
                                                ostr.writePendingValues()
                                            },
                                            context: context)
    }

    ///
    /// - parameter _: `BaseSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: BaseSeq, outSeq: BaseSeq)`:
    ///
    ///   - returnValue: `BaseSeq`
    ///
    ///   - outSeq: `BaseSeq`
    func opBaseSeq(_ iceP_inSeq: BaseSeq, context: Ice.Context? = nil) throws -> (returnValue: BaseSeq, outSeq: BaseSeq) {
        return try _impl._invoke(operation: "opBaseSeq",
                                 mode: .Normal,
                                 write: { ostr in
                                     BaseSeqHelper.write(to: ostr, value: iceP_inSeq)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     let iceP_outSeq: BaseSeq = try BaseSeqHelper.read(from: istr)
                                     let iceP_returnValue: BaseSeq = try BaseSeqHelper.read(from: istr)
                                     try istr.readPendingValues()
                                     return (iceP_returnValue, iceP_outSeq)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `BaseSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: BaseSeq, outSeq: BaseSeq)` - The result of the operation
    func opBaseSeqAsync(_ iceP_inSeq: BaseSeq, context: Ice.Context? = nil) async throws -> (returnValue: BaseSeq, outSeq: BaseSeq) {
        return try await _impl._invokeAsync(operation: "opBaseSeq",
                                            mode: .Normal,
                                            write: { ostr in
                                                BaseSeqHelper.write(to: ostr, value: iceP_inSeq)
                                                ostr.writePendingValues()
                                            },
                                            read: { istr in
                                                let iceP_outSeq: BaseSeq = try BaseSeqHelper.read(from: istr)
                                                let iceP_returnValue: BaseSeq = try BaseSeqHelper.read(from: istr)
                                                try istr.readPendingValues()
                                                return (iceP_returnValue, iceP_outSeq)
                                            },
                                            context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Compact?`
    func getCompact(context: Ice.Context? = nil) throws -> Compact? {
        return try _impl._invoke(operation: "getCompact",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: Compact?
                                     try istr.read(Compact.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Compact?` - The result of the operation
    func getCompactAsync(context: Ice.Context? = nil) async throws -> Compact? {
        return try await _impl._invokeAsync(operation: "getCompact",
                                            mode: .Normal,
                                            read: { istr in
                                                var iceP_returnValue: Compact?
                                                try istr.read(Compact.self) { iceP_returnValue = $0 }
                                                try istr.readPendingValues()
                                                return iceP_returnValue
                                            },
                                            context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `InnerA?`
    func getInnerA(context: Ice.Context? = nil) throws -> InnerA? {
        return try _impl._invoke(operation: "getInnerA",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: InnerA?
                                     try istr.read(InnerA.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `InnerA?` - The result of the operation
    func getInnerAAsync(context: Ice.Context? = nil) async throws -> InnerA? {
        return try await _impl._invokeAsync(operation: "getInnerA",
                                            mode: .Normal,
                                            read: { istr in
                                                var iceP_returnValue: InnerA?
                                                try istr.read(InnerA.self) { iceP_returnValue = $0 }
                                                try istr.readPendingValues()
                                                return iceP_returnValue
                                            },
                                            context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `InnerSubA?`
    func getInnerSubA(context: Ice.Context? = nil) throws -> InnerSubA? {
        return try _impl._invoke(operation: "getInnerSubA",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: InnerSubA?
                                     try istr.read(InnerSubA.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `InnerSubA?` - The result of the operation
    func getInnerSubAAsync(context: Ice.Context? = nil) async throws -> InnerSubA? {
        return try await _impl._invokeAsync(operation: "getInnerSubA",
                                            mode: .Normal,
                                            read: { istr in
                                                var iceP_returnValue: InnerSubA?
                                                try istr.read(InnerSubA.self) { iceP_returnValue = $0 }
                                                try istr.readPendingValues()
                                                return iceP_returnValue
                                            },
                                            context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func throwInnerEx(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "throwInnerEx",
                          mode: .Normal,
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as InnerEx {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `` - The result of the operation
    func throwInnerExAsync(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invokeAsync(operation: "throwInnerEx",
                                            mode: .Normal,
                                            userException:{ ex in
                                                do  {
                                                    throw ex
                                                } catch let error as InnerEx {
                                                    throw error
                                                } catch is Ice.UserException {}
                                            },
                                            context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func throwInnerSubEx(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "throwInnerSubEx",
                          mode: .Normal,
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as InnerSubEx {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `` - The result of the operation
    func throwInnerSubExAsync(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invokeAsync(operation: "throwInnerSubEx",
                                            mode: .Normal,
                                            userException:{ ex in
                                                do  {
                                                    throw ex
                                                } catch let error as InnerSubEx {
                                                    throw error
                                                } catch is Ice.UserException {}
                                            },
                                            context: context)
    }

    ///
    /// - parameter _: `M?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: M?, v2: M?)`:
    ///
    ///   - returnValue: `M?`
    ///
    ///   - v2: `M?`
    func opM(_ iceP_v1: M?, context: Ice.Context? = nil) throws -> (returnValue: M?, v2: M?) {
        return try _impl._invoke(operation: "opM",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_v1)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     var iceP_v2: M?
                                     try istr.read(M.self) { iceP_v2 = $0 }
                                     var iceP_returnValue: M?
                                     try istr.read(M.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return (iceP_returnValue, iceP_v2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `M?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: M?, v2: M?)` - The result of the operation
    func opMAsync(_ iceP_v1: M?, context: Ice.Context? = nil) async throws -> (returnValue: M?, v2: M?) {
        return try await _impl._invokeAsync(operation: "opM",
                                            mode: .Normal,
                                            write: { ostr in
                                                ostr.write(iceP_v1)
                                                ostr.writePendingValues()
                                            },
                                            read: { istr in
                                                var iceP_v2: M?
                                                try istr.read(M.self) { iceP_v2 = $0 }
                                                var iceP_returnValue: M?
                                                try istr.read(M.self) { iceP_returnValue = $0 }
                                                try istr.readPendingValues()
                                                return (iceP_returnValue, iceP_v2)
                                            },
                                            context: context)
    }

    ///
    /// - parameter _: `F1?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: F1?, f12: F1?)`:
    ///
    ///   - returnValue: `F1?`
    ///
    ///   - f12: `F1?`
    func opF1(_ iceP_f11: F1?, context: Ice.Context? = nil) throws -> (returnValue: F1?, f12: F1?) {
        return try _impl._invoke(operation: "opF1",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_f11)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     var iceP_f12: F1?
                                     try istr.read(F1.self) { iceP_f12 = $0 }
                                     var iceP_returnValue: F1?
                                     try istr.read(F1.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return (iceP_returnValue, iceP_f12)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `F1?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: F1?, f12: F1?)` - The result of the operation
    func opF1Async(_ iceP_f11: F1?, context: Ice.Context? = nil) async throws -> (returnValue: F1?, f12: F1?) {
        return try await _impl._invokeAsync(operation: "opF1",
                                            mode: .Normal,
                                            write: { ostr in
                                                ostr.write(iceP_f11)
                                                ostr.writePendingValues()
                                            },
                                            read: { istr in
                                                var iceP_f12: F1?
                                                try istr.read(F1.self) { iceP_f12 = $0 }
                                                var iceP_returnValue: F1?
                                                try istr.read(F1.self) { iceP_returnValue = $0 }
                                                try istr.readPendingValues()
                                                return (iceP_returnValue, iceP_f12)
                                            },
                                            context: context)
    }

    ///
    /// - parameter _: `F2Prx?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: F2Prx?, f22: F2Prx?)`:
    ///
    ///   - returnValue: `F2Prx?`
    ///
    ///   - f22: `F2Prx?`
    func opF2(_ iceP_f21: F2Prx?, context: Ice.Context? = nil) throws -> (returnValue: F2Prx?, f22: F2Prx?) {
        return try _impl._invoke(operation: "opF2",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_f21)
                                 },
                                 read: { istr in
                                     let iceP_f22: F2Prx? = try istr.read(F2Prx.self)
                                     let iceP_returnValue: F2Prx? = try istr.read(F2Prx.self)
                                     return (iceP_returnValue, iceP_f22)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `F2Prx?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: F2Prx?, f22: F2Prx?)` - The result of the operation
    func opF2Async(_ iceP_f21: F2Prx?, context: Ice.Context? = nil) async throws -> (returnValue: F2Prx?, f22: F2Prx?) {
        return try await _impl._invokeAsync(operation: "opF2",
                                            mode: .Normal,
                                            write: { ostr in
                                                ostr.write(iceP_f21)
                                            },
                                            read: { istr in
                                                let iceP_f22: F2Prx? = try istr.read(F2Prx.self)
                                                let iceP_returnValue: F2Prx? = try istr.read(F2Prx.self)
                                                return (iceP_returnValue, iceP_f22)
                                            },
                                            context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Bool`
    func hasF3(context: Ice.Context? = nil) throws -> Swift.Bool {
        return try _impl._invoke(operation: "hasF3",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: Swift.Bool = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Bool` - The result of the operation
    func hasF3Async(context: Ice.Context? = nil) async throws -> Swift.Bool {
        return try await _impl._invokeAsync(operation: "hasF3",
                                            mode: .Normal,
                                            read: { istr in
                                                let iceP_returnValue: Swift.Bool = try istr.read()
                                                return iceP_returnValue
                                            },
                                            context: context)
    }

    ///
    /// - parameter _: `F3?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: F3?, f32: F3?)`:
    ///
    ///   - returnValue: `F3?`
    ///
    ///   - f32: `F3?`
    func opF3(_ iceP_f31: F3?, context: Ice.Context? = nil) throws -> (returnValue: F3?, f32: F3?) {
        return try _impl._invoke(operation: "opF3",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_f31)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     var iceP_f32: F3?
                                     try istr.read(F3.self) { iceP_f32 = $0 }
                                     var iceP_returnValue: F3?
                                     try istr.read(F3.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return (iceP_returnValue, iceP_f32)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `F3?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: F3?, f32: F3?)` - The result of the operation
    func opF3Async(_ iceP_f31: F3?, context: Ice.Context? = nil) async throws -> (returnValue: F3?, f32: F3?) {
        return try await _impl._invokeAsync(operation: "opF3",
                                            mode: .Normal,
                                            write: { ostr in
                                                ostr.write(iceP_f31)
                                                ostr.writePendingValues()
                                            },
                                            read: { istr in
                                                var iceP_f32: F3?
                                                try istr.read(F3.self) { iceP_f32 = $0 }
                                                var iceP_returnValue: F3?
                                                try istr.read(F3.self) { iceP_returnValue = $0 }
                                                try istr.readPendingValues()
                                                return (iceP_returnValue, iceP_f32)
                                            },
                                            context: context)
    }
}

/// TestIntfPrx overview.
///
/// TestIntfPrx Methods:
///
///  - opDerived: 
///
///  - opDerivedAsync: 
///
///  - throwDerived: 
///
///  - throwDerivedAsync: 
public protocol TestIntfPrx: Ice.ObjectPrx {}

private final class TestIntfPrxI: Ice.ObjectPrxI, TestIntfPrx {
    public override class func ice_staticId() -> Swift.String {
        return TestIntfTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: TestIntfPrx.Protocol) throws -> TestIntfPrx {
    try communicator.makeProxyImpl(proxyString) as TestIntfPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `TestIntfPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `TestIntfPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: TestIntfPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> TestIntfPrx? {
    return try TestIntfPrxI.checkedCast(prx: prx, facet: facet, context: context) as TestIntfPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `TestIntfPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `TestIntfPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: TestIntfPrx.Protocol, facet: Swift.String? = nil) -> TestIntfPrx {
    return TestIntfPrxI.uncheckedCast(prx: prx, facet: facet) as TestIntfPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `TestIntfPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: TestIntfPrx.Protocol) -> Swift.String {
    return TestIntfTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `TestIntfPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `TestIntfPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `TestIntfPrx?` - The extracted proxy
    func read(_ type: TestIntfPrx.Protocol) throws -> TestIntfPrx? {
        return try read() as TestIntfPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `TestIntfPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `TestIntfPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: TestIntfPrx.Protocol) throws -> TestIntfPrx? {
        return try read(tag: tag) as TestIntfPrxI?
    }
}

/// TestIntfPrx overview.
///
/// TestIntfPrx Methods:
///
///  - opDerived: 
///
///  - opDerivedAsync: 
///
///  - throwDerived: 
///
///  - throwDerivedAsync: 
public extension TestIntfPrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Base?`
    func opDerived(context: Ice.Context? = nil) throws -> Base? {
        return try _impl._invoke(operation: "opDerived",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: Base?
                                     try istr.read(Base.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Base?` - The result of the operation
    func opDerivedAsync(context: Ice.Context? = nil) async throws -> Base? {
        return try await _impl._invokeAsync(operation: "opDerived",
                                            mode: .Normal,
                                            read: { istr in
                                                var iceP_returnValue: Base?
                                                try istr.read(Base.self) { iceP_returnValue = $0 }
                                                try istr.readPendingValues()
                                                return iceP_returnValue
                                            },
                                            context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func throwDerived(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "throwDerived",
                          mode: .Normal,
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as BaseEx {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `` - The result of the operation
    func throwDerivedAsync(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invokeAsync(operation: "throwDerived",
                                            mode: .Normal,
                                            userException:{ ex in
                                                do  {
                                                    throw ex
                                                } catch let error as BaseEx {
                                                    throw error
                                                } catch is Ice.UserException {}
                                            },
                                            context: context)
    }
}

/// UnexpectedObjectExceptionTestPrx overview.
///
/// UnexpectedObjectExceptionTestPrx Methods:
///
///  - op: 
///
///  - opAsync: 
public protocol UnexpectedObjectExceptionTestPrx: Ice.ObjectPrx {}

private final class UnexpectedObjectExceptionTestPrxI: Ice.ObjectPrxI, UnexpectedObjectExceptionTestPrx {
    public override class func ice_staticId() -> Swift.String {
        return UnexpectedObjectExceptionTestTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: UnexpectedObjectExceptionTestPrx.Protocol) throws -> UnexpectedObjectExceptionTestPrx {
    try communicator.makeProxyImpl(proxyString) as UnexpectedObjectExceptionTestPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `UnexpectedObjectExceptionTestPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `UnexpectedObjectExceptionTestPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: UnexpectedObjectExceptionTestPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> UnexpectedObjectExceptionTestPrx? {
    return try UnexpectedObjectExceptionTestPrxI.checkedCast(prx: prx, facet: facet, context: context) as UnexpectedObjectExceptionTestPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `UnexpectedObjectExceptionTestPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `UnexpectedObjectExceptionTestPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: UnexpectedObjectExceptionTestPrx.Protocol, facet: Swift.String? = nil) -> UnexpectedObjectExceptionTestPrx {
    return UnexpectedObjectExceptionTestPrxI.uncheckedCast(prx: prx, facet: facet) as UnexpectedObjectExceptionTestPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `UnexpectedObjectExceptionTestPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: UnexpectedObjectExceptionTestPrx.Protocol) -> Swift.String {
    return UnexpectedObjectExceptionTestTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `UnexpectedObjectExceptionTestPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `UnexpectedObjectExceptionTestPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `UnexpectedObjectExceptionTestPrx?` - The extracted proxy
    func read(_ type: UnexpectedObjectExceptionTestPrx.Protocol) throws -> UnexpectedObjectExceptionTestPrx? {
        return try read() as UnexpectedObjectExceptionTestPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `UnexpectedObjectExceptionTestPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `UnexpectedObjectExceptionTestPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: UnexpectedObjectExceptionTestPrx.Protocol) throws -> UnexpectedObjectExceptionTestPrx? {
        return try read(tag: tag) as UnexpectedObjectExceptionTestPrxI?
    }
}

/// UnexpectedObjectExceptionTestPrx overview.
///
/// UnexpectedObjectExceptionTestPrx Methods:
///
///  - op: 
///
///  - opAsync: 
public extension UnexpectedObjectExceptionTestPrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Empty?`
    func op(context: Ice.Context? = nil) throws -> Empty? {
        return try _impl._invoke(operation: "op",
                                 mode: .Normal,
                                 read: { istr in
                                     var iceP_returnValue: Empty?
                                     try istr.read(Empty.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Empty?` - The result of the operation
    func opAsync(context: Ice.Context? = nil) async throws -> Empty? {
        return try await _impl._invokeAsync(operation: "op",
                                            mode: .Normal,
                                            read: { istr in
                                                var iceP_returnValue: Empty?
                                                try istr.read(Empty.self) { iceP_returnValue = $0 }
                                                try istr.readPendingValues()
                                                return iceP_returnValue
                                            },
                                            context: context)
    }
}

/// :nodoc:
public class Base_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Base.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Base() -> Ice.ValueTypeResolver {
        return Base_TypeResolver()
    }
}

open class Base: Ice.Value {
    public var theS: S = S()
    public var str: Swift.String = ""

    public required init() {}

    public init(theS: S, str: Swift.String) {
        self.theS = theS
        self.str = str
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::Base" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.theS = try istr.read()
        self.str = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Base.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.theS)
        ostr.write(self.str)
        ostr.endSlice()
    }
}

/// :nodoc:
public class A_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return A.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_A() -> Ice.ValueTypeResolver {
        return A_TypeResolver()
    }
}

open class A: Ice.Value {
    public var theB: B? = nil
    public var theC: C? = nil
    public var preMarshalInvoked: Swift.Bool = false
    public var postUnmarshalInvoked: Swift.Bool = false

    public required init() {}

    public init(theB: B?, theC: C?, preMarshalInvoked: Swift.Bool, postUnmarshalInvoked: Swift.Bool) {
        self.theB = theB
        self.theC = theC
        self.preMarshalInvoked = preMarshalInvoked
        self.postUnmarshalInvoked = postUnmarshalInvoked
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::A" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(B.self) { self.theB = $0 }
        try istr.read(C.self) { self.theC = $0 }
        self.preMarshalInvoked = try istr.read()
        self.postUnmarshalInvoked = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: A.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.theB)
        ostr.write(self.theC)
        ostr.write(self.preMarshalInvoked)
        ostr.write(self.postUnmarshalInvoked)
        ostr.endSlice()
    }
}

/// :nodoc:
public class B_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return B.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_B() -> Ice.ValueTypeResolver {
        return B_TypeResolver()
    }
}

open class B: A {
    public var theA: A? = nil

    public required init() {
        super.init()
    }

    public init(theB: B?, theC: C?, preMarshalInvoked: Swift.Bool, postUnmarshalInvoked: Swift.Bool, theA: A?) {
        self.theA = theA
        super.init(theB: theB, theC: theC, preMarshalInvoked: preMarshalInvoked, postUnmarshalInvoked: postUnmarshalInvoked)
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::B" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(A.self) { self.theA = $0 }
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: B.ice_staticId(), compactId: -1, last: false)
        ostr.write(self.theA)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}

/// :nodoc:
public class C_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return C.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_C() -> Ice.ValueTypeResolver {
        return C_TypeResolver()
    }
}

open class C: Ice.Value {
    public var theB: B? = nil
    public var preMarshalInvoked: Swift.Bool = false
    public var postUnmarshalInvoked: Swift.Bool = false

    public required init() {}

    public init(theB: B?, preMarshalInvoked: Swift.Bool, postUnmarshalInvoked: Swift.Bool) {
        self.theB = theB
        self.preMarshalInvoked = preMarshalInvoked
        self.postUnmarshalInvoked = postUnmarshalInvoked
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::C" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(B.self) { self.theB = $0 }
        self.preMarshalInvoked = try istr.read()
        self.postUnmarshalInvoked = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: C.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.theB)
        ostr.write(self.preMarshalInvoked)
        ostr.write(self.postUnmarshalInvoked)
        ostr.endSlice()
    }
}

/// :nodoc:
public class D_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return D.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_D() -> Ice.ValueTypeResolver {
        return D_TypeResolver()
    }
}

open class D: Ice.Value {
    public var theA: A? = nil
    public var theB: B? = nil
    public var theC: C? = nil
    public var preMarshalInvoked: Swift.Bool = false
    public var postUnmarshalInvoked: Swift.Bool = false

    public required init() {}

    public init(theA: A?, theB: B?, theC: C?, preMarshalInvoked: Swift.Bool, postUnmarshalInvoked: Swift.Bool) {
        self.theA = theA
        self.theB = theB
        self.theC = theC
        self.preMarshalInvoked = preMarshalInvoked
        self.postUnmarshalInvoked = postUnmarshalInvoked
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::D" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(A.self) { self.theA = $0 }
        try istr.read(B.self) { self.theB = $0 }
        try istr.read(C.self) { self.theC = $0 }
        self.preMarshalInvoked = try istr.read()
        self.postUnmarshalInvoked = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: D.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.theA)
        ostr.write(self.theB)
        ostr.write(self.theC)
        ostr.write(self.preMarshalInvoked)
        ostr.write(self.postUnmarshalInvoked)
        ostr.endSlice()
    }
}

/// :nodoc:
public class E_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return E.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_E() -> Ice.ValueTypeResolver {
        return E_TypeResolver()
    }
}

open class E: Ice.Value {
    public var i: Swift.Int32 = 0
    public var s: Swift.String = ""

    public required init() {}

    public init(i: Swift.Int32, s: Swift.String) {
        self.i = i
        self.s = s
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::E" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.i = try istr.read()
        self.s = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: E.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.i)
        ostr.write(self.s)
        ostr.endSlice()
    }
}

/// :nodoc:
public class F_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return F.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_F() -> Ice.ValueTypeResolver {
        return F_TypeResolver()
    }
}

open class F: Ice.Value {
    public var e1: E? = nil
    public var e2: E? = nil

    public required init() {}

    public init(e1: E?, e2: E?) {
        self.e1 = e1
        self.e2 = e2
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::F" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(E.self) { self.e1 = $0 }
        try istr.read(E.self) { self.e2 = $0 }
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: F.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.e1)
        ostr.write(self.e2)
        ostr.endSlice()
    }
}

/// :nodoc:
public class G_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return G.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_G() -> Ice.ValueTypeResolver {
        return G_TypeResolver()
    }
}

open class G: Base {
    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::G" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: G.ice_staticId(), compactId: -1, last: false)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}

/// :nodoc:
public class Compact_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Compact.self
    }
}

public extension Ice.TypeIdResolver {
    @objc static func TypeId_1() -> Swift.String {
        return "::Test::Compact"
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Compact() -> Ice.ValueTypeResolver {
        return Compact_TypeResolver()
    }
}

open class Compact: Ice.Value {
    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::Compact" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Compact.ice_staticId(), compactId: 1, last: true)
        ostr.endSlice()
    }
}

/// :nodoc:
public class CompactScoped_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return CompactScoped.self
    }
}

public extension Ice.TypeIdResolver {
    @objc static func TypeId_2() -> Swift.String {
        return "::Test::CompactScoped"
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_CompactScoped() -> Ice.ValueTypeResolver {
        return CompactScoped_TypeResolver()
    }
}

open class CompactScoped: Ice.Value {
    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::CompactScoped" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CompactScoped.ice_staticId(), compactId: 2, last: true)
        ostr.endSlice()
    }
}

/// :nodoc:
public class CompactExt_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return CompactExt.self
    }
}

public extension Ice.TypeIdResolver {
    @objc static func TypeId_789() -> Swift.String {
        return "::Test::CompactExt"
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_CompactExt() -> Ice.ValueTypeResolver {
        return CompactExt_TypeResolver()
    }
}

open class CompactExt: Compact {
    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::CompactExt" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CompactExt.ice_staticId(), compactId: 789, last: false)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}

/// :nodoc:
public class InnerA_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return InnerA.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Inner_A() -> Ice.ValueTypeResolver {
        return InnerA_TypeResolver()
    }
}

open class InnerA: Ice.Value {
    public var theA: A? = nil

    public required init() {}

    public init(theA: A?) {
        self.theA = theA
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::Inner::A" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(A.self) { self.theA = $0 }
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: InnerA.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.theA)
        ostr.endSlice()
    }
}

/// :nodoc:
public class InnerSubA_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return InnerSubA.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Inner_Sub_A() -> Ice.ValueTypeResolver {
        return InnerSubA_TypeResolver()
    }
}

open class InnerSubA: Ice.Value {
    public var theA: InnerA? = nil

    public required init() {}

    public init(theA: InnerA?) {
        self.theA = theA
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::Inner::Sub::A" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(InnerA.self) { self.theA = $0 }
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: InnerSubA.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.theA)
        ostr.endSlice()
    }
}

/// :nodoc:
public class A1_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return A1.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_A1() -> Ice.ValueTypeResolver {
        return A1_TypeResolver()
    }
}

open class A1: Ice.Value {
    public var name: Swift.String = ""

    public required init() {}

    public init(name: Swift.String) {
        self.name = name
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::A1" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.name = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: A1.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.name)
        ostr.endSlice()
    }
}

/// :nodoc:
public class B1_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return B1.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_B1() -> Ice.ValueTypeResolver {
        return B1_TypeResolver()
    }
}

open class B1: Ice.Value {
    public var a1: A1? = nil
    public var a2: A1? = nil

    public required init() {}

    public init(a1: A1?, a2: A1?) {
        self.a1 = a1
        self.a2 = a2
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::B1" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(A1.self) { self.a1 = $0 }
        try istr.read(A1.self) { self.a2 = $0 }
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: B1.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.a1)
        ostr.write(self.a2)
        ostr.endSlice()
    }
}

/// :nodoc:
public class D1_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return D1.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_D1() -> Ice.ValueTypeResolver {
        return D1_TypeResolver()
    }
}

open class D1: B1 {
    public var a3: A1? = nil
    public var a4: A1? = nil

    public required init() {
        super.init()
    }

    public init(a1: A1?, a2: A1?, a3: A1?, a4: A1?) {
        self.a3 = a3
        self.a4 = a4
        super.init(a1: a1, a2: a2)
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::D1" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(A1.self) { self.a3 = $0 }
        try istr.read(A1.self) { self.a4 = $0 }
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: D1.ice_staticId(), compactId: -1, last: false)
        ostr.write(self.a3)
        ostr.write(self.a4)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}

/// :nodoc:
public class Recursive_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Recursive.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Recursive() -> Ice.ValueTypeResolver {
        return Recursive_TypeResolver()
    }
}

open class Recursive: Ice.Value {
    public var v: Recursive? = nil

    public required init() {}

    public init(v: Recursive?) {
        self.v = v
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::Recursive" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(Recursive.self) { self.v = $0 }
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Recursive.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.v)
        ostr.endSlice()
    }
}

/// :nodoc:
public class K_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return K.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_K() -> Ice.ValueTypeResolver {
        return K_TypeResolver()
    }
}

open class K: Ice.Value {
    public var value: Ice.Value? = nil

    public required init() {}

    public init(value: Ice.Value?) {
        self.value = value
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::K" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read() { self.value = $0 }
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: K.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.value)
        ostr.endSlice()
    }
}

/// :nodoc:
public class L_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return L.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_L() -> Ice.ValueTypeResolver {
        return L_TypeResolver()
    }
}

open class L: Ice.Value {
    public var data: Swift.String = ""

    public required init() {}

    public init(data: Swift.String) {
        self.data = data
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::L" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.data = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: L.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.data)
        ostr.endSlice()
    }
}

/// :nodoc:
public class M_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return M.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_M() -> Ice.ValueTypeResolver {
        return M_TypeResolver()
    }
}

open class M: Ice.Value {
    public var v: LMap = LMap()

    public required init() {}

    public init(v: LMap) {
        self.v = v
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::M" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.v = try LMapHelper.read(from: istr)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: M.ice_staticId(), compactId: -1, last: true)
        LMapHelper.write(to: ostr, value: self.v)
        ostr.endSlice()
    }
}

/// :nodoc:
public class F3_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return F3.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_F3() -> Ice.ValueTypeResolver {
        return F3_TypeResolver()
    }
}

open class F3: Ice.Value {
    public var f1: F1? = nil
    public var f2: F2Prx? = nil

    public required init() {}

    public init(f1: F1?, f2: F2Prx?) {
        self.f1 = f1
        self.f2 = f2
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::F3" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(F1.self) { self.f1 = $0 }
        self.f2 = try istr.read(F2Prx.self)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: F3.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.f1)
        ostr.write(self.f2)
        ostr.endSlice()
    }
}

/// :nodoc:
public class Empty_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Empty.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Empty() -> Ice.ValueTypeResolver {
        return Empty_TypeResolver()
    }
}

open class Empty: Ice.Value {
    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::Empty" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Empty.ice_staticId(), compactId: -1, last: true)
        ostr.endSlice()
    }
}

/// :nodoc:
public class AlsoEmpty_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return AlsoEmpty.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_AlsoEmpty() -> Ice.ValueTypeResolver {
        return AlsoEmpty_TypeResolver()
    }
}

open class AlsoEmpty: Ice.Value {
    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::AlsoEmpty" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: AlsoEmpty.ice_staticId(), compactId: -1, last: true)
        ostr.endSlice()
    }
}

/// :nodoc:
public class COneMember_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return COneMember.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_COneMember() -> Ice.ValueTypeResolver {
        return COneMember_TypeResolver()
    }
}

open class COneMember: Ice.Value {
    public var e: Empty? = nil

    public required init() {}

    public init(e: Empty?) {
        self.e = e
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::COneMember" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(Empty.self) { self.e = $0 }
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: COneMember.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.e)
        ostr.endSlice()
    }
}

/// :nodoc:
public class CTwoMembers_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return CTwoMembers.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_CTwoMembers() -> Ice.ValueTypeResolver {
        return CTwoMembers_TypeResolver()
    }
}

open class CTwoMembers: Ice.Value {
    public var e1: Empty? = nil
    public var e2: Empty? = nil

    public required init() {}

    public init(e1: Empty?, e2: Empty?) {
        self.e1 = e1
        self.e2 = e2
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::CTwoMembers" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(Empty.self) { self.e1 = $0 }
        try istr.read(Empty.self) { self.e2 = $0 }
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CTwoMembers.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.e1)
        ostr.write(self.e2)
        ostr.endSlice()
    }
}


/// Dispatcher for `I` servants.
public struct IDisp: Ice.Dispatcher {
    public let servant: I
    private static let defaultObject = Ice.ObjectI<ITraits>()

    public init(_ servant: I) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "ice_id":
            try (servant as? Ice.Object ?? IDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try (servant as? Ice.Object ?? IDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try (servant as? Ice.Object ?? IDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try (servant as? Ice.Object ?? IDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol I {}


/// Dispatcher for `J` servants.
public struct JDisp: Ice.Dispatcher {
    public let servant: J
    private static let defaultObject = Ice.ObjectI<JTraits>()

    public init(_ servant: J) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "ice_id":
            try (servant as? Ice.Object ?? JDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try (servant as? Ice.Object ?? JDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try (servant as? Ice.Object ?? JDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try (servant as? Ice.Object ?? JDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol J: I {}


/// Dispatcher for `Initial` servants.
public struct InitialDisp: Ice.Dispatcher {
    public let servant: Initial
    private static let defaultObject = Ice.ObjectI<InitialTraits>()

    public init(_ servant: Initial) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "acceptsClassCycles":
            try await servant._iceD_acceptsClassCycles(request)
        case "getAMDMB":
            try await servant._iceD_getAMDMB(request)
        case "getAll":
            try await servant._iceD_getAll(request)
        case "getB1":
            try await servant._iceD_getB1(request)
        case "getB2":
            try await servant._iceD_getB2(request)
        case "getC":
            try await servant._iceD_getC(request)
        case "getCompact":
            try await servant._iceD_getCompact(request)
        case "getD":
            try await servant._iceD_getD(request)
        case "getD1":
            try await servant._iceD_getD1(request)
        case "getE":
            try await servant._iceD_getE(request)
        case "getF":
            try await servant._iceD_getF(request)
        case "getInnerA":
            try await servant._iceD_getInnerA(request)
        case "getInnerSubA":
            try await servant._iceD_getInnerSubA(request)
        case "getK":
            try await servant._iceD_getK(request)
        case "getMB":
            try await servant._iceD_getMB(request)
        case "hasF3":
            try await servant._iceD_hasF3(request)
        case "ice_id":
            try (servant as? Ice.Object ?? InitialDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try (servant as? Ice.Object ?? InitialDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try (servant as? Ice.Object ?? InitialDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try (servant as? Ice.Object ?? InitialDisp.defaultObject)._iceD_ice_ping(request)
        case "opBaseSeq":
            try await servant._iceD_opBaseSeq(request)
        case "opF1":
            try await servant._iceD_opF1(request)
        case "opF2":
            try await servant._iceD_opF2(request)
        case "opF3":
            try await servant._iceD_opF3(request)
        case "opM":
            try await servant._iceD_opM(request)
        case "opValue":
            try await servant._iceD_opValue(request)
        case "opValueMap":
            try await servant._iceD_opValueMap(request)
        case "opValueSeq":
            try await servant._iceD_opValueSeq(request)
        case "setCycle":
            try await servant._iceD_setCycle(request)
        case "setG":
            try await servant._iceD_setG(request)
        case "setRecursive":
            try await servant._iceD_setRecursive(request)
        case "shutdown":
            try await servant._iceD_shutdown(request)
        case "throwEDerived":
            try await servant._iceD_throwEDerived(request)
        case "throwInnerEx":
            try await servant._iceD_throwInnerEx(request)
        case "throwInnerSubEx":
            try await servant._iceD_throwInnerSubEx(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol Initial {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func shutdown(current: Ice.Current) throws

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `B?`
    func getB1(current: Ice.Current) throws -> B?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `B?`
    func getB2(current: Ice.Current) throws -> B?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `C?`
    func getC(current: Ice.Current) throws -> C?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `D?`
    func getD(current: Ice.Current) throws -> D?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `E?`
    func getE(current: Ice.Current) throws -> E?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `F?`
    func getF(current: Ice.Current) throws -> F?

    ///
    /// - parameter p: `Recursive?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func setRecursive(p: Recursive?, current: Ice.Current) throws

    ///
    /// - parameter r: `Recursive?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func setCycle(r: Recursive?, current: Ice.Current) throws

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Bool`
    func acceptsClassCycles(current: Ice.Current) throws -> Swift.Bool

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `B?`
    func getMB(current: Ice.Current) throws -> B?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `B?` - The result of the operation
    func getAMDMBAsync(current: Ice.Current) async throws -> B?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(b1: B?, b2: B?, theC: C?, theD: D?)`:
    ///
    ///   - b1: `B?`
    ///
    ///   - b2: `B?`
    ///
    ///   - theC: `C?`
    ///
    ///   - theD: `D?`
    func getAll(current: Ice.Current) throws -> (b1: B?, b2: B?, theC: C?, theD: D?)

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `K?`
    func getK(current: Ice.Current) throws -> K?

    ///
    /// - parameter v1: `Ice.Value?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: Ice.Value?, v2: Ice.Value?)`:
    ///
    ///   - returnValue: `Ice.Value?`
    ///
    ///   - v2: `Ice.Value?`
    func opValue(v1: Ice.Value?, current: Ice.Current) throws -> (returnValue: Ice.Value?, v2: Ice.Value?)

    ///
    /// - parameter v1: `ValueSeq`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: ValueSeq, v2: ValueSeq)`:
    ///
    ///   - returnValue: `ValueSeq`
    ///
    ///   - v2: `ValueSeq`
    func opValueSeq(v1: ValueSeq, current: Ice.Current) throws -> (returnValue: ValueSeq, v2: ValueSeq)

    ///
    /// - parameter v1: `ValueMap`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: ValueMap, v2: ValueMap)`:
    ///
    ///   - returnValue: `ValueMap`
    ///
    ///   - v2: `ValueMap`
    func opValueMap(v1: ValueMap, current: Ice.Current) throws -> (returnValue: ValueMap, v2: ValueMap)

    ///
    /// - parameter d1: `D1?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `D1?`
    func getD1(d1: D1?, current: Ice.Current) throws -> D1?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func throwEDerived(current: Ice.Current) throws

    ///
    /// - parameter theG: `G?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func setG(theG: G?, current: Ice.Current) throws

    ///
    /// - parameter inSeq: `BaseSeq`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: BaseSeq, outSeq: BaseSeq)`:
    ///
    ///   - returnValue: `BaseSeq`
    ///
    ///   - outSeq: `BaseSeq`
    func opBaseSeq(inSeq: BaseSeq, current: Ice.Current) throws -> (returnValue: BaseSeq, outSeq: BaseSeq)

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Compact?`
    func getCompact(current: Ice.Current) throws -> Compact?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `InnerA?`
    func getInnerA(current: Ice.Current) throws -> InnerA?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `InnerSubA?`
    func getInnerSubA(current: Ice.Current) throws -> InnerSubA?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func throwInnerEx(current: Ice.Current) throws

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func throwInnerSubEx(current: Ice.Current) throws

    ///
    /// - parameter v1: `M?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: M?, v2: M?)`:
    ///
    ///   - returnValue: `M?`
    ///
    ///   - v2: `M?`
    func opM(v1: M?, current: Ice.Current) throws -> (returnValue: M?, v2: M?)

    ///
    /// - parameter f11: `F1?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: F1?, f12: F1?)`:
    ///
    ///   - returnValue: `F1?`
    ///
    ///   - f12: `F1?`
    func opF1(f11: F1?, current: Ice.Current) throws -> (returnValue: F1?, f12: F1?)

    ///
    /// - parameter f21: `F2Prx?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: F2Prx?, f22: F2Prx?)`:
    ///
    ///   - returnValue: `F2Prx?`
    ///
    ///   - f22: `F2Prx?`
    func opF2(f21: F2Prx?, current: Ice.Current) throws -> (returnValue: F2Prx?, f22: F2Prx?)

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Bool`
    func hasF3(current: Ice.Current) throws -> Swift.Bool

    ///
    /// - parameter f31: `F3?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: F3?, f32: F3?)`:
    ///
    ///   - returnValue: `F3?`
    ///
    ///   - f32: `F3?`
    func opF3(f31: F3?, current: Ice.Current) throws -> (returnValue: F3?, f32: F3?)
}


/// Dispatcher for `TestIntf` servants.
public struct TestIntfDisp: Ice.Dispatcher {
    public let servant: TestIntf
    private static let defaultObject = Ice.ObjectI<TestIntfTraits>()

    public init(_ servant: TestIntf) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "ice_id":
            try (servant as? Ice.Object ?? TestIntfDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try (servant as? Ice.Object ?? TestIntfDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try (servant as? Ice.Object ?? TestIntfDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try (servant as? Ice.Object ?? TestIntfDisp.defaultObject)._iceD_ice_ping(request)
        case "opDerived":
            try await servant._iceD_opDerived(request)
        case "throwDerived":
            try await servant._iceD_throwDerived(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol TestIntf {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Base?`
    func opDerived(current: Ice.Current) throws -> Base?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func throwDerived(current: Ice.Current) throws
}


/// Dispatcher for `UnexpectedObjectExceptionTest` servants.
public struct UnexpectedObjectExceptionTestDisp: Ice.Dispatcher {
    public let servant: UnexpectedObjectExceptionTest
    private static let defaultObject = Ice.ObjectI<UnexpectedObjectExceptionTestTraits>()

    public init(_ servant: UnexpectedObjectExceptionTest) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "ice_id":
            try (servant as? Ice.Object ?? UnexpectedObjectExceptionTestDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try (servant as? Ice.Object ?? UnexpectedObjectExceptionTestDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try (servant as? Ice.Object ?? UnexpectedObjectExceptionTestDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try (servant as? Ice.Object ?? UnexpectedObjectExceptionTestDisp.defaultObject)._iceD_ice_ping(request)
        case "op":
            try await servant._iceD_op(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol UnexpectedObjectExceptionTest {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Empty?`
    func op(current: Ice.Current) throws -> Empty?
}

/// I overview.
extension I {}

/// J overview.
extension J {}

/// Initial overview.
///
/// Initial Methods:
///
///  - shutdown: 
///
///  - getB1: 
///
///  - getB2: 
///
///  - getC: 
///
///  - getD: 
///
///  - getE: 
///
///  - getF: 
///
///  - setRecursive: 
///
///  - setCycle: 
///
///  - acceptsClassCycles: 
///
///  - getMB: 
///
///  - getAMDMB: 
///
///  - getAll: 
///
///  - getK: 
///
///  - opValue: 
///
///  - opValueSeq: 
///
///  - opValueMap: 
///
///  - getD1: 
///
///  - throwEDerived: 
///
///  - setG: 
///
///  - opBaseSeq: 
///
///  - getCompact: 
///
///  - getInnerA: 
///
///  - getInnerSubA: 
///
///  - throwInnerEx: 
///
///  - throwInnerSubEx: 
///
///  - opM: 
///
///  - opF1: 
///
///  - opF2: 
///
///  - hasF3: 
///
///  - opF3: 
extension Initial {
    public func _iceD_shutdown(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()

        try self.shutdown(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_getB1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()

        let iceP_returnValue = try self.getB1(current: request.current)
        let ostr = request.current.startReplyStream()
        ostr.startEncapsulation(encoding: request.current.encoding, format: nil)
        ostr.write(iceP_returnValue)
        ostr.writePendingValues()
        ostr.endEncapsulation()
        return Ice.OutgoingResponse(ostr)
    }

    public func _iceD_getB2(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()

        let iceP_returnValue = try self.getB2(current: request.current)
        let ostr = request.current.startReplyStream()
        ostr.startEncapsulation(encoding: request.current.encoding, format: nil)
        ostr.write(iceP_returnValue)
        ostr.writePendingValues()
        ostr.endEncapsulation()
        return Ice.OutgoingResponse(ostr)
    }

    public func _iceD_getC(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()

        let iceP_returnValue = try self.getC(current: request.current)
        let ostr = request.current.startReplyStream()
        ostr.startEncapsulation(encoding: request.current.encoding, format: nil)
        ostr.write(iceP_returnValue)
        ostr.writePendingValues()
        ostr.endEncapsulation()
        return Ice.OutgoingResponse(ostr)
    }

    public func _iceD_getD(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()

        let iceP_returnValue = try self.getD(current: request.current)
        let ostr = request.current.startReplyStream()
        ostr.startEncapsulation(encoding: request.current.encoding, format: nil)
        ostr.write(iceP_returnValue)
        ostr.writePendingValues()
        ostr.endEncapsulation()
        return Ice.OutgoingResponse(ostr)
    }

    public func _iceD_getE(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()

        let iceP_returnValue = try self.getE(current: request.current)
        let ostr = request.current.startReplyStream()
        ostr.startEncapsulation(encoding: request.current.encoding, format: nil)
        ostr.write(iceP_returnValue)
        ostr.writePendingValues()
        ostr.endEncapsulation()
        return Ice.OutgoingResponse(ostr)
    }

    public func _iceD_getF(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()

        let iceP_returnValue = try self.getF(current: request.current)
        let ostr = request.current.startReplyStream()
        ostr.startEncapsulation(encoding: request.current.encoding, format: nil)
        ostr.write(iceP_returnValue)
        ostr.writePendingValues()
        ostr.endEncapsulation()
        return Ice.OutgoingResponse(ostr)
    }

    public func _iceD_setRecursive(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_p: Recursive?
        try istr.read(Recursive.self) { iceP_p = $0 }
        try istr.readPendingValues()

        try self.setRecursive(p: iceP_p, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_setCycle(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_r: Recursive?
        try istr.read(Recursive.self) { iceP_r = $0 }
        try istr.readPendingValues()

        try self.setCycle(r: iceP_r, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_acceptsClassCycles(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()

        let iceP_returnValue = try self.acceptsClassCycles(current: request.current)
        let ostr = request.current.startReplyStream()
        ostr.startEncapsulation(encoding: request.current.encoding, format: nil)
        ostr.write(iceP_returnValue)
        ostr.endEncapsulation()
        return Ice.OutgoingResponse(ostr)
    }

    public func _iceD_getMB(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()

        let iceP_returnValue = try self.getMB(current: request.current)
        let ostr = request.current.startReplyStream()
        ostr.startEncapsulation(encoding: request.current.encoding, format: nil)
        ostr.write(iceP_returnValue)
        ostr.writePendingValues()
        ostr.endEncapsulation()
        return Ice.OutgoingResponse(ostr)
    }

    public func _iceD_getAMDMB(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getAMDMBAsync(
            current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_getAll(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()

        let (iceP_b1, iceP_b2, iceP_theC, iceP_theD) = try self.getAll(current: request.current)
        let ostr = request.current.startReplyStream()
        ostr.startEncapsulation(encoding: request.current.encoding, format: nil)
        ostr.write(iceP_b1)
        ostr.write(iceP_b2)
        ostr.write(iceP_theC)
        ostr.write(iceP_theD)
        ostr.writePendingValues()
        ostr.endEncapsulation()
        return Ice.OutgoingResponse(ostr)
    }

    public func _iceD_getK(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()

        let iceP_returnValue = try self.getK(current: request.current)
        let ostr = request.current.startReplyStream()
        ostr.startEncapsulation(encoding: request.current.encoding, format: nil)
        ostr.write(iceP_returnValue)
        ostr.writePendingValues()
        ostr.endEncapsulation()
        return Ice.OutgoingResponse(ostr)
    }

    public func _iceD_opValue(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_v1: Ice.Value?
        try istr.read() { iceP_v1 = $0 }
        try istr.readPendingValues()

        let (iceP_returnValue, iceP_v2) = try self.opValue(v1: iceP_v1, current: request.current)
        let ostr = request.current.startReplyStream()
        ostr.startEncapsulation(encoding: request.current.encoding, format: nil)
        ostr.write(iceP_v2)
        ostr.write(iceP_returnValue)
        ostr.writePendingValues()
        ostr.endEncapsulation()
        return Ice.OutgoingResponse(ostr)
    }

    public func _iceD_opValueSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_v1: ValueSeq = try ValueSeqHelper.read(from: istr)
        try istr.readPendingValues()

        let (iceP_returnValue, iceP_v2) = try self.opValueSeq(v1: iceP_v1, current: request.current)
        let ostr = request.current.startReplyStream()
        ostr.startEncapsulation(encoding: request.current.encoding, format: nil)
        ValueSeqHelper.write(to: ostr, value: iceP_v2)
        ValueSeqHelper.write(to: ostr, value: iceP_returnValue)
        ostr.writePendingValues()
        ostr.endEncapsulation()
        return Ice.OutgoingResponse(ostr)
    }

    public func _iceD_opValueMap(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_v1: ValueMap = try ValueMapHelper.read(from: istr)
        try istr.readPendingValues()

        let (iceP_returnValue, iceP_v2) = try self.opValueMap(v1: iceP_v1, current: request.current)
        let ostr = request.current.startReplyStream()
        ostr.startEncapsulation(encoding: request.current.encoding, format: nil)
        ValueMapHelper.write(to: ostr, value: iceP_v2)
        ValueMapHelper.write(to: ostr, value: iceP_returnValue)
        ostr.writePendingValues()
        ostr.endEncapsulation()
        return Ice.OutgoingResponse(ostr)
    }

    public func _iceD_getD1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_d1: D1?
        try istr.read(D1.self) { iceP_d1 = $0 }
        try istr.readPendingValues()

        let iceP_returnValue = try self.getD1(d1: iceP_d1, current: request.current)
        let ostr = request.current.startReplyStream()
        ostr.startEncapsulation(encoding: request.current.encoding, format: nil)
        ostr.write(iceP_returnValue)
        ostr.writePendingValues()
        ostr.endEncapsulation()
        return Ice.OutgoingResponse(ostr)
    }

    public func _iceD_throwEDerived(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()

        try self.throwEDerived(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_setG(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_theG: G?
        try istr.read(G.self) { iceP_theG = $0 }
        try istr.readPendingValues()

        try self.setG(theG: iceP_theG, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_opBaseSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_inSeq: BaseSeq = try BaseSeqHelper.read(from: istr)
        try istr.readPendingValues()

        let (iceP_returnValue, iceP_outSeq) = try self.opBaseSeq(inSeq: iceP_inSeq, current: request.current)
        let ostr = request.current.startReplyStream()
        ostr.startEncapsulation(encoding: request.current.encoding, format: nil)
        BaseSeqHelper.write(to: ostr, value: iceP_outSeq)
        BaseSeqHelper.write(to: ostr, value: iceP_returnValue)
        ostr.writePendingValues()
        ostr.endEncapsulation()
        return Ice.OutgoingResponse(ostr)
    }

    public func _iceD_getCompact(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()

        let iceP_returnValue = try self.getCompact(current: request.current)
        let ostr = request.current.startReplyStream()
        ostr.startEncapsulation(encoding: request.current.encoding, format: nil)
        ostr.write(iceP_returnValue)
        ostr.writePendingValues()
        ostr.endEncapsulation()
        return Ice.OutgoingResponse(ostr)
    }

    public func _iceD_getInnerA(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()

        let iceP_returnValue = try self.getInnerA(current: request.current)
        let ostr = request.current.startReplyStream()
        ostr.startEncapsulation(encoding: request.current.encoding, format: nil)
        ostr.write(iceP_returnValue)
        ostr.writePendingValues()
        ostr.endEncapsulation()
        return Ice.OutgoingResponse(ostr)
    }

    public func _iceD_getInnerSubA(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()

        let iceP_returnValue = try self.getInnerSubA(current: request.current)
        let ostr = request.current.startReplyStream()
        ostr.startEncapsulation(encoding: request.current.encoding, format: nil)
        ostr.write(iceP_returnValue)
        ostr.writePendingValues()
        ostr.endEncapsulation()
        return Ice.OutgoingResponse(ostr)
    }

    public func _iceD_throwInnerEx(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()

        try self.throwInnerEx(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_throwInnerSubEx(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()

        try self.throwInnerSubEx(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_opM(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_v1: M?
        try istr.read(M.self) { iceP_v1 = $0 }
        try istr.readPendingValues()

        let (iceP_returnValue, iceP_v2) = try self.opM(v1: iceP_v1, current: request.current)
        let ostr = request.current.startReplyStream()
        ostr.startEncapsulation(encoding: request.current.encoding, format: nil)
        ostr.write(iceP_v2)
        ostr.write(iceP_returnValue)
        ostr.writePendingValues()
        ostr.endEncapsulation()
        return Ice.OutgoingResponse(ostr)
    }

    public func _iceD_opF1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_f11: F1?
        try istr.read(F1.self) { iceP_f11 = $0 }
        try istr.readPendingValues()

        let (iceP_returnValue, iceP_f12) = try self.opF1(f11: iceP_f11, current: request.current)
        let ostr = request.current.startReplyStream()
        ostr.startEncapsulation(encoding: request.current.encoding, format: nil)
        ostr.write(iceP_f12)
        ostr.write(iceP_returnValue)
        ostr.writePendingValues()
        ostr.endEncapsulation()
        return Ice.OutgoingResponse(ostr)
    }

    public func _iceD_opF2(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_f21: F2Prx? = try istr.read(F2Prx.self)

        let (iceP_returnValue, iceP_f22) = try self.opF2(f21: iceP_f21, current: request.current)
        let ostr = request.current.startReplyStream()
        ostr.startEncapsulation(encoding: request.current.encoding, format: nil)
        ostr.write(iceP_f22)
        ostr.write(iceP_returnValue)
        ostr.endEncapsulation()
        return Ice.OutgoingResponse(ostr)
    }

    public func _iceD_hasF3(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()

        let iceP_returnValue = try self.hasF3(current: request.current)
        let ostr = request.current.startReplyStream()
        ostr.startEncapsulation(encoding: request.current.encoding, format: nil)
        ostr.write(iceP_returnValue)
        ostr.endEncapsulation()
        return Ice.OutgoingResponse(ostr)
    }

    public func _iceD_opF3(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_f31: F3?
        try istr.read(F3.self) { iceP_f31 = $0 }
        try istr.readPendingValues()

        let (iceP_returnValue, iceP_f32) = try self.opF3(f31: iceP_f31, current: request.current)
        let ostr = request.current.startReplyStream()
        ostr.startEncapsulation(encoding: request.current.encoding, format: nil)
        ostr.write(iceP_f32)
        ostr.write(iceP_returnValue)
        ostr.writePendingValues()
        ostr.endEncapsulation()
        return Ice.OutgoingResponse(ostr)
    }
}

/// TestIntf overview.
///
/// TestIntf Methods:
///
///  - opDerived: 
///
///  - throwDerived: 
extension TestIntf {
    public func _iceD_opDerived(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()

        let iceP_returnValue = try self.opDerived(current: request.current)
        let ostr = request.current.startReplyStream()
        ostr.startEncapsulation(encoding: request.current.encoding, format: nil)
        ostr.write(iceP_returnValue)
        ostr.writePendingValues()
        ostr.endEncapsulation()
        return Ice.OutgoingResponse(ostr)
    }

    public func _iceD_throwDerived(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()

        try self.throwDerived(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}

/// UnexpectedObjectExceptionTest overview.
///
/// UnexpectedObjectExceptionTest Methods:
///
///  - op: 
extension UnexpectedObjectExceptionTest {
    public func _iceD_op(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()

        let iceP_returnValue = try self.op(current: request.current)
        let ostr = request.current.startReplyStream()
        ostr.startEncapsulation(encoding: request.current.encoding, format: nil)
        ostr.write(iceP_returnValue)
        ostr.writePendingValues()
        ostr.endEncapsulation()
        return Ice.OutgoingResponse(ostr)
    }
}
