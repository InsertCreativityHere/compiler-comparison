//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice

public typealias BSeq = [B?]

/// Helper class to read and write `BSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct BSeqHelper {
    /// Read a `BSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `BSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> BSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = BSeq(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(B.self) { p.pointee = $0 }
            }
        }
        return v
    }
    /// Read an optional `BSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `BSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> BSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `BSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `BSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: BSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `BSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `BSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: BSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public class SS3 {
    public var c1: SS1? = nil
    public var c2: SS2? = nil

    public init() {}

    public init(c1: SS1?, c2: SS2?) {
        self.c1 = c1
        self.c2 = c2
    }
}

/// An `Ice.InputStream` extension to read `SS3` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `SS3` structured value from the stream.
    ///
    /// - returns: `SS3` - The structured value read from the stream.
    func read() throws -> SS3 {
        let v = SS3()
        try self.read(SS1.self) { v.c1 = $0 }
        try self.read(SS2.self) { v.c2 = $0 }
        return v
    }

    /// Read an optional `SS3?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `SS3?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> SS3? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as SS3
    }
}

/// An `Ice.OutputStream` extension to write `SS3` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `SS3` structured value to the stream.
    ///
    /// - parameter _: `SS3` - The value to write to the stream.
    func write(_ v: SS3) {
        self.write(v.c1)
        self.write(v.c2)
    }

    /// Write an optional `SS3?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `SS3?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: SS3?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public typealias BDict = [Swift.Int32: B?]

/// Helper class to read and write `BDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct BDictHelper {
    /// Read a `BDict` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `BDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> BDict {
        let sz = try Swift.Int(istr.readSize())
        var v = BDict()
        let e = Ice.DictEntryArray<Swift.Int32, B?>(size: sz)
        for i in 0 ..< sz {
            let key: Swift.Int32 = try istr.read()
            v[key] = nil as B?
            Swift.withUnsafeMutablePointer(to: &v[key, default:nil]) {
                e.values[i] = Ice.DictEntry<Swift.Int32, B?>(key: key, value: $0)
            }
            try istr.read(B.self) { e.values[i].value.pointee = $0 }
        }
        for i in 0..<sz {
            Swift.withUnsafeMutablePointer(to: &v[e.values[i].key, default:nil]) {
                e.values[i].value = $0
            }
        }
        return v
    }
    /// Read an optional `BDict?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `BDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> BDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `BDict` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `BDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: BDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `BDict?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `BDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: BDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// :nodoc:
public class BaseException_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return BaseException.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_BaseException() -> Ice.UserExceptionTypeResolver {
        return BaseException_TypeResolver()
    }
}

open class BaseException: Ice.UserException {
    public var sbe: Swift.String = ""
    public var pb: B? = nil

    public required init() {}

    public init(sbe: Swift.String, pb: B?) {
        self.sbe = sbe
        self.pb = pb
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Test::BaseException" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: BaseException.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.sbe)
        ostr.write(self.pb)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.sbe = try istr.read()
        try istr.read(B.self) { self.pb = $0 }
        try istr.endSlice()
    }

    open override func _usesClasses() -> Swift.Bool {
        return true
    }
}

/// :nodoc:
public class DerivedException_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return DerivedException.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_DerivedException() -> Ice.UserExceptionTypeResolver {
        return DerivedException_TypeResolver()
    }
}

open class DerivedException: BaseException {
    public var sde: Swift.String = ""
    public var pd1: D1? = nil

    public required init() {
        super.init()
    }

    public init(sbe: Swift.String, pb: B?, sde: Swift.String, pd1: D1?) {
        self.sde = sde
        self.pd1 = pd1
        super.init(sbe: sbe, pb: pb)
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Test::DerivedException" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: DerivedException.ice_staticId(), compactId: -1, last: false)
        ostr.write(self.sde)
        ostr.write(self.pd1)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.sde = try istr.read()
        try istr.read(D1.self) { self.pd1 = $0 }
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }
}

public typealias PBaseSeq = [PBase?]

/// Helper class to read and write `PBaseSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct PBaseSeqHelper {
    /// Read a `PBaseSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `PBaseSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> PBaseSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = PBaseSeq(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(PBase.self) { p.pointee = $0 }
            }
        }
        return v
    }
    /// Read an optional `PBaseSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `PBaseSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> PBaseSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `PBaseSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `PBaseSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: PBaseSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `PBaseSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `PBaseSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: PBaseSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice interface`TestIntf`.
public struct TestIntfTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::TestIntf"]
    public static let staticId = "::Test::TestIntf"
}

/// TestIntfPrx overview.
///
/// TestIntfPrx Methods:
///
///  - SBaseAsObject: 
///
///  - SBaseAsObjectAsync: 
///
///  - SBaseAsSBase: 
///
///  - SBaseAsSBaseAsync: 
///
///  - SBSKnownDerivedAsSBase: 
///
///  - SBSKnownDerivedAsSBaseAsync: 
///
///  - SBSKnownDerivedAsSBSKnownDerived: 
///
///  - SBSKnownDerivedAsSBSKnownDerivedAsync: 
///
///  - SBSUnknownDerivedAsSBase: 
///
///  - SBSUnknownDerivedAsSBaseAsync: 
///
///  - SBSUnknownDerivedAsSBaseCompact: 
///
///  - SBSUnknownDerivedAsSBaseCompactAsync: 
///
///  - SUnknownAsObject: 
///
///  - SUnknownAsObjectAsync: 
///
///  - checkSUnknown: 
///
///  - checkSUnknownAsync: 
///
///  - oneElementCycle: 
///
///  - oneElementCycleAsync: 
///
///  - twoElementCycle: 
///
///  - twoElementCycleAsync: 
///
///  - D1AsB: 
///
///  - D1AsBAsync: 
///
///  - D1AsD1: 
///
///  - D1AsD1Async: 
///
///  - D2AsB: 
///
///  - D2AsBAsync: 
///
///  - paramTest1: 
///
///  - paramTest1Async: 
///
///  - paramTest2: 
///
///  - paramTest2Async: 
///
///  - paramTest3: 
///
///  - paramTest3Async: 
///
///  - paramTest4: 
///
///  - paramTest4Async: 
///
///  - returnTest1: 
///
///  - returnTest1Async: 
///
///  - returnTest2: 
///
///  - returnTest2Async: 
///
///  - returnTest3: 
///
///  - returnTest3Async: 
///
///  - sequenceTest: 
///
///  - sequenceTestAsync: 
///
///  - dictionaryTest: 
///
///  - dictionaryTestAsync: 
///
///  - exchangePBase: 
///
///  - exchangePBaseAsync: 
///
///  - PBSUnknownAsPreserved: 
///
///  - PBSUnknownAsPreservedAsync: 
///
///  - checkPBSUnknown: 
///
///  - checkPBSUnknownAsync: 
///
///  - PBSUnknownAsPreservedWithGraph: 
///
///  - PBSUnknownAsPreservedWithGraphAsync: 
///
///  - checkPBSUnknownWithGraph: 
///
///  - checkPBSUnknownWithGraphAsync: 
///
///  - PBSUnknown2AsPreservedWithGraph: 
///
///  - PBSUnknown2AsPreservedWithGraphAsync: 
///
///  - checkPBSUnknown2WithGraph: 
///
///  - checkPBSUnknown2WithGraphAsync: 
///
///  - exchangePNode: 
///
///  - exchangePNodeAsync: 
///
///  - throwBaseAsBase: 
///
///  - throwBaseAsBaseAsync: 
///
///  - throwDerivedAsBase: 
///
///  - throwDerivedAsBaseAsync: 
///
///  - throwDerivedAsDerived: 
///
///  - throwDerivedAsDerivedAsync: 
///
///  - throwUnknownDerivedAsBase: 
///
///  - throwUnknownDerivedAsBaseAsync: 
///
///  - useForward: Use of forward-declared class to verify that code is generated correctly.
///
///  - useForwardAsync: Use of forward-declared class to verify that code is generated correctly.
///
///  - shutdown: 
///
///  - shutdownAsync: 
public protocol TestIntfPrx: Ice.ObjectPrx {}

private final class TestIntfPrxI: Ice.ObjectPrxI, TestIntfPrx {
    public override class func ice_staticId() -> Swift.String {
        return TestIntfTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: TestIntfPrx.Protocol) throws -> TestIntfPrx {
    try communicator.makeProxyImpl(proxyString) as TestIntfPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `TestIntfPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `TestIntfPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: TestIntfPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> TestIntfPrx? {
    return try await TestIntfPrxI.checkedCast(prx: prx, facet: facet, context: context) as TestIntfPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `TestIntfPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `TestIntfPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: TestIntfPrx.Protocol, facet: Swift.String? = nil) -> TestIntfPrx {
    return TestIntfPrxI.uncheckedCast(prx: prx, facet: facet) as TestIntfPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `TestIntfPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: TestIntfPrx.Protocol) -> Swift.String {
    return TestIntfTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `TestIntfPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `TestIntfPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `TestIntfPrx?` - The extracted proxy
    func read(_ type: TestIntfPrx.Protocol) throws -> TestIntfPrx? {
        return try read() as TestIntfPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `TestIntfPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `TestIntfPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: TestIntfPrx.Protocol) throws -> TestIntfPrx? {
        return try read(tag: tag) as TestIntfPrxI?
    }
}

/// TestIntfPrx overview.
///
/// TestIntfPrx Methods:
///
///  - SBaseAsObject: 
///
///  - SBaseAsObjectAsync: 
///
///  - SBaseAsSBase: 
///
///  - SBaseAsSBaseAsync: 
///
///  - SBSKnownDerivedAsSBase: 
///
///  - SBSKnownDerivedAsSBaseAsync: 
///
///  - SBSKnownDerivedAsSBSKnownDerived: 
///
///  - SBSKnownDerivedAsSBSKnownDerivedAsync: 
///
///  - SBSUnknownDerivedAsSBase: 
///
///  - SBSUnknownDerivedAsSBaseAsync: 
///
///  - SBSUnknownDerivedAsSBaseCompact: 
///
///  - SBSUnknownDerivedAsSBaseCompactAsync: 
///
///  - SUnknownAsObject: 
///
///  - SUnknownAsObjectAsync: 
///
///  - checkSUnknown: 
///
///  - checkSUnknownAsync: 
///
///  - oneElementCycle: 
///
///  - oneElementCycleAsync: 
///
///  - twoElementCycle: 
///
///  - twoElementCycleAsync: 
///
///  - D1AsB: 
///
///  - D1AsBAsync: 
///
///  - D1AsD1: 
///
///  - D1AsD1Async: 
///
///  - D2AsB: 
///
///  - D2AsBAsync: 
///
///  - paramTest1: 
///
///  - paramTest1Async: 
///
///  - paramTest2: 
///
///  - paramTest2Async: 
///
///  - paramTest3: 
///
///  - paramTest3Async: 
///
///  - paramTest4: 
///
///  - paramTest4Async: 
///
///  - returnTest1: 
///
///  - returnTest1Async: 
///
///  - returnTest2: 
///
///  - returnTest2Async: 
///
///  - returnTest3: 
///
///  - returnTest3Async: 
///
///  - sequenceTest: 
///
///  - sequenceTestAsync: 
///
///  - dictionaryTest: 
///
///  - dictionaryTestAsync: 
///
///  - exchangePBase: 
///
///  - exchangePBaseAsync: 
///
///  - PBSUnknownAsPreserved: 
///
///  - PBSUnknownAsPreservedAsync: 
///
///  - checkPBSUnknown: 
///
///  - checkPBSUnknownAsync: 
///
///  - PBSUnknownAsPreservedWithGraph: 
///
///  - PBSUnknownAsPreservedWithGraphAsync: 
///
///  - checkPBSUnknownWithGraph: 
///
///  - checkPBSUnknownWithGraphAsync: 
///
///  - PBSUnknown2AsPreservedWithGraph: 
///
///  - PBSUnknown2AsPreservedWithGraphAsync: 
///
///  - checkPBSUnknown2WithGraph: 
///
///  - checkPBSUnknown2WithGraphAsync: 
///
///  - exchangePNode: 
///
///  - exchangePNodeAsync: 
///
///  - throwBaseAsBase: 
///
///  - throwBaseAsBaseAsync: 
///
///  - throwDerivedAsBase: 
///
///  - throwDerivedAsBaseAsync: 
///
///  - throwDerivedAsDerived: 
///
///  - throwDerivedAsDerivedAsync: 
///
///  - throwUnknownDerivedAsBase: 
///
///  - throwUnknownDerivedAsBaseAsync: 
///
///  - useForward: Use of forward-declared class to verify that code is generated correctly.
///
///  - useForwardAsync: Use of forward-declared class to verify that code is generated correctly.
///
///  - shutdown: 
///
///  - shutdownAsync: 
public extension TestIntfPrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.Value?`
    func SBaseAsObject(context: Ice.Context? = nil) async throws -> Ice.Value? {
        return try await _impl._invoke(operation: "SBaseAsObject",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       read: { istr in
                                           var iceP_returnValue: Ice.Value?
                                           try istr.read() { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `SBase?`
    func SBaseAsSBase(context: Ice.Context? = nil) async throws -> SBase? {
        return try await _impl._invoke(operation: "SBaseAsSBase",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       read: { istr in
                                           var iceP_returnValue: SBase?
                                           try istr.read(SBase.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `SBase?`
    func SBSKnownDerivedAsSBase(context: Ice.Context? = nil) async throws -> SBase? {
        return try await _impl._invoke(operation: "SBSKnownDerivedAsSBase",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       read: { istr in
                                           var iceP_returnValue: SBase?
                                           try istr.read(SBase.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `SBSKnownDerived?`
    func SBSKnownDerivedAsSBSKnownDerived(context: Ice.Context? = nil) async throws -> SBSKnownDerived? {
        return try await _impl._invoke(operation: "SBSKnownDerivedAsSBSKnownDerived",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       read: { istr in
                                           var iceP_returnValue: SBSKnownDerived?
                                           try istr.read(SBSKnownDerived.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `SBase?`
    func SBSUnknownDerivedAsSBase(context: Ice.Context? = nil) async throws -> SBase? {
        return try await _impl._invoke(operation: "SBSUnknownDerivedAsSBase",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       read: { istr in
                                           var iceP_returnValue: SBase?
                                           try istr.read(SBase.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `SBase?`
    func SBSUnknownDerivedAsSBaseCompact(context: Ice.Context? = nil) async throws -> SBase? {
        return try await _impl._invoke(operation: "SBSUnknownDerivedAsSBaseCompact",
                                       mode: .Normal,
                                       format: .CompactFormat,
                                       read: { istr in
                                           var iceP_returnValue: SBase?
                                           try istr.read(SBase.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.Value?`
    func SUnknownAsObject(context: Ice.Context? = nil) async throws -> Ice.Value? {
        return try await _impl._invoke(operation: "SUnknownAsObject",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       read: { istr in
                                           var iceP_returnValue: Ice.Value?
                                           try istr.read() { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    ///
    /// - parameter _: `Ice.Value?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func checkSUnknown(_ iceP_o: Ice.Value?, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "checkSUnknown",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       write: { ostr in
                                           ostr.write(iceP_o)
                                           ostr.writePendingValues()
                                       },
                                       context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `B?`
    func oneElementCycle(context: Ice.Context? = nil) async throws -> B? {
        return try await _impl._invoke(operation: "oneElementCycle",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       read: { istr in
                                           var iceP_returnValue: B?
                                           try istr.read(B.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `B?`
    func twoElementCycle(context: Ice.Context? = nil) async throws -> B? {
        return try await _impl._invoke(operation: "twoElementCycle",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       read: { istr in
                                           var iceP_returnValue: B?
                                           try istr.read(B.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `B?`
    func D1AsB(context: Ice.Context? = nil) async throws -> B? {
        return try await _impl._invoke(operation: "D1AsB",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       read: { istr in
                                           var iceP_returnValue: B?
                                           try istr.read(B.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `D1?`
    func D1AsD1(context: Ice.Context? = nil) async throws -> D1? {
        return try await _impl._invoke(operation: "D1AsD1",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       read: { istr in
                                           var iceP_returnValue: D1?
                                           try istr.read(D1.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `B?`
    func D2AsB(context: Ice.Context? = nil) async throws -> B? {
        return try await _impl._invoke(operation: "D2AsB",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       read: { istr in
                                           var iceP_returnValue: B?
                                           try istr.read(B.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(p1: B?, p2: B?)`:
    ///
    ///   - p1: `B?`
    ///
    ///   - p2: `B?`
    func paramTest1(context: Ice.Context? = nil) async throws -> (p1: B?, p2: B?) {
        return try await _impl._invoke(operation: "paramTest1",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       read: { istr in
                                           var iceP_p1: B?
                                           try istr.read(B.self) { iceP_p1 = $0 }
                                           var iceP_p2: B?
                                           try istr.read(B.self) { iceP_p2 = $0 }
                                           try istr.readPendingValues()
                                           return (iceP_p1, iceP_p2)
                                       },
                                       context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(p2: B?, p1: B?)`:
    ///
    ///   - p2: `B?`
    ///
    ///   - p1: `B?`
    func paramTest2(context: Ice.Context? = nil) async throws -> (p2: B?, p1: B?) {
        return try await _impl._invoke(operation: "paramTest2",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       read: { istr in
                                           var iceP_p2: B?
                                           try istr.read(B.self) { iceP_p2 = $0 }
                                           var iceP_p1: B?
                                           try istr.read(B.self) { iceP_p1 = $0 }
                                           try istr.readPendingValues()
                                           return (iceP_p2, iceP_p1)
                                       },
                                       context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: B?, p1: B?, p2: B?)`:
    ///
    ///   - returnValue: `B?`
    ///
    ///   - p1: `B?`
    ///
    ///   - p2: `B?`
    func paramTest3(context: Ice.Context? = nil) async throws -> (returnValue: B?, p1: B?, p2: B?) {
        return try await _impl._invoke(operation: "paramTest3",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       read: { istr in
                                           var iceP_p1: B?
                                           try istr.read(B.self) { iceP_p1 = $0 }
                                           var iceP_p2: B?
                                           try istr.read(B.self) { iceP_p2 = $0 }
                                           var iceP_returnValue: B?
                                           try istr.read(B.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_p1, iceP_p2)
                                       },
                                       context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: B?, p: B?)`:
    ///
    ///   - returnValue: `B?`
    ///
    ///   - p: `B?`
    func paramTest4(context: Ice.Context? = nil) async throws -> (returnValue: B?, p: B?) {
        return try await _impl._invoke(operation: "paramTest4",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       read: { istr in
                                           var iceP_p: B?
                                           try istr.read(B.self) { iceP_p = $0 }
                                           var iceP_returnValue: B?
                                           try istr.read(B.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_p)
                                       },
                                       context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: B?, p1: B?, p2: B?)`:
    ///
    ///   - returnValue: `B?`
    ///
    ///   - p1: `B?`
    ///
    ///   - p2: `B?`
    func returnTest1(context: Ice.Context? = nil) async throws -> (returnValue: B?, p1: B?, p2: B?) {
        return try await _impl._invoke(operation: "returnTest1",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       read: { istr in
                                           var iceP_p1: B?
                                           try istr.read(B.self) { iceP_p1 = $0 }
                                           var iceP_p2: B?
                                           try istr.read(B.self) { iceP_p2 = $0 }
                                           var iceP_returnValue: B?
                                           try istr.read(B.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_p1, iceP_p2)
                                       },
                                       context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: B?, p2: B?, p1: B?)`:
    ///
    ///   - returnValue: `B?`
    ///
    ///   - p2: `B?`
    ///
    ///   - p1: `B?`
    func returnTest2(context: Ice.Context? = nil) async throws -> (returnValue: B?, p2: B?, p1: B?) {
        return try await _impl._invoke(operation: "returnTest2",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       read: { istr in
                                           var iceP_p2: B?
                                           try istr.read(B.self) { iceP_p2 = $0 }
                                           var iceP_p1: B?
                                           try istr.read(B.self) { iceP_p1 = $0 }
                                           var iceP_returnValue: B?
                                           try istr.read(B.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_p2, iceP_p1)
                                       },
                                       context: context)
    }

    ///
    /// - parameter p1: `B?`
    ///
    /// - parameter p2: `B?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `B?`
    func returnTest3(p1 iceP_p1: B?, p2 iceP_p2: B?, context: Ice.Context? = nil) async throws -> B? {
        return try await _impl._invoke(operation: "returnTest3",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       write: { ostr in
                                           ostr.write(iceP_p1)
                                           ostr.write(iceP_p2)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           var iceP_returnValue: B?
                                           try istr.read(B.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    ///
    /// - parameter p1: `SS1?`
    ///
    /// - parameter p2: `SS2?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `SS3`
    func sequenceTest(p1 iceP_p1: SS1?, p2 iceP_p2: SS2?, context: Ice.Context? = nil) async throws -> SS3 {
        return try await _impl._invoke(operation: "sequenceTest",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       write: { ostr in
                                           ostr.write(iceP_p1)
                                           ostr.write(iceP_p2)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           let iceP_returnValue: SS3 = try istr.read()
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    ///
    /// - parameter _: `BDict`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: BDict, bout: BDict)`:
    ///
    ///   - returnValue: `BDict`
    ///
    ///   - bout: `BDict`
    func dictionaryTest(_ iceP_bin: BDict, context: Ice.Context? = nil) async throws -> (returnValue: BDict, bout: BDict) {
        return try await _impl._invoke(operation: "dictionaryTest",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       write: { ostr in
                                           BDictHelper.write(to: ostr, value: iceP_bin)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           let iceP_bout: BDict = try BDictHelper.read(from: istr)
                                           let iceP_returnValue: BDict = try BDictHelper.read(from: istr)
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_bout)
                                       },
                                       context: context)
    }

    ///
    /// - parameter _: `PBase?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `PBase?`
    func exchangePBase(_ iceP_pb: PBase?, context: Ice.Context? = nil) async throws -> PBase? {
        return try await _impl._invoke(operation: "exchangePBase",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       write: { ostr in
                                           ostr.write(iceP_pb)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           var iceP_returnValue: PBase?
                                           try istr.read(PBase.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Preserved?`
    func PBSUnknownAsPreserved(context: Ice.Context? = nil) async throws -> Preserved? {
        return try await _impl._invoke(operation: "PBSUnknownAsPreserved",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       read: { istr in
                                           var iceP_returnValue: Preserved?
                                           try istr.read(Preserved.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    ///
    /// - parameter _: `Preserved?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func checkPBSUnknown(_ iceP_p: Preserved?, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "checkPBSUnknown",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       write: { ostr in
                                           ostr.write(iceP_p)
                                           ostr.writePendingValues()
                                       },
                                       context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Preserved?`
    func PBSUnknownAsPreservedWithGraph(context: Ice.Context? = nil) async throws -> Preserved? {
        return try await _impl._invoke(operation: "PBSUnknownAsPreservedWithGraph",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       read: { istr in
                                           var iceP_returnValue: Preserved?
                                           try istr.read(Preserved.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    ///
    /// - parameter _: `Preserved?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func checkPBSUnknownWithGraph(_ iceP_p: Preserved?, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "checkPBSUnknownWithGraph",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       write: { ostr in
                                           ostr.write(iceP_p)
                                           ostr.writePendingValues()
                                       },
                                       context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Preserved?`
    func PBSUnknown2AsPreservedWithGraph(context: Ice.Context? = nil) async throws -> Preserved? {
        return try await _impl._invoke(operation: "PBSUnknown2AsPreservedWithGraph",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       read: { istr in
                                           var iceP_returnValue: Preserved?
                                           try istr.read(Preserved.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    ///
    /// - parameter _: `Preserved?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func checkPBSUnknown2WithGraph(_ iceP_p: Preserved?, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "checkPBSUnknown2WithGraph",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       write: { ostr in
                                           ostr.write(iceP_p)
                                           ostr.writePendingValues()
                                       },
                                       context: context)
    }

    ///
    /// - parameter _: `PNode?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `PNode?`
    func exchangePNode(_ iceP_pn: PNode?, context: Ice.Context? = nil) async throws -> PNode? {
        return try await _impl._invoke(operation: "exchangePNode",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       write: { ostr in
                                           ostr.write(iceP_pn)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           var iceP_returnValue: PNode?
                                           try istr.read(PNode.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func throwBaseAsBase(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "throwBaseAsBase",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as BaseException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func throwDerivedAsBase(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "throwDerivedAsBase",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as BaseException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func throwDerivedAsDerived(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "throwDerivedAsDerived",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as DerivedException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func throwUnknownDerivedAsBase(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "throwUnknownDerivedAsBase",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as BaseException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    /// Use of forward-declared class to verify that code is generated correctly.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Forward?`
    func useForward(context: Ice.Context? = nil) async throws -> Forward? {
        return try await _impl._invoke(operation: "useForward",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       read: { istr in
                                           var iceP_f: Forward?
                                           try istr.read(Forward.self) { iceP_f = $0 }
                                           try istr.readPendingValues()
                                           return iceP_f
                                       },
                                       context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func shutdown(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "shutdown",
                                       mode: .Normal,
                                       format: .SlicedFormat,
                                       context: context)
    }
}

/// :nodoc:
public class SBase_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return SBase.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_SBase() -> Ice.ValueTypeResolver {
        return SBase_TypeResolver()
    }
}

open class SBase: Ice.Value {
    public var sb: Swift.String = ""

    public required init() {}

    public init(sb: Swift.String) {
        self.sb = sb
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::SBase" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.sb = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: SBase.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.sb)
        ostr.endSlice()
    }
}

/// :nodoc:
public class SBSKnownDerived_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return SBSKnownDerived.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_SBSKnownDerived() -> Ice.ValueTypeResolver {
        return SBSKnownDerived_TypeResolver()
    }
}

open class SBSKnownDerived: SBase {
    public var sbskd: Swift.String = ""

    public required init() {
        super.init()
    }

    public init(sb: Swift.String, sbskd: Swift.String) {
        self.sbskd = sbskd
        super.init(sb: sb)
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::SBSKnownDerived" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.sbskd = try istr.read()
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: SBSKnownDerived.ice_staticId(), compactId: -1, last: false)
        ostr.write(self.sbskd)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}

/// :nodoc:
public class B_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return B.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_B() -> Ice.ValueTypeResolver {
        return B_TypeResolver()
    }
}

open class B: Ice.Value {
    public var sb: Swift.String = ""
    public var pb: B? = nil

    public required init() {}

    public init(sb: Swift.String, pb: B?) {
        self.sb = sb
        self.pb = pb
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::B" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.sb = try istr.read()
        try istr.read(B.self) { self.pb = $0 }
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: B.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.sb)
        ostr.write(self.pb)
        ostr.endSlice()
    }
}

/// :nodoc:
public class D1_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return D1.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_D1() -> Ice.ValueTypeResolver {
        return D1_TypeResolver()
    }
}

open class D1: B {
    public var sd1: Swift.String = ""
    public var pd1: B? = nil

    public required init() {
        super.init()
    }

    public init(sb: Swift.String, pb: B?, sd1: Swift.String, pd1: B?) {
        self.sd1 = sd1
        self.pd1 = pd1
        super.init(sb: sb, pb: pb)
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::D1" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.sd1 = try istr.read()
        try istr.read(B.self) { self.pd1 = $0 }
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: D1.ice_staticId(), compactId: -1, last: false)
        ostr.write(self.sd1)
        ostr.write(self.pd1)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}

/// :nodoc:
public class SS1_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return SS1.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_SS1() -> Ice.ValueTypeResolver {
        return SS1_TypeResolver()
    }
}

open class SS1: Ice.Value {
    public var s: BSeq = BSeq()

    public required init() {}

    public init(s: BSeq) {
        self.s = s
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::SS1" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.s = try BSeqHelper.read(from: istr)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: SS1.ice_staticId(), compactId: -1, last: true)
        BSeqHelper.write(to: ostr, value: self.s)
        ostr.endSlice()
    }
}

/// :nodoc:
public class SS2_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return SS2.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_SS2() -> Ice.ValueTypeResolver {
        return SS2_TypeResolver()
    }
}

open class SS2: Ice.Value {
    public var s: BSeq = BSeq()

    public required init() {}

    public init(s: BSeq) {
        self.s = s
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::SS2" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.s = try BSeqHelper.read(from: istr)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: SS2.ice_staticId(), compactId: -1, last: true)
        BSeqHelper.write(to: ostr, value: self.s)
        ostr.endSlice()
    }
}

/// :nodoc:
public class PBase_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return PBase.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_PBase() -> Ice.ValueTypeResolver {
        return PBase_TypeResolver()
    }
}

open class PBase: Ice.Value {
    public var pi: Swift.Int32 = 0

    public required init() {}

    public init(pi: Swift.Int32) {
        self.pi = pi
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::PBase" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.pi = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: PBase.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.pi)
        ostr.endSlice()
    }
}

/// :nodoc:
public class Preserved_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Preserved.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Preserved() -> Ice.ValueTypeResolver {
        return Preserved_TypeResolver()
    }
}

open class Preserved: PBase {
    public var ps: Swift.String = ""

    public required init() {
        super.init()
    }

    public init(pi: Swift.Int32, ps: Swift.String) {
        self.ps = ps
        super.init(pi: pi)
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::Preserved" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.ps = try istr.read()
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Preserved.ice_staticId(), compactId: -1, last: false)
        ostr.write(self.ps)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}

/// :nodoc:
public class PDerived_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return PDerived.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_PDerived() -> Ice.ValueTypeResolver {
        return PDerived_TypeResolver()
    }
}

open class PDerived: Preserved {
    public var pb: PBase? = nil

    public required init() {
        super.init()
    }

    public init(pi: Swift.Int32, ps: Swift.String, pb: PBase?) {
        self.pb = pb
        super.init(pi: pi, ps: ps)
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::PDerived" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(PBase.self) { self.pb = $0 }
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: PDerived.ice_staticId(), compactId: -1, last: false)
        ostr.write(self.pb)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}

/// :nodoc:
public class CompactPDerived_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return CompactPDerived.self
    }
}

public extension Ice.TypeIdResolver {
    @objc static func TypeId_56() -> Swift.String {
        return "::Test::CompactPDerived"
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_CompactPDerived() -> Ice.ValueTypeResolver {
        return CompactPDerived_TypeResolver()
    }
}

open class CompactPDerived: Preserved {
    public var pb: PBase? = nil

    public required init() {
        super.init()
    }

    public init(pi: Swift.Int32, ps: Swift.String, pb: PBase?) {
        self.pb = pb
        super.init(pi: pi, ps: ps)
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::CompactPDerived" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(PBase.self) { self.pb = $0 }
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CompactPDerived.ice_staticId(), compactId: 56, last: false)
        ostr.write(self.pb)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}

/// :nodoc:
public class PNode_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return PNode.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_PNode() -> Ice.ValueTypeResolver {
        return PNode_TypeResolver()
    }
}

open class PNode: Ice.Value {
    public var next: PNode? = nil

    public required init() {}

    public init(next: PNode?) {
        self.next = next
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::PNode" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(PNode.self) { self.next = $0 }
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: PNode.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.next)
        ostr.endSlice()
    }
}

/// :nodoc:
public class Hidden_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Hidden.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Hidden() -> Ice.ValueTypeResolver {
        return Hidden_TypeResolver()
    }
}

open class Hidden: Ice.Value {
    public var f: Forward? = nil

    public required init() {}

    public init(f: Forward?) {
        self.f = f
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::Hidden" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(Forward.self) { self.f = $0 }
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Hidden.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.f)
        ostr.endSlice()
    }
}

/// :nodoc:
public class Forward_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Forward.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Forward() -> Ice.ValueTypeResolver {
        return Forward_TypeResolver()
    }
}

open class Forward: Ice.Value {
    public var h: Hidden? = nil

    public required init() {}

    public init(h: Hidden?) {
        self.h = h
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::Forward" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(Hidden.self) { self.h = $0 }
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Forward.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.h)
        ostr.endSlice()
    }
}


/// Dispatcher for `TestIntf` servants.
public struct TestIntfDisp: Ice.Dispatcher {
    public let servant: TestIntf
    private static let defaultObject = Ice.ObjectI<TestIntfTraits>()

    public init(_ servant: TestIntf) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "D1AsB":
            try await servant._iceD_D1AsB(request)
        case "D1AsD1":
            try await servant._iceD_D1AsD1(request)
        case "D2AsB":
            try await servant._iceD_D2AsB(request)
        case "PBSUnknown2AsPreservedWithGraph":
            try await servant._iceD_PBSUnknown2AsPreservedWithGraph(request)
        case "PBSUnknownAsPreserved":
            try await servant._iceD_PBSUnknownAsPreserved(request)
        case "PBSUnknownAsPreservedWithGraph":
            try await servant._iceD_PBSUnknownAsPreservedWithGraph(request)
        case "SBSKnownDerivedAsSBSKnownDerived":
            try await servant._iceD_SBSKnownDerivedAsSBSKnownDerived(request)
        case "SBSKnownDerivedAsSBase":
            try await servant._iceD_SBSKnownDerivedAsSBase(request)
        case "SBSUnknownDerivedAsSBase":
            try await servant._iceD_SBSUnknownDerivedAsSBase(request)
        case "SBSUnknownDerivedAsSBaseCompact":
            try await servant._iceD_SBSUnknownDerivedAsSBaseCompact(request)
        case "SBaseAsObject":
            try await servant._iceD_SBaseAsObject(request)
        case "SBaseAsSBase":
            try await servant._iceD_SBaseAsSBase(request)
        case "SUnknownAsObject":
            try await servant._iceD_SUnknownAsObject(request)
        case "checkPBSUnknown":
            try await servant._iceD_checkPBSUnknown(request)
        case "checkPBSUnknown2WithGraph":
            try await servant._iceD_checkPBSUnknown2WithGraph(request)
        case "checkPBSUnknownWithGraph":
            try await servant._iceD_checkPBSUnknownWithGraph(request)
        case "checkSUnknown":
            try await servant._iceD_checkSUnknown(request)
        case "dictionaryTest":
            try await servant._iceD_dictionaryTest(request)
        case "exchangePBase":
            try await servant._iceD_exchangePBase(request)
        case "exchangePNode":
            try await servant._iceD_exchangePNode(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? TestIntfDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? TestIntfDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? TestIntfDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? TestIntfDisp.defaultObject)._iceD_ice_ping(request)
        case "oneElementCycle":
            try await servant._iceD_oneElementCycle(request)
        case "paramTest1":
            try await servant._iceD_paramTest1(request)
        case "paramTest2":
            try await servant._iceD_paramTest2(request)
        case "paramTest3":
            try await servant._iceD_paramTest3(request)
        case "paramTest4":
            try await servant._iceD_paramTest4(request)
        case "returnTest1":
            try await servant._iceD_returnTest1(request)
        case "returnTest2":
            try await servant._iceD_returnTest2(request)
        case "returnTest3":
            try await servant._iceD_returnTest3(request)
        case "sequenceTest":
            try await servant._iceD_sequenceTest(request)
        case "shutdown":
            try await servant._iceD_shutdown(request)
        case "throwBaseAsBase":
            try await servant._iceD_throwBaseAsBase(request)
        case "throwDerivedAsBase":
            try await servant._iceD_throwDerivedAsBase(request)
        case "throwDerivedAsDerived":
            try await servant._iceD_throwDerivedAsDerived(request)
        case "throwUnknownDerivedAsBase":
            try await servant._iceD_throwUnknownDerivedAsBase(request)
        case "twoElementCycle":
            try await servant._iceD_twoElementCycle(request)
        case "useForward":
            try await servant._iceD_useForward(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol TestIntf {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.Value?`
    func SBaseAsObject(current: Ice.Current) async throws -> Ice.Value?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `SBase?`
    func SBaseAsSBase(current: Ice.Current) async throws -> SBase?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `SBase?`
    func SBSKnownDerivedAsSBase(current: Ice.Current) async throws -> SBase?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `SBSKnownDerived?`
    func SBSKnownDerivedAsSBSKnownDerived(current: Ice.Current) async throws -> SBSKnownDerived?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `SBase?`
    func SBSUnknownDerivedAsSBase(current: Ice.Current) async throws -> SBase?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `SBase?`
    func SBSUnknownDerivedAsSBaseCompact(current: Ice.Current) async throws -> SBase?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.Value?`
    func SUnknownAsObject(current: Ice.Current) async throws -> Ice.Value?

    ///
    /// - parameter o: `Ice.Value?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func checkSUnknown(o: Ice.Value?, current: Ice.Current) async throws

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `B?`
    func oneElementCycle(current: Ice.Current) async throws -> B?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `B?`
    func twoElementCycle(current: Ice.Current) async throws -> B?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `B?`
    func D1AsB(current: Ice.Current) async throws -> B?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `D1?`
    func D1AsD1(current: Ice.Current) async throws -> D1?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `B?`
    func D2AsB(current: Ice.Current) async throws -> B?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(p1: B?, p2: B?)`:
    ///
    ///   - p1: `B?`
    ///
    ///   - p2: `B?`
    func paramTest1(current: Ice.Current) async throws -> (p1: B?, p2: B?)

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(p2: B?, p1: B?)`:
    ///
    ///   - p2: `B?`
    ///
    ///   - p1: `B?`
    func paramTest2(current: Ice.Current) async throws -> (p2: B?, p1: B?)

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: B?, p1: B?, p2: B?)`:
    ///
    ///   - returnValue: `B?`
    ///
    ///   - p1: `B?`
    ///
    ///   - p2: `B?`
    func paramTest3(current: Ice.Current) async throws -> (returnValue: B?, p1: B?, p2: B?)

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: B?, p: B?)`:
    ///
    ///   - returnValue: `B?`
    ///
    ///   - p: `B?`
    func paramTest4(current: Ice.Current) async throws -> (returnValue: B?, p: B?)

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: B?, p1: B?, p2: B?)`:
    ///
    ///   - returnValue: `B?`
    ///
    ///   - p1: `B?`
    ///
    ///   - p2: `B?`
    func returnTest1(current: Ice.Current) async throws -> (returnValue: B?, p1: B?, p2: B?)

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: B?, p2: B?, p1: B?)`:
    ///
    ///   - returnValue: `B?`
    ///
    ///   - p2: `B?`
    ///
    ///   - p1: `B?`
    func returnTest2(current: Ice.Current) async throws -> (returnValue: B?, p2: B?, p1: B?)

    ///
    /// - parameter p1: `B?`
    ///
    /// - parameter p2: `B?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `B?`
    func returnTest3(p1: B?, p2: B?, current: Ice.Current) async throws -> B?

    ///
    /// - parameter p1: `SS1?`
    ///
    /// - parameter p2: `SS2?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `SS3`
    func sequenceTest(p1: SS1?, p2: SS2?, current: Ice.Current) async throws -> SS3

    ///
    /// - parameter bin: `BDict`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: BDict, bout: BDict)`:
    ///
    ///   - returnValue: `BDict`
    ///
    ///   - bout: `BDict`
    func dictionaryTest(bin: BDict, current: Ice.Current) async throws -> (returnValue: BDict, bout: BDict)

    ///
    /// - parameter pb: `PBase?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `PBase?`
    func exchangePBase(pb: PBase?, current: Ice.Current) async throws -> PBase?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Preserved?`
    func PBSUnknownAsPreserved(current: Ice.Current) async throws -> Preserved?

    ///
    /// - parameter p: `Preserved?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func checkPBSUnknown(p: Preserved?, current: Ice.Current) async throws

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Preserved?`
    func PBSUnknownAsPreservedWithGraph(current: Ice.Current) async throws -> Preserved?

    ///
    /// - parameter p: `Preserved?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func checkPBSUnknownWithGraph(p: Preserved?, current: Ice.Current) async throws

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Preserved?`
    func PBSUnknown2AsPreservedWithGraph(current: Ice.Current) async throws -> Preserved?

    ///
    /// - parameter p: `Preserved?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func checkPBSUnknown2WithGraph(p: Preserved?, current: Ice.Current) async throws

    ///
    /// - parameter pn: `PNode?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `PNode?`
    func exchangePNode(pn: PNode?, current: Ice.Current) async throws -> PNode?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func throwBaseAsBase(current: Ice.Current) async throws

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func throwDerivedAsBase(current: Ice.Current) async throws

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func throwDerivedAsDerived(current: Ice.Current) async throws

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func throwUnknownDerivedAsBase(current: Ice.Current) async throws

    /// Use of forward-declared class to verify that code is generated correctly.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Forward?`
    func useForward(current: Ice.Current) async throws -> Forward?

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func shutdown(current: Ice.Current) async throws
}

/// TestIntf overview.
///
/// TestIntf Methods:
///
///  - SBaseAsObject: 
///
///  - SBaseAsSBase: 
///
///  - SBSKnownDerivedAsSBase: 
///
///  - SBSKnownDerivedAsSBSKnownDerived: 
///
///  - SBSUnknownDerivedAsSBase: 
///
///  - SBSUnknownDerivedAsSBaseCompact: 
///
///  - SUnknownAsObject: 
///
///  - checkSUnknown: 
///
///  - oneElementCycle: 
///
///  - twoElementCycle: 
///
///  - D1AsB: 
///
///  - D1AsD1: 
///
///  - D2AsB: 
///
///  - paramTest1: 
///
///  - paramTest2: 
///
///  - paramTest3: 
///
///  - paramTest4: 
///
///  - returnTest1: 
///
///  - returnTest2: 
///
///  - returnTest3: 
///
///  - sequenceTest: 
///
///  - dictionaryTest: 
///
///  - exchangePBase: 
///
///  - PBSUnknownAsPreserved: 
///
///  - checkPBSUnknown: 
///
///  - PBSUnknownAsPreservedWithGraph: 
///
///  - checkPBSUnknownWithGraph: 
///
///  - PBSUnknown2AsPreservedWithGraph: 
///
///  - checkPBSUnknown2WithGraph: 
///
///  - exchangePNode: 
///
///  - throwBaseAsBase: 
///
///  - throwDerivedAsBase: 
///
///  - throwDerivedAsDerived: 
///
///  - throwUnknownDerivedAsBase: 
///
///  - useForward: Use of forward-declared class to verify that code is generated correctly.
///
///  - shutdown: 
extension TestIntf {
    public func _iceD_SBaseAsObject(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.SBaseAsObject(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: .SlicedFormat) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_SBaseAsSBase(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.SBaseAsSBase(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: .SlicedFormat) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_SBSKnownDerivedAsSBase(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.SBSKnownDerivedAsSBase(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: .SlicedFormat) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_SBSKnownDerivedAsSBSKnownDerived(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.SBSKnownDerivedAsSBSKnownDerived(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: .SlicedFormat) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_SBSUnknownDerivedAsSBase(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.SBSUnknownDerivedAsSBase(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: .SlicedFormat) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_SBSUnknownDerivedAsSBaseCompact(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.SBSUnknownDerivedAsSBaseCompact(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: .CompactFormat) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_SUnknownAsObject(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.SUnknownAsObject(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: .SlicedFormat) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_checkSUnknown(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_o: Ice.Value?
        try istr.read() { iceP_o = $0 }
        try istr.readPendingValues()
        try await self.checkSUnknown(o: iceP_o, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_oneElementCycle(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.oneElementCycle(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: .SlicedFormat) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_twoElementCycle(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.twoElementCycle(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: .SlicedFormat) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_D1AsB(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.D1AsB(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: .SlicedFormat) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_D1AsD1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.D1AsD1(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: .SlicedFormat) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_D2AsB(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.D2AsB(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: .SlicedFormat) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_paramTest1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.paramTest1(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: .SlicedFormat) { ostr, value in 
            let (iceP_p1, iceP_p2) = value
            ostr.write(iceP_p1)
            ostr.write(iceP_p2)
            ostr.writePendingValues()
        }
    }

    public func _iceD_paramTest2(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.paramTest2(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: .SlicedFormat) { ostr, value in 
            let (iceP_p2, iceP_p1) = value
            ostr.write(iceP_p2)
            ostr.write(iceP_p1)
            ostr.writePendingValues()
        }
    }

    public func _iceD_paramTest3(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.paramTest3(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: .SlicedFormat) { ostr, value in 
            let (iceP_returnValue, iceP_p1, iceP_p2) = value
            ostr.write(iceP_p1)
            ostr.write(iceP_p2)
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_paramTest4(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.paramTest4(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: .SlicedFormat) { ostr, value in 
            let (iceP_returnValue, iceP_p) = value
            ostr.write(iceP_p)
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_returnTest1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.returnTest1(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: .SlicedFormat) { ostr, value in 
            let (iceP_returnValue, iceP_p1, iceP_p2) = value
            ostr.write(iceP_p1)
            ostr.write(iceP_p2)
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_returnTest2(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.returnTest2(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: .SlicedFormat) { ostr, value in 
            let (iceP_returnValue, iceP_p2, iceP_p1) = value
            ostr.write(iceP_p2)
            ostr.write(iceP_p1)
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_returnTest3(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_p1: B?
        try istr.read(B.self) { iceP_p1 = $0 }
        var iceP_p2: B?
        try istr.read(B.self) { iceP_p2 = $0 }
        try istr.readPendingValues()
        let result = try await self.returnTest3(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: .SlicedFormat) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_sequenceTest(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_p1: SS1?
        try istr.read(SS1.self) { iceP_p1 = $0 }
        var iceP_p2: SS2?
        try istr.read(SS2.self) { iceP_p2 = $0 }
        try istr.readPendingValues()
        let result = try await self.sequenceTest(p1: iceP_p1, p2: iceP_p2, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: .SlicedFormat) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_dictionaryTest(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_bin: BDict = try BDictHelper.read(from: istr)
        try istr.readPendingValues()
        let result = try await self.dictionaryTest(bin: iceP_bin, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: .SlicedFormat) { ostr, value in 
            let (iceP_returnValue, iceP_bout) = value
            BDictHelper.write(to: ostr, value: iceP_bout)
            BDictHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_exchangePBase(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_pb: PBase?
        try istr.read(PBase.self) { iceP_pb = $0 }
        try istr.readPendingValues()
        let result = try await self.exchangePBase(pb: iceP_pb, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: .SlicedFormat) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_PBSUnknownAsPreserved(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.PBSUnknownAsPreserved(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: .SlicedFormat) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_checkPBSUnknown(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_p: Preserved?
        try istr.read(Preserved.self) { iceP_p = $0 }
        try istr.readPendingValues()
        try await self.checkPBSUnknown(p: iceP_p, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_PBSUnknownAsPreservedWithGraph(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.PBSUnknownAsPreservedWithGraph(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: .SlicedFormat) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_checkPBSUnknownWithGraph(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_p: Preserved?
        try istr.read(Preserved.self) { iceP_p = $0 }
        try istr.readPendingValues()
        try await self.checkPBSUnknownWithGraph(p: iceP_p, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_PBSUnknown2AsPreservedWithGraph(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.PBSUnknown2AsPreservedWithGraph(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: .SlicedFormat) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_checkPBSUnknown2WithGraph(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_p: Preserved?
        try istr.read(Preserved.self) { iceP_p = $0 }
        try istr.readPendingValues()
        try await self.checkPBSUnknown2WithGraph(p: iceP_p, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_exchangePNode(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_pn: PNode?
        try istr.read(PNode.self) { iceP_pn = $0 }
        try istr.readPendingValues()
        let result = try await self.exchangePNode(pn: iceP_pn, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: .SlicedFormat) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_throwBaseAsBase(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.throwBaseAsBase(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_throwDerivedAsBase(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.throwDerivedAsBase(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_throwDerivedAsDerived(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.throwDerivedAsDerived(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_throwUnknownDerivedAsBase(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.throwUnknownDerivedAsBase(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_useForward(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.useForward(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: .SlicedFormat) { ostr, value in 
            let iceP_f = value
            ostr.write(iceP_f)
            ostr.writePendingValues()
        }
    }

    public func _iceD_shutdown(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.shutdown(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}
