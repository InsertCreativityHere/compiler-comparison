//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice
import PromiseKit

/// Traits for Slice class `C`.
public struct CTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::C"]
    public static let staticId = "::Test::C"
}

public typealias CSeq = [C?]

/// Helper class to read and write `CSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct CSeqHelper {
    /// Read a `CSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `CSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> CSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = CSeq(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(C.self) { p.pointee = $0 }
            }
        }
        return v
    }
    /// Read an optional `CSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `CSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> CSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `CSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `CSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: CSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `CSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `CSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: CSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias CDict = [Swift.Int32: C?]

/// Helper class to read and write `CDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct CDictHelper {
    /// Read a `CDict` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `CDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> CDict {
        let sz = try Swift.Int(istr.readSize())
        var v = CDict()
        let e = Ice.DictEntryArray<Swift.Int32, C?>(size: sz)
        for i in 0 ..< sz {
            let key: Swift.Int32 = try istr.read()
            v[key] = nil as C?
            Swift.withUnsafeMutablePointer(to: &v[key, default:nil]) {
                e.values[i] = Ice.DictEntry<Swift.Int32, C?>(key: key, value: $0)
            }
            try istr.read(C.self) { e.values[i].value.pointee = $0 }
        }
        for i in 0..<sz {
            Swift.withUnsafeMutablePointer(to: &v[e.values[i].key, default:nil]) {
                e.values[i].value = $0
            }
        }
        return v
    }
    /// Read an optional `CDict?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `CDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> CDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `CDict` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `CDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: CDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `CDict?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `CDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: CDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public class S {
    public var theC: C? = nil

    public init() {}

    public init(theC: C?) {
        self.theC = theC
    }
}

/// An `Ice.InputStream` extension to read `S` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `S` structured value from the stream.
    ///
    /// - returns: `S` - The structured value read from the stream.
    func read() throws -> S {
        let v = S()
        try self.read(C.self) { v.theC = $0 }
        return v
    }

    /// Read an optional `S?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `S?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> S? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as S
    }
}

/// An `Ice.OutputStream` extension to write `S` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `S` structured value to the stream.
    ///
    /// - parameter _: `S` - The value to write to the stream.
    func write(_ v: S) {
        self.write(v.theC)
    }

    /// Write an optional `S?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `S?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: S?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public typealias SSeq = [S]

/// Helper class to read and write `SSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct SSeqHelper {
    /// Read a `SSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `SSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> SSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = SSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: S = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `SSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `SSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> SSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `SSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `SSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: SSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `SSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `SSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: SSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias C2Dict = [Swift.Int32: C2?]

/// Helper class to read and write `C2Dict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct C2DictHelper {
    /// Read a `C2Dict` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `C2Dict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> C2Dict {
        let sz = try Swift.Int(istr.readSize())
        var v = C2Dict()
        let e = Ice.DictEntryArray<Swift.Int32, C2?>(size: sz)
        for i in 0 ..< sz {
            let key: Swift.Int32 = try istr.read()
            v[key] = nil as C2?
            Swift.withUnsafeMutablePointer(to: &v[key, default:nil]) {
                e.values[i] = Ice.DictEntry<Swift.Int32, C2?>(key: key, value: $0)
            }
            try istr.read(C2.self) { e.values[i].value.pointee = $0 }
        }
        for i in 0..<sz {
            Swift.withUnsafeMutablePointer(to: &v[e.values[i].key, default:nil]) {
                e.values[i].value = $0
            }
        }
        return v
    }
    /// Read an optional `C2Dict?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `C2Dict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> C2Dict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `C2Dict` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `C2Dict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: C2Dict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `C2Dict?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `C2Dict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: C2Dict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public class S2 {
    public var theC2Dict: C2Dict = C2Dict()

    public init() {}

    public init(theC2Dict: C2Dict) {
        self.theC2Dict = theC2Dict
    }
}

/// An `Ice.InputStream` extension to read `S2` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `S2` structured value from the stream.
    ///
    /// - returns: `S2` - The structured value read from the stream.
    func read() throws -> S2 {
        let v = S2()
        v.theC2Dict = try C2DictHelper.read(from: self)
        return v
    }

    /// Read an optional `S2?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `S2?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> S2? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as S2
    }
}

/// An `Ice.OutputStream` extension to write `S2` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `S2` structured value to the stream.
    ///
    /// - parameter _: `S2` - The value to write to the stream.
    func write(_ v: S2) {
        C2DictHelper.write(to: self, value: v.theC2Dict)
    }

    /// Write an optional `S2?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `S2?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: S2?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public typealias S2Seq = [S2]

/// Helper class to read and write `S2Seq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct S2SeqHelper {
    /// Read a `S2Seq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `S2Seq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> S2Seq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = S2Seq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: S2 = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `S2Seq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `S2Seq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> S2Seq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `S2Seq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `S2Seq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: S2Seq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `S2Seq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `S2Seq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: S2Seq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice class `C2`.
public struct C2Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::C2"]
    public static let staticId = "::Test::C2"
}

/// Traits for Slice class `Leaf`.
public struct LeafTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Leaf"]
    public static let staticId = "::Test::Leaf"
}

/// Traits for Slice class `Node`.
public struct NodeTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Node"]
    public static let staticId = "::Test::Node"
}

public typealias C2DictSeq = [C2Dict]

/// Helper class to read and write `C2DictSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct C2DictSeqHelper {
    /// Read a `C2DictSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `C2DictSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> C2DictSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = C2DictSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: C2Dict = try C2DictHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `C2DictSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `C2DictSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> C2DictSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `C2DictSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `C2DictSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: C2DictSeq) {
        ostr.write(size: v.count)
        for item in v {
            C2DictHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `C2DictSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `C2DictSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: C2DictSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias CSeqSeq = [CSeq]

/// Helper class to read and write `CSeqSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct CSeqSeqHelper {
    /// Read a `CSeqSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `CSeqSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> CSeqSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = CSeqSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: CSeq = try CSeqHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `CSeqSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `CSeqSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> CSeqSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `CSeqSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `CSeqSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: CSeqSeq) {
        ostr.write(size: v.count)
        for item in v {
            CSeqHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `CSeqSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `CSeqSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: CSeqSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public class A {
    public var theSSeq: SSeq = SSeq()

    public init() {}

    public init(theSSeq: SSeq) {
        self.theSSeq = theSSeq
    }
}

/// An `Ice.InputStream` extension to read `A` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `A` structured value from the stream.
    ///
    /// - returns: `A` - The structured value read from the stream.
    func read() throws -> A {
        let v = A()
        v.theSSeq = try SSeqHelper.read(from: self)
        return v
    }

    /// Read an optional `A?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `A?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> A? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as A
    }
}

/// An `Ice.OutputStream` extension to write `A` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `A` structured value to the stream.
    ///
    /// - parameter _: `A` - The value to write to the stream.
    func write(_ v: A) {
        SSeqHelper.write(to: self, value: v.theSSeq)
    }

    /// Write an optional `A?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `A?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: A?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public class B {
    public var theS: S = S()

    public init() {}

    public init(theS: S) {
        self.theS = theS
    }
}

/// An `Ice.InputStream` extension to read `B` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `B` structured value from the stream.
    ///
    /// - returns: `B` - The structured value read from the stream.
    func read() throws -> B {
        let v = B()
        v.theS = try self.read()
        return v
    }

    /// Read an optional `B?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `B?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> B? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as B
    }
}

/// An `Ice.OutputStream` extension to write `B` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `B` structured value to the stream.
    ///
    /// - parameter _: `B` - The value to write to the stream.
    func write(_ v: B) {
        self.write(v.theS)
    }

    /// Write an optional `B?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `B?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: B?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public typealias CSeqDict = [Swift.Int32: CSeq]

/// Helper class to read and write `CSeqDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct CSeqDictHelper {
    /// Read a `CSeqDict` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `CSeqDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> CSeqDict {
        let sz = try Swift.Int(istr.readSize())
        var v = CSeqDict()
        for _ in 0 ..< sz {
            let key: Swift.Int32 = try istr.read()
            let value: CSeq = try CSeqHelper.read(from: istr)
            v[key] = value
        }
        return v
    }
    /// Read an optional `CSeqDict?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `CSeqDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> CSeqDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `CSeqDict` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `CSeqDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: CSeqDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            CSeqHelper.write(to: ostr, value: value)
        }
    }

    /// Wite an optional `CSeqDict?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `CSeqDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: CSeqDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias SDict = [Swift.Int32: S]

/// Helper class to read and write `SDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct SDictHelper {
    /// Read a `SDict` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `SDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> SDict {
        let sz = try Swift.Int(istr.readSize())
        var v = SDict()
        for _ in 0 ..< sz {
            let key: Swift.Int32 = try istr.read()
            let value: S = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `SDict?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `SDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> SDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `SDict` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `SDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: SDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `SDict?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `SDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: SDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias CDictDict = [Swift.Int32: CDict]

/// Helper class to read and write `CDictDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct CDictDictHelper {
    /// Read a `CDictDict` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `CDictDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> CDictDict {
        let sz = try Swift.Int(istr.readSize())
        var v = CDictDict()
        for _ in 0 ..< sz {
            let key: Swift.Int32 = try istr.read()
            let value: CDict = try CDictHelper.read(from: istr)
            v[key] = value
        }
        return v
    }
    /// Read an optional `CDictDict?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `CDictDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> CDictDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `CDictDict` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `CDictDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: CDictDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            CDictHelper.write(to: ostr, value: value)
        }
    }

    /// Wite an optional `CDictDict?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `CDictDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: CDictDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice class `CTest`.
public struct CTestTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::CTest"]
    public static let staticId = "::Test::CTest"
}

public typealias AAABSeq = [AAAB?]

/// Helper class to read and write `AAABSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct AAABSeqHelper {
    /// Read a `AAABSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `AAABSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> AAABSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = AAABSeq(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(AAAB.self) { p.pointee = $0 }
            }
        }
        return v
    }
    /// Read an optional `AAABSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `AAABSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> AAABSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `AAABSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `AAABSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: AAABSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `AAABSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `AAABSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: AAABSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias AAABDict = [Swift.Int32: AAAB?]

/// Helper class to read and write `AAABDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct AAABDictHelper {
    /// Read a `AAABDict` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `AAABDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> AAABDict {
        let sz = try Swift.Int(istr.readSize())
        var v = AAABDict()
        let e = Ice.DictEntryArray<Swift.Int32, AAAB?>(size: sz)
        for i in 0 ..< sz {
            let key: Swift.Int32 = try istr.read()
            v[key] = nil as AAAB?
            Swift.withUnsafeMutablePointer(to: &v[key, default:nil]) {
                e.values[i] = Ice.DictEntry<Swift.Int32, AAAB?>(key: key, value: $0)
            }
            try istr.read(AAAB.self) { e.values[i].value.pointee = $0 }
        }
        for i in 0..<sz {
            Swift.withUnsafeMutablePointer(to: &v[e.values[i].key, default:nil]) {
                e.values[i].value = $0
            }
        }
        return v
    }
    /// Read an optional `AAABDict?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `AAABDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> AAABDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `AAABDict` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `AAABDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: AAABDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `AAABDict?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `AAABDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: AAABDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public class AAABStruct {
    public var bMem: AAAB? = nil

    public init() {}

    public init(bMem: AAAB?) {
        self.bMem = bMem
    }
}

/// An `Ice.InputStream` extension to read `AAABStruct` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `AAABStruct` structured value from the stream.
    ///
    /// - returns: `AAABStruct` - The structured value read from the stream.
    func read() throws -> AAABStruct {
        let v = AAABStruct()
        try self.read(AAAB.self) { v.bMem = $0 }
        return v
    }

    /// Read an optional `AAABStruct?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `AAABStruct?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> AAABStruct? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as AAABStruct
    }
}

/// An `Ice.OutputStream` extension to write `AAABStruct` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `AAABStruct` structured value to the stream.
    ///
    /// - parameter _: `AAABStruct` - The value to write to the stream.
    func write(_ v: AAABStruct) {
        self.write(v.bMem)
    }

    /// Write an optional `AAABStruct?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `AAABStruct?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: AAABStruct?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// Traits for Slice class `AAAC`.
public struct AAACTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::AAA::C"]
    public static let staticId = "::Test::AAA::C"
}

public typealias AAACSeq = [AAAC?]

/// Helper class to read and write `AAACSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct AAACSeqHelper {
    /// Read a `AAACSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `AAACSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> AAACSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = AAACSeq(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(AAAC.self) { p.pointee = $0 }
            }
        }
        return v
    }
    /// Read an optional `AAACSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `AAACSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> AAACSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `AAACSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `AAACSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: AAACSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `AAACSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `AAACSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: AAACSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias AAACDict = [Swift.Int32: AAAC?]

/// Helper class to read and write `AAACDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct AAACDictHelper {
    /// Read a `AAACDict` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `AAACDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> AAACDict {
        let sz = try Swift.Int(istr.readSize())
        var v = AAACDict()
        let e = Ice.DictEntryArray<Swift.Int32, AAAC?>(size: sz)
        for i in 0 ..< sz {
            let key: Swift.Int32 = try istr.read()
            v[key] = nil as AAAC?
            Swift.withUnsafeMutablePointer(to: &v[key, default:nil]) {
                e.values[i] = Ice.DictEntry<Swift.Int32, AAAC?>(key: key, value: $0)
            }
            try istr.read(AAAC.self) { e.values[i].value.pointee = $0 }
        }
        for i in 0..<sz {
            Swift.withUnsafeMutablePointer(to: &v[e.values[i].key, default:nil]) {
                e.values[i].value = $0
            }
        }
        return v
    }
    /// Read an optional `AAACDict?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `AAACDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> AAACDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `AAACDict` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `AAACDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: AAACDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `AAACDict?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `AAACDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: AAACDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public class AAACStruct {
    public var cMem: AAAC? = nil

    public init() {}

    public init(cMem: AAAC?) {
        self.cMem = cMem
    }
}

/// An `Ice.InputStream` extension to read `AAACStruct` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `AAACStruct` structured value from the stream.
    ///
    /// - returns: `AAACStruct` - The structured value read from the stream.
    func read() throws -> AAACStruct {
        let v = AAACStruct()
        try self.read(AAAC.self) { v.cMem = $0 }
        return v
    }

    /// Read an optional `AAACStruct?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `AAACStruct?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> AAACStruct? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as AAACStruct
    }
}

/// An `Ice.OutputStream` extension to write `AAACStruct` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `AAACStruct` structured value to the stream.
    ///
    /// - parameter _: `AAACStruct` - The value to write to the stream.
    func write(_ v: AAACStruct) {
        self.write(v.cMem)
    }

    /// Write an optional `AAACStruct?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `AAACStruct?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: AAACStruct?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// Traits for Slice class `AAAB`.
public struct AAABTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::AAA::B"]
    public static let staticId = "::Test::AAA::B"
}

public typealias CCCForwardProxySeq = [Ice.ObjectPrx?]

/// Helper class to read and write `CCCForwardProxySeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct CCCForwardProxySeqHelper {
    /// Read a `CCCForwardProxySeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `CCCForwardProxySeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> CCCForwardProxySeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = CCCForwardProxySeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
            v.append(j)
        }
        return v
    }
    /// Read an optional `CCCForwardProxySeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `CCCForwardProxySeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> CCCForwardProxySeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `CCCForwardProxySeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `CCCForwardProxySeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: CCCForwardProxySeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `CCCForwardProxySeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `CCCForwardProxySeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: CCCForwardProxySeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice class `CCCForward`.
public struct CCCForwardTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::CCC::Forward"]
    public static let staticId = "::Test::CCC::Forward"
}

/// Traits for Slice interface `DDDI`.
public struct DDDITraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::DDD::I"]
    public static let staticId = "::Test::DDD::I"
}

/// Traits for Slice class `DDDC`.
public struct DDDCTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::DDD::C"]
    public static let staticId = "::Test::DDD::C"
}

/// Traits for Slice class `DDDU`.
public struct DDDUTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::DDD::U"]
    public static let staticId = "::Test::DDD::U"
}

/// Traits for Slice class `DDDC2`.
public struct DDDC2Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::DDD::C2"]
    public static let staticId = "::Test::DDD::C2"
}

/// DDDIPrx overview.
///
/// DDDIPrx Methods:
///
///  - op: 
///
///  - opAsync: 
public protocol DDDIPrx: Ice.ObjectPrx {}

private final class DDDIPrxI: Ice.ObjectPrxI, DDDIPrx {
    public override class func ice_staticId() -> Swift.String {
        return DDDITraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `DDDIPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `DDDIPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: DDDIPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> DDDIPrx? {
    return try DDDIPrxI.checkedCast(prx: prx, facet: facet, context: context) as DDDIPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `DDDIPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `DDDIPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: DDDIPrx.Protocol, facet: Swift.String? = nil) -> DDDIPrx {
    return DDDIPrxI.uncheckedCast(prx: prx, facet: facet) as DDDIPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `DDDIPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: DDDIPrx.Protocol) -> Swift.String {
    return DDDITraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `DDDIPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `DDDIPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `DDDIPrx?` - The extracted proxy
    func read(_ type: DDDIPrx.Protocol) throws -> DDDIPrx? {
        return try read() as DDDIPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `DDDIPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `DDDIPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: DDDIPrx.Protocol) throws -> DDDIPrx? {
        return try read(tag: tag) as DDDIPrxI?
    }
}

/// DDDIPrx overview.
///
/// DDDIPrx Methods:
///
///  - op: 
///
///  - opAsync: 
public extension DDDIPrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func op(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "op",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func opAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "op",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// :nodoc:
public class C_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return C.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_C() -> Ice.ValueTypeResolver {
        return C_TypeResolver()
    }
}

open class C: Ice.Value {
    public var `left`: C? = nil
    public var `right`: C? = nil

    public required init() {}

    public init(`left`: C?, `right`: C?) {
        self.`left` = `left`
        self.`right` = `right`
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return CTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return CTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(C.self) { self.`left` = $0 }
        try istr.read(C.self) { self.`right` = $0 }
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CTraits.staticId, compactId: -1, last: true)
        ostr.write(self.`left`)
        ostr.write(self.`right`)
        ostr.endSlice()
    }
}

/// :nodoc:
public class C2_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return C2.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_C2() -> Ice.ValueTypeResolver {
        return C2_TypeResolver()
    }
}

open class C2: Ice.Value {
    public var theS2Seq: S2Seq = S2Seq()

    public required init() {}

    public init(theS2Seq: S2Seq) {
        self.theS2Seq = theS2Seq
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return C2Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return C2Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.theS2Seq = try S2SeqHelper.read(from: istr)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: C2Traits.staticId, compactId: -1, last: true)
        S2SeqHelper.write(to: ostr, value: self.theS2Seq)
        ostr.endSlice()
    }
}

/// :nodoc:
public class Leaf_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Leaf.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Leaf() -> Ice.ValueTypeResolver {
        return Leaf_TypeResolver()
    }
}

open class Leaf: Ice.Value {
    public var i: Swift.Int32 = 0

    public required init() {}

    public init(i: Swift.Int32) {
        self.i = i
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return LeafTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return LeafTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.i = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: LeafTraits.staticId, compactId: -1, last: true)
        ostr.write(self.i)
        ostr.endSlice()
    }
}

/// :nodoc:
public class Node_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Node.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Node() -> Ice.ValueTypeResolver {
        return Node_TypeResolver()
    }
}

open class Node: Ice.Value {
    public var l: Leaf? = nil
    public var n: Node? = nil

    public required init() {}

    public init(l: Leaf?, n: Node?) {
        self.l = l
        self.n = n
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return NodeTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return NodeTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(Leaf.self) { self.l = $0 }
        try istr.read(Node.self) { self.n = $0 }
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: NodeTraits.staticId, compactId: -1, last: true)
        ostr.write(self.l)
        ostr.write(self.n)
        ostr.endSlice()
    }
}

/// :nodoc:
public class CTest_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return CTest.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_CTest() -> Ice.ValueTypeResolver {
        return CTest_TypeResolver()
    }
}

open class CTest: Ice.Value {
    public var theCSeq: CSeq = CSeq()
    public var theSSeq: SSeq = SSeq()
    public var theC2DictSeq: C2DictSeq = C2DictSeq()
    public var theCSeqSeq: CSeqSeq = CSeqSeq()
    public var theS: S = S()
    public var theA: A = A()
    public var theS2: S2 = S2()
    public var theB: B = B()
    public var theCDict: CDict = CDict()
    public var theCSeqDict: CSeqDict = CSeqDict()
    public var theSDict: SDict = SDict()
    public var theCDictDict: CDictDict = CDictDict()

    public required init() {}

    public init(theCSeq: CSeq, theSSeq: SSeq, theC2DictSeq: C2DictSeq, theCSeqSeq: CSeqSeq, theS: S, theA: A, theS2: S2, theB: B, theCDict: CDict, theCSeqDict: CSeqDict, theSDict: SDict, theCDictDict: CDictDict) {
        self.theCSeq = theCSeq
        self.theSSeq = theSSeq
        self.theC2DictSeq = theC2DictSeq
        self.theCSeqSeq = theCSeqSeq
        self.theS = theS
        self.theA = theA
        self.theS2 = theS2
        self.theB = theB
        self.theCDict = theCDict
        self.theCSeqDict = theCSeqDict
        self.theSDict = theSDict
        self.theCDictDict = theCDictDict
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return CTestTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return CTestTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.theCSeq = try CSeqHelper.read(from: istr)
        self.theSSeq = try SSeqHelper.read(from: istr)
        self.theC2DictSeq = try C2DictSeqHelper.read(from: istr)
        self.theCSeqSeq = try CSeqSeqHelper.read(from: istr)
        self.theS = try istr.read()
        self.theA = try istr.read()
        self.theS2 = try istr.read()
        self.theB = try istr.read()
        self.theCDict = try CDictHelper.read(from: istr)
        self.theCSeqDict = try CSeqDictHelper.read(from: istr)
        self.theSDict = try SDictHelper.read(from: istr)
        self.theCDictDict = try CDictDictHelper.read(from: istr)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CTestTraits.staticId, compactId: -1, last: true)
        CSeqHelper.write(to: ostr, value: self.theCSeq)
        SSeqHelper.write(to: ostr, value: self.theSSeq)
        C2DictSeqHelper.write(to: ostr, value: self.theC2DictSeq)
        CSeqSeqHelper.write(to: ostr, value: self.theCSeqSeq)
        ostr.write(self.theS)
        ostr.write(self.theA)
        ostr.write(self.theS2)
        ostr.write(self.theB)
        CDictHelper.write(to: ostr, value: self.theCDict)
        CSeqDictHelper.write(to: ostr, value: self.theCSeqDict)
        SDictHelper.write(to: ostr, value: self.theSDict)
        CDictDictHelper.write(to: ostr, value: self.theCDictDict)
        ostr.endSlice()
    }
}

/// :nodoc:
public class AAAC_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return AAAC.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_AAA_C() -> Ice.ValueTypeResolver {
        return AAAC_TypeResolver()
    }
}

open class AAAC: Ice.Value {
    public var obj1: Ice.Value? = nil
    public var obj2: Ice.Value? = nil
    public var b1: AAAB? = nil
    public var b2: AAAB? = nil
    public var x: AAABSeq = AAABSeq()
    public var y: AAABDict = AAABDict()
    public var z: AAABStruct = AAABStruct()

    public required init() {}

    public init(obj1: Ice.Value?, obj2: Ice.Value?, b1: AAAB?, b2: AAAB?, x: AAABSeq, y: AAABDict, z: AAABStruct) {
        self.obj1 = obj1
        self.obj2 = obj2
        self.b1 = b1
        self.b2 = b2
        self.x = x
        self.y = y
        self.z = z
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return AAACTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return AAACTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read() { self.obj1 = $0 }
        try istr.read() { self.obj2 = $0 }
        try istr.read(AAAB.self) { self.b1 = $0 }
        try istr.read(AAAB.self) { self.b2 = $0 }
        self.x = try AAABSeqHelper.read(from: istr)
        self.y = try AAABDictHelper.read(from: istr)
        self.z = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: AAACTraits.staticId, compactId: -1, last: true)
        ostr.write(self.obj1)
        ostr.write(self.obj2)
        ostr.write(self.b1)
        ostr.write(self.b2)
        AAABSeqHelper.write(to: ostr, value: self.x)
        AAABDictHelper.write(to: ostr, value: self.y)
        ostr.write(self.z)
        ostr.endSlice()
    }
}

/// :nodoc:
public class AAAB_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return AAAB.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_AAA_B() -> Ice.ValueTypeResolver {
        return AAAB_TypeResolver()
    }
}

open class AAAB: Ice.Value {
    public var obj1: Ice.Value? = nil
    public var obj2: Ice.Value? = nil
    public var c1: AAAC? = nil
    public var c2: AAAC? = nil
    public var x: AAACSeq = AAACSeq()
    public var y: AAACDict = AAACDict()
    public var z: AAACStruct = AAACStruct()

    public required init() {}

    public init(obj1: Ice.Value?, obj2: Ice.Value?, c1: AAAC?, c2: AAAC?, x: AAACSeq, y: AAACDict, z: AAACStruct) {
        self.obj1 = obj1
        self.obj2 = obj2
        self.c1 = c1
        self.c2 = c2
        self.x = x
        self.y = y
        self.z = z
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return AAABTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return AAABTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read() { self.obj1 = $0 }
        try istr.read() { self.obj2 = $0 }
        try istr.read(AAAC.self) { self.c1 = $0 }
        try istr.read(AAAC.self) { self.c2 = $0 }
        self.x = try AAACSeqHelper.read(from: istr)
        self.y = try AAACDictHelper.read(from: istr)
        self.z = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: AAABTraits.staticId, compactId: -1, last: true)
        ostr.write(self.obj1)
        ostr.write(self.obj2)
        ostr.write(self.c1)
        ostr.write(self.c2)
        AAACSeqHelper.write(to: ostr, value: self.x)
        AAACDictHelper.write(to: ostr, value: self.y)
        ostr.write(self.z)
        ostr.endSlice()
    }
}

/// :nodoc:
public class CCCForward_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return CCCForward.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_CCC_Forward() -> Ice.ValueTypeResolver {
        return CCCForward_TypeResolver()
    }
}

open class CCCForward: Ice.Value {
    public required init() {}

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return CCCForwardTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return CCCForwardTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CCCForwardTraits.staticId, compactId: -1, last: true)
        ostr.endSlice()
    }
}

/// :nodoc:
public class DDDC_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return DDDC.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_DDD_C() -> Ice.ValueTypeResolver {
        return DDDC_TypeResolver()
    }
}

open class DDDC: Ice.Value {
    public required init() {}

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return DDDCTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return DDDCTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: DDDCTraits.staticId, compactId: -1, last: true)
        ostr.endSlice()
    }
}

/// :nodoc:
public class DDDU_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return DDDU.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_DDD_U() -> Ice.ValueTypeResolver {
        return DDDU_TypeResolver()
    }
}

open class DDDU: Ice.Value {
    public var myI: Ice.Value? = nil
    public var myIstar: DDDIPrx? = nil
    public var myC: DDDC? = nil
    public var myCstar: Ice.ObjectPrx? = nil
    public var myC2: DDDC2? = nil
    public var myC2star: Ice.ObjectPrx? = nil

    public required init() {}

    public init(myI: Ice.Value?, myIstar: DDDIPrx?, myC: DDDC?, myCstar: Ice.ObjectPrx?, myC2: DDDC2?, myC2star: Ice.ObjectPrx?) {
        self.myI = myI
        self.myIstar = myIstar
        self.myC = myC
        self.myCstar = myCstar
        self.myC2 = myC2
        self.myC2star = myC2star
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return DDDUTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return DDDUTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read() { self.myI = $0 }
        self.myIstar = try istr.read(DDDIPrx.self)
        try istr.read(DDDC.self) { self.myC = $0 }
        self.myCstar = try istr.read(Ice.ObjectPrx.self)
        try istr.read(DDDC2.self) { self.myC2 = $0 }
        self.myC2star = try istr.read(Ice.ObjectPrx.self)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: DDDUTraits.staticId, compactId: -1, last: true)
        ostr.write(self.myI)
        ostr.write(self.myIstar)
        ostr.write(self.myC)
        ostr.write(self.myCstar)
        ostr.write(self.myC2)
        ostr.write(self.myC2star)
        ostr.endSlice()
    }
}

/// :nodoc:
public class DDDC2_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return DDDC2.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_DDD_C2() -> Ice.ValueTypeResolver {
        return DDDC2_TypeResolver()
    }
}

open class DDDC2: Ice.Value {
    public required init() {}

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return DDDC2Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return DDDC2Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: DDDC2Traits.staticId, compactId: -1, last: true)
        ostr.endSlice()
    }
}


/// Dispatcher for `DDDI` servants.
public struct DDDIDisp: Ice.Disp {
    public let servant: DDDI
    private static let defaultObject = Ice.ObjectI<DDDITraits>()

    public init(_ servant: DDDI) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "ice_id":
            return try (servant as? Object ?? DDDIDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? DDDIDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? DDDIDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? DDDIDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "op":
            return try servant._iceD_op(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol DDDI {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func op(current: Ice.Current) throws
}

/// DDDI overview.
///
/// DDDI Methods:
///
///  - op: 
public extension DDDI {
    func _iceD_op(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.op(current: current)

        return inS.setResult()
    }
}
