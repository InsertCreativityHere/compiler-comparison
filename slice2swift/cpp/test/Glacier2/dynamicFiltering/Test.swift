//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice
import Glacier2

/// Traits for Slice interface`Backend`.
public struct BackendTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Backend"]
    public static let staticId = "::Test::Backend"
}

public enum StateCode: Swift.UInt8 {
    /// Initial
    case Initial = 0
    /// Running
    case Running = 1
    /// Finished
    case Finished = 2
    public init() {
        self = .Initial
    }
}

/// An `Ice.InputStream` extension to read `StateCode` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - returns: `StateCode` - The enumarated value.
    func read() throws -> StateCode {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 2)
        guard let val = StateCode(rawValue: rawValue) else {
            throw Ice.MarshalException("invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StateCode` - The enumerated value.
    func read(tag: Swift.Int32) throws -> StateCode? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as StateCode
    }
}

/// An `Ice.OutputStream` extension to write `StateCode` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// parameter _: `StateCode` - The enumerator to write.
    func write(_ v: StateCode) {
        write(enum: v.rawValue, maxValue: 2)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// parameter _: `StateCode` - The enumerator to write.
    func write(tag: Swift.Int32, value: StateCode?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 2)
    }
}

public struct TestToken: Swift.Hashable {
    public var expectedResult: Swift.Bool = false
    public var description: Swift.String = ""
    public var code: StateCode = .Initial
    public var config: Swift.Int16 = 0
    public var caseIndex: Swift.Int16 = 0
    public var testReference: Swift.String = ""

    public init() {}

    public init(expectedResult: Swift.Bool, description: Swift.String, code: StateCode, config: Swift.Int16, caseIndex: Swift.Int16, testReference: Swift.String) {
        self.expectedResult = expectedResult
        self.description = description
        self.code = code
        self.config = config
        self.caseIndex = caseIndex
        self.testReference = testReference
    }
}

/// An `Ice.InputStream` extension to read `TestToken` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `TestToken` structured value from the stream.
    ///
    /// - returns: `TestToken` - The structured value read from the stream.
    func read() throws -> TestToken {
        var v = TestToken()
        v.expectedResult = try self.read()
        v.description = try self.read()
        v.code = try self.read()
        v.config = try self.read()
        v.caseIndex = try self.read()
        v.testReference = try self.read()
        return v
    }

    /// Read an optional `TestToken?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `TestToken?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> TestToken? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as TestToken
    }
}

/// An `Ice.OutputStream` extension to write `TestToken` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `TestToken` structured value to the stream.
    ///
    /// - parameter _: `TestToken` - The value to write to the stream.
    func write(_ v: TestToken) {
        self.write(v.expectedResult)
        self.write(v.description)
        self.write(v.code)
        self.write(v.config)
        self.write(v.caseIndex)
        self.write(v.testReference)
    }

    /// Write an optional `TestToken?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `TestToken?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: TestToken?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// Traits for Slice interface`TestController`.
public struct TestControllerTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::TestController"]
    public static let staticId = "::Test::TestController"
}

/// Traits for Slice interface`TestSession`.
public struct TestSessionTraits: Ice.SliceTraits {
    public static let staticIds = ["::Glacier2::Session", "::Ice::Object", "::Test::TestSession"]
    public static let staticId = "::Test::TestSession"
}

/// BackendPrx overview.
///
/// BackendPrx Methods:
///
///  - check: 
///
///  - checkAsync: 
///
///  - shutdown: 
///
///  - shutdownAsync: 
public protocol BackendPrx: Ice.ObjectPrx {}

private final class BackendPrxI: Ice.ObjectPrxI, BackendPrx {
    public override class func ice_staticId() -> Swift.String {
        return BackendTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: BackendPrx.Protocol) throws -> BackendPrx {
    try communicator.makeProxyImpl(proxyString) as BackendPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `BackendPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `BackendPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: BackendPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> BackendPrx? {
    return try BackendPrxI.checkedCast(prx: prx, facet: facet, context: context) as BackendPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `BackendPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `BackendPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: BackendPrx.Protocol, facet: Swift.String? = nil) -> BackendPrx {
    return BackendPrxI.uncheckedCast(prx: prx, facet: facet) as BackendPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `BackendPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: BackendPrx.Protocol) -> Swift.String {
    return BackendTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `BackendPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `BackendPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `BackendPrx?` - The extracted proxy
    func read(_ type: BackendPrx.Protocol) throws -> BackendPrx? {
        return try read() as BackendPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `BackendPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `BackendPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: BackendPrx.Protocol) throws -> BackendPrx? {
        return try read(tag: tag) as BackendPrxI?
    }
}

/// BackendPrx overview.
///
/// BackendPrx Methods:
///
///  - check: 
///
///  - checkAsync: 
///
///  - shutdown: 
///
///  - shutdownAsync: 
public extension BackendPrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func check(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "check",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `` - The result of the operation
    func checkAsync(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invokeAsync(operation: "check",
                                            mode: .Normal,
                                            context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func shutdown(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "shutdown",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `` - The result of the operation
    func shutdownAsync(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invokeAsync(operation: "shutdown",
                                            mode: .Normal,
                                            context: context)
    }
}

/// The test controller interface permits coordination between the test
/// server and the test client. Prior to each call the client makes on
/// various backend references, it calls step on the controller. The
/// controller will manage the configuration of the system and return a
/// flag indicating whether the next call is meant to succeed or not.
///
/// TestControllerPrx Methods:
///
///  - step: 
///
///  - stepAsync: 
///
///  - shutdown: 
///
///  - shutdownAsync: 
public protocol TestControllerPrx: Ice.ObjectPrx {}

private final class TestControllerPrxI: Ice.ObjectPrxI, TestControllerPrx {
    public override class func ice_staticId() -> Swift.String {
        return TestControllerTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: TestControllerPrx.Protocol) throws -> TestControllerPrx {
    try communicator.makeProxyImpl(proxyString) as TestControllerPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `TestControllerPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `TestControllerPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: TestControllerPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> TestControllerPrx? {
    return try TestControllerPrxI.checkedCast(prx: prx, facet: facet, context: context) as TestControllerPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `TestControllerPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `TestControllerPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: TestControllerPrx.Protocol, facet: Swift.String? = nil) -> TestControllerPrx {
    return TestControllerPrxI.uncheckedCast(prx: prx, facet: facet) as TestControllerPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `TestControllerPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: TestControllerPrx.Protocol) -> Swift.String {
    return TestControllerTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `TestControllerPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `TestControllerPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `TestControllerPrx?` - The extracted proxy
    func read(_ type: TestControllerPrx.Protocol) throws -> TestControllerPrx? {
        return try read() as TestControllerPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `TestControllerPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `TestControllerPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: TestControllerPrx.Protocol) throws -> TestControllerPrx? {
        return try read(tag: tag) as TestControllerPrxI?
    }
}

/// The test controller interface permits coordination between the test
/// server and the test client. Prior to each call the client makes on
/// various backend references, it calls step on the controller. The
/// controller will manage the configuration of the system and return a
/// flag indicating whether the next call is meant to succeed or not.
///
/// TestControllerPrx Methods:
///
///  - step: 
///
///  - stepAsync: 
///
///  - shutdown: 
///
///  - shutdownAsync: 
public extension TestControllerPrx {
    ///
    /// - parameter currentSession: `Glacier2.SessionPrx?`
    ///
    /// - parameter currentState: `TestToken`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `TestToken`
    func step(currentSession iceP_currentSession: Glacier2.SessionPrx?, currentState iceP_currentState: TestToken, context: Ice.Context? = nil) throws -> TestToken {
        return try _impl._invoke(operation: "step",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_currentSession)
                                     ostr.write(iceP_currentState)
                                 },
                                 read: { istr in
                                     let iceP_newState: TestToken = try istr.read()
                                     return iceP_newState
                                 },
                                 context: context)
    }

    ///
    /// - parameter currentSession: `Glacier2.SessionPrx?`
    ///
    /// - parameter currentState: `TestToken`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `TestToken` - The result of the operation
    func stepAsync(currentSession iceP_currentSession: Glacier2.SessionPrx?, currentState iceP_currentState: TestToken, context: Ice.Context? = nil) async throws -> TestToken {
        return try await _impl._invokeAsync(operation: "step",
                                            mode: .Normal,
                                            write: { ostr in
                                                ostr.write(iceP_currentSession)
                                                ostr.write(iceP_currentState)
                                            },
                                            read: { istr in
                                                let iceP_newState: TestToken = try istr.read()
                                                return iceP_newState
                                            },
                                            context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func shutdown(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "shutdown",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `` - The result of the operation
    func shutdownAsync(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invokeAsync(operation: "shutdown",
                                            mode: .Normal,
                                            context: context)
    }
}

/// TestSessionPrx overview.
///
/// TestSessionPrx Methods:
///
///  - shutdown: 
///
///  - shutdownAsync: 
public protocol TestSessionPrx: Glacier2.SessionPrx {}

private final class TestSessionPrxI: Ice.ObjectPrxI, TestSessionPrx {
    public override class func ice_staticId() -> Swift.String {
        return TestSessionTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: TestSessionPrx.Protocol) throws -> TestSessionPrx {
    try communicator.makeProxyImpl(proxyString) as TestSessionPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `TestSessionPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `TestSessionPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: TestSessionPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> TestSessionPrx? {
    return try TestSessionPrxI.checkedCast(prx: prx, facet: facet, context: context) as TestSessionPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `TestSessionPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `TestSessionPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: TestSessionPrx.Protocol, facet: Swift.String? = nil) -> TestSessionPrx {
    return TestSessionPrxI.uncheckedCast(prx: prx, facet: facet) as TestSessionPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `TestSessionPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: TestSessionPrx.Protocol) -> Swift.String {
    return TestSessionTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `TestSessionPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `TestSessionPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `TestSessionPrx?` - The extracted proxy
    func read(_ type: TestSessionPrx.Protocol) throws -> TestSessionPrx? {
        return try read() as TestSessionPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `TestSessionPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `TestSessionPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: TestSessionPrx.Protocol) throws -> TestSessionPrx? {
        return try read(tag: tag) as TestSessionPrxI?
    }
}

/// TestSessionPrx overview.
///
/// TestSessionPrx Methods:
///
///  - shutdown: 
///
///  - shutdownAsync: 
public extension TestSessionPrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func shutdown(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "shutdown",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `` - The result of the operation
    func shutdownAsync(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invokeAsync(operation: "shutdown",
                                            mode: .Normal,
                                            context: context)
    }
}


/// Dispatcher for `Backend` servants.
public struct BackendDisp: Ice.Dispatcher {
    public let servant: Backend
    private static let defaultObject = Ice.ObjectI<BackendTraits>()

    public init(_ servant: Backend) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "check":
            try await servant._iceD_check(request)
        case "ice_id":
            try (servant as? Ice.Object ?? BackendDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try (servant as? Ice.Object ?? BackendDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try (servant as? Ice.Object ?? BackendDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try (servant as? Ice.Object ?? BackendDisp.defaultObject)._iceD_ice_ping(request)
        case "shutdown":
            try await servant._iceD_shutdown(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol Backend {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func check(current: Ice.Current) throws

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func shutdown(current: Ice.Current) throws
}


/// Dispatcher for `TestController` servants.
public struct TestControllerDisp: Ice.Dispatcher {
    public let servant: TestController
    private static let defaultObject = Ice.ObjectI<TestControllerTraits>()

    public init(_ servant: TestController) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "ice_id":
            try (servant as? Ice.Object ?? TestControllerDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try (servant as? Ice.Object ?? TestControllerDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try (servant as? Ice.Object ?? TestControllerDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try (servant as? Ice.Object ?? TestControllerDisp.defaultObject)._iceD_ice_ping(request)
        case "shutdown":
            try await servant._iceD_shutdown(request)
        case "step":
            try await servant._iceD_step(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

/// The test controller interface permits coordination between the test
/// server and the test client. Prior to each call the client makes on
/// various backend references, it calls step on the controller. The
/// controller will manage the configuration of the system and return a
/// flag indicating whether the next call is meant to succeed or not.
public protocol TestController {
    ///
    /// - parameter currentSession: `Glacier2.SessionPrx?`
    ///
    /// - parameter currentState: `TestToken`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `TestToken`
    func step(currentSession: Glacier2.SessionPrx?, currentState: TestToken, current: Ice.Current) throws -> TestToken

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func shutdown(current: Ice.Current) throws
}


/// Dispatcher for `TestSession` servants.
public struct TestSessionDisp: Ice.Dispatcher {
    public let servant: TestSession
    private static let defaultObject = Ice.ObjectI<TestSessionTraits>()

    public init(_ servant: TestSession) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "destroy":
            try await servant._iceD_destroy(request)
        case "ice_id":
            try (servant as? Ice.Object ?? TestSessionDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try (servant as? Ice.Object ?? TestSessionDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try (servant as? Ice.Object ?? TestSessionDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try (servant as? Ice.Object ?? TestSessionDisp.defaultObject)._iceD_ice_ping(request)
        case "shutdown":
            try await servant._iceD_shutdown(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol TestSession: Glacier2.Session {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func shutdown(current: Ice.Current) throws
}

/// Backend overview.
///
/// Backend Methods:
///
///  - check: 
///
///  - shutdown: 
extension Backend {
    public func _iceD_check(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()

        try self.check(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_shutdown(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()

        try self.shutdown(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}

/// The test controller interface permits coordination between the test
/// server and the test client. Prior to each call the client makes on
/// various backend references, it calls step on the controller. The
/// controller will manage the configuration of the system and return a
/// flag indicating whether the next call is meant to succeed or not.
///
/// TestController Methods:
///
///  - step: 
///
///  - shutdown: 
extension TestController {
    public func _iceD_step(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_currentSession: Glacier2.SessionPrx? = try istr.read(Glacier2.SessionPrx.self)
        let iceP_currentState: TestToken = try istr.read()

        let iceP_newState = try self.step(currentSession: iceP_currentSession, currentState: iceP_currentState, current: request.current)
        let ostr = request.current.startReplyStream()
        ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
        ostr.write(iceP_newState)
        ostr.endEncapsulation()
        return Ice.OutgoingResponse(ostr)
    }

    public func _iceD_shutdown(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()

        try self.shutdown(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}

/// TestSession overview.
///
/// TestSession Methods:
///
///  - shutdown: 
extension TestSession {
    public func _iceD_shutdown(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()

        try self.shutdown(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}
