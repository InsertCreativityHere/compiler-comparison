//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Internal.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice
import PromiseKit

/// Traits for Slice class`InternalDbEnvDescriptor`.
public struct InternalDbEnvDescriptorTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::InternalDbEnvDescriptor"]
    public static let staticId = "::IceGrid::InternalDbEnvDescriptor"
}

public typealias InternalDbEnvDescriptorSeq = [InternalDbEnvDescriptor?]

/// Helper class to read and write `InternalDbEnvDescriptorSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InternalDbEnvDescriptorSeqHelper {
    /// Read a `InternalDbEnvDescriptorSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `InternalDbEnvDescriptorSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InternalDbEnvDescriptorSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = InternalDbEnvDescriptorSeq(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(InternalDbEnvDescriptor.self) { p.pointee = $0 }
            }
        }
        return v
    }
    /// Read an optional `InternalDbEnvDescriptorSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `InternalDbEnvDescriptorSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InternalDbEnvDescriptorSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `InternalDbEnvDescriptorSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `InternalDbEnvDescriptorSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InternalDbEnvDescriptorSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `InternalDbEnvDescriptorSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `InternalDbEnvDescriptorSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: InternalDbEnvDescriptorSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice class`InternalAdapterDescriptor`.
public struct InternalAdapterDescriptorTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::InternalAdapterDescriptor"]
    public static let staticId = "::IceGrid::InternalAdapterDescriptor"
}

public typealias InternalAdapterDescriptorSeq = [InternalAdapterDescriptor?]

/// Helper class to read and write `InternalAdapterDescriptorSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InternalAdapterDescriptorSeqHelper {
    /// Read a `InternalAdapterDescriptorSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `InternalAdapterDescriptorSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InternalAdapterDescriptorSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = InternalAdapterDescriptorSeq(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(InternalAdapterDescriptor.self) { p.pointee = $0 }
            }
        }
        return v
    }
    /// Read an optional `InternalAdapterDescriptorSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `InternalAdapterDescriptorSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InternalAdapterDescriptorSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `InternalAdapterDescriptorSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `InternalAdapterDescriptorSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InternalAdapterDescriptorSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `InternalAdapterDescriptorSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `InternalAdapterDescriptorSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: InternalAdapterDescriptorSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias PropertyDescriptorSeqDict = [Swift.String: PropertyDescriptorSeq]

/// Helper class to read and write `PropertyDescriptorSeqDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct PropertyDescriptorSeqDictHelper {
    /// Read a `PropertyDescriptorSeqDict` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `PropertyDescriptorSeqDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> PropertyDescriptorSeqDict {
        let sz = try Swift.Int(istr.readSize())
        var v = PropertyDescriptorSeqDict()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: PropertyDescriptorSeq = try PropertyDescriptorSeqHelper.read(from: istr)
            v[key] = value
        }
        return v
    }
    /// Read an optional `PropertyDescriptorSeqDict?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `PropertyDescriptorSeqDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> PropertyDescriptorSeqDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `PropertyDescriptorSeqDict` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `PropertyDescriptorSeqDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: PropertyDescriptorSeqDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            PropertyDescriptorSeqHelper.write(to: ostr, value: value)
        }
    }

    /// Wite an optional `PropertyDescriptorSeqDict?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `PropertyDescriptorSeqDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: PropertyDescriptorSeqDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice class`InternalServerDescriptor`.
public struct InternalServerDescriptorTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::InternalServerDescriptor"]
    public static let staticId = "::IceGrid::InternalServerDescriptor"
}

/// :nodoc:
public class AdapterActiveException_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return AdapterActiveException.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceGrid_AdapterActiveException() -> Ice.UserExceptionTypeResolver {
        return AdapterActiveException_TypeResolver()
    }
}

/// This exception is raised if an adapter is active.
open class AdapterActiveException: Ice.UserException {
    public required init() {}

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::IceGrid::AdapterActiveException"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: AdapterActiveException.ice_staticId(), compactId: -1, last: true)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }
}

/// :nodoc:
public class AdapterNotActiveException_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return AdapterNotActiveException.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceGrid_AdapterNotActiveException() -> Ice.UserExceptionTypeResolver {
        return AdapterNotActiveException_TypeResolver()
    }
}

open class AdapterNotActiveException: Ice.UserException {
    /// True if the adapter can be activated on demand.
    public var activatable: Swift.Bool = false

    public required init() {}

    public init(activatable: Swift.Bool) {
        self.activatable = activatable
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::IceGrid::AdapterNotActiveException"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: AdapterNotActiveException.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.activatable)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.activatable = try istr.read()
        try istr.endSlice()
    }
}

/// Traits for Slice interface`Adapter`.
public struct AdapterTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::Adapter"]
    public static let staticId = "::IceGrid::Adapter"
}

/// :nodoc:
public class AdapterExistsException_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return AdapterExistsException.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceGrid_AdapterExistsException() -> Ice.UserExceptionTypeResolver {
        return AdapterExistsException_TypeResolver()
    }
}

/// This exception is raised if an adapter with the same name already exists.
open class AdapterExistsException: Ice.UserException {
    public var id: Swift.String = ""

    public required init() {}

    public init(id: Swift.String) {
        self.id = id
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::IceGrid::AdapterExistsException"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: AdapterExistsException.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.id)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.id = try istr.read()
        try istr.endSlice()
    }
}

public typealias AdapterPrxDict = [Swift.String: AdapterPrx?]

/// Helper class to read and write `AdapterPrxDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct AdapterPrxDictHelper {
    /// Read a `AdapterPrxDict` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `AdapterPrxDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> AdapterPrxDict {
        let sz = try Swift.Int(istr.readSize())
        var v = AdapterPrxDict()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: AdapterPrx? = try istr.read(AdapterPrx.self)
            v[key] = value
        }
        return v
    }
    /// Read an optional `AdapterPrxDict?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `AdapterPrxDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> AdapterPrxDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `AdapterPrxDict` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `AdapterPrxDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: AdapterPrxDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `AdapterPrxDict?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `AdapterPrxDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: AdapterPrxDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice interface`FileReader`.
public struct FileReaderTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::FileReader"]
    public static let staticId = "::IceGrid::FileReader"
}

/// Traits for Slice interface`Server`.
public struct ServerTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::FileReader", "::IceGrid::Server"]
    public static let staticId = "::IceGrid::Server"
}

public typealias InternalRegistryPrxSeq = [InternalRegistryPrx?]

/// Helper class to read and write `InternalRegistryPrxSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InternalRegistryPrxSeqHelper {
    /// Read a `InternalRegistryPrxSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `InternalRegistryPrxSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InternalRegistryPrxSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = InternalRegistryPrxSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: InternalRegistryPrx? = try istr.read(InternalRegistryPrx.self)
            v.append(j)
        }
        return v
    }
    /// Read an optional `InternalRegistryPrxSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `InternalRegistryPrxSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InternalRegistryPrxSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `InternalRegistryPrxSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `InternalRegistryPrxSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InternalRegistryPrxSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `InternalRegistryPrxSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `InternalRegistryPrxSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: InternalRegistryPrxSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice interface`ReplicaObserver`.
public struct ReplicaObserverTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::ReplicaObserver"]
    public static let staticId = "::IceGrid::ReplicaObserver"
}

/// Traits for Slice interface`Node`.
public struct NodeTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::FileReader", "::IceGrid::Node", "::IceGrid::ReplicaObserver"]
    public static let staticId = "::IceGrid::Node"
}

public typealias NodePrxSeq = [NodePrx?]

/// Helper class to read and write `NodePrxSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct NodePrxSeqHelper {
    /// Read a `NodePrxSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `NodePrxSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> NodePrxSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = NodePrxSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: NodePrx? = try istr.read(NodePrx.self)
            v.append(j)
        }
        return v
    }
    /// Read an optional `NodePrxSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `NodePrxSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> NodePrxSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `NodePrxSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `NodePrxSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: NodePrxSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `NodePrxSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `NodePrxSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: NodePrxSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// :nodoc:
public class NodeActiveException_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return NodeActiveException.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceGrid_NodeActiveException() -> Ice.UserExceptionTypeResolver {
        return NodeActiveException_TypeResolver()
    }
}

/// This exception is raised if a node is already registered and active.
open class NodeActiveException: Ice.UserException {
    public required init() {}

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::IceGrid::NodeActiveException"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: NodeActiveException.ice_staticId(), compactId: -1, last: true)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }
}

/// Traits for Slice interface`NodeSession`.
public struct NodeSessionTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::NodeSession"]
    public static let staticId = "::IceGrid::NodeSession"
}

/// :nodoc:
public class ReplicaActiveException_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return ReplicaActiveException.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceGrid_ReplicaActiveException() -> Ice.UserExceptionTypeResolver {
        return ReplicaActiveException_TypeResolver()
    }
}

/// This exception is raised if a replica is already registered and active.
open class ReplicaActiveException: Ice.UserException {
    public required init() {}

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::IceGrid::ReplicaActiveException"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: ReplicaActiveException.ice_staticId(), compactId: -1, last: true)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }
}

public enum TopicName: Swift.UInt8 {
    /// RegistryObserver
    case RegistryObserver = 0
    /// NodeObserver
    case NodeObserver = 1
    /// ApplicationObserver
    case ApplicationObserver = 2
    /// AdapterObserver
    case AdapterObserver = 3
    /// ObjectObserver
    case ObjectObserver = 4
    public init() {
        self = .RegistryObserver
    }
}

/// An `Ice.InputStream` extension to read `TopicName` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - returns: `TopicName` - The enumarated value.
    func read() throws -> TopicName {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 4)
        guard let val = TopicName(rawValue: rawValue) else {
            throw Ice.MarshalException(reason: "invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `TopicName` - The enumerated value.
    func read(tag: Swift.Int32) throws -> TopicName? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as TopicName
    }
}

/// An `Ice.OutputStream` extension to write `TopicName` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// parameter _: `TopicName` - The enumerator to write.
    func write(_ v: TopicName) {
        write(enum: v.rawValue, maxValue: 4)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// parameter _: `TopicName` - The enumerator to write.
    func write(tag: Swift.Int32, value: TopicName?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 4)
    }
}

/// Traits for Slice interface`DatabaseObserver`.
public struct DatabaseObserverTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::AdapterObserver", "::IceGrid::ApplicationObserver", "::IceGrid::DatabaseObserver", "::IceGrid::ObjectObserver"]
    public static let staticId = "::IceGrid::DatabaseObserver"
}

public typealias StringLongDict = [Swift.String: Swift.Int64]

/// Helper class to read and write `StringLongDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringLongDictHelper {
    /// Read a `StringLongDict` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringLongDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringLongDict {
        let sz = try Swift.Int(istr.readSize())
        var v = StringLongDict()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: Swift.Int64 = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `StringLongDict?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringLongDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringLongDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringLongDict` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringLongDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringLongDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `StringLongDict?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringLongDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: StringLongDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice interface`ReplicaSession`.
public struct ReplicaSessionTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::ReplicaSession"]
    public static let staticId = "::IceGrid::ReplicaSession"
}

/// Traits for Slice class`InternalNodeInfo`.
public struct InternalNodeInfoTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::InternalNodeInfo"]
    public static let staticId = "::IceGrid::InternalNodeInfo"
}

/// Traits for Slice class`InternalReplicaInfo`.
public struct InternalReplicaInfoTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::InternalReplicaInfo"]
    public static let staticId = "::IceGrid::InternalReplicaInfo"
}

/// Traits for Slice interface`InternalRegistry`.
public struct InternalRegistryTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::FileReader", "::IceGrid::InternalRegistry"]
    public static let staticId = "::IceGrid::InternalRegistry"
}

/// AdapterPrx overview.
///
/// AdapterPrx Methods:
///
///  - activate: Activate this adapter.
///
///  - activateAsync: Activate this adapter.
///
///  - getDirectProxy: Get the adapter direct proxy.
///
///  - getDirectProxyAsync: Get the adapter direct proxy.
///
///  - setDirectProxy: Set the direct proxy for this adapter.
///
///  - setDirectProxyAsync: Set the direct proxy for this adapter.
public protocol AdapterPrx: Ice.ObjectPrx {}

private final class AdapterPrxI: Ice.ObjectPrxI, AdapterPrx {
    public override class func ice_staticId() -> Swift.String {
        return AdapterTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `AdapterPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `AdapterPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: AdapterPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> AdapterPrx? {
    return try AdapterPrxI.checkedCast(prx: prx, facet: facet, context: context) as AdapterPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `AdapterPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `AdapterPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: AdapterPrx.Protocol, facet: Swift.String? = nil) -> AdapterPrx {
    return AdapterPrxI.uncheckedCast(prx: prx, facet: facet) as AdapterPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `AdapterPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: AdapterPrx.Protocol) -> Swift.String {
    return AdapterTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `AdapterPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `AdapterPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `AdapterPrx?` - The extracted proxy
    func read(_ type: AdapterPrx.Protocol) throws -> AdapterPrx? {
        return try read() as AdapterPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `AdapterPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `AdapterPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: AdapterPrx.Protocol) throws -> AdapterPrx? {
        return try read(tag: tag) as AdapterPrxI?
    }
}

/// AdapterPrx overview.
///
/// AdapterPrx Methods:
///
///  - activate: Activate this adapter.
///
///  - activateAsync: Activate this adapter.
///
///  - getDirectProxy: Get the adapter direct proxy.
///
///  - getDirectProxyAsync: Get the adapter direct proxy.
///
///  - setDirectProxy: Set the direct proxy for this adapter.
///
///  - setDirectProxyAsync: Set the direct proxy for this adapter.
public extension AdapterPrx {
    /// Activate this adapter. If this adapter can be activated, this will activate the adapter and return the direct
    /// proxy of the adapter once it's active. If this adapter can be activated on demand, this will return 0 if the
    /// adapter is inactive or the adapter direct proxy it's active.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.ObjectPrx?`
    func activate(context: Ice.Context? = nil) throws -> Ice.ObjectPrx? {
        return try _impl._invoke(operation: "activate",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Activate this adapter. If this adapter can be activated, this will activate the adapter and return the direct
    /// proxy of the adapter once it's active. If this adapter can be activated on demand, this will return 0 if the
    /// adapter is inactive or the adapter direct proxy it's active.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Ice.ObjectPrx?>` - The result of the operation
    func activateAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Ice.ObjectPrx?> {
        return _impl._invokeAsync(operation: "activate",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get the adapter direct proxy. The adapter direct proxy is a proxy created with the object adapter. The proxy
    /// contains the last known adapter endpoints.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.ObjectPrx?` - A direct proxy containing the last known adapter endpoints if the adapter is already active.
    func getDirectProxy(context: Ice.Context? = nil) throws -> Ice.ObjectPrx? {
        return try _impl._invoke(operation: "getDirectProxy",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as AdapterNotActiveException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Get the adapter direct proxy. The adapter direct proxy is a proxy created with the object adapter. The proxy
    /// contains the last known adapter endpoints.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Ice.ObjectPrx?>` - The result of the operation
    func getDirectProxyAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Ice.ObjectPrx?> {
        return _impl._invokeAsync(operation: "getDirectProxy",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as AdapterNotActiveException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Set the direct proxy for this adapter.
    ///
    /// - parameter _: `Ice.ObjectPrx?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - AdapterActiveException - The adapter is already active. It's not possible to override the direct proxy of
    ///     an active adapter.
    func setDirectProxy(_ iceP_proxy: Ice.ObjectPrx?, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "setDirectProxy",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_proxy)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as AdapterActiveException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Set the direct proxy for this adapter.
    ///
    /// - parameter _: `Ice.ObjectPrx?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func setDirectProxyAsync(_ iceP_proxy: Ice.ObjectPrx?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "setDirectProxy",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_proxy)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as AdapterActiveException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// FileReaderPrx overview.
///
/// FileReaderPrx Methods:
///
///  - getOffsetFromEnd: Count the number of given lines from the end of the file and return the file offset.
///
///  - getOffsetFromEndAsync: Count the number of given lines from the end of the file and return the file offset.
///
///  - read: Read lines (or size bytes) at the specified position from the given file.
///
///  - readAsync: Read lines (or size bytes) at the specified position from the given file.
public protocol FileReaderPrx: Ice.ObjectPrx {}

private final class FileReaderPrxI: Ice.ObjectPrxI, FileReaderPrx {
    public override class func ice_staticId() -> Swift.String {
        return FileReaderTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `FileReaderPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `FileReaderPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: FileReaderPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> FileReaderPrx? {
    return try FileReaderPrxI.checkedCast(prx: prx, facet: facet, context: context) as FileReaderPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `FileReaderPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `FileReaderPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: FileReaderPrx.Protocol, facet: Swift.String? = nil) -> FileReaderPrx {
    return FileReaderPrxI.uncheckedCast(prx: prx, facet: facet) as FileReaderPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `FileReaderPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: FileReaderPrx.Protocol) -> Swift.String {
    return FileReaderTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `FileReaderPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `FileReaderPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `FileReaderPrx?` - The extracted proxy
    func read(_ type: FileReaderPrx.Protocol) throws -> FileReaderPrx? {
        return try read() as FileReaderPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `FileReaderPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `FileReaderPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: FileReaderPrx.Protocol) throws -> FileReaderPrx? {
        return try read(tag: tag) as FileReaderPrxI?
    }
}

/// FileReaderPrx overview.
///
/// FileReaderPrx Methods:
///
///  - getOffsetFromEnd: Count the number of given lines from the end of the file and return the file offset.
///
///  - getOffsetFromEndAsync: Count the number of given lines from the end of the file and return the file offset.
///
///  - read: Read lines (or size bytes) at the specified position from the given file.
///
///  - readAsync: Read lines (or size bytes) at the specified position from the given file.
public extension FileReaderPrx {
    /// Count the number of given lines from the end of the file and return the file offset.
    ///
    /// - parameter filename: `Swift.String`
    ///
    /// - parameter lines: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Int64`
    func getOffsetFromEnd(filename iceP_filename: Swift.String, lines iceP_lines: Swift.Int32, context: Ice.Context? = nil) throws -> Swift.Int64 {
        return try _impl._invoke(operation: "getOffsetFromEnd",
                                 mode: .Idempotent,
                                 write: { ostr in
                                     ostr.write(iceP_filename)
                                     ostr.write(iceP_lines)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: Swift.Int64 = try istr.read()
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as FileNotAvailableException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Count the number of given lines from the end of the file and return the file offset.
    ///
    /// - parameter filename: `Swift.String`
    ///
    /// - parameter lines: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Int64>` - The result of the operation
    func getOffsetFromEndAsync(filename iceP_filename: Swift.String, lines iceP_lines: Swift.Int32, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Int64> {
        return _impl._invokeAsync(operation: "getOffsetFromEnd",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_filename)
                                      ostr.write(iceP_lines)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: Swift.Int64 = try istr.read()
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as FileNotAvailableException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Read lines (or size bytes) at the specified position from the given file.
    ///
    /// - parameter filename: `Swift.String`
    ///
    /// - parameter pos: `Swift.Int64`
    ///
    /// - parameter size: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: Swift.Bool, newPos: Swift.Int64, lines: Ice.StringSeq)`:
    ///
    ///   - returnValue: `Swift.Bool`
    ///
    ///   - newPos: `Swift.Int64`
    ///
    ///   - lines: `Ice.StringSeq`
    func read(filename iceP_filename: Swift.String, pos iceP_pos: Swift.Int64, size iceP_size: Swift.Int32, context: Ice.Context? = nil) throws -> (returnValue: Swift.Bool, newPos: Swift.Int64, lines: Ice.StringSeq) {
        return try _impl._invoke(operation: "read",
                                 mode: .Idempotent,
                                 write: { ostr in
                                     ostr.write(iceP_filename)
                                     ostr.write(iceP_pos)
                                     ostr.write(iceP_size)
                                 },
                                 read: { istr in
                                     let iceP_newPos: Swift.Int64 = try istr.read()
                                     let iceP_lines: Ice.StringSeq = try istr.read()
                                     let iceP_returnValue: Swift.Bool = try istr.read()
                                     return (iceP_returnValue, iceP_newPos, iceP_lines)
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as FileNotAvailableException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Read lines (or size bytes) at the specified position from the given file.
    ///
    /// - parameter filename: `Swift.String`
    ///
    /// - parameter pos: `Swift.Int64`
    ///
    /// - parameter size: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: Swift.Bool, newPos: Swift.Int64, lines: Ice.StringSeq)>` - The result of the operation
    func readAsync(filename iceP_filename: Swift.String, pos iceP_pos: Swift.Int64, size iceP_size: Swift.Int32, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: Swift.Bool, newPos: Swift.Int64, lines: Ice.StringSeq)> {
        return _impl._invokeAsync(operation: "read",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_filename)
                                      ostr.write(iceP_pos)
                                      ostr.write(iceP_size)
                                  },
                                  read: { istr in
                                      let iceP_newPos: Swift.Int64 = try istr.read()
                                      let iceP_lines: Ice.StringSeq = try istr.read()
                                      let iceP_returnValue: Swift.Bool = try istr.read()
                                      return (iceP_returnValue, iceP_newPos, iceP_lines)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as FileNotAvailableException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// ServerPrx overview.
///
/// ServerPrx Methods:
///
///  - start: Start the server.
///
///  - startAsync: Start the server.
///
///  - stop: Stop the server.
///
///  - stopAsync: Stop the server.
///
///  - checkUpdate: Check if the given server can be loaded on this node.
///
///  - checkUpdateAsync: Check if the given server can be loaded on this node.
///
///  - setEnabled: Enable or disable the server.
///
///  - setEnabledAsync: Enable or disable the server.
///
///  - isEnabled: Check if the server is enabled.
///
///  - isEnabledAsync: Check if the server is enabled.
///
///  - sendSignal: Send signal to the server
///
///  - sendSignalAsync: Send signal to the server
///
///  - writeMessage: Write message on servers' stdout or stderr.
///
///  - writeMessageAsync: Write message on servers' stdout or stderr.
///
///  - getState: Return the server state.
///
///  - getStateAsync: Return the server state.
///
///  - getPid: Get the server pid.
///
///  - getPidAsync: Get the server pid.
///
///  - setProcess: Set the process proxy.
///
///  - setProcessAsync: Set the process proxy.
public protocol ServerPrx: FileReaderPrx {}

private final class ServerPrxI: Ice.ObjectPrxI, ServerPrx {
    public override class func ice_staticId() -> Swift.String {
        return ServerTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `ServerPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `ServerPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: ServerPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> ServerPrx? {
    return try ServerPrxI.checkedCast(prx: prx, facet: facet, context: context) as ServerPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `ServerPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `ServerPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: ServerPrx.Protocol, facet: Swift.String? = nil) -> ServerPrx {
    return ServerPrxI.uncheckedCast(prx: prx, facet: facet) as ServerPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `ServerPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: ServerPrx.Protocol) -> Swift.String {
    return ServerTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `ServerPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `ServerPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `ServerPrx?` - The extracted proxy
    func read(_ type: ServerPrx.Protocol) throws -> ServerPrx? {
        return try read() as ServerPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `ServerPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `ServerPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: ServerPrx.Protocol) throws -> ServerPrx? {
        return try read(tag: tag) as ServerPrxI?
    }
}

/// ServerPrx overview.
///
/// ServerPrx Methods:
///
///  - start: Start the server.
///
///  - startAsync: Start the server.
///
///  - stop: Stop the server.
///
///  - stopAsync: Stop the server.
///
///  - checkUpdate: Check if the given server can be loaded on this node.
///
///  - checkUpdateAsync: Check if the given server can be loaded on this node.
///
///  - setEnabled: Enable or disable the server.
///
///  - setEnabledAsync: Enable or disable the server.
///
///  - isEnabled: Check if the server is enabled.
///
///  - isEnabledAsync: Check if the server is enabled.
///
///  - sendSignal: Send signal to the server
///
///  - sendSignalAsync: Send signal to the server
///
///  - writeMessage: Write message on servers' stdout or stderr.
///
///  - writeMessageAsync: Write message on servers' stdout or stderr.
///
///  - getState: Return the server state.
///
///  - getStateAsync: Return the server state.
///
///  - getPid: Get the server pid.
///
///  - getPidAsync: Get the server pid.
///
///  - setProcess: Set the process proxy.
///
///  - setProcessAsync: Set the process proxy.
public extension ServerPrx {
    /// Start the server.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func start(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "start",
                          mode: .Normal,
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as ServerStartException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Start the server.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func startAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "start",
                                  mode: .Normal,
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ServerStartException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Stop the server. This methods returns only when the server is deactivated. If the server doesn't stop after a
    /// configurable amount of time, it will be killed.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func stop(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "stop",
                          mode: .Normal,
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as ServerStopException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Stop the server. This methods returns only when the server is deactivated. If the server doesn't stop after a
    /// configurable amount of time, it will be killed.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func stopAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "stop",
                                  mode: .Normal,
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ServerStopException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Check if the given server can be loaded on this node.
    ///
    /// - parameter svr: `InternalServerDescriptor?`
    ///
    /// - parameter noRestart: `Swift.Bool`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Bool` - True if the server is inactive.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if the server can't be updated.
    func checkUpdate(svr iceP_svr: InternalServerDescriptor?, noRestart iceP_noRestart: Swift.Bool, context: Ice.Context? = nil) throws -> Swift.Bool {
        return try _impl._invoke(operation: "checkUpdate",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_svr)
                                     ostr.write(iceP_noRestart)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     let iceP_returnValue: Swift.Bool = try istr.read()
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as DeploymentException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Check if the given server can be loaded on this node.
    ///
    /// - parameter svr: `InternalServerDescriptor?`
    ///
    /// - parameter noRestart: `Swift.Bool`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Bool>` - The result of the operation
    func checkUpdateAsync(svr iceP_svr: InternalServerDescriptor?, noRestart iceP_noRestart: Swift.Bool, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Bool> {
        return _impl._invokeAsync(operation: "checkUpdate",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_svr)
                                      ostr.write(iceP_noRestart)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      let iceP_returnValue: Swift.Bool = try istr.read()
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Enable or disable the server.
    ///
    /// - parameter _: `Swift.Bool`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func setEnabled(_ iceP_enable: Swift.Bool, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "setEnabled",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_enable)
                          },
                          context: context)
    }

    /// Enable or disable the server.
    ///
    /// - parameter _: `Swift.Bool`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func setEnabledAsync(_ iceP_enable: Swift.Bool, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "setEnabled",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_enable)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Check if the server is enabled.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Bool`
    func isEnabled(context: Ice.Context? = nil) throws -> Swift.Bool {
        return try _impl._invoke(operation: "isEnabled",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: Swift.Bool = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Check if the server is enabled.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Bool>` - The result of the operation
    func isEnabledAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Bool> {
        return _impl._invokeAsync(operation: "isEnabled",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: Swift.Bool = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Send signal to the server
    ///
    /// - parameter _: `Swift.String`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func sendSignal(_ iceP_signal: Swift.String, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "sendSignal",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_signal)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as BadSignalException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Send signal to the server
    ///
    /// - parameter _: `Swift.String`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func sendSignalAsync(_ iceP_signal: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "sendSignal",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_signal)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as BadSignalException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Write message on servers' stdout or stderr.
    ///
    /// - parameter message: `Swift.String`
    ///
    /// - parameter fd: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func writeMessage(message iceP_message: Swift.String, fd iceP_fd: Swift.Int32, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "writeMessage",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_message)
                              ostr.write(iceP_fd)
                          },
                          context: context)
    }

    /// Write message on servers' stdout or stderr.
    ///
    /// - parameter message: `Swift.String`
    ///
    /// - parameter fd: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func writeMessageAsync(message iceP_message: Swift.String, fd iceP_fd: Swift.Int32, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "writeMessage",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_message)
                                      ostr.write(iceP_fd)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Return the server state.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `ServerState` - The server state.
    func getState(context: Ice.Context? = nil) throws -> ServerState {
        return try _impl._invoke(operation: "getState",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: ServerState = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Return the server state.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<ServerState>` - The result of the operation
    func getStateAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<ServerState> {
        return _impl._invokeAsync(operation: "getState",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: ServerState = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get the server pid. Note that the value returned by this method is system dependant. On Unix operating systems,
    /// it's the pid value returned by the fork() system call and converted to an integer.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Int32`
    func getPid(context: Ice.Context? = nil) throws -> Swift.Int32 {
        return try _impl._invoke(operation: "getPid",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: Swift.Int32 = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get the server pid. Note that the value returned by this method is system dependant. On Unix operating systems,
    /// it's the pid value returned by the fork() system call and converted to an integer.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Int32>` - The result of the operation
    func getPidAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Int32> {
        return _impl._invokeAsync(operation: "getPid",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: Swift.Int32 = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Set the process proxy.
    ///
    /// - parameter _: `Ice.ProcessPrx?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func setProcess(_ iceP_proc: Ice.ProcessPrx?, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "setProcess",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_proc)
                          },
                          context: context)
    }

    /// Set the process proxy.
    ///
    /// - parameter _: `Ice.ProcessPrx?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func setProcessAsync(_ iceP_proc: Ice.ProcessPrx?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "setProcess",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_proc)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// ReplicaObserverPrx overview.
///
/// ReplicaObserverPrx Methods:
///
///  - replicaInit: Initialization of the replica observer.
///
///  - replicaInitAsync: Initialization of the replica observer.
///
///  - replicaAdded: Notification that a replica has been added.
///
///  - replicaAddedAsync: Notification that a replica has been added.
///
///  - replicaRemoved: Notification that a replica has been removed.
///
///  - replicaRemovedAsync: Notification that a replica has been removed.
public protocol ReplicaObserverPrx: Ice.ObjectPrx {}

private final class ReplicaObserverPrxI: Ice.ObjectPrxI, ReplicaObserverPrx {
    public override class func ice_staticId() -> Swift.String {
        return ReplicaObserverTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `ReplicaObserverPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `ReplicaObserverPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: ReplicaObserverPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> ReplicaObserverPrx? {
    return try ReplicaObserverPrxI.checkedCast(prx: prx, facet: facet, context: context) as ReplicaObserverPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `ReplicaObserverPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `ReplicaObserverPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: ReplicaObserverPrx.Protocol, facet: Swift.String? = nil) -> ReplicaObserverPrx {
    return ReplicaObserverPrxI.uncheckedCast(prx: prx, facet: facet) as ReplicaObserverPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `ReplicaObserverPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: ReplicaObserverPrx.Protocol) -> Swift.String {
    return ReplicaObserverTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `ReplicaObserverPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `ReplicaObserverPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `ReplicaObserverPrx?` - The extracted proxy
    func read(_ type: ReplicaObserverPrx.Protocol) throws -> ReplicaObserverPrx? {
        return try read() as ReplicaObserverPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `ReplicaObserverPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `ReplicaObserverPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: ReplicaObserverPrx.Protocol) throws -> ReplicaObserverPrx? {
        return try read(tag: tag) as ReplicaObserverPrxI?
    }
}

/// ReplicaObserverPrx overview.
///
/// ReplicaObserverPrx Methods:
///
///  - replicaInit: Initialization of the replica observer.
///
///  - replicaInitAsync: Initialization of the replica observer.
///
///  - replicaAdded: Notification that a replica has been added.
///
///  - replicaAddedAsync: Notification that a replica has been added.
///
///  - replicaRemoved: Notification that a replica has been removed.
///
///  - replicaRemovedAsync: Notification that a replica has been removed.
public extension ReplicaObserverPrx {
    /// Initialization of the replica observer.
    ///
    /// - parameter _: `InternalRegistryPrxSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func replicaInit(_ iceP_replicas: InternalRegistryPrxSeq, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "replicaInit",
                          mode: .Normal,
                          write: { ostr in
                              InternalRegistryPrxSeqHelper.write(to: ostr, value: iceP_replicas)
                          },
                          context: context)
    }

    /// Initialization of the replica observer.
    ///
    /// - parameter _: `InternalRegistryPrxSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func replicaInitAsync(_ iceP_replicas: InternalRegistryPrxSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "replicaInit",
                                  mode: .Normal,
                                  write: { ostr in
                                      InternalRegistryPrxSeqHelper.write(to: ostr, value: iceP_replicas)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Notification that a replica has been added. The node should establish a session with this new replica.
    ///
    /// - parameter _: `InternalRegistryPrx?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func replicaAdded(_ iceP_replica: InternalRegistryPrx?, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "replicaAdded",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_replica)
                          },
                          context: context)
    }

    /// Notification that a replica has been added. The node should establish a session with this new replica.
    ///
    /// - parameter _: `InternalRegistryPrx?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func replicaAddedAsync(_ iceP_replica: InternalRegistryPrx?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "replicaAdded",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_replica)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Notification that a replica has been removed. The node should destroy the session to this replica.
    ///
    /// - parameter _: `InternalRegistryPrx?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func replicaRemoved(_ iceP_replica: InternalRegistryPrx?, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "replicaRemoved",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_replica)
                          },
                          context: context)
    }

    /// Notification that a replica has been removed. The node should destroy the session to this replica.
    ///
    /// - parameter _: `InternalRegistryPrx?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func replicaRemovedAsync(_ iceP_replica: InternalRegistryPrx?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "replicaRemoved",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_replica)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// NodePrx overview.
///
/// NodePrx Methods:
///
///  - loadServer: Load the given server.
///
///  - loadServerAsync: Load the given server.
///
///  - loadServerWithoutRestart: Load the given server and ensure the server won't be restarted.
///
///  - loadServerWithoutRestartAsync: Load the given server and ensure the server won't be restarted.
///
///  - destroyServer: Destroy the given server.
///
///  - destroyServerAsync: Destroy the given server.
///
///  - destroyServerWithoutRestart: Destroy the server if it's not active.
///
///  - destroyServerWithoutRestartAsync: Destroy the server if it's not active.
///
///  - registerWithReplica: Establish a session to the given replica, this method only returns once the registration was attempted (unlike replicaAdded below).
///
///  - registerWithReplicaAsync: Establish a session to the given replica, this method only returns once the registration was attempted (unlike replicaAdded below).
///
///  - getName: Get the node name.
///
///  - getNameAsync: Get the node name.
///
///  - getHostname: Get the node hostname.
///
///  - getHostnameAsync: Get the node hostname.
///
///  - getLoad: Get the node load.
///
///  - getLoadAsync: Get the node load.
///
///  - getProcessorSocketCount: Get the number of processor sockets for the machine where this node is running.
///
///  - getProcessorSocketCountAsync: Get the number of processor sockets for the machine where this node is running.
///
///  - shutdown: Shutdown the node.
///
///  - shutdownAsync: Shutdown the node.
public protocol NodePrx: FileReaderPrx, ReplicaObserverPrx {}

private final class NodePrxI: Ice.ObjectPrxI, NodePrx {
    public override class func ice_staticId() -> Swift.String {
        return NodeTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `NodePrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `NodePrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: NodePrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> NodePrx? {
    return try NodePrxI.checkedCast(prx: prx, facet: facet, context: context) as NodePrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `NodePrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `NodePrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: NodePrx.Protocol, facet: Swift.String? = nil) -> NodePrx {
    return NodePrxI.uncheckedCast(prx: prx, facet: facet) as NodePrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `NodePrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: NodePrx.Protocol) -> Swift.String {
    return NodeTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `NodePrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `NodePrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `NodePrx?` - The extracted proxy
    func read(_ type: NodePrx.Protocol) throws -> NodePrx? {
        return try read() as NodePrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `NodePrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `NodePrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: NodePrx.Protocol) throws -> NodePrx? {
        return try read(tag: tag) as NodePrxI?
    }
}

/// NodePrx overview.
///
/// NodePrx Methods:
///
///  - loadServer: Load the given server.
///
///  - loadServerAsync: Load the given server.
///
///  - loadServerWithoutRestart: Load the given server and ensure the server won't be restarted.
///
///  - loadServerWithoutRestartAsync: Load the given server and ensure the server won't be restarted.
///
///  - destroyServer: Destroy the given server.
///
///  - destroyServerAsync: Destroy the given server.
///
///  - destroyServerWithoutRestart: Destroy the server if it's not active.
///
///  - destroyServerWithoutRestartAsync: Destroy the server if it's not active.
///
///  - registerWithReplica: Establish a session to the given replica, this method only returns once the registration was attempted (unlike replicaAdded below).
///
///  - registerWithReplicaAsync: Establish a session to the given replica, this method only returns once the registration was attempted (unlike replicaAdded below).
///
///  - getName: Get the node name.
///
///  - getNameAsync: Get the node name.
///
///  - getHostname: Get the node hostname.
///
///  - getHostnameAsync: Get the node hostname.
///
///  - getLoad: Get the node load.
///
///  - getLoadAsync: Get the node load.
///
///  - getProcessorSocketCount: Get the number of processor sockets for the machine where this node is running.
///
///  - getProcessorSocketCountAsync: Get the number of processor sockets for the machine where this node is running.
///
///  - shutdown: Shutdown the node.
///
///  - shutdownAsync: Shutdown the node.
public extension NodePrx {
    /// Load the given server. If the server resources weren't already created (database environment directories,
    /// property files, etc), they will be created. The returned proxy is never null.
    ///
    /// - parameter svr: `InternalServerDescriptor?`
    ///
    /// - parameter replicaName: `Swift.String`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: ServerPrx?, adapters: AdapterPrxDict, activateTimeout: Swift.Int32, deactivateTimeout: Swift.Int32)`:
    ///
    ///   - returnValue: `ServerPrx?`
    ///
    ///   - adapters: `AdapterPrxDict`
    ///
    ///   - activateTimeout: `Swift.Int32`
    ///
    ///   - deactivateTimeout: `Swift.Int32`
    func loadServer(svr iceP_svr: InternalServerDescriptor?, replicaName iceP_replicaName: Swift.String, context: Ice.Context? = nil) throws -> (returnValue: ServerPrx?, adapters: AdapterPrxDict, activateTimeout: Swift.Int32, deactivateTimeout: Swift.Int32) {
        return try _impl._invoke(operation: "loadServer",
                                 mode: .Idempotent,
                                 write: { ostr in
                                     ostr.write(iceP_svr)
                                     ostr.write(iceP_replicaName)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     let iceP_adapters: AdapterPrxDict = try AdapterPrxDictHelper.read(from: istr)
                                     let iceP_activateTimeout: Swift.Int32 = try istr.read()
                                     let iceP_deactivateTimeout: Swift.Int32 = try istr.read()
                                     let iceP_returnValue: ServerPrx? = try istr.read(ServerPrx.self)
                                     return (iceP_returnValue, iceP_adapters, iceP_activateTimeout, iceP_deactivateTimeout)
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as DeploymentException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Load the given server. If the server resources weren't already created (database environment directories,
    /// property files, etc), they will be created. The returned proxy is never null.
    ///
    /// - parameter svr: `InternalServerDescriptor?`
    ///
    /// - parameter replicaName: `Swift.String`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: ServerPrx?, adapters: AdapterPrxDict, activateTimeout: Swift.Int32, deactivateTimeout: Swift.Int32)>` - The result of the operation
    func loadServerAsync(svr iceP_svr: InternalServerDescriptor?, replicaName iceP_replicaName: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: ServerPrx?, adapters: AdapterPrxDict, activateTimeout: Swift.Int32, deactivateTimeout: Swift.Int32)> {
        return _impl._invokeAsync(operation: "loadServer",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_svr)
                                      ostr.write(iceP_replicaName)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      let iceP_adapters: AdapterPrxDict = try AdapterPrxDictHelper.read(from: istr)
                                      let iceP_activateTimeout: Swift.Int32 = try istr.read()
                                      let iceP_deactivateTimeout: Swift.Int32 = try istr.read()
                                      let iceP_returnValue: ServerPrx? = try istr.read(ServerPrx.self)
                                      return (iceP_returnValue, iceP_adapters, iceP_activateTimeout, iceP_deactivateTimeout)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Load the given server and ensure the server won't be restarted. If the server resources weren't already created
    /// (database environment directories, property files, etc), they will be created. If the server can't be updated
    /// without a restart, a DeploymentException is raised. The returned proxy is never null.
    ///
    /// - parameter svr: `InternalServerDescriptor?`
    ///
    /// - parameter replicaName: `Swift.String`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: ServerPrx?, adapters: AdapterPrxDict, activateTimeout: Swift.Int32, deactivateTimeout: Swift.Int32)`:
    ///
    ///   - returnValue: `ServerPrx?`
    ///
    ///   - adapters: `AdapterPrxDict`
    ///
    ///   - activateTimeout: `Swift.Int32`
    ///
    ///   - deactivateTimeout: `Swift.Int32`
    func loadServerWithoutRestart(svr iceP_svr: InternalServerDescriptor?, replicaName iceP_replicaName: Swift.String, context: Ice.Context? = nil) throws -> (returnValue: ServerPrx?, adapters: AdapterPrxDict, activateTimeout: Swift.Int32, deactivateTimeout: Swift.Int32) {
        return try _impl._invoke(operation: "loadServerWithoutRestart",
                                 mode: .Idempotent,
                                 write: { ostr in
                                     ostr.write(iceP_svr)
                                     ostr.write(iceP_replicaName)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     let iceP_adapters: AdapterPrxDict = try AdapterPrxDictHelper.read(from: istr)
                                     let iceP_activateTimeout: Swift.Int32 = try istr.read()
                                     let iceP_deactivateTimeout: Swift.Int32 = try istr.read()
                                     let iceP_returnValue: ServerPrx? = try istr.read(ServerPrx.self)
                                     return (iceP_returnValue, iceP_adapters, iceP_activateTimeout, iceP_deactivateTimeout)
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as DeploymentException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Load the given server and ensure the server won't be restarted. If the server resources weren't already created
    /// (database environment directories, property files, etc), they will be created. If the server can't be updated
    /// without a restart, a DeploymentException is raised. The returned proxy is never null.
    ///
    /// - parameter svr: `InternalServerDescriptor?`
    ///
    /// - parameter replicaName: `Swift.String`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: ServerPrx?, adapters: AdapterPrxDict, activateTimeout: Swift.Int32, deactivateTimeout: Swift.Int32)>` - The result of the operation
    func loadServerWithoutRestartAsync(svr iceP_svr: InternalServerDescriptor?, replicaName iceP_replicaName: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: ServerPrx?, adapters: AdapterPrxDict, activateTimeout: Swift.Int32, deactivateTimeout: Swift.Int32)> {
        return _impl._invokeAsync(operation: "loadServerWithoutRestart",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_svr)
                                      ostr.write(iceP_replicaName)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      let iceP_adapters: AdapterPrxDict = try AdapterPrxDictHelper.read(from: istr)
                                      let iceP_activateTimeout: Swift.Int32 = try istr.read()
                                      let iceP_deactivateTimeout: Swift.Int32 = try istr.read()
                                      let iceP_returnValue: ServerPrx? = try istr.read(ServerPrx.self)
                                      return (iceP_returnValue, iceP_adapters, iceP_activateTimeout, iceP_deactivateTimeout)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Destroy the given server.
    ///
    /// - parameter name: `Swift.String`
    ///
    /// - parameter uuid: `Swift.String`
    ///
    /// - parameter revision: `Swift.Int32`
    ///
    /// - parameter replicaName: `Swift.String`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func destroyServer(name iceP_name: Swift.String, uuid iceP_uuid: Swift.String, revision iceP_revision: Swift.Int32, replicaName iceP_replicaName: Swift.String, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "destroyServer",
                          mode: .Idempotent,
                          write: { ostr in
                              ostr.write(iceP_name)
                              ostr.write(iceP_uuid)
                              ostr.write(iceP_revision)
                              ostr.write(iceP_replicaName)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as DeploymentException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Destroy the given server.
    ///
    /// - parameter name: `Swift.String`
    ///
    /// - parameter uuid: `Swift.String`
    ///
    /// - parameter revision: `Swift.Int32`
    ///
    /// - parameter replicaName: `Swift.String`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func destroyServerAsync(name iceP_name: Swift.String, uuid iceP_uuid: Swift.String, revision iceP_revision: Swift.Int32, replicaName iceP_replicaName: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "destroyServer",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_name)
                                      ostr.write(iceP_uuid)
                                      ostr.write(iceP_revision)
                                      ostr.write(iceP_replicaName)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Destroy the server if it's not active.
    ///
    /// - parameter name: `Swift.String`
    ///
    /// - parameter uuid: `Swift.String`
    ///
    /// - parameter revision: `Swift.Int32`
    ///
    /// - parameter replicaName: `Swift.String`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func destroyServerWithoutRestart(name iceP_name: Swift.String, uuid iceP_uuid: Swift.String, revision iceP_revision: Swift.Int32, replicaName iceP_replicaName: Swift.String, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "destroyServerWithoutRestart",
                          mode: .Idempotent,
                          write: { ostr in
                              ostr.write(iceP_name)
                              ostr.write(iceP_uuid)
                              ostr.write(iceP_revision)
                              ostr.write(iceP_replicaName)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as DeploymentException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Destroy the server if it's not active.
    ///
    /// - parameter name: `Swift.String`
    ///
    /// - parameter uuid: `Swift.String`
    ///
    /// - parameter revision: `Swift.Int32`
    ///
    /// - parameter replicaName: `Swift.String`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func destroyServerWithoutRestartAsync(name iceP_name: Swift.String, uuid iceP_uuid: Swift.String, revision iceP_revision: Swift.Int32, replicaName iceP_replicaName: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "destroyServerWithoutRestart",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_name)
                                      ostr.write(iceP_uuid)
                                      ostr.write(iceP_revision)
                                      ostr.write(iceP_replicaName)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Establish a session to the given replica, this method only returns once the registration was attempted (unlike
    /// replicaAdded below).
    ///
    /// - parameter _: `InternalRegistryPrx?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func registerWithReplica(_ iceP_replica: InternalRegistryPrx?, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "registerWithReplica",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_replica)
                          },
                          context: context)
    }

    /// Establish a session to the given replica, this method only returns once the registration was attempted (unlike
    /// replicaAdded below).
    ///
    /// - parameter _: `InternalRegistryPrx?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func registerWithReplicaAsync(_ iceP_replica: InternalRegistryPrx?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "registerWithReplica",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_replica)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get the node name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String`
    func getName(context: Ice.Context? = nil) throws -> Swift.String {
        return try _impl._invoke(operation: "getName",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: Swift.String = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get the node name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.String>` - The result of the operation
    func getNameAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.String> {
        return _impl._invokeAsync(operation: "getName",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: Swift.String = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get the node hostname.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String`
    func getHostname(context: Ice.Context? = nil) throws -> Swift.String {
        return try _impl._invoke(operation: "getHostname",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: Swift.String = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get the node hostname.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.String>` - The result of the operation
    func getHostnameAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.String> {
        return _impl._invokeAsync(operation: "getHostname",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: Swift.String = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get the node load.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `LoadInfo`
    func getLoad(context: Ice.Context? = nil) throws -> LoadInfo {
        return try _impl._invoke(operation: "getLoad",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: LoadInfo = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get the node load.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<LoadInfo>` - The result of the operation
    func getLoadAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<LoadInfo> {
        return _impl._invokeAsync(operation: "getLoad",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: LoadInfo = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get the number of processor sockets for the machine where this node is running.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Int32`
    func getProcessorSocketCount(context: Ice.Context? = nil) throws -> Swift.Int32 {
        return try _impl._invoke(operation: "getProcessorSocketCount",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: Swift.Int32 = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get the number of processor sockets for the machine where this node is running.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Int32>` - The result of the operation
    func getProcessorSocketCountAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Int32> {
        return _impl._invokeAsync(operation: "getProcessorSocketCount",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: Swift.Int32 = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Shutdown the node.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func shutdown(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "shutdown",
                          mode: .Idempotent,
                          context: context)
    }

    /// Shutdown the node.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func shutdownAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "shutdown",
                                  mode: .Idempotent,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// NodeSessionPrx overview.
///
/// NodeSessionPrx Methods:
///
///  - keepAlive: The node call this method to keep the session alive.
///
///  - keepAliveAsync: The node call this method to keep the session alive.
///
///  - setReplicaObserver: Set the replica observer.
///
///  - setReplicaObserverAsync: Set the replica observer.
///
///  - getTimeout: Return the node session timeout.
///
///  - getTimeoutAsync: Return the node session timeout.
///
///  - getObserver: Return the node observer.
///
///  - getObserverAsync: Return the node observer.
///
///  - loadServers: Ask the registry to load the servers on the node.
///
///  - loadServersAsync: Ask the registry to load the servers on the node.
///
///  - getServers: Get the name of the servers deployed on the node.
///
///  - getServersAsync: Get the name of the servers deployed on the node.
///
///  - waitForApplicationUpdate: Wait for the application update to complete (the application is completely updated once all the registry replicas have been updated).
///
///  - waitForApplicationUpdateAsync: Wait for the application update to complete (the application is completely updated once all the registry replicas have been updated).
///
///  - destroy: Destroy the session.
///
///  - destroyAsync: Destroy the session.
public protocol NodeSessionPrx: Ice.ObjectPrx {}

private final class NodeSessionPrxI: Ice.ObjectPrxI, NodeSessionPrx {
    public override class func ice_staticId() -> Swift.String {
        return NodeSessionTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `NodeSessionPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `NodeSessionPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: NodeSessionPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> NodeSessionPrx? {
    return try NodeSessionPrxI.checkedCast(prx: prx, facet: facet, context: context) as NodeSessionPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `NodeSessionPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `NodeSessionPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: NodeSessionPrx.Protocol, facet: Swift.String? = nil) -> NodeSessionPrx {
    return NodeSessionPrxI.uncheckedCast(prx: prx, facet: facet) as NodeSessionPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `NodeSessionPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: NodeSessionPrx.Protocol) -> Swift.String {
    return NodeSessionTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `NodeSessionPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `NodeSessionPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `NodeSessionPrx?` - The extracted proxy
    func read(_ type: NodeSessionPrx.Protocol) throws -> NodeSessionPrx? {
        return try read() as NodeSessionPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `NodeSessionPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `NodeSessionPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: NodeSessionPrx.Protocol) throws -> NodeSessionPrx? {
        return try read(tag: tag) as NodeSessionPrxI?
    }
}

/// NodeSessionPrx overview.
///
/// NodeSessionPrx Methods:
///
///  - keepAlive: The node call this method to keep the session alive.
///
///  - keepAliveAsync: The node call this method to keep the session alive.
///
///  - setReplicaObserver: Set the replica observer.
///
///  - setReplicaObserverAsync: Set the replica observer.
///
///  - getTimeout: Return the node session timeout.
///
///  - getTimeoutAsync: Return the node session timeout.
///
///  - getObserver: Return the node observer.
///
///  - getObserverAsync: Return the node observer.
///
///  - loadServers: Ask the registry to load the servers on the node.
///
///  - loadServersAsync: Ask the registry to load the servers on the node.
///
///  - getServers: Get the name of the servers deployed on the node.
///
///  - getServersAsync: Get the name of the servers deployed on the node.
///
///  - waitForApplicationUpdate: Wait for the application update to complete (the application is completely updated once all the registry replicas have been updated).
///
///  - waitForApplicationUpdateAsync: Wait for the application update to complete (the application is completely updated once all the registry replicas have been updated).
///
///  - destroy: Destroy the session.
///
///  - destroyAsync: Destroy the session.
public extension NodeSessionPrx {
    /// The node call this method to keep the session alive.
    ///
    /// - parameter _: `LoadInfo`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func keepAlive(_ iceP_load: LoadInfo, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "keepAlive",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_load)
                          },
                          context: context)
    }

    /// The node call this method to keep the session alive.
    ///
    /// - parameter _: `LoadInfo`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func keepAliveAsync(_ iceP_load: LoadInfo, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "keepAlive",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_load)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Set the replica observer. The node calls this method when it's ready to receive notifications for the replicas.
    /// It only calls this for the session with the master.
    ///
    /// - parameter _: `ReplicaObserverPrx?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func setReplicaObserver(_ iceP_observer: ReplicaObserverPrx?, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "setReplicaObserver",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_observer)
                          },
                          context: context)
    }

    /// Set the replica observer. The node calls this method when it's ready to receive notifications for the replicas.
    /// It only calls this for the session with the master.
    ///
    /// - parameter _: `ReplicaObserverPrx?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func setReplicaObserverAsync(_ iceP_observer: ReplicaObserverPrx?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "setReplicaObserver",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_observer)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Return the node session timeout.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Int32`
    func getTimeout(context: Ice.Context? = nil) throws -> Swift.Int32 {
        return try _impl._invoke(operation: "getTimeout",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: Swift.Int32 = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Return the node session timeout.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Int32>` - The result of the operation
    func getTimeoutAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Int32> {
        return _impl._invokeAsync(operation: "getTimeout",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: Swift.Int32 = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Return the node observer.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `NodeObserverPrx?`
    func getObserver(context: Ice.Context? = nil) throws -> NodeObserverPrx? {
        return try _impl._invoke(operation: "getObserver",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: NodeObserverPrx? = try istr.read(NodeObserverPrx.self)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Return the node observer.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<NodeObserverPrx?>` - The result of the operation
    func getObserverAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<NodeObserverPrx?> {
        return _impl._invokeAsync(operation: "getObserver",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: NodeObserverPrx? = try istr.read(NodeObserverPrx.self)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Ask the registry to load the servers on the node.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func loadServers(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "loadServers",
                          mode: .Idempotent,
                          context: context)
    }

    /// Ask the registry to load the servers on the node.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func loadServersAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "loadServers",
                                  mode: .Idempotent,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get the name of the servers deployed on the node.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.StringSeq`
    func getServers(context: Ice.Context? = nil) throws -> Ice.StringSeq {
        return try _impl._invoke(operation: "getServers",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: Ice.StringSeq = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get the name of the servers deployed on the node.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Ice.StringSeq>` - The result of the operation
    func getServersAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Ice.StringSeq> {
        return _impl._invokeAsync(operation: "getServers",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: Ice.StringSeq = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Wait for the application update to complete (the application is completely updated once all the registry
    /// replicas have been updated). This is used by the node to ensure that before to start a server all the
    /// replicas have the up-to-date descriptor of the server.
    ///
    /// - parameter application: `Swift.String`
    ///
    /// - parameter revision: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func waitForApplicationUpdate(application iceP_application: Swift.String, revision iceP_revision: Swift.Int32, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "waitForApplicationUpdate",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_application)
                              ostr.write(iceP_revision)
                          },
                          context: context)
    }

    /// Wait for the application update to complete (the application is completely updated once all the registry
    /// replicas have been updated). This is used by the node to ensure that before to start a server all the
    /// replicas have the up-to-date descriptor of the server.
    ///
    /// - parameter application: `Swift.String`
    ///
    /// - parameter revision: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func waitForApplicationUpdateAsync(application iceP_application: Swift.String, revision iceP_revision: Swift.Int32, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "waitForApplicationUpdate",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_application)
                                      ostr.write(iceP_revision)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Destroy the session.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func destroy(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "destroy",
                          mode: .Normal,
                          context: context)
    }

    /// Destroy the session.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func destroyAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "destroy",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// DatabaseObserverPrx overview.
public protocol DatabaseObserverPrx: ApplicationObserverPrx, ObjectObserverPrx, AdapterObserverPrx {}

private final class DatabaseObserverPrxI: Ice.ObjectPrxI, DatabaseObserverPrx {
    public override class func ice_staticId() -> Swift.String {
        return DatabaseObserverTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `DatabaseObserverPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `DatabaseObserverPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: DatabaseObserverPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> DatabaseObserverPrx? {
    return try DatabaseObserverPrxI.checkedCast(prx: prx, facet: facet, context: context) as DatabaseObserverPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `DatabaseObserverPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `DatabaseObserverPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: DatabaseObserverPrx.Protocol, facet: Swift.String? = nil) -> DatabaseObserverPrx {
    return DatabaseObserverPrxI.uncheckedCast(prx: prx, facet: facet) as DatabaseObserverPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `DatabaseObserverPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: DatabaseObserverPrx.Protocol) -> Swift.String {
    return DatabaseObserverTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `DatabaseObserverPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `DatabaseObserverPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `DatabaseObserverPrx?` - The extracted proxy
    func read(_ type: DatabaseObserverPrx.Protocol) throws -> DatabaseObserverPrx? {
        return try read() as DatabaseObserverPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `DatabaseObserverPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `DatabaseObserverPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: DatabaseObserverPrx.Protocol) throws -> DatabaseObserverPrx? {
        return try read(tag: tag) as DatabaseObserverPrxI?
    }
}

/// DatabaseObserverPrx overview.
public extension DatabaseObserverPrx {}

/// ReplicaSessionPrx overview.
///
/// ReplicaSessionPrx Methods:
///
///  - keepAlive: The replica call this method to keep the session alive.
///
///  - keepAliveAsync: The replica call this method to keep the session alive.
///
///  - getTimeout: Return the replica session timeout.
///
///  - getTimeoutAsync: Return the replica session timeout.
///
///  - setDatabaseObserver: Set the database observer.
///
///  - setDatabaseObserverAsync: Set the database observer.
///
///  - setEndpoints: This method sets the endpoints of the replica.
///
///  - setEndpointsAsync: This method sets the endpoints of the replica.
///
///  - registerWellKnownObjects: Registers the replica well-known objects with the master.
///
///  - registerWellKnownObjectsAsync: Registers the replica well-known objects with the master.
///
///  - setAdapterDirectProxy: Set the adapter direct proxy of the given adapter in the master.
///
///  - setAdapterDirectProxyAsync: Set the adapter direct proxy of the given adapter in the master.
///
///  - receivedUpdate: Notify the master that an update was received.
///
///  - receivedUpdateAsync: Notify the master that an update was received.
///
///  - destroy: Destroy the session.
///
///  - destroyAsync: Destroy the session.
public protocol ReplicaSessionPrx: Ice.ObjectPrx {}

private final class ReplicaSessionPrxI: Ice.ObjectPrxI, ReplicaSessionPrx {
    public override class func ice_staticId() -> Swift.String {
        return ReplicaSessionTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `ReplicaSessionPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `ReplicaSessionPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: ReplicaSessionPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> ReplicaSessionPrx? {
    return try ReplicaSessionPrxI.checkedCast(prx: prx, facet: facet, context: context) as ReplicaSessionPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `ReplicaSessionPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `ReplicaSessionPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: ReplicaSessionPrx.Protocol, facet: Swift.String? = nil) -> ReplicaSessionPrx {
    return ReplicaSessionPrxI.uncheckedCast(prx: prx, facet: facet) as ReplicaSessionPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `ReplicaSessionPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: ReplicaSessionPrx.Protocol) -> Swift.String {
    return ReplicaSessionTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `ReplicaSessionPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `ReplicaSessionPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `ReplicaSessionPrx?` - The extracted proxy
    func read(_ type: ReplicaSessionPrx.Protocol) throws -> ReplicaSessionPrx? {
        return try read() as ReplicaSessionPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `ReplicaSessionPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `ReplicaSessionPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: ReplicaSessionPrx.Protocol) throws -> ReplicaSessionPrx? {
        return try read(tag: tag) as ReplicaSessionPrxI?
    }
}

/// ReplicaSessionPrx overview.
///
/// ReplicaSessionPrx Methods:
///
///  - keepAlive: The replica call this method to keep the session alive.
///
///  - keepAliveAsync: The replica call this method to keep the session alive.
///
///  - getTimeout: Return the replica session timeout.
///
///  - getTimeoutAsync: Return the replica session timeout.
///
///  - setDatabaseObserver: Set the database observer.
///
///  - setDatabaseObserverAsync: Set the database observer.
///
///  - setEndpoints: This method sets the endpoints of the replica.
///
///  - setEndpointsAsync: This method sets the endpoints of the replica.
///
///  - registerWellKnownObjects: Registers the replica well-known objects with the master.
///
///  - registerWellKnownObjectsAsync: Registers the replica well-known objects with the master.
///
///  - setAdapterDirectProxy: Set the adapter direct proxy of the given adapter in the master.
///
///  - setAdapterDirectProxyAsync: Set the adapter direct proxy of the given adapter in the master.
///
///  - receivedUpdate: Notify the master that an update was received.
///
///  - receivedUpdateAsync: Notify the master that an update was received.
///
///  - destroy: Destroy the session.
///
///  - destroyAsync: Destroy the session.
public extension ReplicaSessionPrx {
    /// The replica call this method to keep the session alive.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func keepAlive(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "keepAlive",
                          mode: .Normal,
                          context: context)
    }

    /// The replica call this method to keep the session alive.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func keepAliveAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "keepAlive",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Return the replica session timeout.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Int32`
    func getTimeout(context: Ice.Context? = nil) throws -> Swift.Int32 {
        return try _impl._invoke(operation: "getTimeout",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: Swift.Int32 = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Return the replica session timeout.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Int32>` - The result of the operation
    func getTimeoutAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Int32> {
        return _impl._invokeAsync(operation: "getTimeout",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: Swift.Int32 = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Set the database observer. Once the observer is subscribed, it will receive the database and database updates.
    ///
    /// - parameter dbObs: `DatabaseObserverPrx?`
    ///
    /// - parameter serials: `StringLongDict?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func setDatabaseObserver(dbObs iceP_dbObs: DatabaseObserverPrx?, serials iceP_serials: StringLongDict? = nil, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "setDatabaseObserver",
                          mode: .Idempotent,
                          write: { ostr in
                              ostr.write(iceP_dbObs)
                              StringLongDictHelper.write(to: ostr, tag: 1, value: iceP_serials)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as DeploymentException {
                                  throw error
                              } catch let error as ObserverAlreadyRegisteredException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Set the database observer. Once the observer is subscribed, it will receive the database and database updates.
    ///
    /// - parameter dbObs: `DatabaseObserverPrx?`
    ///
    /// - parameter serials: `StringLongDict?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func setDatabaseObserverAsync(dbObs iceP_dbObs: DatabaseObserverPrx?, serials iceP_serials: StringLongDict? = nil, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "setDatabaseObserver",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_dbObs)
                                      StringLongDictHelper.write(to: ostr, tag: 1, value: iceP_serials)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as DeploymentException {
                                          throw error
                                      } catch let error as ObserverAlreadyRegisteredException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// This method sets the endpoints of the replica. This allows the master to create proxies with multiple endpoints
    /// for replicated objects (e.g.: IceGrid::Query object).
    ///
    /// - parameter _: `StringObjectProxyDict`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func setEndpoints(_ iceP_endpoints: StringObjectProxyDict, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "setEndpoints",
                          mode: .Idempotent,
                          write: { ostr in
                              StringObjectProxyDictHelper.write(to: ostr, value: iceP_endpoints)
                          },
                          context: context)
    }

    /// This method sets the endpoints of the replica. This allows the master to create proxies with multiple endpoints
    /// for replicated objects (e.g.: IceGrid::Query object).
    ///
    /// - parameter _: `StringObjectProxyDict`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func setEndpointsAsync(_ iceP_endpoints: StringObjectProxyDict, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "setEndpoints",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      StringObjectProxyDictHelper.write(to: ostr, value: iceP_endpoints)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Registers the replica well-known objects with the master.
    ///
    /// - parameter _: `ObjectInfoSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func registerWellKnownObjects(_ iceP_objects: ObjectInfoSeq, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "registerWellKnownObjects",
                          mode: .Idempotent,
                          write: { ostr in
                              ObjectInfoSeqHelper.write(to: ostr, value: iceP_objects)
                          },
                          context: context)
    }

    /// Registers the replica well-known objects with the master.
    ///
    /// - parameter _: `ObjectInfoSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func registerWellKnownObjectsAsync(_ iceP_objects: ObjectInfoSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "registerWellKnownObjects",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ObjectInfoSeqHelper.write(to: ostr, value: iceP_objects)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Set the adapter direct proxy of the given adapter in the master. This is used to support dynamic registration
    /// with the locator registry interface.
    ///
    /// - parameter adapterId: `Swift.String`
    ///
    /// - parameter replicaGroupId: `Swift.String`
    ///
    /// - parameter proxy: `Ice.ObjectPrx?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func setAdapterDirectProxy(adapterId iceP_adapterId: Swift.String, replicaGroupId iceP_replicaGroupId: Swift.String, proxy iceP_proxy: Ice.ObjectPrx?, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "setAdapterDirectProxy",
                          mode: .Idempotent,
                          write: { ostr in
                              ostr.write(iceP_adapterId)
                              ostr.write(iceP_replicaGroupId)
                              ostr.write(iceP_proxy)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as AdapterNotExistException {
                                  throw error
                              } catch let error as AdapterExistsException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Set the adapter direct proxy of the given adapter in the master. This is used to support dynamic registration
    /// with the locator registry interface.
    ///
    /// - parameter adapterId: `Swift.String`
    ///
    /// - parameter replicaGroupId: `Swift.String`
    ///
    /// - parameter proxy: `Ice.ObjectPrx?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func setAdapterDirectProxyAsync(adapterId iceP_adapterId: Swift.String, replicaGroupId iceP_replicaGroupId: Swift.String, proxy iceP_proxy: Ice.ObjectPrx?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "setAdapterDirectProxy",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_adapterId)
                                      ostr.write(iceP_replicaGroupId)
                                      ostr.write(iceP_proxy)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as AdapterNotExistException {
                                          throw error
                                      } catch let error as AdapterExistsException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Notify the master that an update was received. The master might wait for replication updates to be received by
    /// all the replicas before to continue.
    ///
    /// - parameter name: `TopicName`
    ///
    /// - parameter serial: `Swift.Int32`
    ///
    /// - parameter failure: `Swift.String`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func receivedUpdate(name iceP_name: TopicName, serial iceP_serial: Swift.Int32, failure iceP_failure: Swift.String, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "receivedUpdate",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_name)
                              ostr.write(iceP_serial)
                              ostr.write(iceP_failure)
                          },
                          context: context)
    }

    /// Notify the master that an update was received. The master might wait for replication updates to be received by
    /// all the replicas before to continue.
    ///
    /// - parameter name: `TopicName`
    ///
    /// - parameter serial: `Swift.Int32`
    ///
    /// - parameter failure: `Swift.String`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func receivedUpdateAsync(name iceP_name: TopicName, serial iceP_serial: Swift.Int32, failure iceP_failure: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "receivedUpdate",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_name)
                                      ostr.write(iceP_serial)
                                      ostr.write(iceP_failure)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Destroy the session.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func destroy(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "destroy",
                          mode: .Normal,
                          context: context)
    }

    /// Destroy the session.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func destroyAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "destroy",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// InternalRegistryPrx overview.
///
/// InternalRegistryPrx Methods:
///
///  - registerNode: Register a node with the registry.
///
///  - registerNodeAsync: Register a node with the registry.
///
///  - registerReplica: Register a replica with the registry.
///
///  - registerReplicaAsync: Register a replica with the registry.
///
///  - registerWithReplica: Create a session with the given registry replica.
///
///  - registerWithReplicaAsync: Create a session with the given registry replica.
///
///  - getNodes: Return the proxies of all the nodes known by this registry.
///
///  - getNodesAsync: Return the proxies of all the nodes known by this registry.
///
///  - getReplicas: Return the proxies of all the registry replicas known by this registry.
///
///  - getReplicasAsync: Return the proxies of all the registry replicas known by this registry.
///
///  - getApplications: Return applications, adapters, objects from this replica.
///
///  - getApplicationsAsync: Return applications, adapters, objects from this replica.
///
///  - getAdapters: 
///
///  - getAdaptersAsync: 
///
///  - getObjects: 
///
///  - getObjectsAsync: 
///
///  - shutdown: Shutdown this registry.
///
///  - shutdownAsync: Shutdown this registry.
public protocol InternalRegistryPrx: FileReaderPrx {}

private final class InternalRegistryPrxI: Ice.ObjectPrxI, InternalRegistryPrx {
    public override class func ice_staticId() -> Swift.String {
        return InternalRegistryTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `InternalRegistryPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `InternalRegistryPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: InternalRegistryPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> InternalRegistryPrx? {
    return try InternalRegistryPrxI.checkedCast(prx: prx, facet: facet, context: context) as InternalRegistryPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `InternalRegistryPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `InternalRegistryPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: InternalRegistryPrx.Protocol, facet: Swift.String? = nil) -> InternalRegistryPrx {
    return InternalRegistryPrxI.uncheckedCast(prx: prx, facet: facet) as InternalRegistryPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `InternalRegistryPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: InternalRegistryPrx.Protocol) -> Swift.String {
    return InternalRegistryTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `InternalRegistryPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `InternalRegistryPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `InternalRegistryPrx?` - The extracted proxy
    func read(_ type: InternalRegistryPrx.Protocol) throws -> InternalRegistryPrx? {
        return try read() as InternalRegistryPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `InternalRegistryPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `InternalRegistryPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: InternalRegistryPrx.Protocol) throws -> InternalRegistryPrx? {
        return try read(tag: tag) as InternalRegistryPrxI?
    }
}

/// InternalRegistryPrx overview.
///
/// InternalRegistryPrx Methods:
///
///  - registerNode: Register a node with the registry.
///
///  - registerNodeAsync: Register a node with the registry.
///
///  - registerReplica: Register a replica with the registry.
///
///  - registerReplicaAsync: Register a replica with the registry.
///
///  - registerWithReplica: Create a session with the given registry replica.
///
///  - registerWithReplicaAsync: Create a session with the given registry replica.
///
///  - getNodes: Return the proxies of all the nodes known by this registry.
///
///  - getNodesAsync: Return the proxies of all the nodes known by this registry.
///
///  - getReplicas: Return the proxies of all the registry replicas known by this registry.
///
///  - getReplicasAsync: Return the proxies of all the registry replicas known by this registry.
///
///  - getApplications: Return applications, adapters, objects from this replica.
///
///  - getApplicationsAsync: Return applications, adapters, objects from this replica.
///
///  - getAdapters: 
///
///  - getAdaptersAsync: 
///
///  - getObjects: 
///
///  - getObjectsAsync: 
///
///  - shutdown: Shutdown this registry.
///
///  - shutdownAsync: Shutdown this registry.
public extension InternalRegistryPrx {
    /// Register a node with the registry. If a node with the same name is already registered,
    /// registerNode overrides the existing registration only when the previously
    /// registered node is not active.
    ///
    /// - parameter info: `InternalNodeInfo?` Some information on the node.
    ///
    /// - parameter prx: `NodePrx?` The proxy of the node.
    ///
    /// - parameter loadInf: `LoadInfo` The load information of the node.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `NodeSessionPrx?` - The node session proxy.
    ///
    /// - throws:
    ///
    ///   - NodeActiveException - Raised if the node is already registered and currently active.
    func registerNode(info iceP_info: InternalNodeInfo?, prx iceP_prx: NodePrx?, loadInf iceP_loadInf: LoadInfo, context: Ice.Context? = nil) throws -> NodeSessionPrx? {
        return try _impl._invoke(operation: "registerNode",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_info)
                                     ostr.write(iceP_prx)
                                     ostr.write(iceP_loadInf)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     let iceP_returnValue: NodeSessionPrx? = try istr.read(NodeSessionPrx.self)
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as NodeActiveException {
                                         throw error
                                     } catch let error as PermissionDeniedException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Register a node with the registry. If a node with the same name is already registered,
    /// registerNode overrides the existing registration only when the previously
    /// registered node is not active.
    ///
    /// - parameter info: `InternalNodeInfo?` Some information on the node.
    ///
    /// - parameter prx: `NodePrx?` The proxy of the node.
    ///
    /// - parameter loadInf: `LoadInfo` The load information of the node.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<NodeSessionPrx?>` - The result of the operation
    func registerNodeAsync(info iceP_info: InternalNodeInfo?, prx iceP_prx: NodePrx?, loadInf iceP_loadInf: LoadInfo, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<NodeSessionPrx?> {
        return _impl._invokeAsync(operation: "registerNode",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_info)
                                      ostr.write(iceP_prx)
                                      ostr.write(iceP_loadInf)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      let iceP_returnValue: NodeSessionPrx? = try istr.read(NodeSessionPrx.self)
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as NodeActiveException {
                                          throw error
                                      } catch let error as PermissionDeniedException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Register a replica with the registry. If a replica with the same name is already registered,
    /// registerReplica overrides the existing registration only when the previously
    /// registered node is not active.
    ///
    /// - parameter info: `InternalReplicaInfo?` Some information on the replica.
    ///
    /// - parameter prx: `InternalRegistryPrx?` The proxy of the replica.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `ReplicaSessionPrx?` - The replica session proxy.
    ///
    /// - throws:
    ///
    ///   - ReplicaActiveException - Raised if the replica is already registered and currently active.
    func registerReplica(info iceP_info: InternalReplicaInfo?, prx iceP_prx: InternalRegistryPrx?, context: Ice.Context? = nil) throws -> ReplicaSessionPrx? {
        return try _impl._invoke(operation: "registerReplica",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_info)
                                     ostr.write(iceP_prx)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     let iceP_returnValue: ReplicaSessionPrx? = try istr.read(ReplicaSessionPrx.self)
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as PermissionDeniedException {
                                         throw error
                                     } catch let error as ReplicaActiveException {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    /// Register a replica with the registry. If a replica with the same name is already registered,
    /// registerReplica overrides the existing registration only when the previously
    /// registered node is not active.
    ///
    /// - parameter info: `InternalReplicaInfo?` Some information on the replica.
    ///
    /// - parameter prx: `InternalRegistryPrx?` The proxy of the replica.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<ReplicaSessionPrx?>` - The result of the operation
    func registerReplicaAsync(info iceP_info: InternalReplicaInfo?, prx iceP_prx: InternalRegistryPrx?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<ReplicaSessionPrx?> {
        return _impl._invokeAsync(operation: "registerReplica",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_info)
                                      ostr.write(iceP_prx)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      let iceP_returnValue: ReplicaSessionPrx? = try istr.read(ReplicaSessionPrx.self)
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as PermissionDeniedException {
                                          throw error
                                      } catch let error as ReplicaActiveException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Create a session with the given registry replica. This method returns only once the session creation has been
    /// attempted.
    ///
    /// - parameter _: `InternalRegistryPrx?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func registerWithReplica(_ iceP_prx: InternalRegistryPrx?, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "registerWithReplica",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_prx)
                          },
                          context: context)
    }

    /// Create a session with the given registry replica. This method returns only once the session creation has been
    /// attempted.
    ///
    /// - parameter _: `InternalRegistryPrx?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func registerWithReplicaAsync(_ iceP_prx: InternalRegistryPrx?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "registerWithReplica",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_prx)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Return the proxies of all the nodes known by this registry.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `NodePrxSeq`
    func getNodes(context: Ice.Context? = nil) throws -> NodePrxSeq {
        return try _impl._invoke(operation: "getNodes",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: NodePrxSeq = try NodePrxSeqHelper.read(from: istr)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Return the proxies of all the nodes known by this registry.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<NodePrxSeq>` - The result of the operation
    func getNodesAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<NodePrxSeq> {
        return _impl._invokeAsync(operation: "getNodes",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: NodePrxSeq = try NodePrxSeqHelper.read(from: istr)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Return the proxies of all the registry replicas known by this registry.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `InternalRegistryPrxSeq`
    func getReplicas(context: Ice.Context? = nil) throws -> InternalRegistryPrxSeq {
        return try _impl._invoke(operation: "getReplicas",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: InternalRegistryPrxSeq = try InternalRegistryPrxSeqHelper.read(from: istr)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Return the proxies of all the registry replicas known by this registry.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<InternalRegistryPrxSeq>` - The result of the operation
    func getReplicasAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<InternalRegistryPrxSeq> {
        return _impl._invokeAsync(operation: "getReplicas",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: InternalRegistryPrxSeq = try InternalRegistryPrxSeqHelper.read(from: istr)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Return applications, adapters, objects from this replica.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: ApplicationInfoSeq, serial: Swift.Int64)`:
    ///
    ///   - returnValue: `ApplicationInfoSeq`
    ///
    ///   - serial: `Swift.Int64`
    func getApplications(context: Ice.Context? = nil) throws -> (returnValue: ApplicationInfoSeq, serial: Swift.Int64) {
        return try _impl._invoke(operation: "getApplications",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_serial: Swift.Int64 = try istr.read()
                                     let iceP_returnValue: ApplicationInfoSeq = try ApplicationInfoSeqHelper.read(from: istr)
                                     try istr.readPendingValues()
                                     return (iceP_returnValue, iceP_serial)
                                 },
                                 context: context)
    }

    /// Return applications, adapters, objects from this replica.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: ApplicationInfoSeq, serial: Swift.Int64)>` - The result of the operation
    func getApplicationsAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: ApplicationInfoSeq, serial: Swift.Int64)> {
        return _impl._invokeAsync(operation: "getApplications",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_serial: Swift.Int64 = try istr.read()
                                      let iceP_returnValue: ApplicationInfoSeq = try ApplicationInfoSeqHelper.read(from: istr)
                                      try istr.readPendingValues()
                                      return (iceP_returnValue, iceP_serial)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: AdapterInfoSeq, serial: Swift.Int64)`:
    ///
    ///   - returnValue: `AdapterInfoSeq`
    ///
    ///   - serial: `Swift.Int64`
    func getAdapters(context: Ice.Context? = nil) throws -> (returnValue: AdapterInfoSeq, serial: Swift.Int64) {
        return try _impl._invoke(operation: "getAdapters",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_serial: Swift.Int64 = try istr.read()
                                     let iceP_returnValue: AdapterInfoSeq = try AdapterInfoSeqHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_serial)
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: AdapterInfoSeq, serial: Swift.Int64)>` - The result of the operation
    func getAdaptersAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: AdapterInfoSeq, serial: Swift.Int64)> {
        return _impl._invokeAsync(operation: "getAdapters",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_serial: Swift.Int64 = try istr.read()
                                      let iceP_returnValue: AdapterInfoSeq = try AdapterInfoSeqHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_serial)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: ObjectInfoSeq, serial: Swift.Int64)`:
    ///
    ///   - returnValue: `ObjectInfoSeq`
    ///
    ///   - serial: `Swift.Int64`
    func getObjects(context: Ice.Context? = nil) throws -> (returnValue: ObjectInfoSeq, serial: Swift.Int64) {
        return try _impl._invoke(operation: "getObjects",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_serial: Swift.Int64 = try istr.read()
                                     let iceP_returnValue: ObjectInfoSeq = try ObjectInfoSeqHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_serial)
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: ObjectInfoSeq, serial: Swift.Int64)>` - The result of the operation
    func getObjectsAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: ObjectInfoSeq, serial: Swift.Int64)> {
        return _impl._invokeAsync(operation: "getObjects",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_serial: Swift.Int64 = try istr.read()
                                      let iceP_returnValue: ObjectInfoSeq = try ObjectInfoSeqHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_serial)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Shutdown this registry.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func shutdown(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "shutdown",
                          mode: .Idempotent,
                          context: context)
    }

    /// Shutdown this registry.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func shutdownAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "shutdown",
                                  mode: .Idempotent,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// :nodoc:
public class InternalDbEnvDescriptor_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return InternalDbEnvDescriptor.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceGrid_InternalDbEnvDescriptor() -> Ice.ValueTypeResolver {
        return InternalDbEnvDescriptor_TypeResolver()
    }
}

open class InternalDbEnvDescriptor: Ice.Value {
    /// The name of the database environment.
    public var name: Swift.String = ""
    /// The database properties.
    public var properties: PropertyDescriptorSeq = PropertyDescriptorSeq()

    public required init() {}

    public init(name: Swift.String, properties: PropertyDescriptorSeq) {
        self.name = name
        self.properties = properties
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return InternalDbEnvDescriptorTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return InternalDbEnvDescriptorTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.name = try istr.read()
        self.properties = try PropertyDescriptorSeqHelper.read(from: istr)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: InternalDbEnvDescriptorTraits.staticId, compactId: -1, last: true)
        ostr.write(self.name)
        PropertyDescriptorSeqHelper.write(to: ostr, value: self.properties)
        ostr.endSlice()
    }
}

/// :nodoc:
public class InternalAdapterDescriptor_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return InternalAdapterDescriptor.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceGrid_InternalAdapterDescriptor() -> Ice.ValueTypeResolver {
        return InternalAdapterDescriptor_TypeResolver()
    }
}

open class InternalAdapterDescriptor: Ice.Value {
    /// The identifier of the server.
    public var id: Swift.String = ""
    /// Specifies if the lifetime of the adapter is the same as the server.
    public var serverLifetime: Swift.Bool = false

    public required init() {}

    public init(id: Swift.String, serverLifetime: Swift.Bool) {
        self.id = id
        self.serverLifetime = serverLifetime
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return InternalAdapterDescriptorTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return InternalAdapterDescriptorTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.id = try istr.read()
        self.serverLifetime = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: InternalAdapterDescriptorTraits.staticId, compactId: -1, last: true)
        ostr.write(self.id)
        ostr.write(self.serverLifetime)
        ostr.endSlice()
    }
}

/// :nodoc:
public class InternalServerDescriptor_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return InternalServerDescriptor.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceGrid_InternalServerDescriptor() -> Ice.ValueTypeResolver {
        return InternalServerDescriptor_TypeResolver()
    }
}

open class InternalServerDescriptor: Ice.Value {
    /// The server ID.
    public var id: Swift.String = ""
    /// The server application
    public var application: Swift.String = ""
    /// The application uuid.
    public var uuid: Swift.String = ""
    /// The application revision.
    public var revision: Swift.Int32 = 0
    /// The id of the session which allocated the server.
    public var sessionId: Swift.String = ""
    /// The server executable.
    public var exe: Swift.String = ""
    /// The server working directory.
    public var pwd: Swift.String = ""
    /// The user ID to use to run the server.
    public var user: Swift.String = ""
    /// The server activation mode.
    public var activation: Swift.String = ""
    /// The server activation timeout.
    public var activationTimeout: Swift.String = ""
    /// The server deactivation timeout.
    public var deactivationTimeout: Swift.String = ""
    /// Specifies if a process object is registered.
    public var processRegistered: Swift.Bool = false
    /// The server command line options.
    public var options: Ice.StringSeq = Ice.StringSeq()
    /// The server environment variables.
    public var envs: Ice.StringSeq = Ice.StringSeq()
    /// The path of the server logs.
    public var logs: Ice.StringSeq = Ice.StringSeq()
    /// The indirect object adapters.
    public var adapters: InternalAdapterDescriptorSeq = InternalAdapterDescriptorSeq()
    public var dbEnvs: InternalDbEnvDescriptorSeq = InternalDbEnvDescriptorSeq()
    /// The configuration files of the server.
    public var properties: PropertyDescriptorSeqDict = PropertyDescriptorSeqDict()
    /// IceBox service names
    public var services: Ice.StringSeq? = nil

    public required init() {}

    public init(id: Swift.String, application: Swift.String, uuid: Swift.String, revision: Swift.Int32, sessionId: Swift.String, exe: Swift.String, pwd: Swift.String, user: Swift.String, activation: Swift.String, activationTimeout: Swift.String, deactivationTimeout: Swift.String, processRegistered: Swift.Bool, options: Ice.StringSeq, envs: Ice.StringSeq, logs: Ice.StringSeq, adapters: InternalAdapterDescriptorSeq, dbEnvs: InternalDbEnvDescriptorSeq, properties: PropertyDescriptorSeqDict, services: Ice.StringSeq?) {
        self.id = id
        self.application = application
        self.uuid = uuid
        self.revision = revision
        self.sessionId = sessionId
        self.exe = exe
        self.pwd = pwd
        self.user = user
        self.activation = activation
        self.activationTimeout = activationTimeout
        self.deactivationTimeout = deactivationTimeout
        self.processRegistered = processRegistered
        self.options = options
        self.envs = envs
        self.logs = logs
        self.adapters = adapters
        self.dbEnvs = dbEnvs
        self.properties = properties
        self.services = services
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return InternalServerDescriptorTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return InternalServerDescriptorTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.id = try istr.read()
        self.application = try istr.read()
        self.uuid = try istr.read()
        self.revision = try istr.read()
        self.sessionId = try istr.read()
        self.exe = try istr.read()
        self.pwd = try istr.read()
        self.user = try istr.read()
        self.activation = try istr.read()
        self.activationTimeout = try istr.read()
        self.deactivationTimeout = try istr.read()
        self.processRegistered = try istr.read()
        self.options = try istr.read()
        self.envs = try istr.read()
        self.logs = try istr.read()
        self.adapters = try InternalAdapterDescriptorSeqHelper.read(from: istr)
        self.dbEnvs = try InternalDbEnvDescriptorSeqHelper.read(from: istr)
        self.properties = try PropertyDescriptorSeqDictHelper.read(from: istr)
        self.services = try istr.read(tag: 1)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: InternalServerDescriptorTraits.staticId, compactId: -1, last: true)
        ostr.write(self.id)
        ostr.write(self.application)
        ostr.write(self.uuid)
        ostr.write(self.revision)
        ostr.write(self.sessionId)
        ostr.write(self.exe)
        ostr.write(self.pwd)
        ostr.write(self.user)
        ostr.write(self.activation)
        ostr.write(self.activationTimeout)
        ostr.write(self.deactivationTimeout)
        ostr.write(self.processRegistered)
        ostr.write(self.options)
        ostr.write(self.envs)
        ostr.write(self.logs)
        InternalAdapterDescriptorSeqHelper.write(to: ostr, value: self.adapters)
        InternalDbEnvDescriptorSeqHelper.write(to: ostr, value: self.dbEnvs)
        PropertyDescriptorSeqDictHelper.write(to: ostr, value: self.properties)
        ostr.write(tag: 1, value: self.services)
        ostr.endSlice()
    }
}

/// :nodoc:
public class InternalNodeInfo_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return InternalNodeInfo.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceGrid_InternalNodeInfo() -> Ice.ValueTypeResolver {
        return InternalNodeInfo_TypeResolver()
    }
}

/// Information about an IceGrid node.
open class InternalNodeInfo: Ice.Value {
    /// The name of the node.
    public var name: Swift.String = ""
    /// The operating system name.
    public var os: Swift.String = ""
    /// The network name of the host running this node (as defined in uname()).
    public var hostname: Swift.String = ""
    /// The operation system release level (as defined in uname()).
    public var release: Swift.String = ""
    /// The operation system version (as defined in uname()).
    public var version: Swift.String = ""
    /// The machine hardware type (as defined in uname()).
    public var machine: Swift.String = ""
    /// The number of processor threads (e.g. 8 on system with 1 quad-core CPU, with 2 threads per core)
    public var nProcessors: Swift.Int32 = 0
    /// The path to the node data directory.
    public var dataDir: Swift.String = ""

    public required init() {}

    public init(name: Swift.String, os: Swift.String, hostname: Swift.String, release: Swift.String, version: Swift.String, machine: Swift.String, nProcessors: Swift.Int32, dataDir: Swift.String) {
        self.name = name
        self.os = os
        self.hostname = hostname
        self.release = release
        self.version = version
        self.machine = machine
        self.nProcessors = nProcessors
        self.dataDir = dataDir
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return InternalNodeInfoTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return InternalNodeInfoTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.name = try istr.read()
        self.os = try istr.read()
        self.hostname = try istr.read()
        self.release = try istr.read()
        self.version = try istr.read()
        self.machine = try istr.read()
        self.nProcessors = try istr.read()
        self.dataDir = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: InternalNodeInfoTraits.staticId, compactId: -1, last: true)
        ostr.write(self.name)
        ostr.write(self.os)
        ostr.write(self.hostname)
        ostr.write(self.release)
        ostr.write(self.version)
        ostr.write(self.machine)
        ostr.write(self.nProcessors)
        ostr.write(self.dataDir)
        ostr.endSlice()
    }
}

/// :nodoc:
public class InternalReplicaInfo_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return InternalReplicaInfo.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceGrid_InternalReplicaInfo() -> Ice.ValueTypeResolver {
        return InternalReplicaInfo_TypeResolver()
    }
}

/// Information about an IceGrid registry replica.
open class InternalReplicaInfo: Ice.Value {
    /// The name of the registry.
    public var name: Swift.String = ""
    /// The network name of the host running this registry (as defined in uname()).
    public var hostname: Swift.String = ""

    public required init() {}

    public init(name: Swift.String, hostname: Swift.String) {
        self.name = name
        self.hostname = hostname
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return InternalReplicaInfoTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return InternalReplicaInfoTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.name = try istr.read()
        self.hostname = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: InternalReplicaInfoTraits.staticId, compactId: -1, last: true)
        ostr.write(self.name)
        ostr.write(self.hostname)
        ostr.endSlice()
    }
}


/// Dispatcher for `Adapter` servants.
public struct AdapterDisp: Ice.Disp {
    public let servant: Adapter
    private static let defaultObject = Ice.ObjectI<AdapterTraits>()

    public init(_ servant: Adapter) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "activate":
            return try servant._iceD_activate(incoming: request, current: current)
        case "getDirectProxy":
            return try servant._iceD_getDirectProxy(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? AdapterDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? AdapterDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? AdapterDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? AdapterDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "setDirectProxy":
            return try servant._iceD_setDirectProxy(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol Adapter {
    /// Activate this adapter. If this adapter can be activated, this will activate the adapter and return the direct
    /// proxy of the adapter once it's active. If this adapter can be activated on demand, this will return 0 if the
    /// adapter is inactive or the adapter direct proxy it's active.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `PromiseKit.Promise<Ice.ObjectPrx?>` - The result of the operation
    func activateAsync(current: Ice.Current) -> PromiseKit.Promise<Ice.ObjectPrx?>

    /// Get the adapter direct proxy. The adapter direct proxy is a proxy created with the object adapter. The proxy
    /// contains the last known adapter endpoints.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.ObjectPrx?` - A direct proxy containing the last known adapter endpoints if the adapter is already active.
    func getDirectProxy(current: Ice.Current) throws -> Ice.ObjectPrx?

    /// Set the direct proxy for this adapter.
    ///
    /// - parameter proxy: `Ice.ObjectPrx?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - AdapterActiveException - The adapter is already active. It's not possible to override the direct proxy of
    ///     an active adapter.
    func setDirectProxy(proxy: Ice.ObjectPrx?, current: Ice.Current) throws
}


/// Dispatcher for `FileReader` servants.
public struct FileReaderDisp: Ice.Disp {
    public let servant: FileReader
    private static let defaultObject = Ice.ObjectI<FileReaderTraits>()

    public init(_ servant: FileReader) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "getOffsetFromEnd":
            return try servant._iceD_getOffsetFromEnd(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? FileReaderDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? FileReaderDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? FileReaderDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? FileReaderDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "read":
            return try servant._iceD_read(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol FileReader {
    /// Count the number of given lines from the end of the file and return the file offset.
    ///
    /// - parameter filename: `Swift.String`
    ///
    /// - parameter lines: `Swift.Int32`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Int64`
    func getOffsetFromEnd(filename: Swift.String, lines: Swift.Int32, current: Ice.Current) throws -> Swift.Int64

    /// Read lines (or size bytes) at the specified position from the given file.
    ///
    /// - parameter filename: `Swift.String`
    ///
    /// - parameter pos: `Swift.Int64`
    ///
    /// - parameter size: `Swift.Int32`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: Swift.Bool, newPos: Swift.Int64, lines: Ice.StringSeq)`:
    ///
    ///   - returnValue: `Swift.Bool`
    ///
    ///   - newPos: `Swift.Int64`
    ///
    ///   - lines: `Ice.StringSeq`
    func read(filename: Swift.String, pos: Swift.Int64, size: Swift.Int32, current: Ice.Current) throws -> (returnValue: Swift.Bool, newPos: Swift.Int64, lines: Ice.StringSeq)
}


/// Dispatcher for `Server` servants.
public struct ServerDisp: Ice.Disp {
    public let servant: Server
    private static let defaultObject = Ice.ObjectI<ServerTraits>()

    public init(_ servant: Server) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "checkUpdate":
            return try servant._iceD_checkUpdate(incoming: request, current: current)
        case "getOffsetFromEnd":
            return try servant._iceD_getOffsetFromEnd(incoming: request, current: current)
        case "getPid":
            return try servant._iceD_getPid(incoming: request, current: current)
        case "getState":
            return try servant._iceD_getState(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? ServerDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? ServerDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? ServerDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? ServerDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "isEnabled":
            return try servant._iceD_isEnabled(incoming: request, current: current)
        case "read":
            return try servant._iceD_read(incoming: request, current: current)
        case "sendSignal":
            return try servant._iceD_sendSignal(incoming: request, current: current)
        case "setEnabled":
            return try servant._iceD_setEnabled(incoming: request, current: current)
        case "setProcess":
            return try servant._iceD_setProcess(incoming: request, current: current)
        case "start":
            return try servant._iceD_start(incoming: request, current: current)
        case "stop":
            return try servant._iceD_stop(incoming: request, current: current)
        case "writeMessage":
            return try servant._iceD_writeMessage(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol Server: FileReader {
    /// Start the server.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func startAsync(current: Ice.Current) -> PromiseKit.Promise<Swift.Void>

    /// Stop the server. This methods returns only when the server is deactivated. If the server doesn't stop after a
    /// configurable amount of time, it will be killed.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func stopAsync(current: Ice.Current) -> PromiseKit.Promise<Swift.Void>

    /// Check if the given server can be loaded on this node.
    ///
    /// - parameter svr: `InternalServerDescriptor?`
    ///
    /// - parameter noRestart: `Swift.Bool`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Bool` - True if the server is inactive.
    ///
    /// - throws:
    ///
    ///   - DeploymentException - Raised if the server can't be updated.
    func checkUpdate(svr: InternalServerDescriptor?, noRestart: Swift.Bool, current: Ice.Current) throws -> Swift.Bool

    /// Enable or disable the server.
    ///
    /// - parameter enable: `Swift.Bool`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func setEnabled(enable: Swift.Bool, current: Ice.Current) throws

    /// Check if the server is enabled.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Bool`
    func isEnabled(current: Ice.Current) throws -> Swift.Bool

    /// Send signal to the server
    ///
    /// - parameter signal: `Swift.String`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func sendSignal(signal: Swift.String, current: Ice.Current) throws

    /// Write message on servers' stdout or stderr.
    ///
    /// - parameter message: `Swift.String`
    ///
    /// - parameter fd: `Swift.Int32`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func writeMessage(message: Swift.String, fd: Swift.Int32, current: Ice.Current) throws

    /// Return the server state.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `ServerState` - The server state.
    func getState(current: Ice.Current) throws -> ServerState

    /// Get the server pid. Note that the value returned by this method is system dependant. On Unix operating systems,
    /// it's the pid value returned by the fork() system call and converted to an integer.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Int32`
    func getPid(current: Ice.Current) throws -> Swift.Int32

    /// Set the process proxy.
    ///
    /// - parameter proc: `Ice.ProcessPrx?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func setProcessAsync(proc: Ice.ProcessPrx?, current: Ice.Current) -> PromiseKit.Promise<Swift.Void>
}


/// Dispatcher for `ReplicaObserver` servants.
public struct ReplicaObserverDisp: Ice.Disp {
    public let servant: ReplicaObserver
    private static let defaultObject = Ice.ObjectI<ReplicaObserverTraits>()

    public init(_ servant: ReplicaObserver) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "ice_id":
            return try (servant as? Object ?? ReplicaObserverDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? ReplicaObserverDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? ReplicaObserverDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? ReplicaObserverDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "replicaAdded":
            return try servant._iceD_replicaAdded(incoming: request, current: current)
        case "replicaInit":
            return try servant._iceD_replicaInit(incoming: request, current: current)
        case "replicaRemoved":
            return try servant._iceD_replicaRemoved(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol ReplicaObserver {
    /// Initialization of the replica observer.
    ///
    /// - parameter replicas: `InternalRegistryPrxSeq`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func replicaInit(replicas: InternalRegistryPrxSeq, current: Ice.Current) throws

    /// Notification that a replica has been added. The node should establish a session with this new replica.
    ///
    /// - parameter replica: `InternalRegistryPrx?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func replicaAdded(replica: InternalRegistryPrx?, current: Ice.Current) throws

    /// Notification that a replica has been removed. The node should destroy the session to this replica.
    ///
    /// - parameter replica: `InternalRegistryPrx?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func replicaRemoved(replica: InternalRegistryPrx?, current: Ice.Current) throws
}


/// Dispatcher for `Node` servants.
public struct NodeDisp: Ice.Disp {
    public let servant: Node
    private static let defaultObject = Ice.ObjectI<NodeTraits>()

    public init(_ servant: Node) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "destroyServer":
            return try servant._iceD_destroyServer(incoming: request, current: current)
        case "destroyServerWithoutRestart":
            return try servant._iceD_destroyServerWithoutRestart(incoming: request, current: current)
        case "getHostname":
            return try servant._iceD_getHostname(incoming: request, current: current)
        case "getLoad":
            return try servant._iceD_getLoad(incoming: request, current: current)
        case "getName":
            return try servant._iceD_getName(incoming: request, current: current)
        case "getOffsetFromEnd":
            return try servant._iceD_getOffsetFromEnd(incoming: request, current: current)
        case "getProcessorSocketCount":
            return try servant._iceD_getProcessorSocketCount(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? NodeDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? NodeDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? NodeDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? NodeDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "loadServer":
            return try servant._iceD_loadServer(incoming: request, current: current)
        case "loadServerWithoutRestart":
            return try servant._iceD_loadServerWithoutRestart(incoming: request, current: current)
        case "read":
            return try servant._iceD_read(incoming: request, current: current)
        case "registerWithReplica":
            return try servant._iceD_registerWithReplica(incoming: request, current: current)
        case "replicaAdded":
            return try servant._iceD_replicaAdded(incoming: request, current: current)
        case "replicaInit":
            return try servant._iceD_replicaInit(incoming: request, current: current)
        case "replicaRemoved":
            return try servant._iceD_replicaRemoved(incoming: request, current: current)
        case "shutdown":
            return try servant._iceD_shutdown(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol Node: FileReader, ReplicaObserver {
    /// Load the given server. If the server resources weren't already created (database environment directories,
    /// property files, etc), they will be created. The returned proxy is never null.
    ///
    /// - parameter svr: `InternalServerDescriptor?`
    ///
    /// - parameter replicaName: `Swift.String`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: ServerPrx?, adapters: AdapterPrxDict, activateTimeout: Swift.Int32, deactivateTimeout: Swift.Int32)>` - The result of the operation
    func loadServerAsync(svr: InternalServerDescriptor?, replicaName: Swift.String, current: Ice.Current) -> PromiseKit.Promise<(returnValue: ServerPrx?, adapters: AdapterPrxDict, activateTimeout: Swift.Int32, deactivateTimeout: Swift.Int32)>

    /// Load the given server and ensure the server won't be restarted. If the server resources weren't already created
    /// (database environment directories, property files, etc), they will be created. If the server can't be updated
    /// without a restart, a DeploymentException is raised. The returned proxy is never null.
    ///
    /// - parameter svr: `InternalServerDescriptor?`
    ///
    /// - parameter replicaName: `Swift.String`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: ServerPrx?, adapters: AdapterPrxDict, activateTimeout: Swift.Int32, deactivateTimeout: Swift.Int32)>` - The result of the operation
    func loadServerWithoutRestartAsync(svr: InternalServerDescriptor?, replicaName: Swift.String, current: Ice.Current) -> PromiseKit.Promise<(returnValue: ServerPrx?, adapters: AdapterPrxDict, activateTimeout: Swift.Int32, deactivateTimeout: Swift.Int32)>

    /// Destroy the given server.
    ///
    /// - parameter name: `Swift.String`
    ///
    /// - parameter uuid: `Swift.String`
    ///
    /// - parameter revision: `Swift.Int32`
    ///
    /// - parameter replicaName: `Swift.String`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func destroyServerAsync(name: Swift.String, uuid: Swift.String, revision: Swift.Int32, replicaName: Swift.String, current: Ice.Current) -> PromiseKit.Promise<Swift.Void>

    /// Destroy the server if it's not active.
    ///
    /// - parameter name: `Swift.String`
    ///
    /// - parameter uuid: `Swift.String`
    ///
    /// - parameter revision: `Swift.Int32`
    ///
    /// - parameter replicaName: `Swift.String`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func destroyServerWithoutRestartAsync(name: Swift.String, uuid: Swift.String, revision: Swift.Int32, replicaName: Swift.String, current: Ice.Current) -> PromiseKit.Promise<Swift.Void>

    /// Establish a session to the given replica, this method only returns once the registration was attempted (unlike
    /// replicaAdded below).
    ///
    /// - parameter replica: `InternalRegistryPrx?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func registerWithReplica(replica: InternalRegistryPrx?, current: Ice.Current) throws

    /// Get the node name.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String`
    func getName(current: Ice.Current) throws -> Swift.String

    /// Get the node hostname.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String`
    func getHostname(current: Ice.Current) throws -> Swift.String

    /// Get the node load.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `LoadInfo`
    func getLoad(current: Ice.Current) throws -> LoadInfo

    /// Get the number of processor sockets for the machine where this node is running.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Int32`
    func getProcessorSocketCount(current: Ice.Current) throws -> Swift.Int32

    /// Shutdown the node.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func shutdown(current: Ice.Current) throws
}


/// Dispatcher for `NodeSession` servants.
public struct NodeSessionDisp: Ice.Disp {
    public let servant: NodeSession
    private static let defaultObject = Ice.ObjectI<NodeSessionTraits>()

    public init(_ servant: NodeSession) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "destroy":
            return try servant._iceD_destroy(incoming: request, current: current)
        case "getObserver":
            return try servant._iceD_getObserver(incoming: request, current: current)
        case "getServers":
            return try servant._iceD_getServers(incoming: request, current: current)
        case "getTimeout":
            return try servant._iceD_getTimeout(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? NodeSessionDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? NodeSessionDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? NodeSessionDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? NodeSessionDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "keepAlive":
            return try servant._iceD_keepAlive(incoming: request, current: current)
        case "loadServers":
            return try servant._iceD_loadServers(incoming: request, current: current)
        case "setReplicaObserver":
            return try servant._iceD_setReplicaObserver(incoming: request, current: current)
        case "waitForApplicationUpdate":
            return try servant._iceD_waitForApplicationUpdate(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol NodeSession {
    /// The node call this method to keep the session alive.
    ///
    /// - parameter load: `LoadInfo`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func keepAlive(load: LoadInfo, current: Ice.Current) throws

    /// Set the replica observer. The node calls this method when it's ready to receive notifications for the replicas.
    /// It only calls this for the session with the master.
    ///
    /// - parameter observer: `ReplicaObserverPrx?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func setReplicaObserver(observer: ReplicaObserverPrx?, current: Ice.Current) throws

    /// Return the node session timeout.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Int32`
    func getTimeout(current: Ice.Current) throws -> Swift.Int32

    /// Return the node observer.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `NodeObserverPrx?`
    func getObserver(current: Ice.Current) throws -> NodeObserverPrx?

    /// Ask the registry to load the servers on the node.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func loadServersAsync(current: Ice.Current) -> PromiseKit.Promise<Swift.Void>

    /// Get the name of the servers deployed on the node.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.StringSeq`
    func getServers(current: Ice.Current) throws -> Ice.StringSeq

    /// Wait for the application update to complete (the application is completely updated once all the registry
    /// replicas have been updated). This is used by the node to ensure that before to start a server all the
    /// replicas have the up-to-date descriptor of the server.
    ///
    /// - parameter application: `Swift.String`
    ///
    /// - parameter revision: `Swift.Int32`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func waitForApplicationUpdateAsync(application: Swift.String, revision: Swift.Int32, current: Ice.Current) -> PromiseKit.Promise<Swift.Void>

    /// Destroy the session.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func destroy(current: Ice.Current) throws
}


/// Dispatcher for `DatabaseObserver` servants.
public struct DatabaseObserverDisp: Ice.Disp {
    public let servant: DatabaseObserver
    private static let defaultObject = Ice.ObjectI<DatabaseObserverTraits>()

    public init(_ servant: DatabaseObserver) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "adapterAdded":
            return try servant._iceD_adapterAdded(incoming: request, current: current)
        case "adapterInit":
            return try servant._iceD_adapterInit(incoming: request, current: current)
        case "adapterRemoved":
            return try servant._iceD_adapterRemoved(incoming: request, current: current)
        case "adapterUpdated":
            return try servant._iceD_adapterUpdated(incoming: request, current: current)
        case "applicationAdded":
            return try servant._iceD_applicationAdded(incoming: request, current: current)
        case "applicationInit":
            return try servant._iceD_applicationInit(incoming: request, current: current)
        case "applicationRemoved":
            return try servant._iceD_applicationRemoved(incoming: request, current: current)
        case "applicationUpdated":
            return try servant._iceD_applicationUpdated(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? DatabaseObserverDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? DatabaseObserverDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? DatabaseObserverDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? DatabaseObserverDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "objectAdded":
            return try servant._iceD_objectAdded(incoming: request, current: current)
        case "objectInit":
            return try servant._iceD_objectInit(incoming: request, current: current)
        case "objectRemoved":
            return try servant._iceD_objectRemoved(incoming: request, current: current)
        case "objectUpdated":
            return try servant._iceD_objectUpdated(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol DatabaseObserver: ApplicationObserver, ObjectObserver, AdapterObserver {}


/// Dispatcher for `ReplicaSession` servants.
public struct ReplicaSessionDisp: Ice.Disp {
    public let servant: ReplicaSession
    private static let defaultObject = Ice.ObjectI<ReplicaSessionTraits>()

    public init(_ servant: ReplicaSession) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "destroy":
            return try servant._iceD_destroy(incoming: request, current: current)
        case "getTimeout":
            return try servant._iceD_getTimeout(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? ReplicaSessionDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? ReplicaSessionDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? ReplicaSessionDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? ReplicaSessionDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "keepAlive":
            return try servant._iceD_keepAlive(incoming: request, current: current)
        case "receivedUpdate":
            return try servant._iceD_receivedUpdate(incoming: request, current: current)
        case "registerWellKnownObjects":
            return try servant._iceD_registerWellKnownObjects(incoming: request, current: current)
        case "setAdapterDirectProxy":
            return try servant._iceD_setAdapterDirectProxy(incoming: request, current: current)
        case "setDatabaseObserver":
            return try servant._iceD_setDatabaseObserver(incoming: request, current: current)
        case "setEndpoints":
            return try servant._iceD_setEndpoints(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol ReplicaSession {
    /// The replica call this method to keep the session alive.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func keepAlive(current: Ice.Current) throws

    /// Return the replica session timeout.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Int32`
    func getTimeout(current: Ice.Current) throws -> Swift.Int32

    /// Set the database observer. Once the observer is subscribed, it will receive the database and database updates.
    ///
    /// - parameter dbObs: `DatabaseObserverPrx?`
    ///
    /// - parameter serials: `StringLongDict?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func setDatabaseObserver(dbObs: DatabaseObserverPrx?, serials: StringLongDict?, current: Ice.Current) throws

    /// This method sets the endpoints of the replica. This allows the master to create proxies with multiple endpoints
    /// for replicated objects (e.g.: IceGrid::Query object).
    ///
    /// - parameter endpoints: `StringObjectProxyDict`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func setEndpoints(endpoints: StringObjectProxyDict, current: Ice.Current) throws

    /// Registers the replica well-known objects with the master.
    ///
    /// - parameter objects: `ObjectInfoSeq`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func registerWellKnownObjects(objects: ObjectInfoSeq, current: Ice.Current) throws

    /// Set the adapter direct proxy of the given adapter in the master. This is used to support dynamic registration
    /// with the locator registry interface.
    ///
    /// - parameter adapterId: `Swift.String`
    ///
    /// - parameter replicaGroupId: `Swift.String`
    ///
    /// - parameter proxy: `Ice.ObjectPrx?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func setAdapterDirectProxy(adapterId: Swift.String, replicaGroupId: Swift.String, proxy: Ice.ObjectPrx?, current: Ice.Current) throws

    /// Notify the master that an update was received. The master might wait for replication updates to be received by
    /// all the replicas before to continue.
    ///
    /// - parameter name: `TopicName`
    ///
    /// - parameter serial: `Swift.Int32`
    ///
    /// - parameter failure: `Swift.String`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func receivedUpdate(name: TopicName, serial: Swift.Int32, failure: Swift.String, current: Ice.Current) throws

    /// Destroy the session.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func destroy(current: Ice.Current) throws
}


/// Dispatcher for `InternalRegistry` servants.
public struct InternalRegistryDisp: Ice.Disp {
    public let servant: InternalRegistry
    private static let defaultObject = Ice.ObjectI<InternalRegistryTraits>()

    public init(_ servant: InternalRegistry) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "getAdapters":
            return try servant._iceD_getAdapters(incoming: request, current: current)
        case "getApplications":
            return try servant._iceD_getApplications(incoming: request, current: current)
        case "getNodes":
            return try servant._iceD_getNodes(incoming: request, current: current)
        case "getObjects":
            return try servant._iceD_getObjects(incoming: request, current: current)
        case "getOffsetFromEnd":
            return try servant._iceD_getOffsetFromEnd(incoming: request, current: current)
        case "getReplicas":
            return try servant._iceD_getReplicas(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? InternalRegistryDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? InternalRegistryDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? InternalRegistryDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? InternalRegistryDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "read":
            return try servant._iceD_read(incoming: request, current: current)
        case "registerNode":
            return try servant._iceD_registerNode(incoming: request, current: current)
        case "registerReplica":
            return try servant._iceD_registerReplica(incoming: request, current: current)
        case "registerWithReplica":
            return try servant._iceD_registerWithReplica(incoming: request, current: current)
        case "shutdown":
            return try servant._iceD_shutdown(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol InternalRegistry: FileReader {
    /// Register a node with the registry. If a node with the same name is already registered,
    /// registerNode overrides the existing registration only when the previously
    /// registered node is not active.
    ///
    /// - parameter info: `InternalNodeInfo?` Some information on the node.
    ///
    /// - parameter prx: `NodePrx?` The proxy of the node.
    ///
    /// - parameter loadInf: `LoadInfo` The load information of the node.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `NodeSessionPrx?` - The node session proxy.
    ///
    /// - throws:
    ///
    ///   - NodeActiveException - Raised if the node is already registered and currently active.
    func registerNode(info: InternalNodeInfo?, prx: NodePrx?, loadInf: LoadInfo, current: Ice.Current) throws -> NodeSessionPrx?

    /// Register a replica with the registry. If a replica with the same name is already registered,
    /// registerReplica overrides the existing registration only when the previously
    /// registered node is not active.
    ///
    /// - parameter info: `InternalReplicaInfo?` Some information on the replica.
    ///
    /// - parameter prx: `InternalRegistryPrx?` The proxy of the replica.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `ReplicaSessionPrx?` - The replica session proxy.
    ///
    /// - throws:
    ///
    ///   - ReplicaActiveException - Raised if the replica is already registered and currently active.
    func registerReplica(info: InternalReplicaInfo?, prx: InternalRegistryPrx?, current: Ice.Current) throws -> ReplicaSessionPrx?

    /// Create a session with the given registry replica. This method returns only once the session creation has been
    /// attempted.
    ///
    /// - parameter prx: `InternalRegistryPrx?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func registerWithReplica(prx: InternalRegistryPrx?, current: Ice.Current) throws

    /// Return the proxies of all the nodes known by this registry.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `NodePrxSeq`
    func getNodes(current: Ice.Current) throws -> NodePrxSeq

    /// Return the proxies of all the registry replicas known by this registry.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `InternalRegistryPrxSeq`
    func getReplicas(current: Ice.Current) throws -> InternalRegistryPrxSeq

    /// Return applications, adapters, objects from this replica.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: ApplicationInfoSeq, serial: Swift.Int64)`:
    ///
    ///   - returnValue: `ApplicationInfoSeq`
    ///
    ///   - serial: `Swift.Int64`
    func getApplications(current: Ice.Current) throws -> (returnValue: ApplicationInfoSeq, serial: Swift.Int64)

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: AdapterInfoSeq, serial: Swift.Int64)`:
    ///
    ///   - returnValue: `AdapterInfoSeq`
    ///
    ///   - serial: `Swift.Int64`
    func getAdapters(current: Ice.Current) throws -> (returnValue: AdapterInfoSeq, serial: Swift.Int64)

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: ObjectInfoSeq, serial: Swift.Int64)`:
    ///
    ///   - returnValue: `ObjectInfoSeq`
    ///
    ///   - serial: `Swift.Int64`
    func getObjects(current: Ice.Current) throws -> (returnValue: ObjectInfoSeq, serial: Swift.Int64)

    /// Shutdown this registry.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func shutdown(current: Ice.Current) throws
}

/// Adapter overview.
///
/// Adapter Methods:
///
///  - activate: Activate this adapter.
///
///  - getDirectProxy: Get the adapter direct proxy.
///
///  - setDirectProxy: Set the direct proxy for this adapter.
public extension Adapter {
    func _iceD_activate(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        return inS.setResultPromise(activateAsync(current: current)) { (ostr, retVals) in
            let iceP_returnValue = retVals
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_getDirectProxy(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getDirectProxy(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_setDirectProxy(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_proxy: Ice.ObjectPrx? = try inS.read { istr in
            let iceP_proxy: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
            return iceP_proxy
        }

        try self.setDirectProxy(proxy: iceP_proxy, current: current)

        return inS.setResult()
    }
}

/// FileReader overview.
///
/// FileReader Methods:
///
///  - getOffsetFromEnd: Count the number of given lines from the end of the file and return the file offset.
///
///  - read: Read lines (or size bytes) at the specified position from the given file.
public extension FileReader {
    func _iceD_getOffsetFromEnd(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_filename, iceP_lines): (Swift.String, Swift.Int32) = try inS.read { istr in
            let iceP_filename: Swift.String = try istr.read()
            let iceP_lines: Swift.Int32 = try istr.read()
            return (iceP_filename, iceP_lines)
        }

        let iceP_returnValue = try self.getOffsetFromEnd(filename: iceP_filename, lines: iceP_lines, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_read(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_filename, iceP_pos, iceP_size): (Swift.String, Swift.Int64, Swift.Int32) = try inS.read { istr in
            let iceP_filename: Swift.String = try istr.read()
            let iceP_pos: Swift.Int64 = try istr.read()
            let iceP_size: Swift.Int32 = try istr.read()
            return (iceP_filename, iceP_pos, iceP_size)
        }

        let (iceP_returnValue, iceP_newPos, iceP_lines) = try self.read(filename: iceP_filename, pos: iceP_pos, size: iceP_size, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_newPos)
            ostr.write(iceP_lines)
            ostr.write(iceP_returnValue)
        }
    }
}

/// Server overview.
///
/// Server Methods:
///
///  - start: Start the server.
///
///  - stop: Stop the server.
///
///  - checkUpdate: Check if the given server can be loaded on this node.
///
///  - setEnabled: Enable or disable the server.
///
///  - isEnabled: Check if the server is enabled.
///
///  - sendSignal: Send signal to the server
///
///  - writeMessage: Write message on servers' stdout or stderr.
///
///  - getState: Return the server state.
///
///  - getPid: Get the server pid.
///
///  - setProcess: Set the process proxy.
public extension Server {
    func _iceD_start(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        return inS.setResultPromise(startAsync(current: current))
    }

    func _iceD_stop(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        return inS.setResultPromise(stopAsync(current: current))
    }

    func _iceD_checkUpdate(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_svr, iceP_noRestart): (InternalServerDescriptor?, Swift.Bool) = try inS.read { istr in
            var iceP_svr: InternalServerDescriptor?
            try istr.read(InternalServerDescriptor.self) { iceP_svr = $0 }
            let iceP_noRestart: Swift.Bool = try istr.read()
            try istr.readPendingValues()
            return (iceP_svr, iceP_noRestart)
        }

        let iceP_returnValue = try self.checkUpdate(svr: iceP_svr, noRestart: iceP_noRestart, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_setEnabled(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_enable: Swift.Bool = try inS.read { istr in
            let iceP_enable: Swift.Bool = try istr.read()
            return iceP_enable
        }

        try self.setEnabled(enable: iceP_enable, current: current)

        return inS.setResult()
    }

    func _iceD_isEnabled(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.isEnabled(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_sendSignal(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_signal: Swift.String = try inS.read { istr in
            let iceP_signal: Swift.String = try istr.read()
            return iceP_signal
        }

        try self.sendSignal(signal: iceP_signal, current: current)

        return inS.setResult()
    }

    func _iceD_writeMessage(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_message, iceP_fd): (Swift.String, Swift.Int32) = try inS.read { istr in
            let iceP_message: Swift.String = try istr.read()
            let iceP_fd: Swift.Int32 = try istr.read()
            return (iceP_message, iceP_fd)
        }

        try self.writeMessage(message: iceP_message, fd: iceP_fd, current: current)

        return inS.setResult()
    }

    func _iceD_getState(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getState(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_getPid(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getPid(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_setProcess(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_proc: Ice.ProcessPrx? = try inS.read { istr in
            let iceP_proc: Ice.ProcessPrx? = try istr.read(Ice.ProcessPrx.self)
            return iceP_proc
        }

        return inS.setResultPromise(setProcessAsync(proc: iceP_proc, current: current))
    }
}

/// ReplicaObserver overview.
///
/// ReplicaObserver Methods:
///
///  - replicaInit: Initialization of the replica observer.
///
///  - replicaAdded: Notification that a replica has been added.
///
///  - replicaRemoved: Notification that a replica has been removed.
public extension ReplicaObserver {
    func _iceD_replicaInit(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_replicas: InternalRegistryPrxSeq = try inS.read { istr in
            let iceP_replicas: InternalRegistryPrxSeq = try InternalRegistryPrxSeqHelper.read(from: istr)
            return iceP_replicas
        }

        try self.replicaInit(replicas: iceP_replicas, current: current)

        return inS.setResult()
    }

    func _iceD_replicaAdded(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_replica: InternalRegistryPrx? = try inS.read { istr in
            let iceP_replica: InternalRegistryPrx? = try istr.read(InternalRegistryPrx.self)
            return iceP_replica
        }

        try self.replicaAdded(replica: iceP_replica, current: current)

        return inS.setResult()
    }

    func _iceD_replicaRemoved(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_replica: InternalRegistryPrx? = try inS.read { istr in
            let iceP_replica: InternalRegistryPrx? = try istr.read(InternalRegistryPrx.self)
            return iceP_replica
        }

        try self.replicaRemoved(replica: iceP_replica, current: current)

        return inS.setResult()
    }
}

/// Node overview.
///
/// Node Methods:
///
///  - loadServer: Load the given server.
///
///  - loadServerWithoutRestart: Load the given server and ensure the server won't be restarted.
///
///  - destroyServer: Destroy the given server.
///
///  - destroyServerWithoutRestart: Destroy the server if it's not active.
///
///  - registerWithReplica: Establish a session to the given replica, this method only returns once the registration was attempted (unlike replicaAdded below).
///
///  - getName: Get the node name.
///
///  - getHostname: Get the node hostname.
///
///  - getLoad: Get the node load.
///
///  - getProcessorSocketCount: Get the number of processor sockets for the machine where this node is running.
///
///  - shutdown: Shutdown the node.
public extension Node {
    func _iceD_loadServer(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_svr, iceP_replicaName): (InternalServerDescriptor?, Swift.String) = try inS.read { istr in
            var iceP_svr: InternalServerDescriptor?
            try istr.read(InternalServerDescriptor.self) { iceP_svr = $0 }
            let iceP_replicaName: Swift.String = try istr.read()
            try istr.readPendingValues()
            return (iceP_svr, iceP_replicaName)
        }

        return inS.setResultPromise(loadServerAsync(svr: iceP_svr, replicaName: iceP_replicaName, current: current)) { (ostr, retVals) in
            let (iceP_returnValue, iceP_adapters, iceP_activateTimeout, iceP_deactivateTimeout) = retVals
            AdapterPrxDictHelper.write(to: ostr, value: iceP_adapters)
            ostr.write(iceP_activateTimeout)
            ostr.write(iceP_deactivateTimeout)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_loadServerWithoutRestart(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_svr, iceP_replicaName): (InternalServerDescriptor?, Swift.String) = try inS.read { istr in
            var iceP_svr: InternalServerDescriptor?
            try istr.read(InternalServerDescriptor.self) { iceP_svr = $0 }
            let iceP_replicaName: Swift.String = try istr.read()
            try istr.readPendingValues()
            return (iceP_svr, iceP_replicaName)
        }

        return inS.setResultPromise(loadServerWithoutRestartAsync(svr: iceP_svr, replicaName: iceP_replicaName, current: current)) { (ostr, retVals) in
            let (iceP_returnValue, iceP_adapters, iceP_activateTimeout, iceP_deactivateTimeout) = retVals
            AdapterPrxDictHelper.write(to: ostr, value: iceP_adapters)
            ostr.write(iceP_activateTimeout)
            ostr.write(iceP_deactivateTimeout)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_destroyServer(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_name, iceP_uuid, iceP_revision, iceP_replicaName): (Swift.String, Swift.String, Swift.Int32, Swift.String) = try inS.read { istr in
            let iceP_name: Swift.String = try istr.read()
            let iceP_uuid: Swift.String = try istr.read()
            let iceP_revision: Swift.Int32 = try istr.read()
            let iceP_replicaName: Swift.String = try istr.read()
            return (iceP_name, iceP_uuid, iceP_revision, iceP_replicaName)
        }

        return inS.setResultPromise(destroyServerAsync(name: iceP_name, uuid: iceP_uuid, revision: iceP_revision, replicaName: iceP_replicaName, current: current))
    }

    func _iceD_destroyServerWithoutRestart(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_name, iceP_uuid, iceP_revision, iceP_replicaName): (Swift.String, Swift.String, Swift.Int32, Swift.String) = try inS.read { istr in
            let iceP_name: Swift.String = try istr.read()
            let iceP_uuid: Swift.String = try istr.read()
            let iceP_revision: Swift.Int32 = try istr.read()
            let iceP_replicaName: Swift.String = try istr.read()
            return (iceP_name, iceP_uuid, iceP_revision, iceP_replicaName)
        }

        return inS.setResultPromise(destroyServerWithoutRestartAsync(name: iceP_name, uuid: iceP_uuid, revision: iceP_revision, replicaName: iceP_replicaName, current: current))
    }

    func _iceD_registerWithReplica(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_replica: InternalRegistryPrx? = try inS.read { istr in
            let iceP_replica: InternalRegistryPrx? = try istr.read(InternalRegistryPrx.self)
            return iceP_replica
        }

        try self.registerWithReplica(replica: iceP_replica, current: current)

        return inS.setResult()
    }

    func _iceD_getName(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getName(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_getHostname(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getHostname(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_getLoad(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getLoad(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_getProcessorSocketCount(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getProcessorSocketCount(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_shutdown(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.shutdown(current: current)

        return inS.setResult()
    }
}

/// NodeSession overview.
///
/// NodeSession Methods:
///
///  - keepAlive: The node call this method to keep the session alive.
///
///  - setReplicaObserver: Set the replica observer.
///
///  - getTimeout: Return the node session timeout.
///
///  - getObserver: Return the node observer.
///
///  - loadServers: Ask the registry to load the servers on the node.
///
///  - getServers: Get the name of the servers deployed on the node.
///
///  - waitForApplicationUpdate: Wait for the application update to complete (the application is completely updated once all the registry replicas have been updated).
///
///  - destroy: Destroy the session.
public extension NodeSession {
    func _iceD_keepAlive(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_load: LoadInfo = try inS.read { istr in
            let iceP_load: LoadInfo = try istr.read()
            return iceP_load
        }

        try self.keepAlive(load: iceP_load, current: current)

        return inS.setResult()
    }

    func _iceD_setReplicaObserver(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_observer: ReplicaObserverPrx? = try inS.read { istr in
            let iceP_observer: ReplicaObserverPrx? = try istr.read(ReplicaObserverPrx.self)
            return iceP_observer
        }

        try self.setReplicaObserver(observer: iceP_observer, current: current)

        return inS.setResult()
    }

    func _iceD_getTimeout(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getTimeout(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_getObserver(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getObserver(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_loadServers(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        return inS.setResultPromise(loadServersAsync(current: current))
    }

    func _iceD_getServers(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getServers(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_waitForApplicationUpdate(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_application, iceP_revision): (Swift.String, Swift.Int32) = try inS.read { istr in
            let iceP_application: Swift.String = try istr.read()
            let iceP_revision: Swift.Int32 = try istr.read()
            return (iceP_application, iceP_revision)
        }

        return inS.setResultPromise(waitForApplicationUpdateAsync(application: iceP_application, revision: iceP_revision, current: current))
    }

    func _iceD_destroy(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.destroy(current: current)

        return inS.setResult()
    }
}

/// DatabaseObserver overview.
public extension DatabaseObserver {}

/// ReplicaSession overview.
///
/// ReplicaSession Methods:
///
///  - keepAlive: The replica call this method to keep the session alive.
///
///  - getTimeout: Return the replica session timeout.
///
///  - setDatabaseObserver: Set the database observer.
///
///  - setEndpoints: This method sets the endpoints of the replica.
///
///  - registerWellKnownObjects: Registers the replica well-known objects with the master.
///
///  - setAdapterDirectProxy: Set the adapter direct proxy of the given adapter in the master.
///
///  - receivedUpdate: Notify the master that an update was received.
///
///  - destroy: Destroy the session.
public extension ReplicaSession {
    func _iceD_keepAlive(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.keepAlive(current: current)

        return inS.setResult()
    }

    func _iceD_getTimeout(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getTimeout(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_setDatabaseObserver(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_dbObs, iceP_serials): (DatabaseObserverPrx?, StringLongDict?) = try inS.read { istr in
            let iceP_dbObs: DatabaseObserverPrx? = try istr.read(DatabaseObserverPrx.self)
            let iceP_serials: StringLongDict? = try StringLongDictHelper.read(from: istr, tag: 1)
            return (iceP_dbObs, iceP_serials)
        }

        try self.setDatabaseObserver(dbObs: iceP_dbObs, serials: iceP_serials, current: current)

        return inS.setResult()
    }

    func _iceD_setEndpoints(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_endpoints: StringObjectProxyDict = try inS.read { istr in
            let iceP_endpoints: StringObjectProxyDict = try StringObjectProxyDictHelper.read(from: istr)
            return iceP_endpoints
        }

        try self.setEndpoints(endpoints: iceP_endpoints, current: current)

        return inS.setResult()
    }

    func _iceD_registerWellKnownObjects(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_objects: ObjectInfoSeq = try inS.read { istr in
            let iceP_objects: ObjectInfoSeq = try ObjectInfoSeqHelper.read(from: istr)
            return iceP_objects
        }

        try self.registerWellKnownObjects(objects: iceP_objects, current: current)

        return inS.setResult()
    }

    func _iceD_setAdapterDirectProxy(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_adapterId, iceP_replicaGroupId, iceP_proxy): (Swift.String, Swift.String, Ice.ObjectPrx?) = try inS.read { istr in
            let iceP_adapterId: Swift.String = try istr.read()
            let iceP_replicaGroupId: Swift.String = try istr.read()
            let iceP_proxy: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
            return (iceP_adapterId, iceP_replicaGroupId, iceP_proxy)
        }

        try self.setAdapterDirectProxy(adapterId: iceP_adapterId, replicaGroupId: iceP_replicaGroupId, proxy: iceP_proxy, current: current)

        return inS.setResult()
    }

    func _iceD_receivedUpdate(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_name, iceP_serial, iceP_failure): (TopicName, Swift.Int32, Swift.String) = try inS.read { istr in
            let iceP_name: TopicName = try istr.read()
            let iceP_serial: Swift.Int32 = try istr.read()
            let iceP_failure: Swift.String = try istr.read()
            return (iceP_name, iceP_serial, iceP_failure)
        }

        try self.receivedUpdate(name: iceP_name, serial: iceP_serial, failure: iceP_failure, current: current)

        return inS.setResult()
    }

    func _iceD_destroy(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.destroy(current: current)

        return inS.setResult()
    }
}

/// InternalRegistry overview.
///
/// InternalRegistry Methods:
///
///  - registerNode: Register a node with the registry.
///
///  - registerReplica: Register a replica with the registry.
///
///  - registerWithReplica: Create a session with the given registry replica.
///
///  - getNodes: Return the proxies of all the nodes known by this registry.
///
///  - getReplicas: Return the proxies of all the registry replicas known by this registry.
///
///  - getApplications: Return applications, adapters, objects from this replica.
///
///  - getAdapters: 
///
///  - getObjects: 
///
///  - shutdown: Shutdown this registry.
public extension InternalRegistry {
    func _iceD_registerNode(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_info, iceP_prx, iceP_loadInf): (InternalNodeInfo?, NodePrx?, LoadInfo) = try inS.read { istr in
            var iceP_info: InternalNodeInfo?
            try istr.read(InternalNodeInfo.self) { iceP_info = $0 }
            let iceP_prx: NodePrx? = try istr.read(NodePrx.self)
            let iceP_loadInf: LoadInfo = try istr.read()
            try istr.readPendingValues()
            return (iceP_info, iceP_prx, iceP_loadInf)
        }

        let iceP_returnValue = try self.registerNode(info: iceP_info, prx: iceP_prx, loadInf: iceP_loadInf, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_registerReplica(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_info, iceP_prx): (InternalReplicaInfo?, InternalRegistryPrx?) = try inS.read { istr in
            var iceP_info: InternalReplicaInfo?
            try istr.read(InternalReplicaInfo.self) { iceP_info = $0 }
            let iceP_prx: InternalRegistryPrx? = try istr.read(InternalRegistryPrx.self)
            try istr.readPendingValues()
            return (iceP_info, iceP_prx)
        }

        let iceP_returnValue = try self.registerReplica(info: iceP_info, prx: iceP_prx, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_registerWithReplica(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_prx: InternalRegistryPrx? = try inS.read { istr in
            let iceP_prx: InternalRegistryPrx? = try istr.read(InternalRegistryPrx.self)
            return iceP_prx
        }

        try self.registerWithReplica(prx: iceP_prx, current: current)

        return inS.setResult()
    }

    func _iceD_getNodes(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getNodes(current: current)

        return inS.setResult{ ostr in
            NodePrxSeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_getReplicas(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.getReplicas(current: current)

        return inS.setResult{ ostr in
            InternalRegistryPrxSeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_getApplications(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let (iceP_returnValue, iceP_serial) = try self.getApplications(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_serial)
            ApplicationInfoSeqHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_getAdapters(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let (iceP_returnValue, iceP_serial) = try self.getAdapters(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_serial)
            AdapterInfoSeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_getObjects(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let (iceP_returnValue, iceP_serial) = try self.getObjects(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_serial)
            ObjectInfoSeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_shutdown(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.shutdown(current: current)

        return inS.setResult()
    }
}
