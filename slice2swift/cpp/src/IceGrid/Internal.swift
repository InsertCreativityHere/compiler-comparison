//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Internal.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice

public typealias InternalDbEnvDescriptorSeq = [InternalDbEnvDescriptor?]

/// Helper class to read and write `InternalDbEnvDescriptorSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InternalDbEnvDescriptorSeqHelper {
    /// Read a `InternalDbEnvDescriptorSeq` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InternalDbEnvDescriptorSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = InternalDbEnvDescriptorSeq(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(InternalDbEnvDescriptor.self) { p.pointee = $0 }
            }
        }
        return v
    }

    /// Read an optional `InternalDbEnvDescriptorSeq?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InternalDbEnvDescriptorSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `InternalDbEnvDescriptorSeq` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InternalDbEnvDescriptorSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `InternalDbEnvDescriptorSeq?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: InternalDbEnvDescriptorSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias InternalAdapterDescriptorSeq = [InternalAdapterDescriptor?]

/// Helper class to read and write `InternalAdapterDescriptorSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InternalAdapterDescriptorSeqHelper {
    /// Read a `InternalAdapterDescriptorSeq` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InternalAdapterDescriptorSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = InternalAdapterDescriptorSeq(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(InternalAdapterDescriptor.self) { p.pointee = $0 }
            }
        }
        return v
    }

    /// Read an optional `InternalAdapterDescriptorSeq?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InternalAdapterDescriptorSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `InternalAdapterDescriptorSeq` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InternalAdapterDescriptorSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `InternalAdapterDescriptorSeq?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: InternalAdapterDescriptorSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias PropertyDescriptorSeqDict = [Swift.String: PropertyDescriptorSeq]

/// Helper class to read and write `PropertyDescriptorSeqDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct PropertyDescriptorSeqDictHelper {
    /// Read a `PropertyDescriptorSeqDict` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> PropertyDescriptorSeqDict {
        let sz = try Swift.Int(istr.readSize())
        var v = PropertyDescriptorSeqDict()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: PropertyDescriptorSeq = try PropertyDescriptorSeqHelper.read(from: istr)
            v[key] = value
        }
        return v
    }

    /// Read an optional `PropertyDescriptorSeqDict?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> PropertyDescriptorSeqDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `PropertyDescriptorSeqDict` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: PropertyDescriptorSeqDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            PropertyDescriptorSeqHelper.write(to: ostr, value: value)
        }
    }

    /// Write an optional `PropertyDescriptorSeqDict?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: PropertyDescriptorSeqDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// :nodoc:
public class AdapterActiveException_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return AdapterActiveException.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceGrid_AdapterActiveException() -> Ice.UserExceptionTypeResolver {
        return AdapterActiveException_TypeResolver()
    }
}

/// This exception is raised if an adapter is active.
open class AdapterActiveException: Ice.UserException, @unchecked Sendable {
    /// - Returns: The Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::IceGrid::AdapterActiveException" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: AdapterActiveException.ice_staticId(), compactId: -1, last: true)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }
}

/// :nodoc:
public class AdapterNotActiveException_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return AdapterNotActiveException.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceGrid_AdapterNotActiveException() -> Ice.UserExceptionTypeResolver {
        return AdapterNotActiveException_TypeResolver()
    }
}

open class AdapterNotActiveException: Ice.UserException, @unchecked Sendable {
    /// True if the adapter can be activated on demand.
    public var activatable: Swift.Bool = false

    public required init() {}

    public init(activatable: Swift.Bool) {
        self.activatable = activatable
    }

    /// - Returns: The Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::IceGrid::AdapterNotActiveException" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: AdapterNotActiveException.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.activatable)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.activatable = try istr.read()
        try istr.endSlice()
    }
}

/// Traits for Slice interface `Adapter`.
public struct AdapterTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::Adapter"]
    public static let staticId = "::IceGrid::Adapter"
}

/// :nodoc:
public class AdapterExistsException_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return AdapterExistsException.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceGrid_AdapterExistsException() -> Ice.UserExceptionTypeResolver {
        return AdapterExistsException_TypeResolver()
    }
}

/// This exception is raised if an adapter with the same name already exists.
open class AdapterExistsException: Ice.UserException, @unchecked Sendable {
    public var id: Swift.String = ""

    public required init() {}

    public init(id: Swift.String) {
        self.id = id
    }

    /// - Returns: The Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::IceGrid::AdapterExistsException" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: AdapterExistsException.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.id)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.id = try istr.read()
        try istr.endSlice()
    }
}

public typealias AdapterPrxDict = [Swift.String: AdapterPrx?]

/// Helper class to read and write `AdapterPrxDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct AdapterPrxDictHelper {
    /// Read a `AdapterPrxDict` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> AdapterPrxDict {
        let sz = try Swift.Int(istr.readSize())
        var v = AdapterPrxDict()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: AdapterPrx? = try istr.read(AdapterPrx.self)
            v[key] = value
        }
        return v
    }

    /// Read an optional `AdapterPrxDict?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> AdapterPrxDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `AdapterPrxDict` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: AdapterPrxDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `AdapterPrxDict?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: AdapterPrxDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice interface `FileReader`.
public struct FileReaderTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::FileReader"]
    public static let staticId = "::IceGrid::FileReader"
}

/// Traits for Slice interface `Server`.
public struct ServerTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::FileReader", "::IceGrid::Server"]
    public static let staticId = "::IceGrid::Server"
}

public typealias InternalRegistryPrxSeq = [InternalRegistryPrx?]

/// Helper class to read and write `InternalRegistryPrxSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InternalRegistryPrxSeqHelper {
    /// Read a `InternalRegistryPrxSeq` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InternalRegistryPrxSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = InternalRegistryPrxSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: InternalRegistryPrx? = try istr.read(InternalRegistryPrx.self)
            v.append(j)
        }
        return v
    }

    /// Read an optional `InternalRegistryPrxSeq?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InternalRegistryPrxSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `InternalRegistryPrxSeq` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InternalRegistryPrxSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `InternalRegistryPrxSeq?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: InternalRegistryPrxSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice interface `ReplicaObserver`.
public struct ReplicaObserverTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::ReplicaObserver"]
    public static let staticId = "::IceGrid::ReplicaObserver"
}

/// Traits for Slice interface `Node`.
public struct NodeTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::FileReader", "::IceGrid::Node", "::IceGrid::ReplicaObserver"]
    public static let staticId = "::IceGrid::Node"
}

public typealias NodePrxSeq = [NodePrx?]

/// Helper class to read and write `NodePrxSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct NodePrxSeqHelper {
    /// Read a `NodePrxSeq` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> NodePrxSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = NodePrxSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: NodePrx? = try istr.read(NodePrx.self)
            v.append(j)
        }
        return v
    }

    /// Read an optional `NodePrxSeq?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> NodePrxSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `NodePrxSeq` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: NodePrxSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `NodePrxSeq?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: NodePrxSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// :nodoc:
public class NodeActiveException_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return NodeActiveException.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceGrid_NodeActiveException() -> Ice.UserExceptionTypeResolver {
        return NodeActiveException_TypeResolver()
    }
}

/// This exception is raised if a node is already registered and active.
open class NodeActiveException: Ice.UserException, @unchecked Sendable {
    /// - Returns: The Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::IceGrid::NodeActiveException" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: NodeActiveException.ice_staticId(), compactId: -1, last: true)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }
}

/// Traits for Slice interface `NodeSession`.
public struct NodeSessionTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::NodeSession"]
    public static let staticId = "::IceGrid::NodeSession"
}

/// :nodoc:
public class ReplicaActiveException_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return ReplicaActiveException.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceGrid_ReplicaActiveException() -> Ice.UserExceptionTypeResolver {
        return ReplicaActiveException_TypeResolver()
    }
}

/// This exception is raised if a replica is already registered and active.
open class ReplicaActiveException: Ice.UserException, @unchecked Sendable {
    /// - Returns: The Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::IceGrid::ReplicaActiveException" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: ReplicaActiveException.ice_staticId(), compactId: -1, last: true)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }
}

public enum TopicName: Swift.UInt8 {
    case RegistryObserver = 0
    case NodeObserver = 1
    case ApplicationObserver = 2
    case AdapterObserver = 3
    case ObjectObserver = 4
    public init() {
        self = .RegistryObserver
    }
}

/// An `Ice.InputStream` extension to read `TopicName` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - Returns:  The enumerated value.
    func read() throws -> TopicName {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 4)
        guard let val = TopicName(rawValue: rawValue) else {
            throw Ice.MarshalException("invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The enumerated value.
    func read(tag: Swift.Int32) throws -> TopicName? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as TopicName
    }
}

/// An `Ice.OutputStream` extension to write `TopicName` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// - Parameter v: The enumerator to write.
    func write(_ v: TopicName) {
        write(enum: v.rawValue, maxValue: 4)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The enumerator to write.
    func write(tag: Swift.Int32, value: TopicName?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 4)
    }
}

/// Traits for Slice interface `DatabaseObserver`.
public struct DatabaseObserverTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::AdapterObserver", "::IceGrid::ApplicationObserver", "::IceGrid::DatabaseObserver", "::IceGrid::ObjectObserver"]
    public static let staticId = "::IceGrid::DatabaseObserver"
}

public typealias StringLongDict = [Swift.String: Swift.Int64]

/// Helper class to read and write `StringLongDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringLongDictHelper {
    /// Read a `StringLongDict` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringLongDict {
        let sz = try Swift.Int(istr.readSize())
        var v = StringLongDict()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: Swift.Int64 = try istr.read()
            v[key] = value
        }
        return v
    }

    /// Read an optional `StringLongDict?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringLongDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `StringLongDict` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringLongDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `StringLongDict?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: StringLongDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice interface `ReplicaSession`.
public struct ReplicaSessionTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::ReplicaSession"]
    public static let staticId = "::IceGrid::ReplicaSession"
}

/// Traits for Slice interface `InternalRegistry`.
public struct InternalRegistryTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceGrid::FileReader", "::IceGrid::InternalRegistry"]
    public static let staticId = "::IceGrid::InternalRegistry"
}

public protocol AdapterPrx: Ice.ObjectPrx {}

private final class AdapterPrxI: Ice.ObjectPrxI, AdapterPrx {
    public override class func ice_staticId() -> Swift.String {
        return AdapterTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: AdapterPrx.Protocol) throws -> AdapterPrx {
    try communicator.makeProxyImpl(proxyString) as AdapterPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: AdapterPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> AdapterPrx? {
    return try await AdapterPrxI.checkedCast(prx: prx, facet: facet, context: context) as AdapterPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: AdapterPrx.Protocol, facet: Swift.String? = nil) -> AdapterPrx {
    return AdapterPrxI.uncheckedCast(prx: prx, facet: facet) as AdapterPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: AdapterPrx.Protocol) -> Swift.String {
    return AdapterTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `AdapterPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: AdapterPrx.Protocol) throws -> AdapterPrx? {
        return try read() as AdapterPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: AdapterPrx.Protocol) throws -> AdapterPrx? {
        return try read(tag: tag) as AdapterPrxI?
    }
}

public extension AdapterPrx {
    /// Activate this adapter. If this adapter can be activated, this will activate the adapter and return the direct
    /// proxy of the adapter once it's active. If this adapter can be activated on demand, this will return 0 if the
    /// adapter is inactive or the adapter direct proxy it's active.
    ///
    /// - Parameter context: Optional request context.
    func activate(context: Ice.Context? = nil) async throws -> Ice.ObjectPrx? {
        return try await _impl._invoke(operation: "activate",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    /// Get the adapter direct proxy. The adapter direct proxy is a proxy created with the object adapter. The proxy
    /// contains the last known adapter endpoints.
    ///
    /// - Parameter context: Optional request context.
    ///
    /// - Returns: A direct proxy containing the last known adapter endpoints if the adapter is already active.
    func getDirectProxy(context: Ice.Context? = nil) async throws -> Ice.ObjectPrx? {
        return try await _impl._invoke(operation: "getDirectProxy",
                                       mode: .Idempotent,
                                       read: { istr in
                                           let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                           return iceP_returnValue
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as AdapterNotActiveException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    /// Set the direct proxy for this adapter.
    ///
    /// - Parameters:
    ///   - iceP_proxy
    ///   - context: Optional request context.
    ///
    /// - Throws:
    ///   - AdapterActiveException The adapter is already active. It's not possible to override the direct proxy of
    ///     an active adapter.
    func setDirectProxy(_ iceP_proxy: Ice.ObjectPrx?, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "setDirectProxy",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_proxy)
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as AdapterActiveException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }
}

public protocol FileReaderPrx: Ice.ObjectPrx {}

private final class FileReaderPrxI: Ice.ObjectPrxI, FileReaderPrx {
    public override class func ice_staticId() -> Swift.String {
        return FileReaderTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: FileReaderPrx.Protocol) throws -> FileReaderPrx {
    try communicator.makeProxyImpl(proxyString) as FileReaderPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: FileReaderPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> FileReaderPrx? {
    return try await FileReaderPrxI.checkedCast(prx: prx, facet: facet, context: context) as FileReaderPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: FileReaderPrx.Protocol, facet: Swift.String? = nil) -> FileReaderPrx {
    return FileReaderPrxI.uncheckedCast(prx: prx, facet: facet) as FileReaderPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: FileReaderPrx.Protocol) -> Swift.String {
    return FileReaderTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `FileReaderPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: FileReaderPrx.Protocol) throws -> FileReaderPrx? {
        return try read() as FileReaderPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: FileReaderPrx.Protocol) throws -> FileReaderPrx? {
        return try read(tag: tag) as FileReaderPrxI?
    }
}

public extension FileReaderPrx {
    /// Count the number of given lines from the end of the file and return the file offset.
    ///
    /// - Parameters:
    ///   - iceP_filename
    ///   - iceP_lines
    ///   - context: Optional request context.
    func getOffsetFromEnd(filename iceP_filename: Swift.String, lines iceP_lines: Swift.Int32, context: Ice.Context? = nil) async throws -> Swift.Int64 {
        return try await _impl._invoke(operation: "getOffsetFromEnd",
                                       mode: .Idempotent,
                                       write: { ostr in
                                           ostr.write(iceP_filename)
                                           ostr.write(iceP_lines)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Swift.Int64 = try istr.read()
                                           return iceP_returnValue
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as FileNotAvailableException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    /// Read lines (or size bytes) at the specified position from the given file.
    ///
    /// - Parameters:
    ///   - iceP_filename
    ///   - iceP_pos
    ///   - iceP_size
    ///   - context: Optional request context.
    ///
    /// - Returns:
    ///   - returnValue
    ///   - newPos
    ///   - lines
    func read(filename iceP_filename: Swift.String, pos iceP_pos: Swift.Int64, size iceP_size: Swift.Int32, context: Ice.Context? = nil) async throws -> (returnValue: Swift.Bool, newPos: Swift.Int64, lines: Ice.StringSeq) {
        return try await _impl._invoke(operation: "read",
                                       mode: .Idempotent,
                                       write: { ostr in
                                           ostr.write(iceP_filename)
                                           ostr.write(iceP_pos)
                                           ostr.write(iceP_size)
                                       },
                                       read: { istr in
                                           let iceP_newPos: Swift.Int64 = try istr.read()
                                           let iceP_lines: Ice.StringSeq = try istr.read()
                                           let iceP_returnValue: Swift.Bool = try istr.read()
                                           return (iceP_returnValue, iceP_newPos, iceP_lines)
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as FileNotAvailableException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }
}

public protocol ServerPrx: FileReaderPrx {}

private final class ServerPrxI: Ice.ObjectPrxI, ServerPrx {
    public override class func ice_staticId() -> Swift.String {
        return ServerTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: ServerPrx.Protocol) throws -> ServerPrx {
    try communicator.makeProxyImpl(proxyString) as ServerPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: ServerPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> ServerPrx? {
    return try await ServerPrxI.checkedCast(prx: prx, facet: facet, context: context) as ServerPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: ServerPrx.Protocol, facet: Swift.String? = nil) -> ServerPrx {
    return ServerPrxI.uncheckedCast(prx: prx, facet: facet) as ServerPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: ServerPrx.Protocol) -> Swift.String {
    return ServerTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `ServerPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: ServerPrx.Protocol) throws -> ServerPrx? {
        return try read() as ServerPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: ServerPrx.Protocol) throws -> ServerPrx? {
        return try read(tag: tag) as ServerPrxI?
    }
}

public extension ServerPrx {
    /// Start the server.
    ///
    /// - Parameter context: Optional request context.
    func start(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "start",
                                       mode: .Normal,
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as ServerStartException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    /// Stop the server. This methods returns only when the server is deactivated. If the server doesn't stop after a
    /// configurable amount of time, it will be killed.
    ///
    /// - Parameter context: Optional request context.
    func stop(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "stop",
                                       mode: .Normal,
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as ServerStopException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    /// Check if the given server can be loaded on this node.
    ///
    /// - Parameters:
    ///   - iceP_svr
    ///   - iceP_noRestart
    ///   - context: Optional request context.
    ///
    /// - Returns: True if the server is inactive.
    ///
    /// - Throws:
    ///   - DeploymentException Raised if the server can't be updated.
    func checkUpdate(svr iceP_svr: InternalServerDescriptor?, noRestart iceP_noRestart: Swift.Bool, context: Ice.Context? = nil) async throws -> Swift.Bool {
        return try await _impl._invoke(operation: "checkUpdate",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_svr)
                                           ostr.write(iceP_noRestart)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Swift.Bool = try istr.read()
                                           return iceP_returnValue
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as DeploymentException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    /// Enable or disable the server.
    ///
    /// - Parameters:
    ///   - iceP_enable
    ///   - context: Optional request context.
    func setEnabled(_ iceP_enable: Swift.Bool, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "setEnabled",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_enable)
                                       },
                                       context: context)
    }

    /// Check if the server is enabled.
    ///
    /// - Parameter context: Optional request context.
    func isEnabled(context: Ice.Context? = nil) async throws -> Swift.Bool {
        return try await _impl._invoke(operation: "isEnabled",
                                       mode: .Idempotent,
                                       read: { istr in
                                           let iceP_returnValue: Swift.Bool = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    /// Send signal to the server
    ///
    /// - Parameters:
    ///   - iceP_signal
    ///   - context: Optional request context.
    func sendSignal(_ iceP_signal: Swift.String, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "sendSignal",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_signal)
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as BadSignalException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    /// Write message on servers' stdout or stderr.
    ///
    /// - Parameters:
    ///   - iceP_message
    ///   - iceP_fd
    ///   - context: Optional request context.
    func writeMessage(message iceP_message: Swift.String, fd iceP_fd: Swift.Int32, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "writeMessage",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_message)
                                           ostr.write(iceP_fd)
                                       },
                                       context: context)
    }

    /// Return the server state.
    ///
    /// - Parameter context: Optional request context.
    ///
    /// - Returns: The server state.
    func getState(context: Ice.Context? = nil) async throws -> ServerState {
        return try await _impl._invoke(operation: "getState",
                                       mode: .Idempotent,
                                       read: { istr in
                                           let iceP_returnValue: ServerState = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    /// Get the server pid. Note that the value returned by this method is system dependant. On Unix operating systems,
    /// it's the pid value returned by the fork() system call and converted to an integer.
    ///
    /// - Parameter context: Optional request context.
    func getPid(context: Ice.Context? = nil) async throws -> Swift.Int32 {
        return try await _impl._invoke(operation: "getPid",
                                       mode: .Idempotent,
                                       read: { istr in
                                           let iceP_returnValue: Swift.Int32 = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    /// Set the process proxy.
    ///
    /// - Parameters:
    ///   - iceP_proc
    ///   - context: Optional request context.
    func setProcess(_ iceP_proc: Ice.ProcessPrx?, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "setProcess",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_proc)
                                       },
                                       context: context)
    }
}

public protocol ReplicaObserverPrx: Ice.ObjectPrx {}

private final class ReplicaObserverPrxI: Ice.ObjectPrxI, ReplicaObserverPrx {
    public override class func ice_staticId() -> Swift.String {
        return ReplicaObserverTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: ReplicaObserverPrx.Protocol) throws -> ReplicaObserverPrx {
    try communicator.makeProxyImpl(proxyString) as ReplicaObserverPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: ReplicaObserverPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> ReplicaObserverPrx? {
    return try await ReplicaObserverPrxI.checkedCast(prx: prx, facet: facet, context: context) as ReplicaObserverPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: ReplicaObserverPrx.Protocol, facet: Swift.String? = nil) -> ReplicaObserverPrx {
    return ReplicaObserverPrxI.uncheckedCast(prx: prx, facet: facet) as ReplicaObserverPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: ReplicaObserverPrx.Protocol) -> Swift.String {
    return ReplicaObserverTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `ReplicaObserverPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: ReplicaObserverPrx.Protocol) throws -> ReplicaObserverPrx? {
        return try read() as ReplicaObserverPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: ReplicaObserverPrx.Protocol) throws -> ReplicaObserverPrx? {
        return try read(tag: tag) as ReplicaObserverPrxI?
    }
}

public extension ReplicaObserverPrx {
    /// Initialization of the replica observer.
    ///
    /// - Parameters:
    ///   - iceP_replicas
    ///   - context: Optional request context.
    func replicaInit(_ iceP_replicas: InternalRegistryPrxSeq, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "replicaInit",
                                       mode: .Normal,
                                       write: { ostr in
                                           InternalRegistryPrxSeqHelper.write(to: ostr, value: iceP_replicas)
                                       },
                                       context: context)
    }

    /// Notification that a replica has been added. The node should establish a session with this new replica.
    ///
    /// - Parameters:
    ///   - iceP_replica
    ///   - context: Optional request context.
    func replicaAdded(_ iceP_replica: InternalRegistryPrx?, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "replicaAdded",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_replica)
                                       },
                                       context: context)
    }

    /// Notification that a replica has been removed. The node should destroy the session to this replica.
    ///
    /// - Parameters:
    ///   - iceP_replica
    ///   - context: Optional request context.
    func replicaRemoved(_ iceP_replica: InternalRegistryPrx?, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "replicaRemoved",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_replica)
                                       },
                                       context: context)
    }
}

public protocol NodePrx: FileReaderPrx, ReplicaObserverPrx {}

private final class NodePrxI: Ice.ObjectPrxI, NodePrx {
    public override class func ice_staticId() -> Swift.String {
        return NodeTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: NodePrx.Protocol) throws -> NodePrx {
    try communicator.makeProxyImpl(proxyString) as NodePrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: NodePrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> NodePrx? {
    return try await NodePrxI.checkedCast(prx: prx, facet: facet, context: context) as NodePrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: NodePrx.Protocol, facet: Swift.String? = nil) -> NodePrx {
    return NodePrxI.uncheckedCast(prx: prx, facet: facet) as NodePrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: NodePrx.Protocol) -> Swift.String {
    return NodeTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `NodePrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: NodePrx.Protocol) throws -> NodePrx? {
        return try read() as NodePrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: NodePrx.Protocol) throws -> NodePrx? {
        return try read(tag: tag) as NodePrxI?
    }
}

public extension NodePrx {
    /// Load the given server. If the server resources weren't already created (database environment directories,
    /// property files, etc), they will be created. The returned proxy is never null.
    ///
    /// - Parameters:
    ///   - iceP_svr
    ///   - iceP_replicaName
    ///   - context: Optional request context.
    ///
    /// - Returns:
    ///   - returnValue
    ///   - adapters
    ///   - activateTimeout
    ///   - deactivateTimeout
    func loadServer(svr iceP_svr: InternalServerDescriptor?, replicaName iceP_replicaName: Swift.String, context: Ice.Context? = nil) async throws -> (returnValue: ServerPrx?, adapters: AdapterPrxDict, activateTimeout: Swift.Int32, deactivateTimeout: Swift.Int32) {
        return try await _impl._invoke(operation: "loadServer",
                                       mode: .Idempotent,
                                       write: { ostr in
                                           ostr.write(iceP_svr)
                                           ostr.write(iceP_replicaName)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           let iceP_adapters: AdapterPrxDict = try AdapterPrxDictHelper.read(from: istr)
                                           let iceP_activateTimeout: Swift.Int32 = try istr.read()
                                           let iceP_deactivateTimeout: Swift.Int32 = try istr.read()
                                           let iceP_returnValue: ServerPrx? = try istr.read(ServerPrx.self)
                                           return (iceP_returnValue, iceP_adapters, iceP_activateTimeout, iceP_deactivateTimeout)
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as DeploymentException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    /// Load the given server and ensure the server won't be restarted. If the server resources weren't already created
    /// (database environment directories, property files, etc), they will be created. If the server can't be updated
    /// without a restart, a DeploymentException is raised. The returned proxy is never null.
    ///
    /// - Parameters:
    ///   - iceP_svr
    ///   - iceP_replicaName
    ///   - context: Optional request context.
    ///
    /// - Returns:
    ///   - returnValue
    ///   - adapters
    ///   - activateTimeout
    ///   - deactivateTimeout
    func loadServerWithoutRestart(svr iceP_svr: InternalServerDescriptor?, replicaName iceP_replicaName: Swift.String, context: Ice.Context? = nil) async throws -> (returnValue: ServerPrx?, adapters: AdapterPrxDict, activateTimeout: Swift.Int32, deactivateTimeout: Swift.Int32) {
        return try await _impl._invoke(operation: "loadServerWithoutRestart",
                                       mode: .Idempotent,
                                       write: { ostr in
                                           ostr.write(iceP_svr)
                                           ostr.write(iceP_replicaName)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           let iceP_adapters: AdapterPrxDict = try AdapterPrxDictHelper.read(from: istr)
                                           let iceP_activateTimeout: Swift.Int32 = try istr.read()
                                           let iceP_deactivateTimeout: Swift.Int32 = try istr.read()
                                           let iceP_returnValue: ServerPrx? = try istr.read(ServerPrx.self)
                                           return (iceP_returnValue, iceP_adapters, iceP_activateTimeout, iceP_deactivateTimeout)
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as DeploymentException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    /// Destroy the given server.
    ///
    /// - Parameters:
    ///   - iceP_name
    ///   - iceP_uuid
    ///   - iceP_revision
    ///   - iceP_replicaName
    ///   - context: Optional request context.
    func destroyServer(name iceP_name: Swift.String, uuid iceP_uuid: Swift.String, revision iceP_revision: Swift.Int32, replicaName iceP_replicaName: Swift.String, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "destroyServer",
                                       mode: .Idempotent,
                                       write: { ostr in
                                           ostr.write(iceP_name)
                                           ostr.write(iceP_uuid)
                                           ostr.write(iceP_revision)
                                           ostr.write(iceP_replicaName)
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as DeploymentException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    /// Destroy the server if it's not active.
    ///
    /// - Parameters:
    ///   - iceP_name
    ///   - iceP_uuid
    ///   - iceP_revision
    ///   - iceP_replicaName
    ///   - context: Optional request context.
    func destroyServerWithoutRestart(name iceP_name: Swift.String, uuid iceP_uuid: Swift.String, revision iceP_revision: Swift.Int32, replicaName iceP_replicaName: Swift.String, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "destroyServerWithoutRestart",
                                       mode: .Idempotent,
                                       write: { ostr in
                                           ostr.write(iceP_name)
                                           ostr.write(iceP_uuid)
                                           ostr.write(iceP_revision)
                                           ostr.write(iceP_replicaName)
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as DeploymentException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    /// Establish a session to the given replica, this method only returns once the registration was attempted (unlike
    /// replicaAdded below).
    ///
    /// - Parameters:
    ///   - iceP_replica
    ///   - context: Optional request context.
    func registerWithReplica(_ iceP_replica: InternalRegistryPrx?, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "registerWithReplica",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_replica)
                                       },
                                       context: context)
    }

    /// Get the node name.
    ///
    /// - Parameter context: Optional request context.
    func getName(context: Ice.Context? = nil) async throws -> Swift.String {
        return try await _impl._invoke(operation: "getName",
                                       mode: .Idempotent,
                                       read: { istr in
                                           let iceP_returnValue: Swift.String = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    /// Get the node hostname.
    ///
    /// - Parameter context: Optional request context.
    func getHostname(context: Ice.Context? = nil) async throws -> Swift.String {
        return try await _impl._invoke(operation: "getHostname",
                                       mode: .Idempotent,
                                       read: { istr in
                                           let iceP_returnValue: Swift.String = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    /// Get the node load.
    ///
    /// - Parameter context: Optional request context.
    func getLoad(context: Ice.Context? = nil) async throws -> LoadInfo {
        return try await _impl._invoke(operation: "getLoad",
                                       mode: .Idempotent,
                                       read: { istr in
                                           let iceP_returnValue: LoadInfo = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    /// Get the number of processor sockets for the machine where this node is running.
    ///
    /// - Parameter context: Optional request context.
    func getProcessorSocketCount(context: Ice.Context? = nil) async throws -> Swift.Int32 {
        return try await _impl._invoke(operation: "getProcessorSocketCount",
                                       mode: .Idempotent,
                                       read: { istr in
                                           let iceP_returnValue: Swift.Int32 = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    /// Shutdown the node.
    ///
    /// - Parameter context: Optional request context.
    func shutdown(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "shutdown",
                                       mode: .Idempotent,
                                       context: context)
    }
}

public protocol NodeSessionPrx: Ice.ObjectPrx {}

private final class NodeSessionPrxI: Ice.ObjectPrxI, NodeSessionPrx {
    public override class func ice_staticId() -> Swift.String {
        return NodeSessionTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: NodeSessionPrx.Protocol) throws -> NodeSessionPrx {
    try communicator.makeProxyImpl(proxyString) as NodeSessionPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: NodeSessionPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> NodeSessionPrx? {
    return try await NodeSessionPrxI.checkedCast(prx: prx, facet: facet, context: context) as NodeSessionPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: NodeSessionPrx.Protocol, facet: Swift.String? = nil) -> NodeSessionPrx {
    return NodeSessionPrxI.uncheckedCast(prx: prx, facet: facet) as NodeSessionPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: NodeSessionPrx.Protocol) -> Swift.String {
    return NodeSessionTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `NodeSessionPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: NodeSessionPrx.Protocol) throws -> NodeSessionPrx? {
        return try read() as NodeSessionPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: NodeSessionPrx.Protocol) throws -> NodeSessionPrx? {
        return try read(tag: tag) as NodeSessionPrxI?
    }
}

public extension NodeSessionPrx {
    /// The node call this method to keep the session alive.
    ///
    /// - Parameters:
    ///   - iceP_load
    ///   - context: Optional request context.
    func keepAlive(_ iceP_load: LoadInfo, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "keepAlive",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_load)
                                       },
                                       context: context)
    }

    /// Set the replica observer. The node calls this method when it's ready to receive notifications for the replicas.
    /// It only calls this for the session with the master.
    ///
    /// - Parameters:
    ///   - iceP_observer
    ///   - context: Optional request context.
    func setReplicaObserver(_ iceP_observer: ReplicaObserverPrx?, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "setReplicaObserver",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_observer)
                                       },
                                       context: context)
    }

    /// Return the node session timeout.
    ///
    /// - Parameter context: Optional request context.
    func getTimeout(context: Ice.Context? = nil) async throws -> Swift.Int32 {
        return try await _impl._invoke(operation: "getTimeout",
                                       mode: .Idempotent,
                                       read: { istr in
                                           let iceP_returnValue: Swift.Int32 = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    /// Return the node observer.
    ///
    /// - Parameter context: Optional request context.
    func getObserver(context: Ice.Context? = nil) async throws -> NodeObserverPrx? {
        return try await _impl._invoke(operation: "getObserver",
                                       mode: .Idempotent,
                                       read: { istr in
                                           let iceP_returnValue: NodeObserverPrx? = try istr.read(NodeObserverPrx.self)
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    /// Ask the registry to load the servers on the node.
    ///
    /// - Parameter context: Optional request context.
    func loadServers(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "loadServers",
                                       mode: .Idempotent,
                                       context: context)
    }

    /// Get the name of the servers deployed on the node.
    ///
    /// - Parameter context: Optional request context.
    func getServers(context: Ice.Context? = nil) async throws -> Ice.StringSeq {
        return try await _impl._invoke(operation: "getServers",
                                       mode: .Idempotent,
                                       read: { istr in
                                           let iceP_returnValue: Ice.StringSeq = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    /// Wait for the application update to complete (the application is completely updated once all the registry
    /// replicas have been updated). This is used by the node to ensure that before to start a server all the
    /// replicas have the up-to-date descriptor of the server.
    ///
    /// - Parameters:
    ///   - iceP_application
    ///   - iceP_revision
    ///   - context: Optional request context.
    func waitForApplicationUpdate(application iceP_application: Swift.String, revision iceP_revision: Swift.Int32, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "waitForApplicationUpdate",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_application)
                                           ostr.write(iceP_revision)
                                       },
                                       context: context)
    }

    /// Destroy the session.
    ///
    /// - Parameter context: Optional request context.
    func destroy(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "destroy",
                                       mode: .Normal,
                                       context: context)
    }
}

public protocol DatabaseObserverPrx: ApplicationObserverPrx, ObjectObserverPrx, AdapterObserverPrx {}

private final class DatabaseObserverPrxI: Ice.ObjectPrxI, DatabaseObserverPrx {
    public override class func ice_staticId() -> Swift.String {
        return DatabaseObserverTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: DatabaseObserverPrx.Protocol) throws -> DatabaseObserverPrx {
    try communicator.makeProxyImpl(proxyString) as DatabaseObserverPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: DatabaseObserverPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> DatabaseObserverPrx? {
    return try await DatabaseObserverPrxI.checkedCast(prx: prx, facet: facet, context: context) as DatabaseObserverPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: DatabaseObserverPrx.Protocol, facet: Swift.String? = nil) -> DatabaseObserverPrx {
    return DatabaseObserverPrxI.uncheckedCast(prx: prx, facet: facet) as DatabaseObserverPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: DatabaseObserverPrx.Protocol) -> Swift.String {
    return DatabaseObserverTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `DatabaseObserverPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: DatabaseObserverPrx.Protocol) throws -> DatabaseObserverPrx? {
        return try read() as DatabaseObserverPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: DatabaseObserverPrx.Protocol) throws -> DatabaseObserverPrx? {
        return try read(tag: tag) as DatabaseObserverPrxI?
    }
}

public extension DatabaseObserverPrx {}

public protocol ReplicaSessionPrx: Ice.ObjectPrx {}

private final class ReplicaSessionPrxI: Ice.ObjectPrxI, ReplicaSessionPrx {
    public override class func ice_staticId() -> Swift.String {
        return ReplicaSessionTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: ReplicaSessionPrx.Protocol) throws -> ReplicaSessionPrx {
    try communicator.makeProxyImpl(proxyString) as ReplicaSessionPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: ReplicaSessionPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> ReplicaSessionPrx? {
    return try await ReplicaSessionPrxI.checkedCast(prx: prx, facet: facet, context: context) as ReplicaSessionPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: ReplicaSessionPrx.Protocol, facet: Swift.String? = nil) -> ReplicaSessionPrx {
    return ReplicaSessionPrxI.uncheckedCast(prx: prx, facet: facet) as ReplicaSessionPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: ReplicaSessionPrx.Protocol) -> Swift.String {
    return ReplicaSessionTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `ReplicaSessionPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: ReplicaSessionPrx.Protocol) throws -> ReplicaSessionPrx? {
        return try read() as ReplicaSessionPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: ReplicaSessionPrx.Protocol) throws -> ReplicaSessionPrx? {
        return try read(tag: tag) as ReplicaSessionPrxI?
    }
}

public extension ReplicaSessionPrx {
    /// The replica call this method to keep the session alive.
    ///
    /// - Parameter context: Optional request context.
    func keepAlive(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "keepAlive",
                                       mode: .Normal,
                                       context: context)
    }

    /// Return the replica session timeout.
    ///
    /// - Parameter context: Optional request context.
    func getTimeout(context: Ice.Context? = nil) async throws -> Swift.Int32 {
        return try await _impl._invoke(operation: "getTimeout",
                                       mode: .Idempotent,
                                       read: { istr in
                                           let iceP_returnValue: Swift.Int32 = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    /// Set the database observer. Once the observer is subscribed, it will receive the database and database updates.
    ///
    /// - Parameters:
    ///   - iceP_dbObs
    ///   - iceP_serials
    ///   - context: Optional request context.
    func setDatabaseObserver(dbObs iceP_dbObs: DatabaseObserverPrx?, serials iceP_serials: StringLongDict? = nil, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "setDatabaseObserver",
                                       mode: .Idempotent,
                                       write: { ostr in
                                           ostr.write(iceP_dbObs)
                                           StringLongDictHelper.write(to: ostr, tag: 1, value: iceP_serials)
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as DeploymentException {
                                               throw error
                                           } catch let error as ObserverAlreadyRegisteredException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    /// This method sets the endpoints of the replica. This allows the master to create proxies with multiple endpoints
    /// for replicated objects (e.g.: IceGrid::Query object).
    ///
    /// - Parameters:
    ///   - iceP_endpoints
    ///   - context: Optional request context.
    func setEndpoints(_ iceP_endpoints: StringObjectProxyDict, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "setEndpoints",
                                       mode: .Idempotent,
                                       write: { ostr in
                                           StringObjectProxyDictHelper.write(to: ostr, value: iceP_endpoints)
                                       },
                                       context: context)
    }

    /// Registers the replica well-known objects with the master.
    ///
    /// - Parameters:
    ///   - iceP_objects
    ///   - context: Optional request context.
    func registerWellKnownObjects(_ iceP_objects: ObjectInfoSeq, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "registerWellKnownObjects",
                                       mode: .Idempotent,
                                       write: { ostr in
                                           ObjectInfoSeqHelper.write(to: ostr, value: iceP_objects)
                                       },
                                       context: context)
    }

    /// Set the adapter direct proxy of the given adapter in the master. This is used to support dynamic registration
    /// with the locator registry interface.
    ///
    /// - Parameters:
    ///   - iceP_adapterId
    ///   - iceP_replicaGroupId
    ///   - iceP_proxy
    ///   - context: Optional request context.
    func setAdapterDirectProxy(adapterId iceP_adapterId: Swift.String, replicaGroupId iceP_replicaGroupId: Swift.String, proxy iceP_proxy: Ice.ObjectPrx?, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "setAdapterDirectProxy",
                                       mode: .Idempotent,
                                       write: { ostr in
                                           ostr.write(iceP_adapterId)
                                           ostr.write(iceP_replicaGroupId)
                                           ostr.write(iceP_proxy)
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as AdapterExistsException {
                                               throw error
                                           } catch let error as AdapterNotExistException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    /// Notify the master that an update was received. The master might wait for replication updates to be received by
    /// all the replicas before to continue.
    ///
    /// - Parameters:
    ///   - iceP_name
    ///   - iceP_serial
    ///   - iceP_failure
    ///   - context: Optional request context.
    func receivedUpdate(name iceP_name: TopicName, serial iceP_serial: Swift.Int32, failure iceP_failure: Swift.String, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "receivedUpdate",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_name)
                                           ostr.write(iceP_serial)
                                           ostr.write(iceP_failure)
                                       },
                                       context: context)
    }

    /// Destroy the session.
    ///
    /// - Parameter context: Optional request context.
    func destroy(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "destroy",
                                       mode: .Normal,
                                       context: context)
    }
}

public protocol InternalRegistryPrx: FileReaderPrx {}

private final class InternalRegistryPrxI: Ice.ObjectPrxI, InternalRegistryPrx {
    public override class func ice_staticId() -> Swift.String {
        return InternalRegistryTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: InternalRegistryPrx.Protocol) throws -> InternalRegistryPrx {
    try communicator.makeProxyImpl(proxyString) as InternalRegistryPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: InternalRegistryPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> InternalRegistryPrx? {
    return try await InternalRegistryPrxI.checkedCast(prx: prx, facet: facet, context: context) as InternalRegistryPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: InternalRegistryPrx.Protocol, facet: Swift.String? = nil) -> InternalRegistryPrx {
    return InternalRegistryPrxI.uncheckedCast(prx: prx, facet: facet) as InternalRegistryPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: InternalRegistryPrx.Protocol) -> Swift.String {
    return InternalRegistryTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `InternalRegistryPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: InternalRegistryPrx.Protocol) throws -> InternalRegistryPrx? {
        return try read() as InternalRegistryPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: InternalRegistryPrx.Protocol) throws -> InternalRegistryPrx? {
        return try read(tag: tag) as InternalRegistryPrxI?
    }
}

public extension InternalRegistryPrx {
    /// Register a node with the registry. If a node with the same name is already registered,
    /// registerNode overrides the existing registration only when the previously
    /// registered node is not active.
    ///
    /// - Parameters:
    ///   - iceP_info: Some information on the node.
    ///   - iceP_prx: The proxy of the node.
    ///   - iceP_loadInf: The load information of the node.
    ///   - context: Optional request context.
    ///
    /// - Returns: The node session proxy.
    ///
    /// - Throws:
    ///   - NodeActiveException Raised if the node is already registered and currently active.
    func registerNode(info iceP_info: InternalNodeInfo?, prx iceP_prx: NodePrx?, loadInf iceP_loadInf: LoadInfo, context: Ice.Context? = nil) async throws -> NodeSessionPrx? {
        return try await _impl._invoke(operation: "registerNode",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_info)
                                           ostr.write(iceP_prx)
                                           ostr.write(iceP_loadInf)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           let iceP_returnValue: NodeSessionPrx? = try istr.read(NodeSessionPrx.self)
                                           return iceP_returnValue
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as NodeActiveException {
                                               throw error
                                           } catch let error as PermissionDeniedException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    /// Register a replica with the registry. If a replica with the same name is already registered,
    /// registerReplica overrides the existing registration only when the previously
    /// registered node is not active.
    ///
    /// - Parameters:
    ///   - iceP_info: Some information on the replica.
    ///   - iceP_prx: The proxy of the replica.
    ///   - context: Optional request context.
    ///
    /// - Returns: The replica session proxy.
    ///
    /// - Throws:
    ///   - ReplicaActiveException Raised if the replica is already registered and currently active.
    func registerReplica(info iceP_info: InternalReplicaInfo?, prx iceP_prx: InternalRegistryPrx?, context: Ice.Context? = nil) async throws -> ReplicaSessionPrx? {
        return try await _impl._invoke(operation: "registerReplica",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_info)
                                           ostr.write(iceP_prx)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           let iceP_returnValue: ReplicaSessionPrx? = try istr.read(ReplicaSessionPrx.self)
                                           return iceP_returnValue
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as ReplicaActiveException {
                                               throw error
                                           } catch let error as PermissionDeniedException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    /// Create a session with the given registry replica. This method returns only once the session creation has been
    /// attempted.
    ///
    /// - Parameters:
    ///   - iceP_prx
    ///   - context: Optional request context.
    func registerWithReplica(_ iceP_prx: InternalRegistryPrx?, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "registerWithReplica",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_prx)
                                       },
                                       context: context)
    }

    /// Return the proxies of all the nodes known by this registry.
    ///
    /// - Parameter context: Optional request context.
    func getNodes(context: Ice.Context? = nil) async throws -> NodePrxSeq {
        return try await _impl._invoke(operation: "getNodes",
                                       mode: .Idempotent,
                                       read: { istr in
                                           let iceP_returnValue: NodePrxSeq = try NodePrxSeqHelper.read(from: istr)
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    /// Return the proxies of all the registry replicas known by this registry.
    ///
    /// - Parameter context: Optional request context.
    func getReplicas(context: Ice.Context? = nil) async throws -> InternalRegistryPrxSeq {
        return try await _impl._invoke(operation: "getReplicas",
                                       mode: .Idempotent,
                                       read: { istr in
                                           let iceP_returnValue: InternalRegistryPrxSeq = try InternalRegistryPrxSeqHelper.read(from: istr)
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    /// Return applications, adapters, objects from this replica.
    ///
    /// - Parameter context: Optional request context.
    ///
    /// - Returns:
    ///   - returnValue
    ///   - serial
    func getApplications(context: Ice.Context? = nil) async throws -> (returnValue: ApplicationInfoSeq, serial: Swift.Int64) {
        return try await _impl._invoke(operation: "getApplications",
                                       mode: .Idempotent,
                                       read: { istr in
                                           let iceP_serial: Swift.Int64 = try istr.read()
                                           let iceP_returnValue: ApplicationInfoSeq = try ApplicationInfoSeqHelper.read(from: istr)
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_serial)
                                       },
                                       context: context)
    }

    func getAdapters(context: Ice.Context? = nil) async throws -> (returnValue: AdapterInfoSeq, serial: Swift.Int64) {
        return try await _impl._invoke(operation: "getAdapters",
                                       mode: .Idempotent,
                                       read: { istr in
                                           let iceP_serial: Swift.Int64 = try istr.read()
                                           let iceP_returnValue: AdapterInfoSeq = try AdapterInfoSeqHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_serial)
                                       },
                                       context: context)
    }

    func getObjects(context: Ice.Context? = nil) async throws -> (returnValue: ObjectInfoSeq, serial: Swift.Int64) {
        return try await _impl._invoke(operation: "getObjects",
                                       mode: .Idempotent,
                                       read: { istr in
                                           let iceP_serial: Swift.Int64 = try istr.read()
                                           let iceP_returnValue: ObjectInfoSeq = try ObjectInfoSeqHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_serial)
                                       },
                                       context: context)
    }

    /// Shutdown this registry.
    ///
    /// - Parameter context: Optional request context.
    func shutdown(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "shutdown",
                                       mode: .Idempotent,
                                       context: context)
    }
}

/// :nodoc:
public class InternalDbEnvDescriptor_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return InternalDbEnvDescriptor.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceGrid_InternalDbEnvDescriptor() -> Ice.ValueTypeResolver {
        return InternalDbEnvDescriptor_TypeResolver()
    }
}

open class InternalDbEnvDescriptor: Ice.Value {
    /// The name of the database environment.
    public var name: Swift.String = ""
    /// The database properties.
    public var properties: PropertyDescriptorSeq = PropertyDescriptorSeq()

    public required init() {}

    public init(name: Swift.String, properties: PropertyDescriptorSeq) {
        self.name = name
        self.properties = properties
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::IceGrid::InternalDbEnvDescriptor" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.name = try istr.read()
        self.properties = try PropertyDescriptorSeqHelper.read(from: istr)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: InternalDbEnvDescriptor.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.name)
        PropertyDescriptorSeqHelper.write(to: ostr, value: self.properties)
        ostr.endSlice()
    }
}

/// :nodoc:
public class InternalAdapterDescriptor_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return InternalAdapterDescriptor.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceGrid_InternalAdapterDescriptor() -> Ice.ValueTypeResolver {
        return InternalAdapterDescriptor_TypeResolver()
    }
}

open class InternalAdapterDescriptor: Ice.Value {
    /// The identifier of the server.
    public var id: Swift.String = ""
    /// Specifies if the lifetime of the adapter is the same as the server.
    public var serverLifetime: Swift.Bool = false

    public required init() {}

    public init(id: Swift.String, serverLifetime: Swift.Bool) {
        self.id = id
        self.serverLifetime = serverLifetime
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::IceGrid::InternalAdapterDescriptor" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.id = try istr.read()
        self.serverLifetime = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: InternalAdapterDescriptor.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.id)
        ostr.write(self.serverLifetime)
        ostr.endSlice()
    }
}

/// :nodoc:
public class InternalServerDescriptor_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return InternalServerDescriptor.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceGrid_InternalServerDescriptor() -> Ice.ValueTypeResolver {
        return InternalServerDescriptor_TypeResolver()
    }
}

open class InternalServerDescriptor: Ice.Value {
    /// The server ID.
    public var id: Swift.String = ""
    /// The server application
    public var application: Swift.String = ""
    /// The application uuid.
    public var uuid: Swift.String = ""
    /// The application revision.
    public var revision: Swift.Int32 = 0
    /// The id of the session which allocated the server.
    public var sessionId: Swift.String = ""
    /// The server executable.
    public var exe: Swift.String = ""
    /// The server working directory.
    public var pwd: Swift.String = ""
    /// The user ID to use to run the server.
    public var user: Swift.String = ""
    /// The server activation mode.
    public var activation: Swift.String = ""
    /// The server activation timeout.
    public var activationTimeout: Swift.String = ""
    /// The server deactivation timeout.
    public var deactivationTimeout: Swift.String = ""
    /// Specifies if a process object is registered.
    public var processRegistered: Swift.Bool = false
    /// The server command line options.
    public var options: Ice.StringSeq = Ice.StringSeq()
    /// The server environment variables.
    public var envs: Ice.StringSeq = Ice.StringSeq()
    /// The path of the server logs.
    public var logs: Ice.StringSeq = Ice.StringSeq()
    /// The indirect object adapters.
    public var adapters: InternalAdapterDescriptorSeq = InternalAdapterDescriptorSeq()
    public var dbEnvs: InternalDbEnvDescriptorSeq = InternalDbEnvDescriptorSeq()
    /// The configuration files of the server.
    public var properties: PropertyDescriptorSeqDict = PropertyDescriptorSeqDict()
    /// IceBox service names
    public var services: Ice.StringSeq? = nil

    public required init() {}

    public init(id: Swift.String, application: Swift.String, uuid: Swift.String, revision: Swift.Int32, sessionId: Swift.String, exe: Swift.String, pwd: Swift.String, user: Swift.String, activation: Swift.String, activationTimeout: Swift.String, deactivationTimeout: Swift.String, processRegistered: Swift.Bool, options: Ice.StringSeq, envs: Ice.StringSeq, logs: Ice.StringSeq, adapters: InternalAdapterDescriptorSeq, dbEnvs: InternalDbEnvDescriptorSeq, properties: PropertyDescriptorSeqDict, services: Ice.StringSeq?) {
        self.id = id
        self.application = application
        self.uuid = uuid
        self.revision = revision
        self.sessionId = sessionId
        self.exe = exe
        self.pwd = pwd
        self.user = user
        self.activation = activation
        self.activationTimeout = activationTimeout
        self.deactivationTimeout = deactivationTimeout
        self.processRegistered = processRegistered
        self.options = options
        self.envs = envs
        self.logs = logs
        self.adapters = adapters
        self.dbEnvs = dbEnvs
        self.properties = properties
        self.services = services
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::IceGrid::InternalServerDescriptor" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.id = try istr.read()
        self.application = try istr.read()
        self.uuid = try istr.read()
        self.revision = try istr.read()
        self.sessionId = try istr.read()
        self.exe = try istr.read()
        self.pwd = try istr.read()
        self.user = try istr.read()
        self.activation = try istr.read()
        self.activationTimeout = try istr.read()
        self.deactivationTimeout = try istr.read()
        self.processRegistered = try istr.read()
        self.options = try istr.read()
        self.envs = try istr.read()
        self.logs = try istr.read()
        self.adapters = try InternalAdapterDescriptorSeqHelper.read(from: istr)
        self.dbEnvs = try InternalDbEnvDescriptorSeqHelper.read(from: istr)
        self.properties = try PropertyDescriptorSeqDictHelper.read(from: istr)
        self.services = try istr.read(tag: 1)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: InternalServerDescriptor.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.id)
        ostr.write(self.application)
        ostr.write(self.uuid)
        ostr.write(self.revision)
        ostr.write(self.sessionId)
        ostr.write(self.exe)
        ostr.write(self.pwd)
        ostr.write(self.user)
        ostr.write(self.activation)
        ostr.write(self.activationTimeout)
        ostr.write(self.deactivationTimeout)
        ostr.write(self.processRegistered)
        ostr.write(self.options)
        ostr.write(self.envs)
        ostr.write(self.logs)
        InternalAdapterDescriptorSeqHelper.write(to: ostr, value: self.adapters)
        InternalDbEnvDescriptorSeqHelper.write(to: ostr, value: self.dbEnvs)
        PropertyDescriptorSeqDictHelper.write(to: ostr, value: self.properties)
        ostr.write(tag: 1, value: self.services)
        ostr.endSlice()
    }
}

/// :nodoc:
public class InternalNodeInfo_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return InternalNodeInfo.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceGrid_InternalNodeInfo() -> Ice.ValueTypeResolver {
        return InternalNodeInfo_TypeResolver()
    }
}

/// Information about an IceGrid node.
open class InternalNodeInfo: Ice.Value {
    /// The name of the node.
    public var name: Swift.String = ""
    /// The operating system name.
    public var os: Swift.String = ""
    /// The network name of the host running this node (as defined in uname()).
    public var hostname: Swift.String = ""
    /// The operation system release level (as defined in uname()).
    public var release: Swift.String = ""
    /// The operation system version (as defined in uname()).
    public var version: Swift.String = ""
    /// The machine hardware type (as defined in uname()).
    public var machine: Swift.String = ""
    /// The number of processor threads (e.g. 8 on system with 1 quad-core CPU, with 2 threads per core)
    public var nProcessors: Swift.Int32 = 0
    /// The path to the node data directory.
    public var dataDir: Swift.String = ""
    /// The Ice SO version of this node, for example 38. It is typically used to load the same version of the IceStorm
    /// service in IceBox.
    public var iceSoVersion: Swift.String? = nil

    public required init() {}

    public init(name: Swift.String, os: Swift.String, hostname: Swift.String, release: Swift.String, version: Swift.String, machine: Swift.String, nProcessors: Swift.Int32, dataDir: Swift.String, iceSoVersion: Swift.String?) {
        self.name = name
        self.os = os
        self.hostname = hostname
        self.release = release
        self.version = version
        self.machine = machine
        self.nProcessors = nProcessors
        self.dataDir = dataDir
        self.iceSoVersion = iceSoVersion
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::IceGrid::InternalNodeInfo" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.name = try istr.read()
        self.os = try istr.read()
        self.hostname = try istr.read()
        self.release = try istr.read()
        self.version = try istr.read()
        self.machine = try istr.read()
        self.nProcessors = try istr.read()
        self.dataDir = try istr.read()
        self.iceSoVersion = try istr.read(tag: 1)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: InternalNodeInfo.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.name)
        ostr.write(self.os)
        ostr.write(self.hostname)
        ostr.write(self.release)
        ostr.write(self.version)
        ostr.write(self.machine)
        ostr.write(self.nProcessors)
        ostr.write(self.dataDir)
        ostr.write(tag: 1, value: self.iceSoVersion)
        ostr.endSlice()
    }
}

/// :nodoc:
public class InternalReplicaInfo_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return InternalReplicaInfo.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceGrid_InternalReplicaInfo() -> Ice.ValueTypeResolver {
        return InternalReplicaInfo_TypeResolver()
    }
}

/// Information about an IceGrid registry replica.
open class InternalReplicaInfo: Ice.Value {
    /// The name of the registry.
    public var name: Swift.String = ""
    /// The network name of the host running this registry (as defined in uname()).
    public var hostname: Swift.String = ""

    public required init() {}

    public init(name: Swift.String, hostname: Swift.String) {
        self.name = name
        self.hostname = hostname
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::IceGrid::InternalReplicaInfo" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.name = try istr.read()
        self.hostname = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: InternalReplicaInfo.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.name)
        ostr.write(self.hostname)
        ostr.endSlice()
    }
}


/// Dispatcher for `Adapter` servants.
public struct AdapterDisp: Ice.Dispatcher {
    public let servant: Adapter
    private static let defaultObject = Ice.ObjectI<AdapterTraits>()

    public init(_ servant: Adapter) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "activate":
            try await servant._iceD_activate(request)
        case "getDirectProxy":
            try await servant._iceD_getDirectProxy(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? AdapterDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? AdapterDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? AdapterDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? AdapterDisp.defaultObject)._iceD_ice_ping(request)
        case "setDirectProxy":
            try await servant._iceD_setDirectProxy(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol Adapter {
    /// Activate this adapter. If this adapter can be activated, this will activate the adapter and return the direct
    /// proxy of the adapter once it's active. If this adapter can be activated on demand, this will return 0 if the
    /// adapter is inactive or the adapter direct proxy it's active.
    ///
    /// - Parameter current: The Current object for the dispatch.
    func activate(current: Ice.Current) async throws -> Ice.ObjectPrx?

    /// Get the adapter direct proxy. The adapter direct proxy is a proxy created with the object adapter. The proxy
    /// contains the last known adapter endpoints.
    ///
    /// - Parameter current: The Current object for the dispatch.
    ///
    /// - Returns: A direct proxy containing the last known adapter endpoints if the adapter is already active.
    func getDirectProxy(current: Ice.Current) async throws -> Ice.ObjectPrx?

    /// Set the direct proxy for this adapter.
    ///
    /// - Parameters:
    ///   - proxy
    ///   - current: The Current object for the dispatch.
    ///
    /// - Throws:
    ///   - AdapterActiveException The adapter is already active. It's not possible to override the direct proxy of
    ///     an active adapter.
    func setDirectProxy(proxy: Ice.ObjectPrx?, current: Ice.Current) async throws
}


/// Dispatcher for `FileReader` servants.
public struct FileReaderDisp: Ice.Dispatcher {
    public let servant: FileReader
    private static let defaultObject = Ice.ObjectI<FileReaderTraits>()

    public init(_ servant: FileReader) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "getOffsetFromEnd":
            try await servant._iceD_getOffsetFromEnd(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? FileReaderDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? FileReaderDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? FileReaderDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? FileReaderDisp.defaultObject)._iceD_ice_ping(request)
        case "read":
            try await servant._iceD_read(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol FileReader {
    /// Count the number of given lines from the end of the file and return the file offset.
    ///
    /// - Parameters:
    ///   - filename
    ///   - lines
    ///   - current: The Current object for the dispatch.
    func getOffsetFromEnd(filename: Swift.String, lines: Swift.Int32, current: Ice.Current) async throws -> Swift.Int64

    /// Read lines (or size bytes) at the specified position from the given file.
    ///
    /// - Parameters:
    ///   - filename
    ///   - pos
    ///   - size
    ///   - current: The Current object for the dispatch.
    ///
    /// - Returns:
    ///   - returnValue
    ///   - newPos
    ///   - lines
    func read(filename: Swift.String, pos: Swift.Int64, size: Swift.Int32, current: Ice.Current) async throws -> (returnValue: Swift.Bool, newPos: Swift.Int64, lines: Ice.StringSeq)
}


/// Dispatcher for `Server` servants.
public struct ServerDisp: Ice.Dispatcher {
    public let servant: Server
    private static let defaultObject = Ice.ObjectI<ServerTraits>()

    public init(_ servant: Server) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "checkUpdate":
            try await servant._iceD_checkUpdate(request)
        case "getOffsetFromEnd":
            try await servant._iceD_getOffsetFromEnd(request)
        case "getPid":
            try await servant._iceD_getPid(request)
        case "getState":
            try await servant._iceD_getState(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? ServerDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? ServerDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? ServerDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? ServerDisp.defaultObject)._iceD_ice_ping(request)
        case "isEnabled":
            try await servant._iceD_isEnabled(request)
        case "read":
            try await servant._iceD_read(request)
        case "sendSignal":
            try await servant._iceD_sendSignal(request)
        case "setEnabled":
            try await servant._iceD_setEnabled(request)
        case "setProcess":
            try await servant._iceD_setProcess(request)
        case "start":
            try await servant._iceD_start(request)
        case "stop":
            try await servant._iceD_stop(request)
        case "writeMessage":
            try await servant._iceD_writeMessage(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol Server: FileReader {
    /// Start the server.
    ///
    /// - Parameter current: The Current object for the dispatch.
    func start(current: Ice.Current) async throws

    /// Stop the server. This methods returns only when the server is deactivated. If the server doesn't stop after a
    /// configurable amount of time, it will be killed.
    ///
    /// - Parameter current: The Current object for the dispatch.
    func stop(current: Ice.Current) async throws

    /// Check if the given server can be loaded on this node.
    ///
    /// - Parameters:
    ///   - svr
    ///   - noRestart
    ///   - current: The Current object for the dispatch.
    ///
    /// - Returns: True if the server is inactive.
    ///
    /// - Throws:
    ///   - DeploymentException Raised if the server can't be updated.
    func checkUpdate(svr: InternalServerDescriptor?, noRestart: Swift.Bool, current: Ice.Current) async throws -> Swift.Bool

    /// Enable or disable the server.
    ///
    /// - Parameters:
    ///   - enable
    ///   - current: The Current object for the dispatch.
    func setEnabled(enable: Swift.Bool, current: Ice.Current) async throws

    /// Check if the server is enabled.
    ///
    /// - Parameter current: The Current object for the dispatch.
    func isEnabled(current: Ice.Current) async throws -> Swift.Bool

    /// Send signal to the server
    ///
    /// - Parameters:
    ///   - signal
    ///   - current: The Current object for the dispatch.
    func sendSignal(signal: Swift.String, current: Ice.Current) async throws

    /// Write message on servers' stdout or stderr.
    ///
    /// - Parameters:
    ///   - message
    ///   - fd
    ///   - current: The Current object for the dispatch.
    func writeMessage(message: Swift.String, fd: Swift.Int32, current: Ice.Current) async throws

    /// Return the server state.
    ///
    /// - Parameter current: The Current object for the dispatch.
    ///
    /// - Returns: The server state.
    func getState(current: Ice.Current) async throws -> ServerState

    /// Get the server pid. Note that the value returned by this method is system dependant. On Unix operating systems,
    /// it's the pid value returned by the fork() system call and converted to an integer.
    ///
    /// - Parameter current: The Current object for the dispatch.
    func getPid(current: Ice.Current) async throws -> Swift.Int32

    /// Set the process proxy.
    ///
    /// - Parameters:
    ///   - proc
    ///   - current: The Current object for the dispatch.
    func setProcess(proc: Ice.ProcessPrx?, current: Ice.Current) async throws
}


/// Dispatcher for `ReplicaObserver` servants.
public struct ReplicaObserverDisp: Ice.Dispatcher {
    public let servant: ReplicaObserver
    private static let defaultObject = Ice.ObjectI<ReplicaObserverTraits>()

    public init(_ servant: ReplicaObserver) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "ice_id":
            try await (servant as? Ice.Object ?? ReplicaObserverDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? ReplicaObserverDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? ReplicaObserverDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? ReplicaObserverDisp.defaultObject)._iceD_ice_ping(request)
        case "replicaAdded":
            try await servant._iceD_replicaAdded(request)
        case "replicaInit":
            try await servant._iceD_replicaInit(request)
        case "replicaRemoved":
            try await servant._iceD_replicaRemoved(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol ReplicaObserver {
    /// Initialization of the replica observer.
    ///
    /// - Parameters:
    ///   - replicas
    ///   - current: The Current object for the dispatch.
    func replicaInit(replicas: InternalRegistryPrxSeq, current: Ice.Current) async throws

    /// Notification that a replica has been added. The node should establish a session with this new replica.
    ///
    /// - Parameters:
    ///   - replica
    ///   - current: The Current object for the dispatch.
    func replicaAdded(replica: InternalRegistryPrx?, current: Ice.Current) async throws

    /// Notification that a replica has been removed. The node should destroy the session to this replica.
    ///
    /// - Parameters:
    ///   - replica
    ///   - current: The Current object for the dispatch.
    func replicaRemoved(replica: InternalRegistryPrx?, current: Ice.Current) async throws
}


/// Dispatcher for `Node` servants.
public struct NodeDisp: Ice.Dispatcher {
    public let servant: Node
    private static let defaultObject = Ice.ObjectI<NodeTraits>()

    public init(_ servant: Node) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "destroyServer":
            try await servant._iceD_destroyServer(request)
        case "destroyServerWithoutRestart":
            try await servant._iceD_destroyServerWithoutRestart(request)
        case "getHostname":
            try await servant._iceD_getHostname(request)
        case "getLoad":
            try await servant._iceD_getLoad(request)
        case "getName":
            try await servant._iceD_getName(request)
        case "getOffsetFromEnd":
            try await servant._iceD_getOffsetFromEnd(request)
        case "getProcessorSocketCount":
            try await servant._iceD_getProcessorSocketCount(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? NodeDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? NodeDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? NodeDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? NodeDisp.defaultObject)._iceD_ice_ping(request)
        case "loadServer":
            try await servant._iceD_loadServer(request)
        case "loadServerWithoutRestart":
            try await servant._iceD_loadServerWithoutRestart(request)
        case "read":
            try await servant._iceD_read(request)
        case "registerWithReplica":
            try await servant._iceD_registerWithReplica(request)
        case "replicaAdded":
            try await servant._iceD_replicaAdded(request)
        case "replicaInit":
            try await servant._iceD_replicaInit(request)
        case "replicaRemoved":
            try await servant._iceD_replicaRemoved(request)
        case "shutdown":
            try await servant._iceD_shutdown(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol Node: FileReader, ReplicaObserver {
    /// Load the given server. If the server resources weren't already created (database environment directories,
    /// property files, etc), they will be created. The returned proxy is never null.
    ///
    /// - Parameters:
    ///   - svr
    ///   - replicaName
    ///   - current: The Current object for the dispatch.
    ///
    /// - Returns:
    ///   - returnValue
    ///   - adapters
    ///   - activateTimeout
    ///   - deactivateTimeout
    func loadServer(svr: InternalServerDescriptor?, replicaName: Swift.String, current: Ice.Current) async throws -> (returnValue: ServerPrx?, adapters: AdapterPrxDict, activateTimeout: Swift.Int32, deactivateTimeout: Swift.Int32)

    /// Load the given server and ensure the server won't be restarted. If the server resources weren't already created
    /// (database environment directories, property files, etc), they will be created. If the server can't be updated
    /// without a restart, a DeploymentException is raised. The returned proxy is never null.
    ///
    /// - Parameters:
    ///   - svr
    ///   - replicaName
    ///   - current: The Current object for the dispatch.
    ///
    /// - Returns:
    ///   - returnValue
    ///   - adapters
    ///   - activateTimeout
    ///   - deactivateTimeout
    func loadServerWithoutRestart(svr: InternalServerDescriptor?, replicaName: Swift.String, current: Ice.Current) async throws -> (returnValue: ServerPrx?, adapters: AdapterPrxDict, activateTimeout: Swift.Int32, deactivateTimeout: Swift.Int32)

    /// Destroy the given server.
    ///
    /// - Parameters:
    ///   - name
    ///   - uuid
    ///   - revision
    ///   - replicaName
    ///   - current: The Current object for the dispatch.
    func destroyServer(name: Swift.String, uuid: Swift.String, revision: Swift.Int32, replicaName: Swift.String, current: Ice.Current) async throws

    /// Destroy the server if it's not active.
    ///
    /// - Parameters:
    ///   - name
    ///   - uuid
    ///   - revision
    ///   - replicaName
    ///   - current: The Current object for the dispatch.
    func destroyServerWithoutRestart(name: Swift.String, uuid: Swift.String, revision: Swift.Int32, replicaName: Swift.String, current: Ice.Current) async throws

    /// Establish a session to the given replica, this method only returns once the registration was attempted (unlike
    /// replicaAdded below).
    ///
    /// - Parameters:
    ///   - replica
    ///   - current: The Current object for the dispatch.
    func registerWithReplica(replica: InternalRegistryPrx?, current: Ice.Current) async throws

    /// Get the node name.
    ///
    /// - Parameter current: The Current object for the dispatch.
    func getName(current: Ice.Current) async throws -> Swift.String

    /// Get the node hostname.
    ///
    /// - Parameter current: The Current object for the dispatch.
    func getHostname(current: Ice.Current) async throws -> Swift.String

    /// Get the node load.
    ///
    /// - Parameter current: The Current object for the dispatch.
    func getLoad(current: Ice.Current) async throws -> LoadInfo

    /// Get the number of processor sockets for the machine where this node is running.
    ///
    /// - Parameter current: The Current object for the dispatch.
    func getProcessorSocketCount(current: Ice.Current) async throws -> Swift.Int32

    /// Shutdown the node.
    ///
    /// - Parameter current: The Current object for the dispatch.
    func shutdown(current: Ice.Current) async throws
}


/// Dispatcher for `NodeSession` servants.
public struct NodeSessionDisp: Ice.Dispatcher {
    public let servant: NodeSession
    private static let defaultObject = Ice.ObjectI<NodeSessionTraits>()

    public init(_ servant: NodeSession) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "destroy":
            try await servant._iceD_destroy(request)
        case "getObserver":
            try await servant._iceD_getObserver(request)
        case "getServers":
            try await servant._iceD_getServers(request)
        case "getTimeout":
            try await servant._iceD_getTimeout(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? NodeSessionDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? NodeSessionDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? NodeSessionDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? NodeSessionDisp.defaultObject)._iceD_ice_ping(request)
        case "keepAlive":
            try await servant._iceD_keepAlive(request)
        case "loadServers":
            try await servant._iceD_loadServers(request)
        case "setReplicaObserver":
            try await servant._iceD_setReplicaObserver(request)
        case "waitForApplicationUpdate":
            try await servant._iceD_waitForApplicationUpdate(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol NodeSession {
    /// The node call this method to keep the session alive.
    ///
    /// - Parameters:
    ///   - load
    ///   - current: The Current object for the dispatch.
    func keepAlive(load: LoadInfo, current: Ice.Current) async throws

    /// Set the replica observer. The node calls this method when it's ready to receive notifications for the replicas.
    /// It only calls this for the session with the master.
    ///
    /// - Parameters:
    ///   - observer
    ///   - current: The Current object for the dispatch.
    func setReplicaObserver(observer: ReplicaObserverPrx?, current: Ice.Current) async throws

    /// Return the node session timeout.
    ///
    /// - Parameter current: The Current object for the dispatch.
    func getTimeout(current: Ice.Current) async throws -> Swift.Int32

    /// Return the node observer.
    ///
    /// - Parameter current: The Current object for the dispatch.
    func getObserver(current: Ice.Current) async throws -> NodeObserverPrx?

    /// Ask the registry to load the servers on the node.
    ///
    /// - Parameter current: The Current object for the dispatch.
    func loadServers(current: Ice.Current) async throws

    /// Get the name of the servers deployed on the node.
    ///
    /// - Parameter current: The Current object for the dispatch.
    func getServers(current: Ice.Current) async throws -> Ice.StringSeq

    /// Wait for the application update to complete (the application is completely updated once all the registry
    /// replicas have been updated). This is used by the node to ensure that before to start a server all the
    /// replicas have the up-to-date descriptor of the server.
    ///
    /// - Parameters:
    ///   - application
    ///   - revision
    ///   - current: The Current object for the dispatch.
    func waitForApplicationUpdate(application: Swift.String, revision: Swift.Int32, current: Ice.Current) async throws

    /// Destroy the session.
    ///
    /// - Parameter current: The Current object for the dispatch.
    func destroy(current: Ice.Current) async throws
}


/// Dispatcher for `DatabaseObserver` servants.
public struct DatabaseObserverDisp: Ice.Dispatcher {
    public let servant: DatabaseObserver
    private static let defaultObject = Ice.ObjectI<DatabaseObserverTraits>()

    public init(_ servant: DatabaseObserver) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "adapterAdded":
            try await servant._iceD_adapterAdded(request)
        case "adapterInit":
            try await servant._iceD_adapterInit(request)
        case "adapterRemoved":
            try await servant._iceD_adapterRemoved(request)
        case "adapterUpdated":
            try await servant._iceD_adapterUpdated(request)
        case "applicationAdded":
            try await servant._iceD_applicationAdded(request)
        case "applicationInit":
            try await servant._iceD_applicationInit(request)
        case "applicationRemoved":
            try await servant._iceD_applicationRemoved(request)
        case "applicationUpdated":
            try await servant._iceD_applicationUpdated(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? DatabaseObserverDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? DatabaseObserverDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? DatabaseObserverDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? DatabaseObserverDisp.defaultObject)._iceD_ice_ping(request)
        case "objectAdded":
            try await servant._iceD_objectAdded(request)
        case "objectInit":
            try await servant._iceD_objectInit(request)
        case "objectRemoved":
            try await servant._iceD_objectRemoved(request)
        case "objectUpdated":
            try await servant._iceD_objectUpdated(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol DatabaseObserver: ApplicationObserver, ObjectObserver, AdapterObserver {}


/// Dispatcher for `ReplicaSession` servants.
public struct ReplicaSessionDisp: Ice.Dispatcher {
    public let servant: ReplicaSession
    private static let defaultObject = Ice.ObjectI<ReplicaSessionTraits>()

    public init(_ servant: ReplicaSession) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "destroy":
            try await servant._iceD_destroy(request)
        case "getTimeout":
            try await servant._iceD_getTimeout(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? ReplicaSessionDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? ReplicaSessionDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? ReplicaSessionDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? ReplicaSessionDisp.defaultObject)._iceD_ice_ping(request)
        case "keepAlive":
            try await servant._iceD_keepAlive(request)
        case "receivedUpdate":
            try await servant._iceD_receivedUpdate(request)
        case "registerWellKnownObjects":
            try await servant._iceD_registerWellKnownObjects(request)
        case "setAdapterDirectProxy":
            try await servant._iceD_setAdapterDirectProxy(request)
        case "setDatabaseObserver":
            try await servant._iceD_setDatabaseObserver(request)
        case "setEndpoints":
            try await servant._iceD_setEndpoints(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol ReplicaSession {
    /// The replica call this method to keep the session alive.
    ///
    /// - Parameter current: The Current object for the dispatch.
    func keepAlive(current: Ice.Current) async throws

    /// Return the replica session timeout.
    ///
    /// - Parameter current: The Current object for the dispatch.
    func getTimeout(current: Ice.Current) async throws -> Swift.Int32

    /// Set the database observer. Once the observer is subscribed, it will receive the database and database updates.
    ///
    /// - Parameters:
    ///   - dbObs
    ///   - serials
    ///   - current: The Current object for the dispatch.
    func setDatabaseObserver(dbObs: DatabaseObserverPrx?, serials: StringLongDict?, current: Ice.Current) async throws

    /// This method sets the endpoints of the replica. This allows the master to create proxies with multiple endpoints
    /// for replicated objects (e.g.: IceGrid::Query object).
    ///
    /// - Parameters:
    ///   - endpoints
    ///   - current: The Current object for the dispatch.
    func setEndpoints(endpoints: StringObjectProxyDict, current: Ice.Current) async throws

    /// Registers the replica well-known objects with the master.
    ///
    /// - Parameters:
    ///   - objects
    ///   - current: The Current object for the dispatch.
    func registerWellKnownObjects(objects: ObjectInfoSeq, current: Ice.Current) async throws

    /// Set the adapter direct proxy of the given adapter in the master. This is used to support dynamic registration
    /// with the locator registry interface.
    ///
    /// - Parameters:
    ///   - adapterId
    ///   - replicaGroupId
    ///   - proxy
    ///   - current: The Current object for the dispatch.
    func setAdapterDirectProxy(adapterId: Swift.String, replicaGroupId: Swift.String, proxy: Ice.ObjectPrx?, current: Ice.Current) async throws

    /// Notify the master that an update was received. The master might wait for replication updates to be received by
    /// all the replicas before to continue.
    ///
    /// - Parameters:
    ///   - name
    ///   - serial
    ///   - failure
    ///   - current: The Current object for the dispatch.
    func receivedUpdate(name: TopicName, serial: Swift.Int32, failure: Swift.String, current: Ice.Current) async throws

    /// Destroy the session.
    ///
    /// - Parameter current: The Current object for the dispatch.
    func destroy(current: Ice.Current) async throws
}


/// Dispatcher for `InternalRegistry` servants.
public struct InternalRegistryDisp: Ice.Dispatcher {
    public let servant: InternalRegistry
    private static let defaultObject = Ice.ObjectI<InternalRegistryTraits>()

    public init(_ servant: InternalRegistry) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "getAdapters":
            try await servant._iceD_getAdapters(request)
        case "getApplications":
            try await servant._iceD_getApplications(request)
        case "getNodes":
            try await servant._iceD_getNodes(request)
        case "getObjects":
            try await servant._iceD_getObjects(request)
        case "getOffsetFromEnd":
            try await servant._iceD_getOffsetFromEnd(request)
        case "getReplicas":
            try await servant._iceD_getReplicas(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? InternalRegistryDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? InternalRegistryDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? InternalRegistryDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? InternalRegistryDisp.defaultObject)._iceD_ice_ping(request)
        case "read":
            try await servant._iceD_read(request)
        case "registerNode":
            try await servant._iceD_registerNode(request)
        case "registerReplica":
            try await servant._iceD_registerReplica(request)
        case "registerWithReplica":
            try await servant._iceD_registerWithReplica(request)
        case "shutdown":
            try await servant._iceD_shutdown(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol InternalRegistry: FileReader {
    /// Register a node with the registry. If a node with the same name is already registered,
    /// registerNode overrides the existing registration only when the previously
    /// registered node is not active.
    ///
    /// - Parameters:
    ///   - info: Some information on the node.
    ///   - prx: The proxy of the node.
    ///   - loadInf: The load information of the node.
    ///   - current: The Current object for the dispatch.
    ///
    /// - Returns: The node session proxy.
    ///
    /// - Throws:
    ///   - NodeActiveException Raised if the node is already registered and currently active.
    func registerNode(info: InternalNodeInfo?, prx: NodePrx?, loadInf: LoadInfo, current: Ice.Current) async throws -> NodeSessionPrx?

    /// Register a replica with the registry. If a replica with the same name is already registered,
    /// registerReplica overrides the existing registration only when the previously
    /// registered node is not active.
    ///
    /// - Parameters:
    ///   - info: Some information on the replica.
    ///   - prx: The proxy of the replica.
    ///   - current: The Current object for the dispatch.
    ///
    /// - Returns: The replica session proxy.
    ///
    /// - Throws:
    ///   - ReplicaActiveException Raised if the replica is already registered and currently active.
    func registerReplica(info: InternalReplicaInfo?, prx: InternalRegistryPrx?, current: Ice.Current) async throws -> ReplicaSessionPrx?

    /// Create a session with the given registry replica. This method returns only once the session creation has been
    /// attempted.
    ///
    /// - Parameters:
    ///   - prx
    ///   - current: The Current object for the dispatch.
    func registerWithReplica(prx: InternalRegistryPrx?, current: Ice.Current) async throws

    /// Return the proxies of all the nodes known by this registry.
    ///
    /// - Parameter current: The Current object for the dispatch.
    func getNodes(current: Ice.Current) async throws -> NodePrxSeq

    /// Return the proxies of all the registry replicas known by this registry.
    ///
    /// - Parameter current: The Current object for the dispatch.
    func getReplicas(current: Ice.Current) async throws -> InternalRegistryPrxSeq

    /// Return applications, adapters, objects from this replica.
    ///
    /// - Parameter current: The Current object for the dispatch.
    ///
    /// - Returns:
    ///   - returnValue
    ///   - serial
    func getApplications(current: Ice.Current) async throws -> (returnValue: ApplicationInfoSeq, serial: Swift.Int64)

    func getAdapters(current: Ice.Current) async throws -> (returnValue: AdapterInfoSeq, serial: Swift.Int64)

    func getObjects(current: Ice.Current) async throws -> (returnValue: ObjectInfoSeq, serial: Swift.Int64)

    /// Shutdown this registry.
    ///
    /// - Parameter current: The Current object for the dispatch.
    func shutdown(current: Ice.Current) async throws
}

extension Adapter {
    public func _iceD_activate(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.activate(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_getDirectProxy(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getDirectProxy(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_setDirectProxy(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_proxy: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
        try await self.setDirectProxy(proxy: iceP_proxy, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}

extension FileReader {
    public func _iceD_getOffsetFromEnd(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_filename: Swift.String = try istr.read()
        let iceP_lines: Swift.Int32 = try istr.read()
        let result = try await self.getOffsetFromEnd(filename: iceP_filename, lines: iceP_lines, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_read(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_filename: Swift.String = try istr.read()
        let iceP_pos: Swift.Int64 = try istr.read()
        let iceP_size: Swift.Int32 = try istr.read()
        let result = try await self.read(filename: iceP_filename, pos: iceP_pos, size: iceP_size, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_newPos, iceP_lines) = value
            ostr.write(iceP_newPos)
            ostr.write(iceP_lines)
            ostr.write(iceP_returnValue)
        }
    }
}

extension Server {
    public func _iceD_start(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.start(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_stop(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.stop(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_checkUpdate(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_svr: InternalServerDescriptor?
        try istr.read(InternalServerDescriptor.self) { iceP_svr = $0 }
        let iceP_noRestart: Swift.Bool = try istr.read()
        try istr.readPendingValues()
        let result = try await self.checkUpdate(svr: iceP_svr, noRestart: iceP_noRestart, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_setEnabled(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_enable: Swift.Bool = try istr.read()
        try await self.setEnabled(enable: iceP_enable, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_isEnabled(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.isEnabled(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_sendSignal(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_signal: Swift.String = try istr.read()
        try await self.sendSignal(signal: iceP_signal, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_writeMessage(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_message: Swift.String = try istr.read()
        let iceP_fd: Swift.Int32 = try istr.read()
        try await self.writeMessage(message: iceP_message, fd: iceP_fd, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_getState(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getState(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_getPid(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getPid(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_setProcess(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_proc: Ice.ProcessPrx? = try istr.read(Ice.ProcessPrx.self)
        try await self.setProcess(proc: iceP_proc, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}

extension ReplicaObserver {
    public func _iceD_replicaInit(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_replicas: InternalRegistryPrxSeq = try InternalRegistryPrxSeqHelper.read(from: istr)
        try await self.replicaInit(replicas: iceP_replicas, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_replicaAdded(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_replica: InternalRegistryPrx? = try istr.read(InternalRegistryPrx.self)
        try await self.replicaAdded(replica: iceP_replica, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_replicaRemoved(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_replica: InternalRegistryPrx? = try istr.read(InternalRegistryPrx.self)
        try await self.replicaRemoved(replica: iceP_replica, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}

extension Node {
    public func _iceD_loadServer(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_svr: InternalServerDescriptor?
        try istr.read(InternalServerDescriptor.self) { iceP_svr = $0 }
        let iceP_replicaName: Swift.String = try istr.read()
        try istr.readPendingValues()
        let result = try await self.loadServer(svr: iceP_svr, replicaName: iceP_replicaName, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_adapters, iceP_activateTimeout, iceP_deactivateTimeout) = value
            AdapterPrxDictHelper.write(to: ostr, value: iceP_adapters)
            ostr.write(iceP_activateTimeout)
            ostr.write(iceP_deactivateTimeout)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_loadServerWithoutRestart(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_svr: InternalServerDescriptor?
        try istr.read(InternalServerDescriptor.self) { iceP_svr = $0 }
        let iceP_replicaName: Swift.String = try istr.read()
        try istr.readPendingValues()
        let result = try await self.loadServerWithoutRestart(svr: iceP_svr, replicaName: iceP_replicaName, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_adapters, iceP_activateTimeout, iceP_deactivateTimeout) = value
            AdapterPrxDictHelper.write(to: ostr, value: iceP_adapters)
            ostr.write(iceP_activateTimeout)
            ostr.write(iceP_deactivateTimeout)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_destroyServer(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_name: Swift.String = try istr.read()
        let iceP_uuid: Swift.String = try istr.read()
        let iceP_revision: Swift.Int32 = try istr.read()
        let iceP_replicaName: Swift.String = try istr.read()
        try await self.destroyServer(name: iceP_name, uuid: iceP_uuid, revision: iceP_revision, replicaName: iceP_replicaName, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_destroyServerWithoutRestart(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_name: Swift.String = try istr.read()
        let iceP_uuid: Swift.String = try istr.read()
        let iceP_revision: Swift.Int32 = try istr.read()
        let iceP_replicaName: Swift.String = try istr.read()
        try await self.destroyServerWithoutRestart(name: iceP_name, uuid: iceP_uuid, revision: iceP_revision, replicaName: iceP_replicaName, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_registerWithReplica(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_replica: InternalRegistryPrx? = try istr.read(InternalRegistryPrx.self)
        try await self.registerWithReplica(replica: iceP_replica, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_getName(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getName(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_getHostname(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getHostname(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_getLoad(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getLoad(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_getProcessorSocketCount(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getProcessorSocketCount(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_shutdown(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.shutdown(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}

extension NodeSession {
    public func _iceD_keepAlive(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_load: LoadInfo = try istr.read()
        try await self.keepAlive(load: iceP_load, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_setReplicaObserver(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_observer: ReplicaObserverPrx? = try istr.read(ReplicaObserverPrx.self)
        try await self.setReplicaObserver(observer: iceP_observer, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_getTimeout(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getTimeout(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_getObserver(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getObserver(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_loadServers(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.loadServers(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_getServers(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getServers(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_waitForApplicationUpdate(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_application: Swift.String = try istr.read()
        let iceP_revision: Swift.Int32 = try istr.read()
        try await self.waitForApplicationUpdate(application: iceP_application, revision: iceP_revision, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_destroy(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.destroy(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}

extension DatabaseObserver {}

extension ReplicaSession {
    public func _iceD_keepAlive(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.keepAlive(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_getTimeout(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getTimeout(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_setDatabaseObserver(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_dbObs: DatabaseObserverPrx? = try istr.read(DatabaseObserverPrx.self)
        let iceP_serials: StringLongDict? = try StringLongDictHelper.read(from: istr, tag: 1)
        try await self.setDatabaseObserver(dbObs: iceP_dbObs, serials: iceP_serials, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_setEndpoints(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_endpoints: StringObjectProxyDict = try StringObjectProxyDictHelper.read(from: istr)
        try await self.setEndpoints(endpoints: iceP_endpoints, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_registerWellKnownObjects(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_objects: ObjectInfoSeq = try ObjectInfoSeqHelper.read(from: istr)
        try await self.registerWellKnownObjects(objects: iceP_objects, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_setAdapterDirectProxy(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_adapterId: Swift.String = try istr.read()
        let iceP_replicaGroupId: Swift.String = try istr.read()
        let iceP_proxy: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
        try await self.setAdapterDirectProxy(adapterId: iceP_adapterId, replicaGroupId: iceP_replicaGroupId, proxy: iceP_proxy, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_receivedUpdate(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_name: TopicName = try istr.read()
        let iceP_serial: Swift.Int32 = try istr.read()
        let iceP_failure: Swift.String = try istr.read()
        try await self.receivedUpdate(name: iceP_name, serial: iceP_serial, failure: iceP_failure, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_destroy(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.destroy(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}

extension InternalRegistry {
    public func _iceD_registerNode(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_info: InternalNodeInfo?
        try istr.read(InternalNodeInfo.self) { iceP_info = $0 }
        let iceP_prx: NodePrx? = try istr.read(NodePrx.self)
        let iceP_loadInf: LoadInfo = try istr.read()
        try istr.readPendingValues()
        let result = try await self.registerNode(info: iceP_info, prx: iceP_prx, loadInf: iceP_loadInf, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_registerReplica(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_info: InternalReplicaInfo?
        try istr.read(InternalReplicaInfo.self) { iceP_info = $0 }
        let iceP_prx: InternalRegistryPrx? = try istr.read(InternalRegistryPrx.self)
        try istr.readPendingValues()
        let result = try await self.registerReplica(info: iceP_info, prx: iceP_prx, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_registerWithReplica(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_prx: InternalRegistryPrx? = try istr.read(InternalRegistryPrx.self)
        try await self.registerWithReplica(prx: iceP_prx, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_getNodes(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getNodes(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            NodePrxSeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_getReplicas(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getReplicas(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            InternalRegistryPrxSeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_getApplications(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getApplications(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_serial) = value
            ostr.write(iceP_serial)
            ApplicationInfoSeqHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_getAdapters(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getAdapters(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_serial) = value
            ostr.write(iceP_serial)
            AdapterInfoSeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_getObjects(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getObjects(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_serial) = value
            ostr.write(iceP_serial)
            ObjectInfoSeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_shutdown(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.shutdown(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}
