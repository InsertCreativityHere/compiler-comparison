//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.9
//
// <auto-generated>
//
// Generated from file `Election.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice
import PromiseKit
import IceStorm

/// The contents of topic.
public struct TopicContent {
    /// The topic identity.
    public var id: Ice.Identity = Ice.Identity()
    /// The topic subscribers.
    public var records: IceStorm.SubscriberRecordSeq = IceStorm.SubscriberRecordSeq()

    public init() {}

    public init(id: Ice.Identity, records: IceStorm.SubscriberRecordSeq) {
        self.id = id
        self.records = records
    }
}

/// An `Ice.InputStream` extension to read `TopicContent` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `TopicContent` structured value from the stream.
    ///
    /// - returns: `TopicContent` - The structured value read from the stream.
    func read() throws -> TopicContent {
        var v = TopicContent()
        v.id = try self.read()
        v.records = try IceStorm.SubscriberRecordSeqHelper.read(from: self)
        return v
    }

    /// Read an optional `TopicContent?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `TopicContent?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> TopicContent? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as TopicContent
    }
}

/// An `Ice.OutputStream` extension to write `TopicContent` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `TopicContent` structured value to the stream.
    ///
    /// - parameter _: `TopicContent` - The value to write to the stream.
    func write(_ v: TopicContent) {
        self.write(v.id)
        IceStorm.SubscriberRecordSeqHelper.write(to: self, value: v.records)
    }

    /// Write an optional `TopicContent?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `TopicContent?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: TopicContent?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// A sequence of topic content.
public typealias TopicContentSeq = [TopicContent]

/// Helper class to read and write `TopicContentSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct TopicContentSeqHelper {
    /// Read a `TopicContentSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `TopicContentSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> TopicContentSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 3)
        var v = TopicContentSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: TopicContent = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `TopicContentSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `TopicContentSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> TopicContentSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `TopicContentSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `TopicContentSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: TopicContentSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `TopicContentSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `TopicContentSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: TopicContentSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// :nodoc:
public class ObserverInconsistencyException_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return ObserverInconsistencyException.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceStormElection_ObserverInconsistencyException() -> Ice.UserExceptionTypeResolver {
        return ObserverInconsistencyException_TypeResolver()
    }
}

/// Thrown if an observer detects an inconsistency.
open class ObserverInconsistencyException: Ice.UserException {
    /// The reason for the inconsistency.
    public var reason: Swift.String = ""

    public required init() {}

    public init(reason: Swift.String) {
        self.reason = reason
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::IceStormElection::ObserverInconsistencyException"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: ObserverInconsistencyException.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.reason)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.reason = try istr.read()
        try istr.endSlice()
    }
}

/// Traits for Slice interface `ReplicaObserver`.
public struct ReplicaObserverTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceStormElection::ReplicaObserver"]
    public static let staticId = "::IceStormElection::ReplicaObserver"
}

/// Traits for Slice interface `TopicManagerSync`.
public struct TopicManagerSyncTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceStormElection::TopicManagerSync"]
    public static let staticId = "::IceStormElection::TopicManagerSync"
}

/// The node state.
public enum NodeState: Swift.UInt8 {
    /// NodeStateInactive The node is inactive and awaiting an election.
    case NodeStateInactive = 0
    /// NodeStateElection The node is electing a leader.
    case NodeStateElection = 1
    /// NodeStateReorganization The replica group is reorganizing.
    case NodeStateReorganization = 2
    /// NodeStateNormal The replica group is active & replicating.
    case NodeStateNormal = 3
    public init() {
        self = .NodeStateInactive
    }
}

/// An `Ice.InputStream` extension to read `NodeState` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - returns: `NodeState` - The enumarated value.
    func read() throws -> NodeState {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 3)
        guard let val = NodeState(rawValue: rawValue) else {
            throw Ice.MarshalException(reason: "invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `NodeState` - The enumerated value.
    func read(tag: Swift.Int32) throws -> NodeState? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as NodeState
    }
}

/// An `Ice.OutputStream` extension to write `NodeState` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// parameter _: `NodeState` - The enumerator to write.
    func write(_ v: NodeState) {
        write(enum: v.rawValue, maxValue: 3)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// parameter _: `NodeState` - The enumerator to write.
    func write(tag: Swift.Int32, value: NodeState?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 3)
    }
}

/// All nodes in the replication group.
public struct NodeInfo {
    /// The identity of the node.
    public var id: Swift.Int32 = 0
    /// The node proxy.
    public var n: NodePrx? = nil

    public init() {}

    public init(id: Swift.Int32, n: NodePrx?) {
        self.id = id
        self.n = n
    }
}

/// An `Ice.InputStream` extension to read `NodeInfo` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `NodeInfo` structured value from the stream.
    ///
    /// - returns: `NodeInfo` - The structured value read from the stream.
    func read() throws -> NodeInfo {
        var v = NodeInfo()
        v.id = try self.read()
        v.n = try self.read(NodePrx.self)
        return v
    }

    /// Read an optional `NodeInfo?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `NodeInfo?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> NodeInfo? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as NodeInfo
    }
}

/// An `Ice.OutputStream` extension to write `NodeInfo` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `NodeInfo` structured value to the stream.
    ///
    /// - parameter _: `NodeInfo` - The value to write to the stream.
    func write(_ v: NodeInfo) {
        self.write(v.id)
        self.write(v.n)
    }

    /// Write an optional `NodeInfo?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `NodeInfo?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: NodeInfo?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// A sequence of node info.
public typealias NodeInfoSeq = [NodeInfo]

/// Helper class to read and write `NodeInfoSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct NodeInfoSeqHelper {
    /// Read a `NodeInfoSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `NodeInfoSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> NodeInfoSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 6)
        var v = NodeInfoSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: NodeInfo = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `NodeInfoSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `NodeInfoSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> NodeInfoSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `NodeInfoSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `NodeInfoSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: NodeInfoSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `NodeInfoSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `NodeInfoSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: NodeInfoSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// The group info.
public struct GroupInfo: Swift.Hashable {
    /// The identity of the node.
    public var id: Swift.Int32 = 0
    /// The last known log update for this node.
    public var llu: LogUpdate = LogUpdate()

    public init() {}

    public init(id: Swift.Int32, llu: LogUpdate) {
        self.id = id
        self.llu = llu
    }
}

/// An `Ice.InputStream` extension to read `GroupInfo` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `GroupInfo` structured value from the stream.
    ///
    /// - returns: `GroupInfo` - The structured value read from the stream.
    func read() throws -> GroupInfo {
        var v = GroupInfo()
        v.id = try self.read()
        v.llu = try self.read()
        return v
    }

    /// Read an optional `GroupInfo?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `GroupInfo?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> GroupInfo? {
        guard try readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try skipSize()
        return try read() as GroupInfo
    }
}

/// An `Ice.OutputStream` extension to write `GroupInfo` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `GroupInfo` structured value to the stream.
    ///
    /// - parameter _: `GroupInfo` - The value to write to the stream.
    func write(_ v: GroupInfo) {
        self.write(v.id)
        self.write(v.llu)
    }

    /// Write an optional `GroupInfo?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `GroupInfo?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: GroupInfo?) {
        if let v = value {
            if writeOptional(tag: tag, format: .VSize) {
                write(size: 20)
                write(v)
            }
        }
    }
}

/// A sequence of group info.
public typealias GroupInfoSeq = [GroupInfo]

/// Helper class to read and write `GroupInfoSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct GroupInfoSeqHelper {
    /// Read a `GroupInfoSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `GroupInfoSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> GroupInfoSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 20)
        var v = GroupInfoSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: GroupInfo = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `GroupInfoSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `GroupInfoSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> GroupInfoSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Wite a `GroupInfoSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `GroupInfoSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: GroupInfoSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `GroupInfoSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `GroupInfoSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: GroupInfoSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 20) {
            write(to: ostr, value: val)
        }
    }
}

public struct QueryInfo {
    /// The node id.
    public var id: Swift.Int32 = 0
    /// The nodes coordinator.
    public var coord: Swift.Int32 = 0
    /// The nodes group name.
    public var group: Swift.String = ""
    /// The replica the node is managing.
    public var replica: Ice.ObjectPrx? = nil
    /// The node state.
    public var state: NodeState = .NodeStateInactive
    /// The sequence of nodes in this nodes group.
    public var up: GroupInfoSeq = GroupInfoSeq()
    /// The highest priority node that this node has seen.
    public var max: Swift.Int32 = 0

    public init() {}

    public init(id: Swift.Int32, coord: Swift.Int32, group: Swift.String, replica: Ice.ObjectPrx?, state: NodeState, up: GroupInfoSeq, max: Swift.Int32) {
        self.id = id
        self.coord = coord
        self.group = group
        self.replica = replica
        self.state = state
        self.up = up
        self.max = max
    }
}

/// An `Ice.InputStream` extension to read `QueryInfo` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `QueryInfo` structured value from the stream.
    ///
    /// - returns: `QueryInfo` - The structured value read from the stream.
    func read() throws -> QueryInfo {
        var v = QueryInfo()
        v.id = try self.read()
        v.coord = try self.read()
        v.group = try self.read()
        v.replica = try self.read(Ice.ObjectPrx.self)
        v.state = try self.read()
        v.up = try GroupInfoSeqHelper.read(from: self)
        v.max = try self.read()
        return v
    }

    /// Read an optional `QueryInfo?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `QueryInfo?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> QueryInfo? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as QueryInfo
    }
}

/// An `Ice.OutputStream` extension to write `QueryInfo` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `QueryInfo` structured value to the stream.
    ///
    /// - parameter _: `QueryInfo` - The value to write to the stream.
    func write(_ v: QueryInfo) {
        self.write(v.id)
        self.write(v.coord)
        self.write(v.group)
        self.write(v.replica)
        self.write(v.state)
        GroupInfoSeqHelper.write(to: self, value: v.up)
        self.write(v.max)
    }

    /// Write an optional `QueryInfo?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `QueryInfo?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: QueryInfo?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// Traits for Slice interface `Node`.
public struct NodeTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::IceStormElection::Node"]
    public static let staticId = "::IceStormElection::Node"
}

/// The replica observer.
///
/// ReplicaObserverPrx Methods:
///
///  - `init`: Initialize the observer.
///
///  - initAsync: Initialize the observer.
///
///  - createTopic: Create the topic with the given name.
///
///  - createTopicAsync: Create the topic with the given name.
///
///  - destroyTopic: Destroy the topic with the given name.
///
///  - destroyTopicAsync: Destroy the topic with the given name.
///
///  - addSubscriber: Add a subscriber to a topic.
///
///  - addSubscriberAsync: Add a subscriber to a topic.
///
///  - removeSubscriber: Remove a subscriber from a topic.
///
///  - removeSubscriberAsync: Remove a subscriber from a topic.
public protocol ReplicaObserverPrx: Ice.ObjectPrx {}

private final class ReplicaObserverPrxI: Ice.ObjectPrxI, ReplicaObserverPrx {
    public override class func ice_staticId() -> Swift.String {
        return ReplicaObserverTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `ReplicaObserverPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `ReplicaObserverPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: ReplicaObserverPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> ReplicaObserverPrx? {
    return try ReplicaObserverPrxI.checkedCast(prx: prx, facet: facet, context: context) as ReplicaObserverPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `ReplicaObserverPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `ReplicaObserverPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: ReplicaObserverPrx.Protocol, facet: Swift.String? = nil) -> ReplicaObserverPrx {
    return ReplicaObserverPrxI.uncheckedCast(prx: prx, facet: facet) as ReplicaObserverPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `ReplicaObserverPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: ReplicaObserverPrx.Protocol) -> Swift.String {
    return ReplicaObserverTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `ReplicaObserverPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `ReplicaObserverPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `ReplicaObserverPrx?` - The extracted proxy
    func read(_ type: ReplicaObserverPrx.Protocol) throws -> ReplicaObserverPrx? {
        return try read() as ReplicaObserverPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `ReplicaObserverPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `ReplicaObserverPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: ReplicaObserverPrx.Protocol) throws -> ReplicaObserverPrx? {
        return try read(tag: tag) as ReplicaObserverPrxI?
    }
}

/// The replica observer.
///
/// ReplicaObserverPrx Methods:
///
///  - `init`: Initialize the observer.
///
///  - initAsync: Initialize the observer.
///
///  - createTopic: Create the topic with the given name.
///
///  - createTopicAsync: Create the topic with the given name.
///
///  - destroyTopic: Destroy the topic with the given name.
///
///  - destroyTopicAsync: Destroy the topic with the given name.
///
///  - addSubscriber: Add a subscriber to a topic.
///
///  - addSubscriberAsync: Add a subscriber to a topic.
///
///  - removeSubscriber: Remove a subscriber from a topic.
///
///  - removeSubscriberAsync: Remove a subscriber from a topic.
public extension ReplicaObserverPrx {
    /// Initialize the observer.
    ///
    /// - parameter llu: `LogUpdate` The last log update seen by the master.
    ///
    /// - parameter content: `TopicContentSeq` The topic content.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - ObserverInconsistencyException - Raised if an
    ///     inconsisency was detected.
    func `init`(llu iceP_llu: LogUpdate, content iceP_content: TopicContentSeq, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "init",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_llu)
                              TopicContentSeqHelper.write(to: ostr, value: iceP_content)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as ObserverInconsistencyException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Initialize the observer.
    ///
    /// - parameter llu: `LogUpdate` The last log update seen by the master.
    ///
    /// - parameter content: `TopicContentSeq` The topic content.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func initAsync(llu iceP_llu: LogUpdate, content iceP_content: TopicContentSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "init",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_llu)
                                      TopicContentSeqHelper.write(to: ostr, value: iceP_content)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ObserverInconsistencyException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Create the topic with the given name.
    ///
    /// - parameter llu: `LogUpdate` The log update token.
    ///
    /// - parameter name: `Swift.String` The topic name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - ObserverInconsistencyException - Raised if an
    ///     inconsisency was detected.
    func createTopic(llu iceP_llu: LogUpdate, name iceP_name: Swift.String, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "createTopic",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_llu)
                              ostr.write(iceP_name)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as ObserverInconsistencyException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Create the topic with the given name.
    ///
    /// - parameter llu: `LogUpdate` The log update token.
    ///
    /// - parameter name: `Swift.String` The topic name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func createTopicAsync(llu iceP_llu: LogUpdate, name iceP_name: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "createTopic",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_llu)
                                      ostr.write(iceP_name)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ObserverInconsistencyException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Destroy the topic with the given name.
    ///
    /// - parameter llu: `LogUpdate` The log update token.
    ///
    /// - parameter name: `Swift.String` The topic name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - ObserverInconsistencyException - Raised if an
    ///     inconsisency was detected.
    func destroyTopic(llu iceP_llu: LogUpdate, name iceP_name: Swift.String, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "destroyTopic",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_llu)
                              ostr.write(iceP_name)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as ObserverInconsistencyException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Destroy the topic with the given name.
    ///
    /// - parameter llu: `LogUpdate` The log update token.
    ///
    /// - parameter name: `Swift.String` The topic name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func destroyTopicAsync(llu iceP_llu: LogUpdate, name iceP_name: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "destroyTopic",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_llu)
                                      ostr.write(iceP_name)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ObserverInconsistencyException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Add a subscriber to a topic.
    ///
    /// - parameter llu: `LogUpdate` The log update token.
    ///
    /// - parameter topic: `Swift.String` The topic name to which to add the subscriber.
    ///
    /// - parameter record: `IceStorm.SubscriberRecord` The subscriber information.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - ObserverInconsistencyException - Raised if an
    ///     inconsisency was detected.
    func addSubscriber(llu iceP_llu: LogUpdate, topic iceP_topic: Swift.String, record iceP_record: IceStorm.SubscriberRecord, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "addSubscriber",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_llu)
                              ostr.write(iceP_topic)
                              ostr.write(iceP_record)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as ObserverInconsistencyException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Add a subscriber to a topic.
    ///
    /// - parameter llu: `LogUpdate` The log update token.
    ///
    /// - parameter topic: `Swift.String` The topic name to which to add the subscriber.
    ///
    /// - parameter record: `IceStorm.SubscriberRecord` The subscriber information.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func addSubscriberAsync(llu iceP_llu: LogUpdate, topic iceP_topic: Swift.String, record iceP_record: IceStorm.SubscriberRecord, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "addSubscriber",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_llu)
                                      ostr.write(iceP_topic)
                                      ostr.write(iceP_record)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ObserverInconsistencyException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Remove a subscriber from a topic.
    ///
    /// - parameter llu: `LogUpdate` The log update token.
    ///
    /// - parameter topic: `Swift.String`
    ///
    /// - parameter subscribers: `Ice.IdentitySeq` The identities of the subscribers to remove.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - throws:
    ///
    ///   - ObserverInconsistencyException - Raised if an
    ///     inconsisency was detected.
    func removeSubscriber(llu iceP_llu: LogUpdate, topic iceP_topic: Swift.String, subscribers iceP_subscribers: Ice.IdentitySeq, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "removeSubscriber",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_llu)
                              ostr.write(iceP_topic)
                              Ice.IdentitySeqHelper.write(to: ostr, value: iceP_subscribers)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as ObserverInconsistencyException {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    /// Remove a subscriber from a topic.
    ///
    /// - parameter llu: `LogUpdate` The log update token.
    ///
    /// - parameter topic: `Swift.String`
    ///
    /// - parameter subscribers: `Ice.IdentitySeq` The identities of the subscribers to remove.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func removeSubscriberAsync(llu iceP_llu: LogUpdate, topic iceP_topic: Swift.String, subscribers iceP_subscribers: Ice.IdentitySeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "removeSubscriber",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_llu)
                                      ostr.write(iceP_topic)
                                      Ice.IdentitySeqHelper.write(to: ostr, value: iceP_subscribers)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as ObserverInconsistencyException {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// Interface used to sync topics.
///
/// TopicManagerSyncPrx Methods:
///
///  - getContent: Retrieve the topic content.
///
///  - getContentAsync: Retrieve the topic content.
public protocol TopicManagerSyncPrx: Ice.ObjectPrx {}

private final class TopicManagerSyncPrxI: Ice.ObjectPrxI, TopicManagerSyncPrx {
    public override class func ice_staticId() -> Swift.String {
        return TopicManagerSyncTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `TopicManagerSyncPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `TopicManagerSyncPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: TopicManagerSyncPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> TopicManagerSyncPrx? {
    return try TopicManagerSyncPrxI.checkedCast(prx: prx, facet: facet, context: context) as TopicManagerSyncPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `TopicManagerSyncPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `TopicManagerSyncPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: TopicManagerSyncPrx.Protocol, facet: Swift.String? = nil) -> TopicManagerSyncPrx {
    return TopicManagerSyncPrxI.uncheckedCast(prx: prx, facet: facet) as TopicManagerSyncPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `TopicManagerSyncPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: TopicManagerSyncPrx.Protocol) -> Swift.String {
    return TopicManagerSyncTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `TopicManagerSyncPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `TopicManagerSyncPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `TopicManagerSyncPrx?` - The extracted proxy
    func read(_ type: TopicManagerSyncPrx.Protocol) throws -> TopicManagerSyncPrx? {
        return try read() as TopicManagerSyncPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `TopicManagerSyncPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `TopicManagerSyncPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: TopicManagerSyncPrx.Protocol) throws -> TopicManagerSyncPrx? {
        return try read(tag: tag) as TopicManagerSyncPrxI?
    }
}

/// Interface used to sync topics.
///
/// TopicManagerSyncPrx Methods:
///
///  - getContent: Retrieve the topic content.
///
///  - getContentAsync: Retrieve the topic content.
public extension TopicManagerSyncPrx {
    /// Retrieve the topic content.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(llu: LogUpdate, content: TopicContentSeq)`:
    ///
    ///   - llu: `LogUpdate` - The last log update token.
    ///
    ///   - content: `TopicContentSeq` - The topic content.
    func getContent(context: Ice.Context? = nil) throws -> (llu: LogUpdate, content: TopicContentSeq) {
        return try _impl._invoke(operation: "getContent",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_llu: LogUpdate = try istr.read()
                                     let iceP_content: TopicContentSeq = try TopicContentSeqHelper.read(from: istr)
                                     return (iceP_llu, iceP_content)
                                 },
                                 context: context)
    }

    /// Retrieve the topic content.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(llu: LogUpdate, content: TopicContentSeq)>` - The result of the operation
    func getContentAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(llu: LogUpdate, content: TopicContentSeq)> {
        return _impl._invokeAsync(operation: "getContent",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_llu: LogUpdate = try istr.read()
                                      let iceP_content: TopicContentSeq = try TopicContentSeqHelper.read(from: istr)
                                      return (iceP_llu, iceP_content)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// A replica node.
///
/// NodePrx Methods:
///
///  - invitation: Invite the node into a group with the given coordinator and group name.
///
///  - invitationAsync: Invite the node into a group with the given coordinator and group name.
///
///  - ready: Call from the group coordinator to a node to inform the node that the replica group is active.
///
///  - readyAsync: Call from the group coordinator to a node to inform the node that the replica group is active.
///
///  - accept: Called to accept an invitation into the given group.
///
///  - acceptAsync: Called to accept an invitation into the given group.
///
///  - areYouCoordinator: Determine if this node is a coordinator.
///
///  - areYouCoordinatorAsync: Determine if this node is a coordinator.
///
///  - areYouThere: Determine if the node is a member of the given group with the given coordinator.
///
///  - areYouThereAsync: Determine if the node is a member of the given group with the given coordinator.
///
///  - sync: Get the sync object for the replica hosted by this node.
///
///  - syncAsync: Get the sync object for the replica hosted by this node.
///
///  - nodes: Get the replication group information.
///
///  - nodesAsync: Get the replication group information.
///
///  - query: Get the query information for the given node.
///
///  - queryAsync: Get the query information for the given node.
public protocol NodePrx: Ice.ObjectPrx {}

private final class NodePrxI: Ice.ObjectPrxI, NodePrx {
    public override class func ice_staticId() -> Swift.String {
        return NodeTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `NodePrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `NodePrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: NodePrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> NodePrx? {
    return try NodePrxI.checkedCast(prx: prx, facet: facet, context: context) as NodePrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `NodePrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `NodePrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: NodePrx.Protocol, facet: Swift.String? = nil) -> NodePrx {
    return NodePrxI.uncheckedCast(prx: prx, facet: facet) as NodePrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `NodePrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: NodePrx.Protocol) -> Swift.String {
    return NodeTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `NodePrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `NodePrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `NodePrx?` - The extracted proxy
    func read(_ type: NodePrx.Protocol) throws -> NodePrx? {
        return try read() as NodePrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `NodePrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `NodePrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: NodePrx.Protocol) throws -> NodePrx? {
        return try read(tag: tag) as NodePrxI?
    }
}

/// A replica node.
///
/// NodePrx Methods:
///
///  - invitation: Invite the node into a group with the given coordinator and group name.
///
///  - invitationAsync: Invite the node into a group with the given coordinator and group name.
///
///  - ready: Call from the group coordinator to a node to inform the node that the replica group is active.
///
///  - readyAsync: Call from the group coordinator to a node to inform the node that the replica group is active.
///
///  - accept: Called to accept an invitation into the given group.
///
///  - acceptAsync: Called to accept an invitation into the given group.
///
///  - areYouCoordinator: Determine if this node is a coordinator.
///
///  - areYouCoordinatorAsync: Determine if this node is a coordinator.
///
///  - areYouThere: Determine if the node is a member of the given group with the given coordinator.
///
///  - areYouThereAsync: Determine if the node is a member of the given group with the given coordinator.
///
///  - sync: Get the sync object for the replica hosted by this node.
///
///  - syncAsync: Get the sync object for the replica hosted by this node.
///
///  - nodes: Get the replication group information.
///
///  - nodesAsync: Get the replication group information.
///
///  - query: Get the query information for the given node.
///
///  - queryAsync: Get the query information for the given node.
public extension NodePrx {
    /// Invite the node into a group with the given coordinator and
    /// group name.
    ///
    /// - parameter j: `Swift.Int32` The group coordinator.
    ///
    /// - parameter gn: `Swift.String` The group name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func invitation(j iceP_j: Swift.Int32, gn iceP_gn: Swift.String, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "invitation",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_j)
                              ostr.write(iceP_gn)
                          },
                          context: context)
    }

    /// Invite the node into a group with the given coordinator and
    /// group name.
    ///
    /// - parameter j: `Swift.Int32` The group coordinator.
    ///
    /// - parameter gn: `Swift.String` The group name.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func invitationAsync(j iceP_j: Swift.Int32, gn iceP_gn: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "invitation",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_j)
                                      ostr.write(iceP_gn)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Call from the group coordinator to a node to inform the node
    /// that the replica group is active.
    ///
    /// - parameter j: `Swift.Int32` The group coordinator.
    ///
    /// - parameter gn: `Swift.String` The group name.
    ///
    /// - parameter coordinator: `Ice.ObjectPrx?` The proxy to the coordinator.
    ///
    /// - parameter max: `Swift.Int32` The highest priority node seen by this replica
    /// group.
    ///
    /// - parameter generation: `Swift.Int64` The current generation count.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func ready(j iceP_j: Swift.Int32, gn iceP_gn: Swift.String, coordinator iceP_coordinator: Ice.ObjectPrx?, max iceP_max: Swift.Int32, generation iceP_generation: Swift.Int64, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "ready",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_j)
                              ostr.write(iceP_gn)
                              ostr.write(iceP_coordinator)
                              ostr.write(iceP_max)
                              ostr.write(iceP_generation)
                          },
                          context: context)
    }

    /// Call from the group coordinator to a node to inform the node
    /// that the replica group is active.
    ///
    /// - parameter j: `Swift.Int32` The group coordinator.
    ///
    /// - parameter gn: `Swift.String` The group name.
    ///
    /// - parameter coordinator: `Ice.ObjectPrx?` The proxy to the coordinator.
    ///
    /// - parameter max: `Swift.Int32` The highest priority node seen by this replica
    /// group.
    ///
    /// - parameter generation: `Swift.Int64` The current generation count.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func readyAsync(j iceP_j: Swift.Int32, gn iceP_gn: Swift.String, coordinator iceP_coordinator: Ice.ObjectPrx?, max iceP_max: Swift.Int32, generation iceP_generation: Swift.Int64, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "ready",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_j)
                                      ostr.write(iceP_gn)
                                      ostr.write(iceP_coordinator)
                                      ostr.write(iceP_max)
                                      ostr.write(iceP_generation)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Called to accept an invitation into
    /// the given group.
    ///
    /// - parameter j: `Swift.Int32` The id of the node accepting the invitation.
    ///
    /// - parameter gn: `Swift.String` The group name.
    ///
    /// - parameter forwardedInvites: `Ice.IntSeq` The ids of the nodes to which
    /// invitations were forwarded.
    ///
    /// - parameter observer: `Ice.ObjectPrx?` The observer.
    ///
    /// - parameter llu: `LogUpdate` The last log update for the given node.
    ///
    /// - parameter max: `Swift.Int32` The highest priority node seen by this replica
    /// group.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func accept(j iceP_j: Swift.Int32, gn iceP_gn: Swift.String, forwardedInvites iceP_forwardedInvites: Ice.IntSeq, observer iceP_observer: Ice.ObjectPrx?, llu iceP_llu: LogUpdate, max iceP_max: Swift.Int32, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "accept",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_j)
                              ostr.write(iceP_gn)
                              ostr.write(iceP_forwardedInvites)
                              ostr.write(iceP_observer)
                              ostr.write(iceP_llu)
                              ostr.write(iceP_max)
                          },
                          context: context)
    }

    /// Called to accept an invitation into
    /// the given group.
    ///
    /// - parameter j: `Swift.Int32` The id of the node accepting the invitation.
    ///
    /// - parameter gn: `Swift.String` The group name.
    ///
    /// - parameter forwardedInvites: `Ice.IntSeq` The ids of the nodes to which
    /// invitations were forwarded.
    ///
    /// - parameter observer: `Ice.ObjectPrx?` The observer.
    ///
    /// - parameter llu: `LogUpdate` The last log update for the given node.
    ///
    /// - parameter max: `Swift.Int32` The highest priority node seen by this replica
    /// group.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func acceptAsync(j iceP_j: Swift.Int32, gn iceP_gn: Swift.String, forwardedInvites iceP_forwardedInvites: Ice.IntSeq, observer iceP_observer: Ice.ObjectPrx?, llu iceP_llu: LogUpdate, max iceP_max: Swift.Int32, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "accept",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_j)
                                      ostr.write(iceP_gn)
                                      ostr.write(iceP_forwardedInvites)
                                      ostr.write(iceP_observer)
                                      ostr.write(iceP_llu)
                                      ostr.write(iceP_max)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Determine if this node is a coordinator.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Bool` - True if the node is a coordinator, false otherwise.
    func areYouCoordinator(context: Ice.Context? = nil) throws -> Swift.Bool {
        return try _impl._invoke(operation: "areYouCoordinator",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: Swift.Bool = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Determine if this node is a coordinator.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Bool>` - The result of the operation
    func areYouCoordinatorAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Bool> {
        return _impl._invokeAsync(operation: "areYouCoordinator",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: Swift.Bool = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Determine if the node is a member of the given group with the
    /// given coordinator.
    ///
    /// - parameter gn: `Swift.String` The group name.
    ///
    /// - parameter j: `Swift.Int32` The group coordinator.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Bool` - True if the node is a member, false otherwise.
    func areYouThere(gn iceP_gn: Swift.String, j iceP_j: Swift.Int32, context: Ice.Context? = nil) throws -> Swift.Bool {
        return try _impl._invoke(operation: "areYouThere",
                                 mode: .Idempotent,
                                 write: { ostr in
                                     ostr.write(iceP_gn)
                                     ostr.write(iceP_j)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: Swift.Bool = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Determine if the node is a member of the given group with the
    /// given coordinator.
    ///
    /// - parameter gn: `Swift.String` The group name.
    ///
    /// - parameter j: `Swift.Int32` The group coordinator.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Bool>` - The result of the operation
    func areYouThereAsync(gn iceP_gn: Swift.String, j iceP_j: Swift.Int32, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Bool> {
        return _impl._invokeAsync(operation: "areYouThere",
                                  mode: .Idempotent,
                                  write: { ostr in
                                      ostr.write(iceP_gn)
                                      ostr.write(iceP_j)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: Swift.Bool = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get the sync object for the replica hosted by this node.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.ObjectPrx?` - The sync object.
    func sync(context: Ice.Context? = nil) throws -> Ice.ObjectPrx? {
        return try _impl._invoke(operation: "sync",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get the sync object for the replica hosted by this node.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Ice.ObjectPrx?>` - The result of the operation
    func syncAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Ice.ObjectPrx?> {
        return _impl._invokeAsync(operation: "sync",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get the replication group information.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `NodeInfoSeq` - The set of configured nodes and the associated
    /// priority.
    func nodes(context: Ice.Context? = nil) throws -> NodeInfoSeq {
        return try _impl._invoke(operation: "nodes",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: NodeInfoSeq = try NodeInfoSeqHelper.read(from: istr)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get the replication group information.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<NodeInfoSeq>` - The result of the operation
    func nodesAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<NodeInfoSeq> {
        return _impl._invokeAsync(operation: "nodes",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: NodeInfoSeq = try NodeInfoSeqHelper.read(from: istr)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    /// Get the query information for the given node.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `QueryInfo` - The query information.
    func query(context: Ice.Context? = nil) throws -> QueryInfo {
        return try _impl._invoke(operation: "query",
                                 mode: .Idempotent,
                                 read: { istr in
                                     let iceP_returnValue: QueryInfo = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    /// Get the query information for the given node.
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<QueryInfo>` - The result of the operation
    func queryAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<QueryInfo> {
        return _impl._invokeAsync(operation: "query",
                                  mode: .Idempotent,
                                  read: { istr in
                                      let iceP_returnValue: QueryInfo = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}


/// Dispatcher for `ReplicaObserver` servants.
public struct ReplicaObserverDisp: Ice.Disp {
    public let servant: ReplicaObserver
    private static let defaultObject = Ice.ObjectI<ReplicaObserverTraits>()

    public init(_ servant: ReplicaObserver) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "addSubscriber":
            return try servant._iceD_addSubscriber(incoming: request, current: current)
        case "createTopic":
            return try servant._iceD_createTopic(incoming: request, current: current)
        case "destroyTopic":
            return try servant._iceD_destroyTopic(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? ReplicaObserverDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? ReplicaObserverDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? ReplicaObserverDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? ReplicaObserverDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "init":
            return try servant._iceD_init(incoming: request, current: current)
        case "removeSubscriber":
            return try servant._iceD_removeSubscriber(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

/// The replica observer.
public protocol ReplicaObserver {
    /// Initialize the observer.
    ///
    /// - parameter llu: `LogUpdate` The last log update seen by the master.
    ///
    /// - parameter content: `TopicContentSeq` The topic content.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - ObserverInconsistencyException - Raised if an
    ///     inconsisency was detected.
    func `init`(llu: LogUpdate, content: TopicContentSeq, current: Ice.Current) throws

    /// Create the topic with the given name.
    ///
    /// - parameter llu: `LogUpdate` The log update token.
    ///
    /// - parameter name: `Swift.String` The topic name.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - ObserverInconsistencyException - Raised if an
    ///     inconsisency was detected.
    func createTopic(llu: LogUpdate, name: Swift.String, current: Ice.Current) throws

    /// Destroy the topic with the given name.
    ///
    /// - parameter llu: `LogUpdate` The log update token.
    ///
    /// - parameter name: `Swift.String` The topic name.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - ObserverInconsistencyException - Raised if an
    ///     inconsisency was detected.
    func destroyTopic(llu: LogUpdate, name: Swift.String, current: Ice.Current) throws

    /// Add a subscriber to a topic.
    ///
    /// - parameter llu: `LogUpdate` The log update token.
    ///
    /// - parameter topic: `Swift.String` The topic name to which to add the subscriber.
    ///
    /// - parameter record: `IceStorm.SubscriberRecord` The subscriber information.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - ObserverInconsistencyException - Raised if an
    ///     inconsisency was detected.
    func addSubscriber(llu: LogUpdate, topic: Swift.String, record: IceStorm.SubscriberRecord, current: Ice.Current) throws

    /// Remove a subscriber from a topic.
    ///
    /// - parameter llu: `LogUpdate` The log update token.
    ///
    /// - parameter topic: `Swift.String`
    ///
    /// - parameter subscribers: `Ice.IdentitySeq` The identities of the subscribers to remove.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - throws:
    ///
    ///   - ObserverInconsistencyException - Raised if an
    ///     inconsisency was detected.
    func removeSubscriber(llu: LogUpdate, topic: Swift.String, subscribers: Ice.IdentitySeq, current: Ice.Current) throws
}


/// Dispatcher for `TopicManagerSync` servants.
public struct TopicManagerSyncDisp: Ice.Disp {
    public let servant: TopicManagerSync
    private static let defaultObject = Ice.ObjectI<TopicManagerSyncTraits>()

    public init(_ servant: TopicManagerSync) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "getContent":
            return try servant._iceD_getContent(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? TopicManagerSyncDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? TopicManagerSyncDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? TopicManagerSyncDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? TopicManagerSyncDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

/// Interface used to sync topics.
public protocol TopicManagerSync {
    /// Retrieve the topic content.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(llu: LogUpdate, content: TopicContentSeq)`:
    ///
    ///   - llu: `LogUpdate` - The last log update token.
    ///
    ///   - content: `TopicContentSeq` - The topic content.
    func getContent(current: Ice.Current) throws -> (llu: LogUpdate, content: TopicContentSeq)
}


/// Dispatcher for `Node` servants.
public struct NodeDisp: Ice.Disp {
    public let servant: Node
    private static let defaultObject = Ice.ObjectI<NodeTraits>()

    public init(_ servant: Node) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "accept":
            return try servant._iceD_accept(incoming: request, current: current)
        case "areYouCoordinator":
            return try servant._iceD_areYouCoordinator(incoming: request, current: current)
        case "areYouThere":
            return try servant._iceD_areYouThere(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? NodeDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? NodeDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? NodeDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? NodeDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "invitation":
            return try servant._iceD_invitation(incoming: request, current: current)
        case "nodes":
            return try servant._iceD_nodes(incoming: request, current: current)
        case "query":
            return try servant._iceD_query(incoming: request, current: current)
        case "ready":
            return try servant._iceD_ready(incoming: request, current: current)
        case "sync":
            return try servant._iceD_sync(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

/// A replica node.
public protocol Node {
    /// Invite the node into a group with the given coordinator and
    /// group name.
    ///
    /// - parameter j: `Swift.Int32` The group coordinator.
    ///
    /// - parameter gn: `Swift.String` The group name.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func invitation(j: Swift.Int32, gn: Swift.String, current: Ice.Current) throws

    /// Call from the group coordinator to a node to inform the node
    /// that the replica group is active.
    ///
    /// - parameter j: `Swift.Int32` The group coordinator.
    ///
    /// - parameter gn: `Swift.String` The group name.
    ///
    /// - parameter coordinator: `Ice.ObjectPrx?` The proxy to the coordinator.
    ///
    /// - parameter max: `Swift.Int32` The highest priority node seen by this replica
    /// group.
    ///
    /// - parameter generation: `Swift.Int64` The current generation count.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func ready(j: Swift.Int32, gn: Swift.String, coordinator: Ice.ObjectPrx?, max: Swift.Int32, generation: Swift.Int64, current: Ice.Current) throws

    /// Called to accept an invitation into
    /// the given group.
    ///
    /// - parameter j: `Swift.Int32` The id of the node accepting the invitation.
    ///
    /// - parameter gn: `Swift.String` The group name.
    ///
    /// - parameter forwardedInvites: `Ice.IntSeq` The ids of the nodes to which
    /// invitations were forwarded.
    ///
    /// - parameter observer: `Ice.ObjectPrx?` The observer.
    ///
    /// - parameter llu: `LogUpdate` The last log update for the given node.
    ///
    /// - parameter max: `Swift.Int32` The highest priority node seen by this replica
    /// group.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func accept(j: Swift.Int32, gn: Swift.String, forwardedInvites: Ice.IntSeq, observer: Ice.ObjectPrx?, llu: LogUpdate, max: Swift.Int32, current: Ice.Current) throws

    /// Determine if this node is a coordinator.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Bool` - True if the node is a coordinator, false otherwise.
    func areYouCoordinator(current: Ice.Current) throws -> Swift.Bool

    /// Determine if the node is a member of the given group with the
    /// given coordinator.
    ///
    /// - parameter gn: `Swift.String` The group name.
    ///
    /// - parameter j: `Swift.Int32` The group coordinator.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Bool` - True if the node is a member, false otherwise.
    func areYouThere(gn: Swift.String, j: Swift.Int32, current: Ice.Current) throws -> Swift.Bool

    /// Get the sync object for the replica hosted by this node.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.ObjectPrx?` - The sync object.
    func sync(current: Ice.Current) throws -> Ice.ObjectPrx?

    /// Get the replication group information.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `NodeInfoSeq` - The set of configured nodes and the associated
    /// priority.
    func nodes(current: Ice.Current) throws -> NodeInfoSeq

    /// Get the query information for the given node.
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `QueryInfo` - The query information.
    func query(current: Ice.Current) throws -> QueryInfo
}

/// The replica observer.
///
/// ReplicaObserver Methods:
///
///  - `init`: Initialize the observer.
///
///  - createTopic: Create the topic with the given name.
///
///  - destroyTopic: Destroy the topic with the given name.
///
///  - addSubscriber: Add a subscriber to a topic.
///
///  - removeSubscriber: Remove a subscriber from a topic.
public extension ReplicaObserver {
    func _iceD_init(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_llu, iceP_content): (LogUpdate, TopicContentSeq) = try inS.read { istr in
            let iceP_llu: LogUpdate = try istr.read()
            let iceP_content: TopicContentSeq = try TopicContentSeqHelper.read(from: istr)
            return (iceP_llu, iceP_content)
        }

        try self.`init`(llu: iceP_llu, content: iceP_content, current: current)

        return inS.setResult()
    }

    func _iceD_createTopic(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_llu, iceP_name): (LogUpdate, Swift.String) = try inS.read { istr in
            let iceP_llu: LogUpdate = try istr.read()
            let iceP_name: Swift.String = try istr.read()
            return (iceP_llu, iceP_name)
        }

        try self.createTopic(llu: iceP_llu, name: iceP_name, current: current)

        return inS.setResult()
    }

    func _iceD_destroyTopic(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_llu, iceP_name): (LogUpdate, Swift.String) = try inS.read { istr in
            let iceP_llu: LogUpdate = try istr.read()
            let iceP_name: Swift.String = try istr.read()
            return (iceP_llu, iceP_name)
        }

        try self.destroyTopic(llu: iceP_llu, name: iceP_name, current: current)

        return inS.setResult()
    }

    func _iceD_addSubscriber(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_llu, iceP_topic, iceP_record): (LogUpdate, Swift.String, IceStorm.SubscriberRecord) = try inS.read { istr in
            let iceP_llu: LogUpdate = try istr.read()
            let iceP_topic: Swift.String = try istr.read()
            let iceP_record: IceStorm.SubscriberRecord = try istr.read()
            return (iceP_llu, iceP_topic, iceP_record)
        }

        try self.addSubscriber(llu: iceP_llu, topic: iceP_topic, record: iceP_record, current: current)

        return inS.setResult()
    }

    func _iceD_removeSubscriber(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_llu, iceP_topic, iceP_subscribers): (LogUpdate, Swift.String, Ice.IdentitySeq) = try inS.read { istr in
            let iceP_llu: LogUpdate = try istr.read()
            let iceP_topic: Swift.String = try istr.read()
            let iceP_subscribers: Ice.IdentitySeq = try Ice.IdentitySeqHelper.read(from: istr)
            return (iceP_llu, iceP_topic, iceP_subscribers)
        }

        try self.removeSubscriber(llu: iceP_llu, topic: iceP_topic, subscribers: iceP_subscribers, current: current)

        return inS.setResult()
    }
}

/// Interface used to sync topics.
///
/// TopicManagerSync Methods:
///
///  - getContent: Retrieve the topic content.
public extension TopicManagerSync {
    func _iceD_getContent(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let (iceP_llu, iceP_content) = try self.getContent(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_llu)
            TopicContentSeqHelper.write(to: ostr, value: iceP_content)
        }
    }
}

/// A replica node.
///
/// Node Methods:
///
///  - invitation: Invite the node into a group with the given coordinator and group name.
///
///  - ready: Call from the group coordinator to a node to inform the node that the replica group is active.
///
///  - accept: Called to accept an invitation into the given group.
///
///  - areYouCoordinator: Determine if this node is a coordinator.
///
///  - areYouThere: Determine if the node is a member of the given group with the given coordinator.
///
///  - sync: Get the sync object for the replica hosted by this node.
///
///  - nodes: Get the replication group information.
///
///  - query: Get the query information for the given node.
public extension Node {
    func _iceD_invitation(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_j, iceP_gn): (Swift.Int32, Swift.String) = try inS.read { istr in
            let iceP_j: Swift.Int32 = try istr.read()
            let iceP_gn: Swift.String = try istr.read()
            return (iceP_j, iceP_gn)
        }

        try self.invitation(j: iceP_j, gn: iceP_gn, current: current)

        return inS.setResult()
    }

    func _iceD_ready(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_j, iceP_gn, iceP_coordinator, iceP_max, iceP_generation): (Swift.Int32, Swift.String, Ice.ObjectPrx?, Swift.Int32, Swift.Int64) = try inS.read { istr in
            let iceP_j: Swift.Int32 = try istr.read()
            let iceP_gn: Swift.String = try istr.read()
            let iceP_coordinator: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
            let iceP_max: Swift.Int32 = try istr.read()
            let iceP_generation: Swift.Int64 = try istr.read()
            return (iceP_j, iceP_gn, iceP_coordinator, iceP_max, iceP_generation)
        }

        try self.ready(j: iceP_j, gn: iceP_gn, coordinator: iceP_coordinator, max: iceP_max, generation: iceP_generation, current: current)

        return inS.setResult()
    }

    func _iceD_accept(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_j, iceP_gn, iceP_forwardedInvites, iceP_observer, iceP_llu, iceP_max): (Swift.Int32, Swift.String, Ice.IntSeq, Ice.ObjectPrx?, LogUpdate, Swift.Int32) = try inS.read { istr in
            let iceP_j: Swift.Int32 = try istr.read()
            let iceP_gn: Swift.String = try istr.read()
            let iceP_forwardedInvites: Ice.IntSeq = try istr.read()
            let iceP_observer: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
            let iceP_llu: LogUpdate = try istr.read()
            let iceP_max: Swift.Int32 = try istr.read()
            return (iceP_j, iceP_gn, iceP_forwardedInvites, iceP_observer, iceP_llu, iceP_max)
        }

        try self.accept(j: iceP_j, gn: iceP_gn, forwardedInvites: iceP_forwardedInvites, observer: iceP_observer, llu: iceP_llu, max: iceP_max, current: current)

        return inS.setResult()
    }

    func _iceD_areYouCoordinator(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.areYouCoordinator(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_areYouThere(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_gn, iceP_j): (Swift.String, Swift.Int32) = try inS.read { istr in
            let iceP_gn: Swift.String = try istr.read()
            let iceP_j: Swift.Int32 = try istr.read()
            return (iceP_gn, iceP_j)
        }

        let iceP_returnValue = try self.areYouThere(gn: iceP_gn, j: iceP_j, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_sync(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.sync(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_nodes(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.nodes(current: current)

        return inS.setResult{ ostr in
            NodeInfoSeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_query(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.query(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }
}
