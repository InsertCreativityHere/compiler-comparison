//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `DBTypes.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice
import IceStormElection

public typealias StringLogUpdateDict = [Swift.String: LogUpdate]

/// Helper class to read and write `StringLogUpdateDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringLogUpdateDictHelper {
    /// Read a `StringLogUpdateDict` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringLogUpdateDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringLogUpdateDict {
        let sz = try Swift.Int(istr.readSize())
        var v = StringLogUpdateDict()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: LogUpdate = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `StringLogUpdateDict?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringLogUpdateDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringLogUpdateDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringLogUpdateDict` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringLogUpdateDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringLogUpdateDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `StringLogUpdateDict?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringLogUpdateDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: StringLogUpdateDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias SubscriberRecordDict = [SubscriberRecordKey: SubscriberRecord]

/// Helper class to read and write `SubscriberRecordDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct SubscriberRecordDictHelper {
    /// Read a `SubscriberRecordDict` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `SubscriberRecordDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> SubscriberRecordDict {
        let sz = try Swift.Int(istr.readSize())
        var v = SubscriberRecordDict()
        for _ in 0 ..< sz {
            let key: SubscriberRecordKey = try istr.read()
            let value: SubscriberRecord = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `SubscriberRecordDict?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `SubscriberRecordDict` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> SubscriberRecordDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `SubscriberRecordDict` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `SubscriberRecordDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: SubscriberRecordDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `SubscriberRecordDict?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `SubscriberRecordDict` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: SubscriberRecordDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public struct AllData {
    public var llus: IceStormElection.StringLogUpdateDict = IceStormElection.StringLogUpdateDict()
    public var subscribers: SubscriberRecordDict = SubscriberRecordDict()

    public init() {}

    public init(llus: IceStormElection.StringLogUpdateDict, subscribers: SubscriberRecordDict) {
        self.llus = llus
        self.subscribers = subscribers
    }
}

/// An `Ice.InputStream` extension to read `AllData` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `AllData` structured value from the stream.
    ///
    /// - returns: `AllData` - The structured value read from the stream.
    func read() throws -> AllData {
        var v = AllData()
        v.llus = try IceStormElection.StringLogUpdateDictHelper.read(from: self)
        v.subscribers = try SubscriberRecordDictHelper.read(from: self)
        return v
    }

    /// Read an optional `AllData?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `AllData?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> AllData? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as AllData
    }
}

/// An `Ice.OutputStream` extension to write `AllData` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `AllData` structured value to the stream.
    ///
    /// - parameter _: `AllData` - The value to write to the stream.
    func write(_ v: AllData) {
        IceStormElection.StringLogUpdateDictHelper.write(to: self, value: v.llus)
        SubscriberRecordDictHelper.write(to: self, value: v.subscribers)
    }

    /// Write an optional `AllData?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `AllData?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: AllData?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}
