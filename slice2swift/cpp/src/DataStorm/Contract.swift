//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Contract.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice
import DataStorm

/// The ClearHistoryPolicy enumeration defines the policy that determines when a reader clears its DataSample
/// history in response to various events.
public enum ClearHistoryPolicy: Swift.UInt8 {
    /// The reader clears its history when a new DataSample is added.
    case OnAdd = 0
    /// The reader clears its history when a DataSample is removed.
    case OnRemove = 1
    /// The reader clears its history when any DataSample event occurs.
    case OnAll = 2
    /// The reader clears its history when any DataSample event occurs, except for PartialUpdate events.
    case OnAllExceptPartialUpdate = 3
    /// The reader never clears its history.
    case Never = 4
    public init() {
        self = .OnAdd
    }
}

/// An `Ice.InputStream` extension to read `ClearHistoryPolicy` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - Returns:  The enumerated value.
    func read() throws -> ClearHistoryPolicy {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 4)
        guard let val = ClearHistoryPolicy(rawValue: rawValue) else {
            throw Ice.MarshalException("invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The enumerated value.
    func read(tag: Swift.Int32) throws -> ClearHistoryPolicy? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as ClearHistoryPolicy
    }
}

/// An `Ice.OutputStream` extension to write `ClearHistoryPolicy` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// - Parameter v: The enumerator to write.
    func write(_ v: ClearHistoryPolicy) {
        write(enum: v.rawValue, maxValue: 4)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The enumerator to write.
    func write(tag: Swift.Int32, value: ClearHistoryPolicy?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 4)
    }
}

public typealias LongLongDict = [Swift.Int64: Swift.Int64]

/// Helper class to read and write `LongLongDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LongLongDictHelper {
    /// Read a `LongLongDict` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LongLongDict {
        let sz = try Swift.Int(istr.readSize())
        var v = LongLongDict()
        for _ in 0 ..< sz {
            let key: Swift.Int64 = try istr.read()
            let value: Swift.Int64 = try istr.read()
            v[key] = value
        }
        return v
    }

    /// Read an optional `LongLongDict?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LongLongDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Write a `LongLongDict` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LongLongDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `LongLongDict?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: LongLongDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 16) {
            write(to: ostr, value: val)
        }
    }
}

public struct DataSample {
    /// The sample id.
    public var id: Swift.Int64 = 0
    /// The key id.
    public var keyId: Swift.Int64 = 0
    /// The key value if the key ID <= 0.
    public var keyValue: Ice.ByteSeq = Ice.ByteSeq()
    /// The timestamp of the sample (write time).
    public var timestamp: Swift.Int64 = 0
    /// The update tag if the sample event is PartialUpdate.
    public var tag: Swift.Int64 = 0
    /// The sample event.
    public var event: DataStorm.SampleEvent = .Add
    /// The value of the sample.
    public var value: Ice.ByteSeq = Ice.ByteSeq()

    public init() {}

    public init(id: Swift.Int64, keyId: Swift.Int64, keyValue: Ice.ByteSeq, timestamp: Swift.Int64, tag: Swift.Int64, event: DataStorm.SampleEvent, value: Ice.ByteSeq) {
        self.id = id
        self.keyId = keyId
        self.keyValue = keyValue
        self.timestamp = timestamp
        self.tag = tag
        self.event = event
        self.value = value
    }
}

/// An `Ice.InputStream` extension to read `DataSample` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `DataSample` structured value from the stream.
    ///
    /// - Returns: The structured value read from the stream.
    func read() throws -> DataSample {
        var v = DataSample()
        v.id = try self.read()
        v.keyId = try self.read()
        v.keyValue = try self.read()
        v.timestamp = try self.read()
        v.tag = try self.read()
        v.event = try self.read()
        v.value = try self.read()
        return v
    }

    /// Read an optional `DataSample?` structured value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> DataSample? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as DataSample
    }
}

/// An `Ice.OutputStream` extension to write `DataSample` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `DataSample` structured value to the stream.
    ///
    /// - Parameter v: The value to write to the stream.
    func write(_ v: DataSample) {
        self.write(v.id)
        self.write(v.keyId)
        self.write(v.keyValue)
        self.write(v.timestamp)
        self.write(v.tag)
        self.write(v.event)
        self.write(v.value)
    }

    /// Write an optional `DataSample?` structured value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The value to write to the stream.
    func write(tag: Swift.Int32, value: DataSample?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public typealias DataSampleSeq = [DataSample]

/// Helper class to read and write `DataSampleSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct DataSampleSeqHelper {
    /// Read a `DataSampleSeq` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> DataSampleSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 35)
        var v = DataSampleSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: DataSample = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `DataSampleSeq?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> DataSampleSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `DataSampleSeq` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: DataSampleSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `DataSampleSeq?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: DataSampleSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public struct DataSamples {
    /// The id of the writer or reader.
    public var id: Swift.Int64 = 0
    /// The samples.
    public var samples: DataSampleSeq = DataSampleSeq()

    public init() {}

    public init(id: Swift.Int64, samples: DataSampleSeq) {
        self.id = id
        self.samples = samples
    }
}

/// An `Ice.InputStream` extension to read `DataSamples` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `DataSamples` structured value from the stream.
    ///
    /// - Returns: The structured value read from the stream.
    func read() throws -> DataSamples {
        var v = DataSamples()
        v.id = try self.read()
        v.samples = try DataSampleSeqHelper.read(from: self)
        return v
    }

    /// Read an optional `DataSamples?` structured value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> DataSamples? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as DataSamples
    }
}

/// An `Ice.OutputStream` extension to write `DataSamples` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `DataSamples` structured value to the stream.
    ///
    /// - Parameter v: The value to write to the stream.
    func write(_ v: DataSamples) {
        self.write(v.id)
        DataSampleSeqHelper.write(to: self, value: v.samples)
    }

    /// Write an optional `DataSamples?` structured value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The value to write to the stream.
    func write(tag: Swift.Int32, value: DataSamples?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public typealias DataSamplesSeq = [DataSamples]

/// Helper class to read and write `DataSamplesSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct DataSamplesSeqHelper {
    /// Read a `DataSamplesSeq` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> DataSamplesSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 9)
        var v = DataSamplesSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: DataSamples = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `DataSamplesSeq?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> DataSamplesSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `DataSamplesSeq` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: DataSamplesSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `DataSamplesSeq?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: DataSamplesSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Provides information about an element, which can be a key, a filter, or a tag. Includes the element's ID, name,
/// and encoded value.
public struct ElementInfo {
    /// The ID of the element. Filter IDs are negative, while key and tag IDs are positive.
    public var id: Swift.Int64 = 0
    /// The name of the filter. This field is empty for key and tag elements.
    public var name: Swift.String = ""
    /// The encoded value of the element.
    public var value: Ice.ByteSeq = Ice.ByteSeq()

    public init() {}

    public init(id: Swift.Int64, name: Swift.String, value: Ice.ByteSeq) {
        self.id = id
        self.name = name
        self.value = value
    }
}

/// An `Ice.InputStream` extension to read `ElementInfo` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `ElementInfo` structured value from the stream.
    ///
    /// - Returns: The structured value read from the stream.
    func read() throws -> ElementInfo {
        var v = ElementInfo()
        v.id = try self.read()
        v.name = try self.read()
        v.value = try self.read()
        return v
    }

    /// Read an optional `ElementInfo?` structured value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> ElementInfo? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as ElementInfo
    }
}

/// An `Ice.OutputStream` extension to write `ElementInfo` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `ElementInfo` structured value to the stream.
    ///
    /// - Parameter v: The value to write to the stream.
    func write(_ v: ElementInfo) {
        self.write(v.id)
        self.write(v.name)
        self.write(v.value)
    }

    /// Write an optional `ElementInfo?` structured value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The value to write to the stream.
    func write(tag: Swift.Int32, value: ElementInfo?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public typealias ElementInfoSeq = [ElementInfo]

/// Helper class to read and write `ElementInfoSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ElementInfoSeqHelper {
    /// Read a `ElementInfoSeq` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ElementInfoSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 10)
        var v = ElementInfoSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: ElementInfo = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `ElementInfoSeq?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ElementInfoSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `ElementInfoSeq` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ElementInfoSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `ElementInfoSeq?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ElementInfoSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Provides information about a topic, including its name and the list of active topic reader or topic writer IDs.
///
/// There is a unique `TopicInfo` for all topic instances with the same name, representing a single logical topic.
/// Each instance has its own topic reader and topic writer, which are lazily initialized and have a unique ID.
public struct TopicInfo {
    /// The name of the topic.
    public var name: Swift.String = ""
    /// The list of active topic reader or topic writer IDs for the topic.
    ///
    /// - In a publisher session announcing topics to a subscriber session, this contains the active topic writer
    /// IDs.
    /// - In a subscriber session announcing topics to a publisher session, this contains the active topic reader
    /// IDs.
    public var ids: Ice.LongSeq = Ice.LongSeq()

    public init() {}

    public init(name: Swift.String, ids: Ice.LongSeq) {
        self.name = name
        self.ids = ids
    }
}

/// An `Ice.InputStream` extension to read `TopicInfo` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `TopicInfo` structured value from the stream.
    ///
    /// - Returns: The structured value read from the stream.
    func read() throws -> TopicInfo {
        var v = TopicInfo()
        v.name = try self.read()
        v.ids = try self.read()
        return v
    }

    /// Read an optional `TopicInfo?` structured value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> TopicInfo? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as TopicInfo
    }
}

/// An `Ice.OutputStream` extension to write `TopicInfo` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `TopicInfo` structured value to the stream.
    ///
    /// - Parameter v: The value to write to the stream.
    func write(_ v: TopicInfo) {
        self.write(v.name)
        self.write(v.ids)
    }

    /// Write an optional `TopicInfo?` structured value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The value to write to the stream.
    func write(tag: Swift.Int32, value: TopicInfo?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// Represents a sequence of active topics used for transmitting topic information during session establishment.
public typealias TopicInfoSeq = [TopicInfo]

/// Helper class to read and write `TopicInfoSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct TopicInfoSeqHelper {
    /// Read a `TopicInfoSeq` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> TopicInfoSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = TopicInfoSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: TopicInfo = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `TopicInfoSeq?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> TopicInfoSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `TopicInfoSeq` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: TopicInfoSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `TopicInfoSeq?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: TopicInfoSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Provides detailed information about topic readers and topic writers, including its ID, name, keys, filters,
/// and tags.
public struct TopicSpec {
    /// The ID of the topic.
    public var id: Swift.Int64 = 0
    /// The name of the topic.
    public var name: Swift.String = ""
    /// The topic's keys and filters.
    public var elements: ElementInfoSeq = ElementInfoSeq()
    /// The topic update tags.
    public var tags: ElementInfoSeq = ElementInfoSeq()

    public init() {}

    public init(id: Swift.Int64, name: Swift.String, elements: ElementInfoSeq, tags: ElementInfoSeq) {
        self.id = id
        self.name = name
        self.elements = elements
        self.tags = tags
    }
}

/// An `Ice.InputStream` extension to read `TopicSpec` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `TopicSpec` structured value from the stream.
    ///
    /// - Returns: The structured value read from the stream.
    func read() throws -> TopicSpec {
        var v = TopicSpec()
        v.id = try self.read()
        v.name = try self.read()
        v.elements = try ElementInfoSeqHelper.read(from: self)
        v.tags = try ElementInfoSeqHelper.read(from: self)
        return v
    }

    /// Read an optional `TopicSpec?` structured value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> TopicSpec? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as TopicSpec
    }
}

/// An `Ice.OutputStream` extension to write `TopicSpec` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `TopicSpec` structured value to the stream.
    ///
    /// - Parameter v: The value to write to the stream.
    func write(_ v: TopicSpec) {
        self.write(v.id)
        self.write(v.name)
        ElementInfoSeqHelper.write(to: self, value: v.elements)
        ElementInfoSeqHelper.write(to: self, value: v.tags)
    }

    /// Write an optional `TopicSpec?` structured value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The value to write to the stream.
    func write(tag: Swift.Int32, value: TopicSpec?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public struct FilterInfo {
    public var name: Swift.String = ""
    public var criteria: Ice.ByteSeq = Ice.ByteSeq()

    public init() {}

    public init(name: Swift.String, criteria: Ice.ByteSeq) {
        self.name = name
        self.criteria = criteria
    }
}

/// An `Ice.InputStream` extension to read `FilterInfo` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `FilterInfo` structured value from the stream.
    ///
    /// - Returns: The structured value read from the stream.
    func read() throws -> FilterInfo {
        var v = FilterInfo()
        v.name = try self.read()
        v.criteria = try self.read()
        return v
    }

    /// Read an optional `FilterInfo?` structured value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> FilterInfo? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as FilterInfo
    }
}

/// An `Ice.OutputStream` extension to write `FilterInfo` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `FilterInfo` structured value to the stream.
    ///
    /// - Parameter v: The value to write to the stream.
    func write(_ v: FilterInfo) {
        self.write(v.name)
        self.write(v.criteria)
    }

    /// Write an optional `FilterInfo?` structured value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The value to write to the stream.
    func write(tag: Swift.Int32, value: FilterInfo?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public class ElementData {
    /// The id of the writer or reader.
    public var id: Swift.Int64 = 0
    /// The config of the writer or reader.
    public var config: ElementConfig? = nil
    /// The lastIds received by the reader.
    public var lastIds: LongLongDict = LongLongDict()

    public init() {}

    public init(id: Swift.Int64, config: ElementConfig?, lastIds: LongLongDict) {
        self.id = id
        self.config = config
        self.lastIds = lastIds
    }
}

/// An `Ice.InputStream` extension to read `ElementData` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `ElementData` structured value from the stream.
    ///
    /// - Returns: The structured value read from the stream.
    func read() throws -> ElementData {
        let v = ElementData()
        v.id = try self.read()
        try self.read(ElementConfig.self) { v.config = $0 }
        v.lastIds = try LongLongDictHelper.read(from: self)
        return v
    }

    /// Read an optional `ElementData?` structured value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> ElementData? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as ElementData
    }
}

/// An `Ice.OutputStream` extension to write `ElementData` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `ElementData` structured value to the stream.
    ///
    /// - Parameter v: The value to write to the stream.
    func write(_ v: ElementData) {
        self.write(v.id)
        self.write(v.config)
        LongLongDictHelper.write(to: self, value: v.lastIds)
    }

    /// Write an optional `ElementData?` structured value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The value to write to the stream.
    func write(tag: Swift.Int32, value: ElementData?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public typealias ElementDataSeq = [ElementData]

/// Helper class to read and write `ElementDataSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ElementDataSeqHelper {
    /// Read a `ElementDataSeq` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ElementDataSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 10)
        var v = ElementDataSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: ElementData = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `ElementDataSeq?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ElementDataSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `ElementDataSeq` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ElementDataSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `ElementDataSeq?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ElementDataSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Provides detailed information about elements that can be either a key or a filter.
public class ElementSpec {
    /// The readers and writers associated with the key or filter.
    public var elements: ElementDataSeq = ElementDataSeq()
    /// The id of the key or filter.
    public var id: Swift.Int64 = 0
    /// The name of the filter. This field is empty for key elements.
    public var name: Swift.String = ""
    /// The value of the key or filter.
    public var value: Ice.ByteSeq = Ice.ByteSeq()
    /// The id of the key or filter from the peer.
    public var peerId: Swift.Int64 = 0
    /// The name of the filter from the peer.
    public var peerName: Swift.String = ""

    public init() {}

    public init(elements: ElementDataSeq, id: Swift.Int64, name: Swift.String, value: Ice.ByteSeq, peerId: Swift.Int64, peerName: Swift.String) {
        self.elements = elements
        self.id = id
        self.name = name
        self.value = value
        self.peerId = peerId
        self.peerName = peerName
    }
}

/// An `Ice.InputStream` extension to read `ElementSpec` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `ElementSpec` structured value from the stream.
    ///
    /// - Returns: The structured value read from the stream.
    func read() throws -> ElementSpec {
        let v = ElementSpec()
        v.elements = try ElementDataSeqHelper.read(from: self)
        v.id = try self.read()
        v.name = try self.read()
        v.value = try self.read()
        v.peerId = try self.read()
        v.peerName = try self.read()
        return v
    }

    /// Read an optional `ElementSpec?` structured value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> ElementSpec? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as ElementSpec
    }
}

/// An `Ice.OutputStream` extension to write `ElementSpec` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `ElementSpec` structured value to the stream.
    ///
    /// - Parameter v: The value to write to the stream.
    func write(_ v: ElementSpec) {
        ElementDataSeqHelper.write(to: self, value: v.elements)
        self.write(v.id)
        self.write(v.name)
        self.write(v.value)
        self.write(v.peerId)
        self.write(v.peerName)
    }

    /// Write an optional `ElementSpec?` structured value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The value to write to the stream.
    func write(tag: Swift.Int32, value: ElementSpec?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public typealias ElementSpecSeq = [ElementSpec]

/// Helper class to read and write `ElementSpecSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ElementSpecSeqHelper {
    /// Read a `ElementSpecSeq` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ElementSpecSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 20)
        var v = ElementSpecSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: ElementSpec = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `ElementSpecSeq?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ElementSpecSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `ElementSpecSeq` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ElementSpecSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `ElementSpecSeq?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ElementSpecSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public class ElementDataAck {
    /// The id of the writer or filter.
    public var id: Swift.Int64 = 0
    /// The config of the writer or reader.
    public var config: ElementConfig? = nil
    /// The lastIds received by the reader.
    public var lastIds: LongLongDict = LongLongDict()
    /// The samples of the writer or reader.
    public var samples: DataSampleSeq = DataSampleSeq()
    /// The id of the writer or reader on the peer.
    public var peerId: Swift.Int64 = 0

    public init() {}

    public init(id: Swift.Int64, config: ElementConfig?, lastIds: LongLongDict, samples: DataSampleSeq, peerId: Swift.Int64) {
        self.id = id
        self.config = config
        self.lastIds = lastIds
        self.samples = samples
        self.peerId = peerId
    }
}

/// An `Ice.InputStream` extension to read `ElementDataAck` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `ElementDataAck` structured value from the stream.
    ///
    /// - Returns: The structured value read from the stream.
    func read() throws -> ElementDataAck {
        let v = ElementDataAck()
        v.id = try self.read()
        try self.read(ElementConfig.self) { v.config = $0 }
        v.lastIds = try LongLongDictHelper.read(from: self)
        v.samples = try DataSampleSeqHelper.read(from: self)
        v.peerId = try self.read()
        return v
    }

    /// Read an optional `ElementDataAck?` structured value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> ElementDataAck? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as ElementDataAck
    }
}

/// An `Ice.OutputStream` extension to write `ElementDataAck` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `ElementDataAck` structured value to the stream.
    ///
    /// - Parameter v: The value to write to the stream.
    func write(_ v: ElementDataAck) {
        self.write(v.id)
        self.write(v.config)
        LongLongDictHelper.write(to: self, value: v.lastIds)
        DataSampleSeqHelper.write(to: self, value: v.samples)
        self.write(v.peerId)
    }

    /// Write an optional `ElementDataAck?` structured value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The value to write to the stream.
    func write(tag: Swift.Int32, value: ElementDataAck?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public typealias ElementDataAckSeq = [ElementDataAck]

/// Helper class to read and write `ElementDataAckSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ElementDataAckSeqHelper {
    /// Read a `ElementDataAckSeq` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ElementDataAckSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 19)
        var v = ElementDataAckSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: ElementDataAck = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `ElementDataAckSeq?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ElementDataAckSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `ElementDataAckSeq` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ElementDataAckSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `ElementDataAckSeq?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ElementDataAckSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public class ElementSpecAck {
    /// The readers or writers associated with the key or filter.
    public var elements: ElementDataAckSeq = ElementDataAckSeq()
    /// The id of the key or filter.
    public var id: Swift.Int64 = 0
    /// The name of the filter.
    public var name: Swift.String = ""
    /// The key or filter value.
    public var value: Ice.ByteSeq = Ice.ByteSeq()
    /// The id of the key or filter on the peer.
    public var peerId: Swift.Int64 = 0
    /// The name of the filter on the peer.
    public var peerName: Swift.String = ""

    public init() {}

    public init(elements: ElementDataAckSeq, id: Swift.Int64, name: Swift.String, value: Ice.ByteSeq, peerId: Swift.Int64, peerName: Swift.String) {
        self.elements = elements
        self.id = id
        self.name = name
        self.value = value
        self.peerId = peerId
        self.peerName = peerName
    }
}

/// An `Ice.InputStream` extension to read `ElementSpecAck` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `ElementSpecAck` structured value from the stream.
    ///
    /// - Returns: The structured value read from the stream.
    func read() throws -> ElementSpecAck {
        let v = ElementSpecAck()
        v.elements = try ElementDataAckSeqHelper.read(from: self)
        v.id = try self.read()
        v.name = try self.read()
        v.value = try self.read()
        v.peerId = try self.read()
        v.peerName = try self.read()
        return v
    }

    /// Read an optional `ElementSpecAck?` structured value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> ElementSpecAck? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as ElementSpecAck
    }
}

/// An `Ice.OutputStream` extension to write `ElementSpecAck` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `ElementSpecAck` structured value to the stream.
    ///
    /// - Parameter v: The value to write to the stream.
    func write(_ v: ElementSpecAck) {
        ElementDataAckSeqHelper.write(to: self, value: v.elements)
        self.write(v.id)
        self.write(v.name)
        self.write(v.value)
        self.write(v.peerId)
        self.write(v.peerName)
    }

    /// Write an optional `ElementSpecAck?` structured value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The value to write to the stream.
    func write(tag: Swift.Int32, value: ElementSpecAck?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public typealias ElementSpecAckSeq = [ElementSpecAck]

/// Helper class to read and write `ElementSpecAckSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ElementSpecAckSeqHelper {
    /// Read a `ElementSpecAckSeq` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ElementSpecAckSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 20)
        var v = ElementSpecAckSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: ElementSpecAck = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `ElementSpecAckSeq?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ElementSpecAckSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `ElementSpecAckSeq` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ElementSpecAckSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `ElementSpecAckSeq?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ElementSpecAckSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice interface `Session`.
public struct SessionTraits: Ice.SliceTraits {
    public static let staticIds = ["::DataStormContract::Session", "::Ice::Object"]
    public static let staticId = "::DataStormContract::Session"
}

/// Traits for Slice interface `PublisherSession`.
public struct PublisherSessionTraits: Ice.SliceTraits {
    public static let staticIds = ["::DataStormContract::PublisherSession", "::DataStormContract::Session", "::Ice::Object"]
    public static let staticId = "::DataStormContract::PublisherSession"
}

/// Traits for Slice interface `SubscriberSession`.
public struct SubscriberSessionTraits: Ice.SliceTraits {
    public static let staticIds = ["::DataStormContract::Session", "::DataStormContract::SubscriberSession", "::Ice::Object"]
    public static let staticId = "::DataStormContract::SubscriberSession"
}

/// Traits for Slice interface `Node`.
public struct NodeTraits: Ice.SliceTraits {
    public static let staticIds = ["::DataStormContract::Node", "::Ice::Object"]
    public static let staticId = "::DataStormContract::Node"
}

/// Traits for Slice interface `Lookup`.
public struct LookupTraits: Ice.SliceTraits {
    public static let staticIds = ["::DataStormContract::Lookup", "::Ice::Object"]
    public static let staticId = "::DataStormContract::Lookup"
}

public protocol SessionPrx: Ice.ObjectPrx {}

private final class SessionPrxI: Ice.ObjectPrxI, SessionPrx {
    public override class func ice_staticId() -> Swift.String {
        return SessionTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: SessionPrx.Protocol) throws -> SessionPrx {
    try communicator.makeProxyImpl(proxyString) as SessionPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: SessionPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> SessionPrx? {
    return try await SessionPrxI.checkedCast(prx: prx, facet: facet, context: context) as SessionPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: SessionPrx.Protocol, facet: Swift.String? = nil) -> SessionPrx {
    return SessionPrxI.uncheckedCast(prx: prx, facet: facet) as SessionPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: SessionPrx.Protocol) -> Swift.String {
    return SessionTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `SessionPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: SessionPrx.Protocol) throws -> SessionPrx? {
        return try read() as SessionPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: SessionPrx.Protocol) throws -> SessionPrx? {
        return try read(tag: tag) as SessionPrxI?
    }
}

public extension SessionPrx {
    /// Announces new and existing topics to the peer.
    ///
    /// - During session establishment, this operation announces existing topics.
    /// - For already established sessions, it is used to announce new topics.
    ///
    /// A publisher session announces the topics it writes, while a subscriber session announces the topics it reads.
    ///
    /// The peer receiving the announcement will invoke `attachTopic` for any topics it is interested in.
    ///
    /// - Parameters:
    ///   - iceP_topics: The sequence of topics to announce.
    ///   - iceP_initialize: Currently unused.
    ///   - context: Optional request context.
    func announceTopics(topics iceP_topics: TopicInfoSeq, initialize iceP_initialize: Swift.Bool, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "announceTopics",
                                       mode: .Normal,
                                       write: { ostr in
                                           TopicInfoSeqHelper.write(to: ostr, value: iceP_topics)
                                           ostr.write(iceP_initialize)
                                       },
                                       context: context)
    }

    /// Attaches a local topic to a remote topic when a session receives a topic announcement from a peer.
    ///
    /// This method is called if the session is interested in the announced topic, which occurs when:
    ///
    /// - The session has a reader for a topic that the peer has a writer for, or
    /// - The session has a writer for a topic that the peer has a reader for.
    ///
    /// - Parameters:
    ///   - iceP_topic: The TopicSpec object describing the topic being attached to the remote topic.
    ///   - context: Optional request context.
    func attachTopic(_ iceP_topic: TopicSpec, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "attachTopic",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_topic)
                                       },
                                       context: context)
    }

    func detachTopic(_ iceP_topic: Swift.Int64, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "detachTopic",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_topic)
                                       },
                                       context: context)
    }

    func attachTags(topic iceP_topic: Swift.Int64, tags iceP_tags: ElementInfoSeq, initialize iceP_initialize: Swift.Bool, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "attachTags",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_topic)
                                           ElementInfoSeqHelper.write(to: ostr, value: iceP_tags)
                                           ostr.write(iceP_initialize)
                                       },
                                       context: context)
    }

    func detachTags(topic iceP_topic: Swift.Int64, tags iceP_tags: Ice.LongSeq, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "detachTags",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_topic)
                                           ostr.write(iceP_tags)
                                       },
                                       context: context)
    }

    /// Announces new elements to the peer.
    ///
    /// The peer will invoke `attachElements` for the elements it is interested in. The announced elements include
    /// the readers and writers associated with the specified topic.
    ///
    /// - Parameters:
    ///   - iceP_topic: The ID of the topic associated with the elements.
    ///   - iceP_elements: The sequence of elements to announce.
    ///   - context: Optional request context.
    func announceElements(topic iceP_topic: Swift.Int64, elements iceP_elements: ElementInfoSeq, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "announceElements",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_topic)
                                           ElementInfoSeqHelper.write(to: ostr, value: iceP_elements)
                                       },
                                       context: context)
    }

    /// Attaches the given topic elements to all subscribers of the specified topic.
    ///
    /// - Parameters:
    ///   - iceP_topicId: The ID of the topic to which the elements belong.
    ///   - iceP_elements: The sequence of elements to attach to the topic's subscribers.
    ///   - iceP_initialize: True if called from attachTopic, false otherwise.
    ///   - context: Optional request context.
    func attachElements(topicId iceP_topicId: Swift.Int64, elements iceP_elements: ElementSpecSeq, initialize iceP_initialize: Swift.Bool, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "attachElements",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_topicId)
                                           ElementSpecSeqHelper.write(to: ostr, value: iceP_elements)
                                           ostr.write(iceP_initialize)
                                           ostr.writePendingValues()
                                       },
                                       context: context)
    }

    func attachElementsAck(topic iceP_topic: Swift.Int64, elements iceP_elements: ElementSpecAckSeq, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "attachElementsAck",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_topic)
                                           ElementSpecAckSeqHelper.write(to: ostr, value: iceP_elements)
                                           ostr.writePendingValues()
                                       },
                                       context: context)
    }

    func detachElements(topic iceP_topic: Swift.Int64, keys iceP_keys: Ice.LongSeq, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "detachElements",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_topic)
                                           ostr.write(iceP_keys)
                                       },
                                       context: context)
    }

    func initSamples(topic iceP_topic: Swift.Int64, samples iceP_samples: DataSamplesSeq, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "initSamples",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_topic)
                                           DataSamplesSeqHelper.write(to: ostr, value: iceP_samples)
                                       },
                                       context: context)
    }

    func disconnected(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "disconnected",
                                       mode: .Normal,
                                       context: context)
    }
}

public protocol PublisherSessionPrx: SessionPrx {}

private final class PublisherSessionPrxI: Ice.ObjectPrxI, PublisherSessionPrx {
    public override class func ice_staticId() -> Swift.String {
        return PublisherSessionTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: PublisherSessionPrx.Protocol) throws -> PublisherSessionPrx {
    try communicator.makeProxyImpl(proxyString) as PublisherSessionPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: PublisherSessionPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> PublisherSessionPrx? {
    return try await PublisherSessionPrxI.checkedCast(prx: prx, facet: facet, context: context) as PublisherSessionPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: PublisherSessionPrx.Protocol, facet: Swift.String? = nil) -> PublisherSessionPrx {
    return PublisherSessionPrxI.uncheckedCast(prx: prx, facet: facet) as PublisherSessionPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: PublisherSessionPrx.Protocol) -> Swift.String {
    return PublisherSessionTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `PublisherSessionPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: PublisherSessionPrx.Protocol) throws -> PublisherSessionPrx? {
        return try read() as PublisherSessionPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: PublisherSessionPrx.Protocol) throws -> PublisherSessionPrx? {
        return try read(tag: tag) as PublisherSessionPrxI?
    }
}

public extension PublisherSessionPrx {}

public protocol SubscriberSessionPrx: SessionPrx {}

private final class SubscriberSessionPrxI: Ice.ObjectPrxI, SubscriberSessionPrx {
    public override class func ice_staticId() -> Swift.String {
        return SubscriberSessionTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: SubscriberSessionPrx.Protocol) throws -> SubscriberSessionPrx {
    try communicator.makeProxyImpl(proxyString) as SubscriberSessionPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: SubscriberSessionPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> SubscriberSessionPrx? {
    return try await SubscriberSessionPrxI.checkedCast(prx: prx, facet: facet, context: context) as SubscriberSessionPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: SubscriberSessionPrx.Protocol, facet: Swift.String? = nil) -> SubscriberSessionPrx {
    return SubscriberSessionPrxI.uncheckedCast(prx: prx, facet: facet) as SubscriberSessionPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: SubscriberSessionPrx.Protocol) -> Swift.String {
    return SubscriberSessionTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `SubscriberSessionPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: SubscriberSessionPrx.Protocol) throws -> SubscriberSessionPrx? {
        return try read() as SubscriberSessionPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: SubscriberSessionPrx.Protocol) throws -> SubscriberSessionPrx? {
        return try read(tag: tag) as SubscriberSessionPrxI?
    }
}

public extension SubscriberSessionPrx {
    /// Queue a sample with the subscribers of the topic element.
    ///
    /// - Parameters:
    ///   - iceP_topicId: The ID of the topic.
    ///   - iceP_elementId: The ID of the element.
    ///   - iceP_sample: The sample to queue.
    ///   - context: Optional request context.
    func s(topicId iceP_topicId: Swift.Int64, elementId iceP_elementId: Swift.Int64, sample iceP_sample: DataSample, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "s",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_topicId)
                                           ostr.write(iceP_elementId)
                                           ostr.write(iceP_sample)
                                       },
                                       context: context)
    }
}

/// The Node interface allows DataStorm nodes to create publisher and subscriber sessions with each other.
///
/// When a node has a writer for a topic that another node is reading, the node initiates the creation of a
/// publisher session. Likewise, when a node has a reader for a topic that another node is writing, the node
/// initiates the creation of a subscriber session.
///
/// The publisher node hosts the publisher session servant, which is accessed by the subscriber node through a
/// PublisherSession proxy. The subscriber node hosts the subscriber session servant, which is accessed by the
/// publisher node through a SubscriberSession proxy.
///
/// NodePrx Methods:
///  - initiateCreateSession: Initiate the creation of a publisher session with a node, after the target node has announced a topic reader for which this node has a corresponding topic writer.
///  - initiateCreateSessionAsync: Initiate the creation of a publisher session with a node, after the target node has announced a topic reader for which this node has a corresponding topic writer.
///  - createSession: Initiate the creation of a subscriber session with a node, after the target node has announced a topic writer for which this node has a corresponding topic reader, or after the node has called Node::initiateCreateSession.
///  - createSessionAsync: Initiate the creation of a subscriber session with a node, after the target node has announced a topic writer for which this node has a corresponding topic reader, or after the node has called Node::initiateCreateSession.
///  - confirmCreateSession: Confirm the creation of a publisher session with a node.
///  - confirmCreateSessionAsync: Confirm the creation of a publisher session with a node.
public protocol NodePrx: Ice.ObjectPrx {}

private final class NodePrxI: Ice.ObjectPrxI, NodePrx {
    public override class func ice_staticId() -> Swift.String {
        return NodeTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: NodePrx.Protocol) throws -> NodePrx {
    try communicator.makeProxyImpl(proxyString) as NodePrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: NodePrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> NodePrx? {
    return try await NodePrxI.checkedCast(prx: prx, facet: facet, context: context) as NodePrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: NodePrx.Protocol, facet: Swift.String? = nil) -> NodePrx {
    return NodePrxI.uncheckedCast(prx: prx, facet: facet) as NodePrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: NodePrx.Protocol) -> Swift.String {
    return NodeTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `NodePrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: NodePrx.Protocol) throws -> NodePrx? {
        return try read() as NodePrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: NodePrx.Protocol) throws -> NodePrx? {
        return try read(tag: tag) as NodePrxI?
    }
}

/// The Node interface allows DataStorm nodes to create publisher and subscriber sessions with each other.
///
/// When a node has a writer for a topic that another node is reading, the node initiates the creation of a
/// publisher session. Likewise, when a node has a reader for a topic that another node is writing, the node
/// initiates the creation of a subscriber session.
///
/// The publisher node hosts the publisher session servant, which is accessed by the subscriber node through a
/// PublisherSession proxy. The subscriber node hosts the subscriber session servant, which is accessed by the
/// publisher node through a SubscriberSession proxy.
///
/// NodePrx Methods:
///  - initiateCreateSession: Initiate the creation of a publisher session with a node, after the target node has announced a topic reader for which this node has a corresponding topic writer.
///  - initiateCreateSessionAsync: Initiate the creation of a publisher session with a node, after the target node has announced a topic reader for which this node has a corresponding topic writer.
///  - createSession: Initiate the creation of a subscriber session with a node, after the target node has announced a topic writer for which this node has a corresponding topic reader, or after the node has called Node::initiateCreateSession.
///  - createSessionAsync: Initiate the creation of a subscriber session with a node, after the target node has announced a topic writer for which this node has a corresponding topic reader, or after the node has called Node::initiateCreateSession.
///  - confirmCreateSession: Confirm the creation of a publisher session with a node.
///  - confirmCreateSessionAsync: Confirm the creation of a publisher session with a node.
public extension NodePrx {
    /// Initiate the creation of a publisher session with a node, after the target node has announced a topic
    /// reader for which this node has a corresponding topic writer.
    ///
    /// - Parameters:
    ///   - iceP_publisher: The publisher node initiating the session. The proxy is never null.
    ///   - context: Optional request context.
    func initiateCreateSession(_ iceP_publisher: NodePrx?, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "initiateCreateSession",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_publisher)
                                       },
                                       context: context)
    }

    /// Initiate the creation of a subscriber session with a node, after the target node has announced a topic
    /// writer for which this node has a corresponding topic reader, or after the node has called
    /// Node::initiateCreateSession.
    ///
    /// - Parameters:
    ///   - iceP_subscriber: The subscriber node initiating the session. The proxy is never null.
    ///   - iceP_session: The subscriber session being created. The proxy is never null.
    ///   - iceP_fromRelay: Indicates if the session is being created from a relay node.
    ///   - context: Optional request context.
    func createSession(subscriber iceP_subscriber: NodePrx?, session iceP_session: SubscriberSessionPrx?, fromRelay iceP_fromRelay: Swift.Bool, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "createSession",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_subscriber)
                                           ostr.write(iceP_session)
                                           ostr.write(iceP_fromRelay)
                                       },
                                       context: context)
    }

    /// Confirm the creation of a publisher session with a node.
    ///
    /// - Parameters:
    ///   - iceP_publisher: The publisher node confirming the session. The proxy is never null.
    ///   - iceP_session: The publisher session being confirmed. The proxy is never null.
    ///   - context: Optional request context.
    func confirmCreateSession(publisher iceP_publisher: NodePrx?, session iceP_session: PublisherSessionPrx?, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "confirmCreateSession",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_publisher)
                                           ostr.write(iceP_session)
                                       },
                                       context: context)
    }
}

/// The lookup interface is used by DataStorm nodes to announce their topic readers and writers to other connected
/// nodes. When multicast is enabled, the lookup interface also broadcasts these announcements.
/// Each DataStorm node hosts a lookup servant with the identity "DataStorm/Lookup".
///
/// LookupPrx Methods:
///  - announceTopicReader: Announce a topic reader.
///  - announceTopicReaderAsync: Announce a topic reader.
///  - announceTopicWriter: Announce a topic writer.
///  - announceTopicWriterAsync: Announce a topic writer.
///  - announceTopics: Announce a set of topic readers and writers.
///  - announceTopicsAsync: Announce a set of topic readers and writers.
///  - createSession: Establish a connection between this node and another node.
///  - createSessionAsync: Establish a connection between this node and another node.
public protocol LookupPrx: Ice.ObjectPrx {}

private final class LookupPrxI: Ice.ObjectPrxI, LookupPrx {
    public override class func ice_staticId() -> Swift.String {
        return LookupTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: LookupPrx.Protocol) throws -> LookupPrx {
    try communicator.makeProxyImpl(proxyString) as LookupPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: LookupPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> LookupPrx? {
    return try await LookupPrxI.checkedCast(prx: prx, facet: facet, context: context) as LookupPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: LookupPrx.Protocol, facet: Swift.String? = nil) -> LookupPrx {
    return LookupPrxI.uncheckedCast(prx: prx, facet: facet) as LookupPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: LookupPrx.Protocol) -> Swift.String {
    return LookupTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `LookupPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: LookupPrx.Protocol) throws -> LookupPrx? {
        return try read() as LookupPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: LookupPrx.Protocol) throws -> LookupPrx? {
        return try read(tag: tag) as LookupPrxI?
    }
}

/// The lookup interface is used by DataStorm nodes to announce their topic readers and writers to other connected
/// nodes. When multicast is enabled, the lookup interface also broadcasts these announcements.
/// Each DataStorm node hosts a lookup servant with the identity "DataStorm/Lookup".
///
/// LookupPrx Methods:
///  - announceTopicReader: Announce a topic reader.
///  - announceTopicReaderAsync: Announce a topic reader.
///  - announceTopicWriter: Announce a topic writer.
///  - announceTopicWriterAsync: Announce a topic writer.
///  - announceTopics: Announce a set of topic readers and writers.
///  - announceTopicsAsync: Announce a set of topic readers and writers.
///  - createSession: Establish a connection between this node and another node.
///  - createSessionAsync: Establish a connection between this node and another node.
public extension LookupPrx {
    /// Announce a topic reader.
    ///
    /// - Parameters:
    ///   - iceP_topic: The name of the topic.
    ///   - iceP_subscriber: The node reading the topic. The subscriber proxy is never null.
    ///   - context: Optional request context.
    func announceTopicReader(topic iceP_topic: Swift.String, subscriber iceP_subscriber: NodePrx?, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "announceTopicReader",
                                       mode: .Idempotent,
                                       write: { ostr in
                                           ostr.write(iceP_topic)
                                           ostr.write(iceP_subscriber)
                                       },
                                       context: context)
    }

    /// Announce a topic writer.
    ///
    /// - Parameters:
    ///   - iceP_topic: The name of the topic.
    ///   - iceP_node: The node writing the topic. The proxy is never null.
    ///   - context: Optional request context.
    func announceTopicWriter(topic iceP_topic: Swift.String, node iceP_node: NodePrx?, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "announceTopicWriter",
                                       mode: .Idempotent,
                                       write: { ostr in
                                           ostr.write(iceP_topic)
                                           ostr.write(iceP_node)
                                       },
                                       context: context)
    }

    /// Announce a set of topic readers and writers.
    ///
    /// - Parameters:
    ///   - iceP_readers: A sequence of topic names for readers.
    ///   - iceP_writers: A sequence of topic names for writers.
    ///   - iceP_node: The node reading or writing the topics. The proxy is never null.
    ///   - context: Optional request context.
    func announceTopics(readers iceP_readers: Ice.StringSeq, writers iceP_writers: Ice.StringSeq, node iceP_node: NodePrx?, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "announceTopics",
                                       mode: .Idempotent,
                                       write: { ostr in
                                           ostr.write(iceP_readers)
                                           ostr.write(iceP_writers)
                                           ostr.write(iceP_node)
                                       },
                                       context: context)
    }

    /// Establish a connection between this node and another node.
    ///
    /// - Parameters:
    ///   - iceP_node: The node initiating the connection. The proxy is never null.
    ///   - context: Optional request context.
    ///
    /// - Returns: A proxy to this node. The proxy is never null.
    func createSession(_ iceP_node: NodePrx?, context: Ice.Context? = nil) async throws -> NodePrx? {
        return try await _impl._invoke(operation: "createSession",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_node)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: NodePrx? = try istr.read(NodePrx.self)
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}

@_documentation(visibility: internal)
public class ElementConfig_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return ElementConfig.self
    }
}

public extension Ice.TypeIdResolver {
    @objc static func TypeId_1() -> Swift.String {
        return "::DataStormContract::ElementConfig"
    }
}

public extension Ice.ClassResolver {
    @objc static func DataStormContract_ElementConfig() -> Ice.ValueTypeResolver {
        return ElementConfig_TypeResolver()
    }
}

/// Represents the configuration of a reader or writer.
open class ElementConfig: Ice.Value {
    public var facet: Swift.String? = nil
    /// An optional sample filter associated with the reader. Sample filters are specified on the reader side.
    public var sampleFilter: FilterInfo? = nil
    /// An optional name for the reader or writer.
    public var name: Swift.String? = nil
    /// An optional priority for the writer.
    /// See also the `DataStorm.Topic.Priority` property.
    public var priority: Swift.Int32? = nil
    /// An optional sample count, specifying the number of samples queued in the writer or reader sample queue.
    /// See also the `DataStorm.Topic.SampleCount` property.
    public var sampleCount: Swift.Int32? = nil
    /// An optional lifetime, specified in milliseconds, representing the maximum time samples are kept in the
    /// writer or reader sample queue. See also the `DataStorm.Topic.SampleLifetime` property.
    public var sampleLifetime: Swift.Int32? = nil
    /// An optional clear history policy that determines when the reader or writer sample history is cleared.
    /// See also the `DataStorm.Topic.ClearHistory` property.
    public var clearHistory: ClearHistoryPolicy? = nil

    public required init() {}

    public init(facet: Swift.String?, sampleFilter: FilterInfo?, name: Swift.String?, priority: Swift.Int32?, sampleCount: Swift.Int32?, sampleLifetime: Swift.Int32?, clearHistory: ClearHistoryPolicy?) {
        self.facet = facet
        self.sampleFilter = sampleFilter
        self.name = name
        self.priority = priority
        self.sampleCount = sampleCount
        self.sampleLifetime = sampleLifetime
        self.clearHistory = clearHistory
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::DataStormContract::ElementConfig" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.facet = try istr.read(tag: 1)
        self.sampleFilter = try istr.read(tag: 2)
        self.name = try istr.read(tag: 3)
        self.priority = try istr.read(tag: 4)
        self.sampleCount = try istr.read(tag: 10)
        self.sampleLifetime = try istr.read(tag: 11)
        self.clearHistory = try istr.read(tag: 12)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: ElementConfig.ice_staticId(), compactId: 1, last: true)
        ostr.write(tag: 1, value: self.facet)
        ostr.write(tag: 2, value: self.sampleFilter)
        ostr.write(tag: 3, value: self.name)
        ostr.write(tag: 4, value: self.priority)
        ostr.write(tag: 10, value: self.sampleCount)
        ostr.write(tag: 11, value: self.sampleLifetime)
        ostr.write(tag: 12, value: self.clearHistory)
        ostr.endSlice()
    }
}


/// Dispatcher for `Session` servants.
public struct SessionDisp: Ice.Dispatcher {
    public let servant: Session
    private static let defaultObject = Ice.ObjectI<SessionTraits>()

    public init(_ servant: Session) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "announceElements":
            try await servant._iceD_announceElements(request)
        case "announceTopics":
            try await servant._iceD_announceTopics(request)
        case "attachElements":
            try await servant._iceD_attachElements(request)
        case "attachElementsAck":
            try await servant._iceD_attachElementsAck(request)
        case "attachTags":
            try await servant._iceD_attachTags(request)
        case "attachTopic":
            try await servant._iceD_attachTopic(request)
        case "detachElements":
            try await servant._iceD_detachElements(request)
        case "detachTags":
            try await servant._iceD_detachTags(request)
        case "detachTopic":
            try await servant._iceD_detachTopic(request)
        case "disconnected":
            try await servant._iceD_disconnected(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? SessionDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? SessionDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? SessionDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? SessionDisp.defaultObject)._iceD_ice_ping(request)
        case "initSamples":
            try await servant._iceD_initSamples(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol Session {
    /// Announces new and existing topics to the peer.
    ///
    /// - During session establishment, this operation announces existing topics.
    /// - For already established sessions, it is used to announce new topics.
    ///
    /// A publisher session announces the topics it writes, while a subscriber session announces the topics it reads.
    ///
    /// The peer receiving the announcement will invoke `attachTopic` for any topics it is interested in.
    ///
    /// - Parameters:
    ///   - topics: The sequence of topics to announce.
    ///   - initialize: Currently unused.
    ///   - current: The Current object for the dispatch.
    func announceTopics(topics: TopicInfoSeq, initialize: Swift.Bool, current: Ice.Current) async throws

    /// Attaches a local topic to a remote topic when a session receives a topic announcement from a peer.
    ///
    /// This method is called if the session is interested in the announced topic, which occurs when:
    ///
    /// - The session has a reader for a topic that the peer has a writer for, or
    /// - The session has a writer for a topic that the peer has a reader for.
    ///
    /// - Parameters:
    ///   - topic: The TopicSpec object describing the topic being attached to the remote topic.
    ///   - current: The Current object for the dispatch.
    func attachTopic(topic: TopicSpec, current: Ice.Current) async throws

    func detachTopic(topic: Swift.Int64, current: Ice.Current) async throws

    func attachTags(topic: Swift.Int64, tags: ElementInfoSeq, initialize: Swift.Bool, current: Ice.Current) async throws

    func detachTags(topic: Swift.Int64, tags: Ice.LongSeq, current: Ice.Current) async throws

    /// Announces new elements to the peer.
    ///
    /// The peer will invoke `attachElements` for the elements it is interested in. The announced elements include
    /// the readers and writers associated with the specified topic.
    ///
    /// - Parameters:
    ///   - topic: The ID of the topic associated with the elements.
    ///   - elements: The sequence of elements to announce.
    ///   - current: The Current object for the dispatch.
    func announceElements(topic: Swift.Int64, elements: ElementInfoSeq, current: Ice.Current) async throws

    /// Attaches the given topic elements to all subscribers of the specified topic.
    ///
    /// - Parameters:
    ///   - topicId: The ID of the topic to which the elements belong.
    ///   - elements: The sequence of elements to attach to the topic's subscribers.
    ///   - initialize: True if called from attachTopic, false otherwise.
    ///   - current: The Current object for the dispatch.
    func attachElements(topicId: Swift.Int64, elements: ElementSpecSeq, initialize: Swift.Bool, current: Ice.Current) async throws

    func attachElementsAck(topic: Swift.Int64, elements: ElementSpecAckSeq, current: Ice.Current) async throws

    func detachElements(topic: Swift.Int64, keys: Ice.LongSeq, current: Ice.Current) async throws

    func initSamples(topic: Swift.Int64, samples: DataSamplesSeq, current: Ice.Current) async throws

    func disconnected(current: Ice.Current) async throws
}


/// Dispatcher for `PublisherSession` servants.
public struct PublisherSessionDisp: Ice.Dispatcher {
    public let servant: PublisherSession
    private static let defaultObject = Ice.ObjectI<PublisherSessionTraits>()

    public init(_ servant: PublisherSession) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "announceElements":
            try await servant._iceD_announceElements(request)
        case "announceTopics":
            try await servant._iceD_announceTopics(request)
        case "attachElements":
            try await servant._iceD_attachElements(request)
        case "attachElementsAck":
            try await servant._iceD_attachElementsAck(request)
        case "attachTags":
            try await servant._iceD_attachTags(request)
        case "attachTopic":
            try await servant._iceD_attachTopic(request)
        case "detachElements":
            try await servant._iceD_detachElements(request)
        case "detachTags":
            try await servant._iceD_detachTags(request)
        case "detachTopic":
            try await servant._iceD_detachTopic(request)
        case "disconnected":
            try await servant._iceD_disconnected(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? PublisherSessionDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? PublisherSessionDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? PublisherSessionDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? PublisherSessionDisp.defaultObject)._iceD_ice_ping(request)
        case "initSamples":
            try await servant._iceD_initSamples(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol PublisherSession: Session {}


/// Dispatcher for `SubscriberSession` servants.
public struct SubscriberSessionDisp: Ice.Dispatcher {
    public let servant: SubscriberSession
    private static let defaultObject = Ice.ObjectI<SubscriberSessionTraits>()

    public init(_ servant: SubscriberSession) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "announceElements":
            try await servant._iceD_announceElements(request)
        case "announceTopics":
            try await servant._iceD_announceTopics(request)
        case "attachElements":
            try await servant._iceD_attachElements(request)
        case "attachElementsAck":
            try await servant._iceD_attachElementsAck(request)
        case "attachTags":
            try await servant._iceD_attachTags(request)
        case "attachTopic":
            try await servant._iceD_attachTopic(request)
        case "detachElements":
            try await servant._iceD_detachElements(request)
        case "detachTags":
            try await servant._iceD_detachTags(request)
        case "detachTopic":
            try await servant._iceD_detachTopic(request)
        case "disconnected":
            try await servant._iceD_disconnected(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? SubscriberSessionDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? SubscriberSessionDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? SubscriberSessionDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? SubscriberSessionDisp.defaultObject)._iceD_ice_ping(request)
        case "initSamples":
            try await servant._iceD_initSamples(request)
        case "s":
            try await servant._iceD_s(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol SubscriberSession: Session {
    /// Queue a sample with the subscribers of the topic element.
    ///
    /// - Parameters:
    ///   - topicId: The ID of the topic.
    ///   - elementId: The ID of the element.
    ///   - sample: The sample to queue.
    ///   - current: The Current object for the dispatch.
    func s(topicId: Swift.Int64, elementId: Swift.Int64, sample: DataSample, current: Ice.Current) async throws
}


/// Dispatcher for `Node` servants.
public struct NodeDisp: Ice.Dispatcher {
    public let servant: Node
    private static let defaultObject = Ice.ObjectI<NodeTraits>()

    public init(_ servant: Node) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "confirmCreateSession":
            try await servant._iceD_confirmCreateSession(request)
        case "createSession":
            try await servant._iceD_createSession(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? NodeDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? NodeDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? NodeDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? NodeDisp.defaultObject)._iceD_ice_ping(request)
        case "initiateCreateSession":
            try await servant._iceD_initiateCreateSession(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

/// The Node interface allows DataStorm nodes to create publisher and subscriber sessions with each other.
///
/// When a node has a writer for a topic that another node is reading, the node initiates the creation of a
/// publisher session. Likewise, when a node has a reader for a topic that another node is writing, the node
/// initiates the creation of a subscriber session.
///
/// The publisher node hosts the publisher session servant, which is accessed by the subscriber node through a
/// PublisherSession proxy. The subscriber node hosts the subscriber session servant, which is accessed by the
/// publisher node through a SubscriberSession proxy.
public protocol Node {
    /// Initiate the creation of a publisher session with a node, after the target node has announced a topic
    /// reader for which this node has a corresponding topic writer.
    ///
    /// - Parameters:
    ///   - publisher: The publisher node initiating the session. The proxy is never null.
    ///   - current: The Current object for the dispatch.
    func initiateCreateSession(publisher: NodePrx?, current: Ice.Current) async throws

    /// Initiate the creation of a subscriber session with a node, after the target node has announced a topic
    /// writer for which this node has a corresponding topic reader, or after the node has called
    /// Node::initiateCreateSession.
    ///
    /// - Parameters:
    ///   - subscriber: The subscriber node initiating the session. The proxy is never null.
    ///   - session: The subscriber session being created. The proxy is never null.
    ///   - fromRelay: Indicates if the session is being created from a relay node.
    ///   - current: The Current object for the dispatch.
    func createSession(subscriber: NodePrx?, session: SubscriberSessionPrx?, fromRelay: Swift.Bool, current: Ice.Current) async throws

    /// Confirm the creation of a publisher session with a node.
    ///
    /// - Parameters:
    ///   - publisher: The publisher node confirming the session. The proxy is never null.
    ///   - session: The publisher session being confirmed. The proxy is never null.
    ///   - current: The Current object for the dispatch.
    func confirmCreateSession(publisher: NodePrx?, session: PublisherSessionPrx?, current: Ice.Current) async throws
}


/// Dispatcher for `Lookup` servants.
public struct LookupDisp: Ice.Dispatcher {
    public let servant: Lookup
    private static let defaultObject = Ice.ObjectI<LookupTraits>()

    public init(_ servant: Lookup) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "announceTopicReader":
            try await servant._iceD_announceTopicReader(request)
        case "announceTopicWriter":
            try await servant._iceD_announceTopicWriter(request)
        case "announceTopics":
            try await servant._iceD_announceTopics(request)
        case "createSession":
            try await servant._iceD_createSession(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? LookupDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? LookupDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? LookupDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? LookupDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

/// The lookup interface is used by DataStorm nodes to announce their topic readers and writers to other connected
/// nodes. When multicast is enabled, the lookup interface also broadcasts these announcements.
/// Each DataStorm node hosts a lookup servant with the identity "DataStorm/Lookup".
public protocol Lookup {
    /// Announce a topic reader.
    ///
    /// - Parameters:
    ///   - topic: The name of the topic.
    ///   - subscriber: The node reading the topic. The subscriber proxy is never null.
    ///   - current: The Current object for the dispatch.
    func announceTopicReader(topic: Swift.String, subscriber: NodePrx?, current: Ice.Current) async throws

    /// Announce a topic writer.
    ///
    /// - Parameters:
    ///   - topic: The name of the topic.
    ///   - node: The node writing the topic. The proxy is never null.
    ///   - current: The Current object for the dispatch.
    func announceTopicWriter(topic: Swift.String, node: NodePrx?, current: Ice.Current) async throws

    /// Announce a set of topic readers and writers.
    ///
    /// - Parameters:
    ///   - readers: A sequence of topic names for readers.
    ///   - writers: A sequence of topic names for writers.
    ///   - node: The node reading or writing the topics. The proxy is never null.
    ///   - current: The Current object for the dispatch.
    func announceTopics(readers: Ice.StringSeq, writers: Ice.StringSeq, node: NodePrx?, current: Ice.Current) async throws

    /// Establish a connection between this node and another node.
    ///
    /// - Parameters:
    ///   - node: The node initiating the connection. The proxy is never null.
    ///   - current: The Current object for the dispatch.
    ///
    /// - Returns: A proxy to this node. The proxy is never null.
    func createSession(node: NodePrx?, current: Ice.Current) async throws -> NodePrx?
}

extension Session {
    public func _iceD_announceTopics(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_topics: TopicInfoSeq = try TopicInfoSeqHelper.read(from: istr)
        let iceP_initialize: Swift.Bool = try istr.read()
        try await self.announceTopics(topics: iceP_topics, initialize: iceP_initialize, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_attachTopic(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_topic: TopicSpec = try istr.read()
        try await self.attachTopic(topic: iceP_topic, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_detachTopic(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_topic: Swift.Int64 = try istr.read()
        try await self.detachTopic(topic: iceP_topic, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_attachTags(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_topic: Swift.Int64 = try istr.read()
        let iceP_tags: ElementInfoSeq = try ElementInfoSeqHelper.read(from: istr)
        let iceP_initialize: Swift.Bool = try istr.read()
        try await self.attachTags(topic: iceP_topic, tags: iceP_tags, initialize: iceP_initialize, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_detachTags(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_topic: Swift.Int64 = try istr.read()
        let iceP_tags: Ice.LongSeq = try istr.read()
        try await self.detachTags(topic: iceP_topic, tags: iceP_tags, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_announceElements(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_topic: Swift.Int64 = try istr.read()
        let iceP_elements: ElementInfoSeq = try ElementInfoSeqHelper.read(from: istr)
        try await self.announceElements(topic: iceP_topic, elements: iceP_elements, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_attachElements(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_topicId: Swift.Int64 = try istr.read()
        let iceP_elements: ElementSpecSeq = try ElementSpecSeqHelper.read(from: istr)
        let iceP_initialize: Swift.Bool = try istr.read()
        try istr.readPendingValues()
        try await self.attachElements(topicId: iceP_topicId, elements: iceP_elements, initialize: iceP_initialize, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_attachElementsAck(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_topic: Swift.Int64 = try istr.read()
        let iceP_elements: ElementSpecAckSeq = try ElementSpecAckSeqHelper.read(from: istr)
        try istr.readPendingValues()
        try await self.attachElementsAck(topic: iceP_topic, elements: iceP_elements, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_detachElements(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_topic: Swift.Int64 = try istr.read()
        let iceP_keys: Ice.LongSeq = try istr.read()
        try await self.detachElements(topic: iceP_topic, keys: iceP_keys, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_initSamples(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_topic: Swift.Int64 = try istr.read()
        let iceP_samples: DataSamplesSeq = try DataSamplesSeqHelper.read(from: istr)
        try await self.initSamples(topic: iceP_topic, samples: iceP_samples, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_disconnected(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.disconnected(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}

extension PublisherSession {}

extension SubscriberSession {
    public func _iceD_s(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_topicId: Swift.Int64 = try istr.read()
        let iceP_elementId: Swift.Int64 = try istr.read()
        let iceP_sample: DataSample = try istr.read()
        try await self.s(topicId: iceP_topicId, elementId: iceP_elementId, sample: iceP_sample, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}

/// The Node interface allows DataStorm nodes to create publisher and subscriber sessions with each other.
///
/// When a node has a writer for a topic that another node is reading, the node initiates the creation of a
/// publisher session. Likewise, when a node has a reader for a topic that another node is writing, the node
/// initiates the creation of a subscriber session.
///
/// The publisher node hosts the publisher session servant, which is accessed by the subscriber node through a
/// PublisherSession proxy. The subscriber node hosts the subscriber session servant, which is accessed by the
/// publisher node through a SubscriberSession proxy.
///
/// Node Methods:
///  - initiateCreateSession: Initiate the creation of a publisher session with a node, after the target node has announced a topic reader for which this node has a corresponding topic writer.
///  - createSession: Initiate the creation of a subscriber session with a node, after the target node has announced a topic writer for which this node has a corresponding topic reader, or after the node has called Node::initiateCreateSession.
///  - confirmCreateSession: Confirm the creation of a publisher session with a node.
extension Node {
    public func _iceD_initiateCreateSession(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_publisher: NodePrx? = try istr.read(NodePrx.self)
        try await self.initiateCreateSession(publisher: iceP_publisher, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_createSession(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_subscriber: NodePrx? = try istr.read(NodePrx.self)
        let iceP_session: SubscriberSessionPrx? = try istr.read(SubscriberSessionPrx.self)
        let iceP_fromRelay: Swift.Bool = try istr.read()
        try await self.createSession(subscriber: iceP_subscriber, session: iceP_session, fromRelay: iceP_fromRelay, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_confirmCreateSession(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_publisher: NodePrx? = try istr.read(NodePrx.self)
        let iceP_session: PublisherSessionPrx? = try istr.read(PublisherSessionPrx.self)
        try await self.confirmCreateSession(publisher: iceP_publisher, session: iceP_session, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}

/// The lookup interface is used by DataStorm nodes to announce their topic readers and writers to other connected
/// nodes. When multicast is enabled, the lookup interface also broadcasts these announcements.
/// Each DataStorm node hosts a lookup servant with the identity "DataStorm/Lookup".
///
/// Lookup Methods:
///  - announceTopicReader: Announce a topic reader.
///  - announceTopicWriter: Announce a topic writer.
///  - announceTopics: Announce a set of topic readers and writers.
///  - createSession: Establish a connection between this node and another node.
extension Lookup {
    public func _iceD_announceTopicReader(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_topic: Swift.String = try istr.read()
        let iceP_subscriber: NodePrx? = try istr.read(NodePrx.self)
        try await self.announceTopicReader(topic: iceP_topic, subscriber: iceP_subscriber, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_announceTopicWriter(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_topic: Swift.String = try istr.read()
        let iceP_node: NodePrx? = try istr.read(NodePrx.self)
        try await self.announceTopicWriter(topic: iceP_topic, node: iceP_node, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_announceTopics(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_readers: Ice.StringSeq = try istr.read()
        let iceP_writers: Ice.StringSeq = try istr.read()
        let iceP_node: NodePrx? = try istr.read(NodePrx.self)
        try await self.announceTopics(readers: iceP_readers, writers: iceP_writers, node: iceP_node, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_createSession(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_node: NodePrx? = try istr.read(NodePrx.self)
        let result = try await self.createSession(node: iceP_node, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }
}
