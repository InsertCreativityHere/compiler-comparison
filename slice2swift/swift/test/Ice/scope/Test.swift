//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice
import PromiseKit

public struct S: Swift.Hashable {
    public var v: Swift.Int32 = 0

    public init() {}

    public init(v: Swift.Int32) {
        self.v = v
    }
}

/// An `Ice.InputStream` extension to read `S` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `S` structured value from the stream.
    ///
    /// - returns: `S` - The structured value read from the stream.
    func read() throws -> S {
        var v = S()
        v.v = try self.read()
        return v
    }

    /// Read an optional `S?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `S?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> S? {
        guard try readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try skipSize()
        return try read() as S
    }
}

/// An `Ice.OutputStream` extension to write `S` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `S` structured value to the stream.
    ///
    /// - parameter _: `S` - The value to write to the stream.
    func write(_ v: S) {
        self.write(v.v)
    }

    /// Write an optional `S?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `S?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: S?) {
        if let v = value {
            if writeOptional(tag: tag, format: .VSize) {
                write(size: 4)
                write(v)
            }
        }
    }
}

public typealias SMap = [Swift.String: S]

/// Helper class to read and write `SMap` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct SMapHelper {
    /// Read a `SMap` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `SMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> SMap {
        let sz = try Swift.Int(istr.readSize())
        var v = SMap()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: S = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `SMap?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `SMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> SMap? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `SMap` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `SMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: SMap) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `SMap?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `SMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: SMap?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias SSeq = [S]

/// Helper class to read and write `SSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct SSeqHelper {
    /// Read a `SSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `SSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> SSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 4)
        var v = SSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: S = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `SSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `SSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> SSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Wite a `SSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `SSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: SSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `SSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `SSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: SSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 4) {
            write(to: ostr, value: val)
        }
    }
}

/// Traits for Slice class `C`.
public struct CTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::C"]
    public static let staticId = "::Test::C"
}

public typealias CMap = [Swift.String: C?]

/// Helper class to read and write `CMap` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct CMapHelper {
    /// Read a `CMap` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `CMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> CMap {
        let sz = try Swift.Int(istr.readSize())
        var v = CMap()
        let e = Ice.DictEntryArray<Swift.String, C?>(size: sz)
        for i in 0 ..< sz {
            let key: Swift.String = try istr.read()
            v[key] = nil as C?
            Swift.withUnsafeMutablePointer(to: &v[key, default:nil]) {
                e.values[i] = Ice.DictEntry<Swift.String, C?>(key: key, value: $0)
            }
            try istr.read(C.self) { e.values[i].value.pointee = $0 }
        }
        for i in 0..<sz {
            Swift.withUnsafeMutablePointer(to: &v[e.values[i].key, default:nil]) {
                e.values[i].value = $0
            }
        }
        return v
    }
    /// Read an optional `CMap?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `CMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> CMap? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `CMap` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `CMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: CMap) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `CMap?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `CMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: CMap?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias CSeq = [C?]

/// Helper class to read and write `CSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct CSeqHelper {
    /// Read a `CSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `CSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> CSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = CSeq(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(C.self) { p.pointee = $0 }
            }
        }
        return v
    }
    /// Read an optional `CSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `CSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> CSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `CSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `CSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: CSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `CSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `CSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: CSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public enum E1: Swift.UInt8 {
    /// v1
    case v1 = 0
    /// v2
    case v2 = 1
    /// v3
    case v3 = 2
    public init() {
        self = .v1
    }
}

/// An `Ice.InputStream` extension to read `E1` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - returns: `E1` - The enumarated value.
    func read() throws -> E1 {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 2)
        guard let val = E1(rawValue: rawValue) else {
            throw Ice.MarshalException(reason: "invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `E1` - The enumerated value.
    func read(tag: Swift.Int32) throws -> E1? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as E1
    }
}

/// An `Ice.OutputStream` extension to write `E1` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// parameter _: `E1` - The enumerator to write.
    func write(_ v: E1) {
        write(enum: v.rawValue, maxValue: 2)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// parameter _: `E1` - The enumerator to write.
    func write(tag: Swift.Int32, value: E1?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 2)
    }
}

public struct S1: Swift.Hashable {
    public var s: Swift.String = ""

    public init() {}

    public init(s: Swift.String) {
        self.s = s
    }
}

/// An `Ice.InputStream` extension to read `S1` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `S1` structured value from the stream.
    ///
    /// - returns: `S1` - The structured value read from the stream.
    func read() throws -> S1 {
        var v = S1()
        v.s = try self.read()
        return v
    }

    /// Read an optional `S1?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `S1?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> S1? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as S1
    }
}

/// An `Ice.OutputStream` extension to write `S1` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `S1` structured value to the stream.
    ///
    /// - parameter _: `S1` - The value to write to the stream.
    func write(_ v: S1) {
        self.write(v.s)
    }

    /// Write an optional `S1?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `S1?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: S1?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public typealias S1Seq = [S1]

/// Helper class to read and write `S1Seq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct S1SeqHelper {
    /// Read a `S1Seq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `S1Seq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> S1Seq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = S1Seq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: S1 = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `S1Seq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `S1Seq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> S1Seq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `S1Seq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `S1Seq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: S1Seq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `S1Seq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `S1Seq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: S1Seq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias S1Map = [Swift.String: S1]

/// Helper class to read and write `S1Map` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct S1MapHelper {
    /// Read a `S1Map` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `S1Map` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> S1Map {
        let sz = try Swift.Int(istr.readSize())
        var v = S1Map()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: S1 = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `S1Map?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `S1Map` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> S1Map? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `S1Map` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `S1Map` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: S1Map) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `S1Map?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `S1Map` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: S1Map?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice class `C1`.
public struct C1Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::C1"]
    public static let staticId = "::Test::C1"
}

public class S2 {
    public var E1: E1 = .v1
    typealias Test_S1 = S1
    public var S1: S1 = Test_S1()
    public var C1: C1? = nil
    typealias Test_S1Seq = S1Seq
    public var S1Seq: S1Seq = Test_S1Seq()
    typealias Test_S1Map = S1Map
    public var S1Map: S1Map = Test_S1Map()

    public init() {}

    public init(E1: E1, S1: S1, C1: C1?, S1Seq: S1Seq, S1Map: S1Map) {
        self.E1 = E1
        self.S1 = S1
        self.C1 = C1
        self.S1Seq = S1Seq
        self.S1Map = S1Map
    }
}

/// An `Ice.InputStream` extension to read `S2` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `S2` structured value from the stream.
    ///
    /// - returns: `S2` - The structured value read from the stream.
    func read() throws -> S2 {
        let v = S2()
        v.E1 = try self.read()
        v.S1 = try self.read()
        try self.read(C1.self) { v.C1 = $0 }
        v.S1Seq = try S1SeqHelper.read(from: self)
        v.S1Map = try S1MapHelper.read(from: self)
        return v
    }

    /// Read an optional `S2?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `S2?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> S2? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as S2
    }
}

/// An `Ice.OutputStream` extension to write `S2` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `S2` structured value to the stream.
    ///
    /// - parameter _: `S2` - The value to write to the stream.
    func write(_ v: S2) {
        self.write(v.E1)
        self.write(v.S1)
        self.write(v.C1)
        S1SeqHelper.write(to: self, value: v.S1Seq)
        S1MapHelper.write(to: self, value: v.S1Map)
    }

    /// Write an optional `S2?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `S2?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: S2?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// Traits for Slice class `C2`.
public struct C2Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::C2"]
    public static let staticId = "::Test::C2"
}

/// Traits for Slice interface `I`.
public struct ITraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::I"]
    public static let staticId = "::Test::I"
}

public typealias IMap = [Swift.String: IPrx?]

/// Helper class to read and write `IMap` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct IMapHelper {
    /// Read a `IMap` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `IMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> IMap {
        let sz = try Swift.Int(istr.readSize())
        var v = IMap()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: IPrx? = try istr.read(IPrx.self)
            v[key] = value
        }
        return v
    }
    /// Read an optional `IMap?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `IMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> IMap? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `IMap` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `IMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: IMap) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `IMap?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `IMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: IMap?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ISeq = [IPrx?]

/// Helper class to read and write `ISeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ISeqHelper {
    /// Read a `ISeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ISeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ISeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = ISeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: IPrx? = try istr.read(IPrx.self)
            v.append(j)
        }
        return v
    }
    /// Read an optional `ISeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ISeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ISeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ISeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ISeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ISeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `ISeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ISeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ISeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public struct InnerS: Swift.Hashable {
    public var v: Swift.Int32 = 0

    public init() {}

    public init(v: Swift.Int32) {
        self.v = v
    }
}

/// An `Ice.InputStream` extension to read `InnerS` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `InnerS` structured value from the stream.
    ///
    /// - returns: `InnerS` - The structured value read from the stream.
    func read() throws -> InnerS {
        var v = InnerS()
        v.v = try self.read()
        return v
    }

    /// Read an optional `InnerS?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `InnerS?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> InnerS? {
        guard try readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try skipSize()
        return try read() as InnerS
    }
}

/// An `Ice.OutputStream` extension to write `InnerS` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `InnerS` structured value to the stream.
    ///
    /// - parameter _: `InnerS` - The value to write to the stream.
    func write(_ v: InnerS) {
        self.write(v.v)
    }

    /// Write an optional `InnerS?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `InnerS?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: InnerS?) {
        if let v = value {
            if writeOptional(tag: tag, format: .VSize) {
                write(size: 4)
                write(v)
            }
        }
    }
}

public struct InnerInner2S: Swift.Hashable {
    public var v: Swift.Int32 = 0

    public init() {}

    public init(v: Swift.Int32) {
        self.v = v
    }
}

/// An `Ice.InputStream` extension to read `InnerInner2S` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `InnerInner2S` structured value from the stream.
    ///
    /// - returns: `InnerInner2S` - The structured value read from the stream.
    func read() throws -> InnerInner2S {
        var v = InnerInner2S()
        v.v = try self.read()
        return v
    }

    /// Read an optional `InnerInner2S?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `InnerInner2S?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> InnerInner2S? {
        guard try readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try skipSize()
        return try read() as InnerInner2S
    }
}

/// An `Ice.OutputStream` extension to write `InnerInner2S` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `InnerInner2S` structured value to the stream.
    ///
    /// - parameter _: `InnerInner2S` - The value to write to the stream.
    func write(_ v: InnerInner2S) {
        self.write(v.v)
    }

    /// Write an optional `InnerInner2S?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `InnerInner2S?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: InnerInner2S?) {
        if let v = value {
            if writeOptional(tag: tag, format: .VSize) {
                write(size: 4)
                write(v)
            }
        }
    }
}

public typealias InnerInner2SMap = [Swift.String: InnerInner2S]

/// Helper class to read and write `InnerInner2SMap` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InnerInner2SMapHelper {
    /// Read a `InnerInner2SMap` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `InnerInner2SMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InnerInner2SMap {
        let sz = try Swift.Int(istr.readSize())
        var v = InnerInner2SMap()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: InnerInner2S = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `InnerInner2SMap?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `InnerInner2SMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InnerInner2SMap? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `InnerInner2SMap` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `InnerInner2SMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InnerInner2SMap) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `InnerInner2SMap?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `InnerInner2SMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: InnerInner2SMap?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias InnerInner2SSeq = [InnerInner2S]

/// Helper class to read and write `InnerInner2SSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InnerInner2SSeqHelper {
    /// Read a `InnerInner2SSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `InnerInner2SSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InnerInner2SSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 4)
        var v = InnerInner2SSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: InnerInner2S = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `InnerInner2SSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `InnerInner2SSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InnerInner2SSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Wite a `InnerInner2SSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `InnerInner2SSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InnerInner2SSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `InnerInner2SSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `InnerInner2SSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: InnerInner2SSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 4) {
            write(to: ostr, value: val)
        }
    }
}

/// Traits for Slice class `InnerInner2C`.
public struct InnerInner2CTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Inner::Inner2::C"]
    public static let staticId = "::Test::Inner::Inner2::C"
}

public typealias InnerInner2CMap = [Swift.String: InnerInner2C?]

/// Helper class to read and write `InnerInner2CMap` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InnerInner2CMapHelper {
    /// Read a `InnerInner2CMap` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `InnerInner2CMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InnerInner2CMap {
        let sz = try Swift.Int(istr.readSize())
        var v = InnerInner2CMap()
        let e = Ice.DictEntryArray<Swift.String, InnerInner2C?>(size: sz)
        for i in 0 ..< sz {
            let key: Swift.String = try istr.read()
            v[key] = nil as InnerInner2C?
            Swift.withUnsafeMutablePointer(to: &v[key, default:nil]) {
                e.values[i] = Ice.DictEntry<Swift.String, InnerInner2C?>(key: key, value: $0)
            }
            try istr.read(InnerInner2C.self) { e.values[i].value.pointee = $0 }
        }
        for i in 0..<sz {
            Swift.withUnsafeMutablePointer(to: &v[e.values[i].key, default:nil]) {
                e.values[i].value = $0
            }
        }
        return v
    }
    /// Read an optional `InnerInner2CMap?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `InnerInner2CMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InnerInner2CMap? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `InnerInner2CMap` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `InnerInner2CMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InnerInner2CMap) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `InnerInner2CMap?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `InnerInner2CMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: InnerInner2CMap?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias InnerInner2CSeq = [InnerInner2C?]

/// Helper class to read and write `InnerInner2CSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InnerInner2CSeqHelper {
    /// Read a `InnerInner2CSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `InnerInner2CSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InnerInner2CSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = InnerInner2CSeq(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(InnerInner2C.self) { p.pointee = $0 }
            }
        }
        return v
    }
    /// Read an optional `InnerInner2CSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `InnerInner2CSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InnerInner2CSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `InnerInner2CSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `InnerInner2CSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InnerInner2CSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `InnerInner2CSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `InnerInner2CSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: InnerInner2CSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice interface `InnerInner2I`.
public struct InnerInner2ITraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Inner::Inner2::I"]
    public static let staticId = "::Test::Inner::Inner2::I"
}

public typealias InnerInner2IMap = [Swift.String: InnerInner2IPrx?]

/// Helper class to read and write `InnerInner2IMap` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InnerInner2IMapHelper {
    /// Read a `InnerInner2IMap` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `InnerInner2IMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InnerInner2IMap {
        let sz = try Swift.Int(istr.readSize())
        var v = InnerInner2IMap()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: InnerInner2IPrx? = try istr.read(InnerInner2IPrx.self)
            v[key] = value
        }
        return v
    }
    /// Read an optional `InnerInner2IMap?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `InnerInner2IMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InnerInner2IMap? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `InnerInner2IMap` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `InnerInner2IMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InnerInner2IMap) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `InnerInner2IMap?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `InnerInner2IMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: InnerInner2IMap?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias InnerInner2ISeq = [InnerInner2IPrx?]

/// Helper class to read and write `InnerInner2ISeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InnerInner2ISeqHelper {
    /// Read a `InnerInner2ISeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `InnerInner2ISeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InnerInner2ISeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = InnerInner2ISeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: InnerInner2IPrx? = try istr.read(InnerInner2IPrx.self)
            v.append(j)
        }
        return v
    }
    /// Read an optional `InnerInner2ISeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `InnerInner2ISeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InnerInner2ISeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `InnerInner2ISeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `InnerInner2ISeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InnerInner2ISeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `InnerInner2ISeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `InnerInner2ISeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: InnerInner2ISeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice class `InnerC`.
public struct InnerCTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Inner::C"]
    public static let staticId = "::Test::Inner::C"
}

public typealias InnerSSeq = [InnerInner2S]

/// Helper class to read and write `InnerSSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InnerSSeqHelper {
    /// Read a `InnerSSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `InnerSSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InnerSSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 4)
        var v = InnerSSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: InnerInner2S = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `InnerSSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `InnerSSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InnerSSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Wite a `InnerSSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `InnerSSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InnerSSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `InnerSSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `InnerSSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: InnerSSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 4) {
            write(to: ostr, value: val)
        }
    }
}

public typealias InnerSMap = [Swift.String: InnerInner2S]

/// Helper class to read and write `InnerSMap` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InnerSMapHelper {
    /// Read a `InnerSMap` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `InnerSMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InnerSMap {
        let sz = try Swift.Int(istr.readSize())
        var v = InnerSMap()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: InnerInner2S = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `InnerSMap?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `InnerSMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InnerSMap? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `InnerSMap` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `InnerSMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InnerSMap) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `InnerSMap?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `InnerSMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: InnerSMap?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias InnerCMap = [Swift.String: InnerInner2C?]

/// Helper class to read and write `InnerCMap` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InnerCMapHelper {
    /// Read a `InnerCMap` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `InnerCMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InnerCMap {
        let sz = try Swift.Int(istr.readSize())
        var v = InnerCMap()
        let e = Ice.DictEntryArray<Swift.String, InnerInner2C?>(size: sz)
        for i in 0 ..< sz {
            let key: Swift.String = try istr.read()
            v[key] = nil as InnerInner2C?
            Swift.withUnsafeMutablePointer(to: &v[key, default:nil]) {
                e.values[i] = Ice.DictEntry<Swift.String, InnerInner2C?>(key: key, value: $0)
            }
            try istr.read(InnerInner2C.self) { e.values[i].value.pointee = $0 }
        }
        for i in 0..<sz {
            Swift.withUnsafeMutablePointer(to: &v[e.values[i].key, default:nil]) {
                e.values[i].value = $0
            }
        }
        return v
    }
    /// Read an optional `InnerCMap?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `InnerCMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InnerCMap? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `InnerCMap` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `InnerCMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InnerCMap) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `InnerCMap?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `InnerCMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: InnerCMap?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias InnerCSeq = [InnerInner2C?]

/// Helper class to read and write `InnerCSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InnerCSeqHelper {
    /// Read a `InnerCSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `InnerCSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InnerCSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = InnerCSeq(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(InnerInner2C.self) { p.pointee = $0 }
            }
        }
        return v
    }
    /// Read an optional `InnerCSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `InnerCSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InnerCSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `InnerCSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `InnerCSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InnerCSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `InnerCSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `InnerCSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: InnerCSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice interface `InnerI`.
public struct InnerITraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Inner::I"]
    public static let staticId = "::Test::Inner::I"
}

public typealias InnerIMap = [Swift.String: InnerIPrx?]

/// Helper class to read and write `InnerIMap` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InnerIMapHelper {
    /// Read a `InnerIMap` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `InnerIMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InnerIMap {
        let sz = try Swift.Int(istr.readSize())
        var v = InnerIMap()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: InnerIPrx? = try istr.read(InnerIPrx.self)
            v[key] = value
        }
        return v
    }
    /// Read an optional `InnerIMap?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `InnerIMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InnerIMap? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `InnerIMap` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `InnerIMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InnerIMap) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `InnerIMap?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `InnerIMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: InnerIMap?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias InnerISeq = [InnerIPrx?]

/// Helper class to read and write `InnerISeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InnerISeqHelper {
    /// Read a `InnerISeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `InnerISeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InnerISeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = InnerISeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: InnerIPrx? = try istr.read(InnerIPrx.self)
            v.append(j)
        }
        return v
    }
    /// Read an optional `InnerISeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `InnerISeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InnerISeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `InnerISeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `InnerISeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InnerISeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `InnerISeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `InnerISeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: InnerISeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice interface `InnerTestInner2I`.
public struct InnerTestInner2ITraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Inner::Test::Inner2::I"]
    public static let staticId = "::Inner::Test::Inner2::I"
}

/// IPrx overview.
///
/// IPrx Methods:
///
///  - opS: 
///
///  - opSAsync: 
///
///  - opSSeq: 
///
///  - opSSeqAsync: 
///
///  - opSMap: 
///
///  - opSMapAsync: 
///
///  - opC: 
///
///  - opCAsync: 
///
///  - opCSeq: 
///
///  - opCSeqAsync: 
///
///  - opCMap: 
///
///  - opCMapAsync: 
///
///  - opE1: 
///
///  - opE1Async: 
///
///  - opS1: 
///
///  - opS1Async: 
///
///  - opC1: 
///
///  - opC1Async: 
///
///  - opS1Seq: 
///
///  - opS1SeqAsync: 
///
///  - opS1Map: 
///
///  - opS1MapAsync: 
///
///  - shutdown: 
///
///  - shutdownAsync: 
public protocol IPrx: Ice.ObjectPrx {}

private final class IPrxI: Ice.ObjectPrxI, IPrx {
    public override class func ice_staticId() -> Swift.String {
        return ITraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `IPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `IPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: IPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> IPrx? {
    return try IPrxI.checkedCast(prx: prx, facet: facet, context: context) as IPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `IPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `IPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: IPrx.Protocol, facet: Swift.String? = nil) -> IPrx {
    return IPrxI.uncheckedCast(prx: prx, facet: facet) as IPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `IPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: IPrx.Protocol) -> Swift.String {
    return ITraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `IPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `IPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `IPrx?` - The extracted proxy
    func read(_ type: IPrx.Protocol) throws -> IPrx? {
        return try read() as IPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `IPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `IPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: IPrx.Protocol) throws -> IPrx? {
        return try read(tag: tag) as IPrxI?
    }
}

/// IPrx overview.
///
/// IPrx Methods:
///
///  - opS: 
///
///  - opSAsync: 
///
///  - opSSeq: 
///
///  - opSSeqAsync: 
///
///  - opSMap: 
///
///  - opSMapAsync: 
///
///  - opC: 
///
///  - opCAsync: 
///
///  - opCSeq: 
///
///  - opCSeqAsync: 
///
///  - opCMap: 
///
///  - opCMapAsync: 
///
///  - opE1: 
///
///  - opE1Async: 
///
///  - opS1: 
///
///  - opS1Async: 
///
///  - opC1: 
///
///  - opC1Async: 
///
///  - opS1Seq: 
///
///  - opS1SeqAsync: 
///
///  - opS1Map: 
///
///  - opS1MapAsync: 
///
///  - shutdown: 
///
///  - shutdownAsync: 
public extension IPrx {
    ///
    /// - parameter _: `S`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: S, s2: S)`:
    ///
    ///   - returnValue: `S`
    ///
    ///   - s2: `S`
    func opS(_ iceP_s1: S, context: Ice.Context? = nil) throws -> (returnValue: S, s2: S) {
        return try _impl._invoke(operation: "opS",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_s1)
                                 },
                                 read: { istr in
                                     let iceP_s2: S = try istr.read()
                                     let iceP_returnValue: S = try istr.read()
                                     return (iceP_returnValue, iceP_s2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `S`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: S, s2: S)>` - The result of the operation
    func opSAsync(_ iceP_s1: S, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: S, s2: S)> {
        return _impl._invokeAsync(operation: "opS",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_s1)
                                  },
                                  read: { istr in
                                      let iceP_s2: S = try istr.read()
                                      let iceP_returnValue: S = try istr.read()
                                      return (iceP_returnValue, iceP_s2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `SSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: SSeq, s2: SSeq)`:
    ///
    ///   - returnValue: `SSeq`
    ///
    ///   - s2: `SSeq`
    func opSSeq(_ iceP_s1: SSeq, context: Ice.Context? = nil) throws -> (returnValue: SSeq, s2: SSeq) {
        return try _impl._invoke(operation: "opSSeq",
                                 mode: .Normal,
                                 write: { ostr in
                                     SSeqHelper.write(to: ostr, value: iceP_s1)
                                 },
                                 read: { istr in
                                     let iceP_s2: SSeq = try SSeqHelper.read(from: istr)
                                     let iceP_returnValue: SSeq = try SSeqHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_s2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `SSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: SSeq, s2: SSeq)>` - The result of the operation
    func opSSeqAsync(_ iceP_s1: SSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: SSeq, s2: SSeq)> {
        return _impl._invokeAsync(operation: "opSSeq",
                                  mode: .Normal,
                                  write: { ostr in
                                      SSeqHelper.write(to: ostr, value: iceP_s1)
                                  },
                                  read: { istr in
                                      let iceP_s2: SSeq = try SSeqHelper.read(from: istr)
                                      let iceP_returnValue: SSeq = try SSeqHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_s2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `SMap`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: SMap, s2: SMap)`:
    ///
    ///   - returnValue: `SMap`
    ///
    ///   - s2: `SMap`
    func opSMap(_ iceP_s1: SMap, context: Ice.Context? = nil) throws -> (returnValue: SMap, s2: SMap) {
        return try _impl._invoke(operation: "opSMap",
                                 mode: .Normal,
                                 write: { ostr in
                                     SMapHelper.write(to: ostr, value: iceP_s1)
                                 },
                                 read: { istr in
                                     let iceP_s2: SMap = try SMapHelper.read(from: istr)
                                     let iceP_returnValue: SMap = try SMapHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_s2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `SMap`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: SMap, s2: SMap)>` - The result of the operation
    func opSMapAsync(_ iceP_s1: SMap, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: SMap, s2: SMap)> {
        return _impl._invokeAsync(operation: "opSMap",
                                  mode: .Normal,
                                  write: { ostr in
                                      SMapHelper.write(to: ostr, value: iceP_s1)
                                  },
                                  read: { istr in
                                      let iceP_s2: SMap = try SMapHelper.read(from: istr)
                                      let iceP_returnValue: SMap = try SMapHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_s2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `C?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: C?, c2: C?)`:
    ///
    ///   - returnValue: `C?`
    ///
    ///   - c2: `C?`
    func opC(_ iceP_c1: C?, context: Ice.Context? = nil) throws -> (returnValue: C?, c2: C?) {
        return try _impl._invoke(operation: "opC",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_c1)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     var iceP_c2: C?
                                     try istr.read(C.self) { iceP_c2 = $0 }
                                     var iceP_returnValue: C?
                                     try istr.read(C.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return (iceP_returnValue, iceP_c2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `C?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: C?, c2: C?)>` - The result of the operation
    func opCAsync(_ iceP_c1: C?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: C?, c2: C?)> {
        return _impl._invokeAsync(operation: "opC",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_c1)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      var iceP_c2: C?
                                      try istr.read(C.self) { iceP_c2 = $0 }
                                      var iceP_returnValue: C?
                                      try istr.read(C.self) { iceP_returnValue = $0 }
                                      try istr.readPendingValues()
                                      return (iceP_returnValue, iceP_c2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `CSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: CSeq, s2: CSeq)`:
    ///
    ///   - returnValue: `CSeq`
    ///
    ///   - s2: `CSeq`
    func opCSeq(_ iceP_s1: CSeq, context: Ice.Context? = nil) throws -> (returnValue: CSeq, s2: CSeq) {
        return try _impl._invoke(operation: "opCSeq",
                                 mode: .Normal,
                                 write: { ostr in
                                     CSeqHelper.write(to: ostr, value: iceP_s1)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     let iceP_s2: CSeq = try CSeqHelper.read(from: istr)
                                     let iceP_returnValue: CSeq = try CSeqHelper.read(from: istr)
                                     try istr.readPendingValues()
                                     return (iceP_returnValue, iceP_s2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `CSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: CSeq, s2: CSeq)>` - The result of the operation
    func opCSeqAsync(_ iceP_s1: CSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: CSeq, s2: CSeq)> {
        return _impl._invokeAsync(operation: "opCSeq",
                                  mode: .Normal,
                                  write: { ostr in
                                      CSeqHelper.write(to: ostr, value: iceP_s1)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      let iceP_s2: CSeq = try CSeqHelper.read(from: istr)
                                      let iceP_returnValue: CSeq = try CSeqHelper.read(from: istr)
                                      try istr.readPendingValues()
                                      return (iceP_returnValue, iceP_s2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `CMap`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: CMap, c2: CMap)`:
    ///
    ///   - returnValue: `CMap`
    ///
    ///   - c2: `CMap`
    func opCMap(_ iceP_c1: CMap, context: Ice.Context? = nil) throws -> (returnValue: CMap, c2: CMap) {
        return try _impl._invoke(operation: "opCMap",
                                 mode: .Normal,
                                 write: { ostr in
                                     CMapHelper.write(to: ostr, value: iceP_c1)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     let iceP_c2: CMap = try CMapHelper.read(from: istr)
                                     let iceP_returnValue: CMap = try CMapHelper.read(from: istr)
                                     try istr.readPendingValues()
                                     return (iceP_returnValue, iceP_c2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `CMap`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: CMap, c2: CMap)>` - The result of the operation
    func opCMapAsync(_ iceP_c1: CMap, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: CMap, c2: CMap)> {
        return _impl._invokeAsync(operation: "opCMap",
                                  mode: .Normal,
                                  write: { ostr in
                                      CMapHelper.write(to: ostr, value: iceP_c1)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      let iceP_c2: CMap = try CMapHelper.read(from: istr)
                                      let iceP_returnValue: CMap = try CMapHelper.read(from: istr)
                                      try istr.readPendingValues()
                                      return (iceP_returnValue, iceP_c2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `E1`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `E1`
    func opE1(_ iceP_E1: E1, context: Ice.Context? = nil) throws -> E1 {
        return try _impl._invoke(operation: "opE1",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_E1)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: E1 = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `E1`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<E1>` - The result of the operation
    func opE1Async(_ iceP_E1: E1, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<E1> {
        return _impl._invokeAsync(operation: "opE1",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_E1)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: E1 = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `S1`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `S1`
    func opS1(_ iceP_S1: S1, context: Ice.Context? = nil) throws -> S1 {
        return try _impl._invoke(operation: "opS1",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_S1)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: S1 = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `S1`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<S1>` - The result of the operation
    func opS1Async(_ iceP_S1: S1, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<S1> {
        return _impl._invokeAsync(operation: "opS1",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_S1)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: S1 = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `C1?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `C1?`
    func opC1(_ iceP_C1: C1?, context: Ice.Context? = nil) throws -> C1? {
        return try _impl._invoke(operation: "opC1",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_C1)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     var iceP_returnValue: C1?
                                     try istr.read(C1.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `C1?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<C1?>` - The result of the operation
    func opC1Async(_ iceP_C1: C1?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<C1?> {
        return _impl._invokeAsync(operation: "opC1",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_C1)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      var iceP_returnValue: C1?
                                      try istr.read(C1.self) { iceP_returnValue = $0 }
                                      try istr.readPendingValues()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `S1Seq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `S1Seq`
    func opS1Seq(_ iceP_S1Seq: S1Seq, context: Ice.Context? = nil) throws -> S1Seq {
        return try _impl._invoke(operation: "opS1Seq",
                                 mode: .Normal,
                                 write: { ostr in
                                     S1SeqHelper.write(to: ostr, value: iceP_S1Seq)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: S1Seq = try S1SeqHelper.read(from: istr)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `S1Seq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<S1Seq>` - The result of the operation
    func opS1SeqAsync(_ iceP_S1Seq: S1Seq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<S1Seq> {
        return _impl._invokeAsync(operation: "opS1Seq",
                                  mode: .Normal,
                                  write: { ostr in
                                      S1SeqHelper.write(to: ostr, value: iceP_S1Seq)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: S1Seq = try S1SeqHelper.read(from: istr)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `S1Map`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `S1Map`
    func opS1Map(_ iceP_S1Map: S1Map, context: Ice.Context? = nil) throws -> S1Map {
        return try _impl._invoke(operation: "opS1Map",
                                 mode: .Normal,
                                 write: { ostr in
                                     S1MapHelper.write(to: ostr, value: iceP_S1Map)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: S1Map = try S1MapHelper.read(from: istr)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `S1Map`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<S1Map>` - The result of the operation
    func opS1MapAsync(_ iceP_S1Map: S1Map, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<S1Map> {
        return _impl._invokeAsync(operation: "opS1Map",
                                  mode: .Normal,
                                  write: { ostr in
                                      S1MapHelper.write(to: ostr, value: iceP_S1Map)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: S1Map = try S1MapHelper.read(from: istr)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func shutdown(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "shutdown",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func shutdownAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "shutdown",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// InnerInner2IPrx overview.
///
/// InnerInner2IPrx Methods:
///
///  - opS: 
///
///  - opSAsync: 
///
///  - opSSeq: 
///
///  - opSSeqAsync: 
///
///  - opSMap: 
///
///  - opSMapAsync: 
///
///  - opC: 
///
///  - opCAsync: 
///
///  - opCSeq: 
///
///  - opCSeqAsync: 
///
///  - opCMap: 
///
///  - opCMapAsync: 
///
///  - shutdown: 
///
///  - shutdownAsync: 
public protocol InnerInner2IPrx: Ice.ObjectPrx {}

private final class InnerInner2IPrxI: Ice.ObjectPrxI, InnerInner2IPrx {
    public override class func ice_staticId() -> Swift.String {
        return InnerInner2ITraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `InnerInner2IPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `InnerInner2IPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: InnerInner2IPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> InnerInner2IPrx? {
    return try InnerInner2IPrxI.checkedCast(prx: prx, facet: facet, context: context) as InnerInner2IPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `InnerInner2IPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `InnerInner2IPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: InnerInner2IPrx.Protocol, facet: Swift.String? = nil) -> InnerInner2IPrx {
    return InnerInner2IPrxI.uncheckedCast(prx: prx, facet: facet) as InnerInner2IPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `InnerInner2IPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: InnerInner2IPrx.Protocol) -> Swift.String {
    return InnerInner2ITraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `InnerInner2IPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `InnerInner2IPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `InnerInner2IPrx?` - The extracted proxy
    func read(_ type: InnerInner2IPrx.Protocol) throws -> InnerInner2IPrx? {
        return try read() as InnerInner2IPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `InnerInner2IPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `InnerInner2IPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: InnerInner2IPrx.Protocol) throws -> InnerInner2IPrx? {
        return try read(tag: tag) as InnerInner2IPrxI?
    }
}

/// InnerInner2IPrx overview.
///
/// InnerInner2IPrx Methods:
///
///  - opS: 
///
///  - opSAsync: 
///
///  - opSSeq: 
///
///  - opSSeqAsync: 
///
///  - opSMap: 
///
///  - opSMapAsync: 
///
///  - opC: 
///
///  - opCAsync: 
///
///  - opCSeq: 
///
///  - opCSeqAsync: 
///
///  - opCMap: 
///
///  - opCMapAsync: 
///
///  - shutdown: 
///
///  - shutdownAsync: 
public extension InnerInner2IPrx {
    ///
    /// - parameter _: `InnerInner2S`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: InnerInner2S, s2: InnerInner2S)`:
    ///
    ///   - returnValue: `InnerInner2S`
    ///
    ///   - s2: `InnerInner2S`
    func opS(_ iceP_s1: InnerInner2S, context: Ice.Context? = nil) throws -> (returnValue: InnerInner2S, s2: InnerInner2S) {
        return try _impl._invoke(operation: "opS",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_s1)
                                 },
                                 read: { istr in
                                     let iceP_s2: InnerInner2S = try istr.read()
                                     let iceP_returnValue: InnerInner2S = try istr.read()
                                     return (iceP_returnValue, iceP_s2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `InnerInner2S`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: InnerInner2S, s2: InnerInner2S)>` - The result of the operation
    func opSAsync(_ iceP_s1: InnerInner2S, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: InnerInner2S, s2: InnerInner2S)> {
        return _impl._invokeAsync(operation: "opS",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_s1)
                                  },
                                  read: { istr in
                                      let iceP_s2: InnerInner2S = try istr.read()
                                      let iceP_returnValue: InnerInner2S = try istr.read()
                                      return (iceP_returnValue, iceP_s2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `InnerInner2SSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: InnerInner2SSeq, s2: InnerInner2SSeq)`:
    ///
    ///   - returnValue: `InnerInner2SSeq`
    ///
    ///   - s2: `InnerInner2SSeq`
    func opSSeq(_ iceP_s1: InnerInner2SSeq, context: Ice.Context? = nil) throws -> (returnValue: InnerInner2SSeq, s2: InnerInner2SSeq) {
        return try _impl._invoke(operation: "opSSeq",
                                 mode: .Normal,
                                 write: { ostr in
                                     InnerInner2SSeqHelper.write(to: ostr, value: iceP_s1)
                                 },
                                 read: { istr in
                                     let iceP_s2: InnerInner2SSeq = try InnerInner2SSeqHelper.read(from: istr)
                                     let iceP_returnValue: InnerInner2SSeq = try InnerInner2SSeqHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_s2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `InnerInner2SSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: InnerInner2SSeq, s2: InnerInner2SSeq)>` - The result of the operation
    func opSSeqAsync(_ iceP_s1: InnerInner2SSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: InnerInner2SSeq, s2: InnerInner2SSeq)> {
        return _impl._invokeAsync(operation: "opSSeq",
                                  mode: .Normal,
                                  write: { ostr in
                                      InnerInner2SSeqHelper.write(to: ostr, value: iceP_s1)
                                  },
                                  read: { istr in
                                      let iceP_s2: InnerInner2SSeq = try InnerInner2SSeqHelper.read(from: istr)
                                      let iceP_returnValue: InnerInner2SSeq = try InnerInner2SSeqHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_s2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `InnerInner2SMap`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: InnerInner2SMap, s2: InnerInner2SMap)`:
    ///
    ///   - returnValue: `InnerInner2SMap`
    ///
    ///   - s2: `InnerInner2SMap`
    func opSMap(_ iceP_s1: InnerInner2SMap, context: Ice.Context? = nil) throws -> (returnValue: InnerInner2SMap, s2: InnerInner2SMap) {
        return try _impl._invoke(operation: "opSMap",
                                 mode: .Normal,
                                 write: { ostr in
                                     InnerInner2SMapHelper.write(to: ostr, value: iceP_s1)
                                 },
                                 read: { istr in
                                     let iceP_s2: InnerInner2SMap = try InnerInner2SMapHelper.read(from: istr)
                                     let iceP_returnValue: InnerInner2SMap = try InnerInner2SMapHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_s2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `InnerInner2SMap`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: InnerInner2SMap, s2: InnerInner2SMap)>` - The result of the operation
    func opSMapAsync(_ iceP_s1: InnerInner2SMap, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: InnerInner2SMap, s2: InnerInner2SMap)> {
        return _impl._invokeAsync(operation: "opSMap",
                                  mode: .Normal,
                                  write: { ostr in
                                      InnerInner2SMapHelper.write(to: ostr, value: iceP_s1)
                                  },
                                  read: { istr in
                                      let iceP_s2: InnerInner2SMap = try InnerInner2SMapHelper.read(from: istr)
                                      let iceP_returnValue: InnerInner2SMap = try InnerInner2SMapHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_s2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `InnerInner2C?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: InnerInner2C?, c2: InnerInner2C?)`:
    ///
    ///   - returnValue: `InnerInner2C?`
    ///
    ///   - c2: `InnerInner2C?`
    func opC(_ iceP_c1: InnerInner2C?, context: Ice.Context? = nil) throws -> (returnValue: InnerInner2C?, c2: InnerInner2C?) {
        return try _impl._invoke(operation: "opC",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_c1)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     var iceP_c2: InnerInner2C?
                                     try istr.read(InnerInner2C.self) { iceP_c2 = $0 }
                                     var iceP_returnValue: InnerInner2C?
                                     try istr.read(InnerInner2C.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return (iceP_returnValue, iceP_c2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `InnerInner2C?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: InnerInner2C?, c2: InnerInner2C?)>` - The result of the operation
    func opCAsync(_ iceP_c1: InnerInner2C?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: InnerInner2C?, c2: InnerInner2C?)> {
        return _impl._invokeAsync(operation: "opC",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_c1)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      var iceP_c2: InnerInner2C?
                                      try istr.read(InnerInner2C.self) { iceP_c2 = $0 }
                                      var iceP_returnValue: InnerInner2C?
                                      try istr.read(InnerInner2C.self) { iceP_returnValue = $0 }
                                      try istr.readPendingValues()
                                      return (iceP_returnValue, iceP_c2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `InnerInner2CSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: InnerInner2CSeq, c2: InnerInner2CSeq)`:
    ///
    ///   - returnValue: `InnerInner2CSeq`
    ///
    ///   - c2: `InnerInner2CSeq`
    func opCSeq(_ iceP_c1: InnerInner2CSeq, context: Ice.Context? = nil) throws -> (returnValue: InnerInner2CSeq, c2: InnerInner2CSeq) {
        return try _impl._invoke(operation: "opCSeq",
                                 mode: .Normal,
                                 write: { ostr in
                                     InnerInner2CSeqHelper.write(to: ostr, value: iceP_c1)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     let iceP_c2: InnerInner2CSeq = try InnerInner2CSeqHelper.read(from: istr)
                                     let iceP_returnValue: InnerInner2CSeq = try InnerInner2CSeqHelper.read(from: istr)
                                     try istr.readPendingValues()
                                     return (iceP_returnValue, iceP_c2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `InnerInner2CSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: InnerInner2CSeq, c2: InnerInner2CSeq)>` - The result of the operation
    func opCSeqAsync(_ iceP_c1: InnerInner2CSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: InnerInner2CSeq, c2: InnerInner2CSeq)> {
        return _impl._invokeAsync(operation: "opCSeq",
                                  mode: .Normal,
                                  write: { ostr in
                                      InnerInner2CSeqHelper.write(to: ostr, value: iceP_c1)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      let iceP_c2: InnerInner2CSeq = try InnerInner2CSeqHelper.read(from: istr)
                                      let iceP_returnValue: InnerInner2CSeq = try InnerInner2CSeqHelper.read(from: istr)
                                      try istr.readPendingValues()
                                      return (iceP_returnValue, iceP_c2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `InnerInner2CMap`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: InnerInner2CMap, c2: InnerInner2CMap)`:
    ///
    ///   - returnValue: `InnerInner2CMap`
    ///
    ///   - c2: `InnerInner2CMap`
    func opCMap(_ iceP_c1: InnerInner2CMap, context: Ice.Context? = nil) throws -> (returnValue: InnerInner2CMap, c2: InnerInner2CMap) {
        return try _impl._invoke(operation: "opCMap",
                                 mode: .Normal,
                                 write: { ostr in
                                     InnerInner2CMapHelper.write(to: ostr, value: iceP_c1)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     let iceP_c2: InnerInner2CMap = try InnerInner2CMapHelper.read(from: istr)
                                     let iceP_returnValue: InnerInner2CMap = try InnerInner2CMapHelper.read(from: istr)
                                     try istr.readPendingValues()
                                     return (iceP_returnValue, iceP_c2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `InnerInner2CMap`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: InnerInner2CMap, c2: InnerInner2CMap)>` - The result of the operation
    func opCMapAsync(_ iceP_c1: InnerInner2CMap, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: InnerInner2CMap, c2: InnerInner2CMap)> {
        return _impl._invokeAsync(operation: "opCMap",
                                  mode: .Normal,
                                  write: { ostr in
                                      InnerInner2CMapHelper.write(to: ostr, value: iceP_c1)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      let iceP_c2: InnerInner2CMap = try InnerInner2CMapHelper.read(from: istr)
                                      let iceP_returnValue: InnerInner2CMap = try InnerInner2CMapHelper.read(from: istr)
                                      try istr.readPendingValues()
                                      return (iceP_returnValue, iceP_c2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func shutdown(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "shutdown",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func shutdownAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "shutdown",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// InnerIPrx overview.
///
/// InnerIPrx Methods:
///
///  - opS: 
///
///  - opSAsync: 
///
///  - opSSeq: 
///
///  - opSSeqAsync: 
///
///  - opSMap: 
///
///  - opSMapAsync: 
///
///  - opC: 
///
///  - opCAsync: 
///
///  - opCSeq: 
///
///  - opCSeqAsync: 
///
///  - opCMap: 
///
///  - opCMapAsync: 
///
///  - shutdown: 
///
///  - shutdownAsync: 
public protocol InnerIPrx: Ice.ObjectPrx {}

private final class InnerIPrxI: Ice.ObjectPrxI, InnerIPrx {
    public override class func ice_staticId() -> Swift.String {
        return InnerITraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `InnerIPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `InnerIPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: InnerIPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> InnerIPrx? {
    return try InnerIPrxI.checkedCast(prx: prx, facet: facet, context: context) as InnerIPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `InnerIPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `InnerIPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: InnerIPrx.Protocol, facet: Swift.String? = nil) -> InnerIPrx {
    return InnerIPrxI.uncheckedCast(prx: prx, facet: facet) as InnerIPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `InnerIPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: InnerIPrx.Protocol) -> Swift.String {
    return InnerITraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `InnerIPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `InnerIPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `InnerIPrx?` - The extracted proxy
    func read(_ type: InnerIPrx.Protocol) throws -> InnerIPrx? {
        return try read() as InnerIPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `InnerIPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `InnerIPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: InnerIPrx.Protocol) throws -> InnerIPrx? {
        return try read(tag: tag) as InnerIPrxI?
    }
}

/// InnerIPrx overview.
///
/// InnerIPrx Methods:
///
///  - opS: 
///
///  - opSAsync: 
///
///  - opSSeq: 
///
///  - opSSeqAsync: 
///
///  - opSMap: 
///
///  - opSMapAsync: 
///
///  - opC: 
///
///  - opCAsync: 
///
///  - opCSeq: 
///
///  - opCSeqAsync: 
///
///  - opCMap: 
///
///  - opCMapAsync: 
///
///  - shutdown: 
///
///  - shutdownAsync: 
public extension InnerIPrx {
    ///
    /// - parameter _: `InnerInner2S`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: InnerInner2S, s2: InnerInner2S)`:
    ///
    ///   - returnValue: `InnerInner2S`
    ///
    ///   - s2: `InnerInner2S`
    func opS(_ iceP_s1: InnerInner2S, context: Ice.Context? = nil) throws -> (returnValue: InnerInner2S, s2: InnerInner2S) {
        return try _impl._invoke(operation: "opS",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_s1)
                                 },
                                 read: { istr in
                                     let iceP_s2: InnerInner2S = try istr.read()
                                     let iceP_returnValue: InnerInner2S = try istr.read()
                                     return (iceP_returnValue, iceP_s2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `InnerInner2S`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: InnerInner2S, s2: InnerInner2S)>` - The result of the operation
    func opSAsync(_ iceP_s1: InnerInner2S, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: InnerInner2S, s2: InnerInner2S)> {
        return _impl._invokeAsync(operation: "opS",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_s1)
                                  },
                                  read: { istr in
                                      let iceP_s2: InnerInner2S = try istr.read()
                                      let iceP_returnValue: InnerInner2S = try istr.read()
                                      return (iceP_returnValue, iceP_s2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `InnerInner2SSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: InnerInner2SSeq, s2: InnerInner2SSeq)`:
    ///
    ///   - returnValue: `InnerInner2SSeq`
    ///
    ///   - s2: `InnerInner2SSeq`
    func opSSeq(_ iceP_s1: InnerInner2SSeq, context: Ice.Context? = nil) throws -> (returnValue: InnerInner2SSeq, s2: InnerInner2SSeq) {
        return try _impl._invoke(operation: "opSSeq",
                                 mode: .Normal,
                                 write: { ostr in
                                     InnerInner2SSeqHelper.write(to: ostr, value: iceP_s1)
                                 },
                                 read: { istr in
                                     let iceP_s2: InnerInner2SSeq = try InnerInner2SSeqHelper.read(from: istr)
                                     let iceP_returnValue: InnerInner2SSeq = try InnerInner2SSeqHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_s2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `InnerInner2SSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: InnerInner2SSeq, s2: InnerInner2SSeq)>` - The result of the operation
    func opSSeqAsync(_ iceP_s1: InnerInner2SSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: InnerInner2SSeq, s2: InnerInner2SSeq)> {
        return _impl._invokeAsync(operation: "opSSeq",
                                  mode: .Normal,
                                  write: { ostr in
                                      InnerInner2SSeqHelper.write(to: ostr, value: iceP_s1)
                                  },
                                  read: { istr in
                                      let iceP_s2: InnerInner2SSeq = try InnerInner2SSeqHelper.read(from: istr)
                                      let iceP_returnValue: InnerInner2SSeq = try InnerInner2SSeqHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_s2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `InnerInner2SMap`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: InnerInner2SMap, s2: InnerInner2SMap)`:
    ///
    ///   - returnValue: `InnerInner2SMap`
    ///
    ///   - s2: `InnerInner2SMap`
    func opSMap(_ iceP_s1: InnerInner2SMap, context: Ice.Context? = nil) throws -> (returnValue: InnerInner2SMap, s2: InnerInner2SMap) {
        return try _impl._invoke(operation: "opSMap",
                                 mode: .Normal,
                                 write: { ostr in
                                     InnerInner2SMapHelper.write(to: ostr, value: iceP_s1)
                                 },
                                 read: { istr in
                                     let iceP_s2: InnerInner2SMap = try InnerInner2SMapHelper.read(from: istr)
                                     let iceP_returnValue: InnerInner2SMap = try InnerInner2SMapHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_s2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `InnerInner2SMap`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: InnerInner2SMap, s2: InnerInner2SMap)>` - The result of the operation
    func opSMapAsync(_ iceP_s1: InnerInner2SMap, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: InnerInner2SMap, s2: InnerInner2SMap)> {
        return _impl._invokeAsync(operation: "opSMap",
                                  mode: .Normal,
                                  write: { ostr in
                                      InnerInner2SMapHelper.write(to: ostr, value: iceP_s1)
                                  },
                                  read: { istr in
                                      let iceP_s2: InnerInner2SMap = try InnerInner2SMapHelper.read(from: istr)
                                      let iceP_returnValue: InnerInner2SMap = try InnerInner2SMapHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_s2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `InnerInner2C?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: InnerInner2C?, c2: InnerInner2C?)`:
    ///
    ///   - returnValue: `InnerInner2C?`
    ///
    ///   - c2: `InnerInner2C?`
    func opC(_ iceP_c1: InnerInner2C?, context: Ice.Context? = nil) throws -> (returnValue: InnerInner2C?, c2: InnerInner2C?) {
        return try _impl._invoke(operation: "opC",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_c1)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     var iceP_c2: InnerInner2C?
                                     try istr.read(InnerInner2C.self) { iceP_c2 = $0 }
                                     var iceP_returnValue: InnerInner2C?
                                     try istr.read(InnerInner2C.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return (iceP_returnValue, iceP_c2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `InnerInner2C?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: InnerInner2C?, c2: InnerInner2C?)>` - The result of the operation
    func opCAsync(_ iceP_c1: InnerInner2C?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: InnerInner2C?, c2: InnerInner2C?)> {
        return _impl._invokeAsync(operation: "opC",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_c1)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      var iceP_c2: InnerInner2C?
                                      try istr.read(InnerInner2C.self) { iceP_c2 = $0 }
                                      var iceP_returnValue: InnerInner2C?
                                      try istr.read(InnerInner2C.self) { iceP_returnValue = $0 }
                                      try istr.readPendingValues()
                                      return (iceP_returnValue, iceP_c2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `InnerInner2CSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: InnerInner2CSeq, c2: InnerInner2CSeq)`:
    ///
    ///   - returnValue: `InnerInner2CSeq`
    ///
    ///   - c2: `InnerInner2CSeq`
    func opCSeq(_ iceP_c1: InnerInner2CSeq, context: Ice.Context? = nil) throws -> (returnValue: InnerInner2CSeq, c2: InnerInner2CSeq) {
        return try _impl._invoke(operation: "opCSeq",
                                 mode: .Normal,
                                 write: { ostr in
                                     InnerInner2CSeqHelper.write(to: ostr, value: iceP_c1)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     let iceP_c2: InnerInner2CSeq = try InnerInner2CSeqHelper.read(from: istr)
                                     let iceP_returnValue: InnerInner2CSeq = try InnerInner2CSeqHelper.read(from: istr)
                                     try istr.readPendingValues()
                                     return (iceP_returnValue, iceP_c2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `InnerInner2CSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: InnerInner2CSeq, c2: InnerInner2CSeq)>` - The result of the operation
    func opCSeqAsync(_ iceP_c1: InnerInner2CSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: InnerInner2CSeq, c2: InnerInner2CSeq)> {
        return _impl._invokeAsync(operation: "opCSeq",
                                  mode: .Normal,
                                  write: { ostr in
                                      InnerInner2CSeqHelper.write(to: ostr, value: iceP_c1)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      let iceP_c2: InnerInner2CSeq = try InnerInner2CSeqHelper.read(from: istr)
                                      let iceP_returnValue: InnerInner2CSeq = try InnerInner2CSeqHelper.read(from: istr)
                                      try istr.readPendingValues()
                                      return (iceP_returnValue, iceP_c2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `InnerInner2CMap`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: InnerInner2CMap, c2: InnerInner2CMap)`:
    ///
    ///   - returnValue: `InnerInner2CMap`
    ///
    ///   - c2: `InnerInner2CMap`
    func opCMap(_ iceP_c1: InnerInner2CMap, context: Ice.Context? = nil) throws -> (returnValue: InnerInner2CMap, c2: InnerInner2CMap) {
        return try _impl._invoke(operation: "opCMap",
                                 mode: .Normal,
                                 write: { ostr in
                                     InnerInner2CMapHelper.write(to: ostr, value: iceP_c1)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     let iceP_c2: InnerInner2CMap = try InnerInner2CMapHelper.read(from: istr)
                                     let iceP_returnValue: InnerInner2CMap = try InnerInner2CMapHelper.read(from: istr)
                                     try istr.readPendingValues()
                                     return (iceP_returnValue, iceP_c2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `InnerInner2CMap`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: InnerInner2CMap, c2: InnerInner2CMap)>` - The result of the operation
    func opCMapAsync(_ iceP_c1: InnerInner2CMap, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: InnerInner2CMap, c2: InnerInner2CMap)> {
        return _impl._invokeAsync(operation: "opCMap",
                                  mode: .Normal,
                                  write: { ostr in
                                      InnerInner2CMapHelper.write(to: ostr, value: iceP_c1)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      let iceP_c2: InnerInner2CMap = try InnerInner2CMapHelper.read(from: istr)
                                      let iceP_returnValue: InnerInner2CMap = try InnerInner2CMapHelper.read(from: istr)
                                      try istr.readPendingValues()
                                      return (iceP_returnValue, iceP_c2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func shutdown(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "shutdown",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func shutdownAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "shutdown",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// InnerTestInner2IPrx overview.
///
/// InnerTestInner2IPrx Methods:
///
///  - opS: 
///
///  - opSAsync: 
///
///  - opSSeq: 
///
///  - opSSeqAsync: 
///
///  - opSMap: 
///
///  - opSMapAsync: 
///
///  - opC: 
///
///  - opCAsync: 
///
///  - opCSeq: 
///
///  - opCSeqAsync: 
///
///  - opCMap: 
///
///  - opCMapAsync: 
///
///  - shutdown: 
///
///  - shutdownAsync: 
public protocol InnerTestInner2IPrx: Ice.ObjectPrx {}

private final class InnerTestInner2IPrxI: Ice.ObjectPrxI, InnerTestInner2IPrx {
    public override class func ice_staticId() -> Swift.String {
        return InnerTestInner2ITraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `InnerTestInner2IPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `InnerTestInner2IPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: InnerTestInner2IPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> InnerTestInner2IPrx? {
    return try InnerTestInner2IPrxI.checkedCast(prx: prx, facet: facet, context: context) as InnerTestInner2IPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `InnerTestInner2IPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `InnerTestInner2IPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: InnerTestInner2IPrx.Protocol, facet: Swift.String? = nil) -> InnerTestInner2IPrx {
    return InnerTestInner2IPrxI.uncheckedCast(prx: prx, facet: facet) as InnerTestInner2IPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `InnerTestInner2IPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: InnerTestInner2IPrx.Protocol) -> Swift.String {
    return InnerTestInner2ITraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `InnerTestInner2IPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `InnerTestInner2IPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `InnerTestInner2IPrx?` - The extracted proxy
    func read(_ type: InnerTestInner2IPrx.Protocol) throws -> InnerTestInner2IPrx? {
        return try read() as InnerTestInner2IPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `InnerTestInner2IPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `InnerTestInner2IPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: InnerTestInner2IPrx.Protocol) throws -> InnerTestInner2IPrx? {
        return try read(tag: tag) as InnerTestInner2IPrxI?
    }
}

/// InnerTestInner2IPrx overview.
///
/// InnerTestInner2IPrx Methods:
///
///  - opS: 
///
///  - opSAsync: 
///
///  - opSSeq: 
///
///  - opSSeqAsync: 
///
///  - opSMap: 
///
///  - opSMapAsync: 
///
///  - opC: 
///
///  - opCAsync: 
///
///  - opCSeq: 
///
///  - opCSeqAsync: 
///
///  - opCMap: 
///
///  - opCMapAsync: 
///
///  - shutdown: 
///
///  - shutdownAsync: 
public extension InnerTestInner2IPrx {
    ///
    /// - parameter _: `S`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: S, s2: S)`:
    ///
    ///   - returnValue: `S`
    ///
    ///   - s2: `S`
    func opS(_ iceP_s1: S, context: Ice.Context? = nil) throws -> (returnValue: S, s2: S) {
        return try _impl._invoke(operation: "opS",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_s1)
                                 },
                                 read: { istr in
                                     let iceP_s2: S = try istr.read()
                                     let iceP_returnValue: S = try istr.read()
                                     return (iceP_returnValue, iceP_s2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `S`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: S, s2: S)>` - The result of the operation
    func opSAsync(_ iceP_s1: S, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: S, s2: S)> {
        return _impl._invokeAsync(operation: "opS",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_s1)
                                  },
                                  read: { istr in
                                      let iceP_s2: S = try istr.read()
                                      let iceP_returnValue: S = try istr.read()
                                      return (iceP_returnValue, iceP_s2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `SSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: SSeq, s2: SSeq)`:
    ///
    ///   - returnValue: `SSeq`
    ///
    ///   - s2: `SSeq`
    func opSSeq(_ iceP_s1: SSeq, context: Ice.Context? = nil) throws -> (returnValue: SSeq, s2: SSeq) {
        return try _impl._invoke(operation: "opSSeq",
                                 mode: .Normal,
                                 write: { ostr in
                                     SSeqHelper.write(to: ostr, value: iceP_s1)
                                 },
                                 read: { istr in
                                     let iceP_s2: SSeq = try SSeqHelper.read(from: istr)
                                     let iceP_returnValue: SSeq = try SSeqHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_s2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `SSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: SSeq, s2: SSeq)>` - The result of the operation
    func opSSeqAsync(_ iceP_s1: SSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: SSeq, s2: SSeq)> {
        return _impl._invokeAsync(operation: "opSSeq",
                                  mode: .Normal,
                                  write: { ostr in
                                      SSeqHelper.write(to: ostr, value: iceP_s1)
                                  },
                                  read: { istr in
                                      let iceP_s2: SSeq = try SSeqHelper.read(from: istr)
                                      let iceP_returnValue: SSeq = try SSeqHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_s2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `SMap`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: SMap, s2: SMap)`:
    ///
    ///   - returnValue: `SMap`
    ///
    ///   - s2: `SMap`
    func opSMap(_ iceP_s1: SMap, context: Ice.Context? = nil) throws -> (returnValue: SMap, s2: SMap) {
        return try _impl._invoke(operation: "opSMap",
                                 mode: .Normal,
                                 write: { ostr in
                                     SMapHelper.write(to: ostr, value: iceP_s1)
                                 },
                                 read: { istr in
                                     let iceP_s2: SMap = try SMapHelper.read(from: istr)
                                     let iceP_returnValue: SMap = try SMapHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_s2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `SMap`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: SMap, s2: SMap)>` - The result of the operation
    func opSMapAsync(_ iceP_s1: SMap, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: SMap, s2: SMap)> {
        return _impl._invokeAsync(operation: "opSMap",
                                  mode: .Normal,
                                  write: { ostr in
                                      SMapHelper.write(to: ostr, value: iceP_s1)
                                  },
                                  read: { istr in
                                      let iceP_s2: SMap = try SMapHelper.read(from: istr)
                                      let iceP_returnValue: SMap = try SMapHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_s2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `C?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: C?, c2: C?)`:
    ///
    ///   - returnValue: `C?`
    ///
    ///   - c2: `C?`
    func opC(_ iceP_c1: C?, context: Ice.Context? = nil) throws -> (returnValue: C?, c2: C?) {
        return try _impl._invoke(operation: "opC",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_c1)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     var iceP_c2: C?
                                     try istr.read(C.self) { iceP_c2 = $0 }
                                     var iceP_returnValue: C?
                                     try istr.read(C.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return (iceP_returnValue, iceP_c2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `C?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: C?, c2: C?)>` - The result of the operation
    func opCAsync(_ iceP_c1: C?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: C?, c2: C?)> {
        return _impl._invokeAsync(operation: "opC",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_c1)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      var iceP_c2: C?
                                      try istr.read(C.self) { iceP_c2 = $0 }
                                      var iceP_returnValue: C?
                                      try istr.read(C.self) { iceP_returnValue = $0 }
                                      try istr.readPendingValues()
                                      return (iceP_returnValue, iceP_c2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `CSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: CSeq, c2: CSeq)`:
    ///
    ///   - returnValue: `CSeq`
    ///
    ///   - c2: `CSeq`
    func opCSeq(_ iceP_c1: CSeq, context: Ice.Context? = nil) throws -> (returnValue: CSeq, c2: CSeq) {
        return try _impl._invoke(operation: "opCSeq",
                                 mode: .Normal,
                                 write: { ostr in
                                     CSeqHelper.write(to: ostr, value: iceP_c1)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     let iceP_c2: CSeq = try CSeqHelper.read(from: istr)
                                     let iceP_returnValue: CSeq = try CSeqHelper.read(from: istr)
                                     try istr.readPendingValues()
                                     return (iceP_returnValue, iceP_c2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `CSeq`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: CSeq, c2: CSeq)>` - The result of the operation
    func opCSeqAsync(_ iceP_c1: CSeq, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: CSeq, c2: CSeq)> {
        return _impl._invokeAsync(operation: "opCSeq",
                                  mode: .Normal,
                                  write: { ostr in
                                      CSeqHelper.write(to: ostr, value: iceP_c1)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      let iceP_c2: CSeq = try CSeqHelper.read(from: istr)
                                      let iceP_returnValue: CSeq = try CSeqHelper.read(from: istr)
                                      try istr.readPendingValues()
                                      return (iceP_returnValue, iceP_c2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `CMap`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: CMap, c2: CMap)`:
    ///
    ///   - returnValue: `CMap`
    ///
    ///   - c2: `CMap`
    func opCMap(_ iceP_c1: CMap, context: Ice.Context? = nil) throws -> (returnValue: CMap, c2: CMap) {
        return try _impl._invoke(operation: "opCMap",
                                 mode: .Normal,
                                 write: { ostr in
                                     CMapHelper.write(to: ostr, value: iceP_c1)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     let iceP_c2: CMap = try CMapHelper.read(from: istr)
                                     let iceP_returnValue: CMap = try CMapHelper.read(from: istr)
                                     try istr.readPendingValues()
                                     return (iceP_returnValue, iceP_c2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `CMap`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: CMap, c2: CMap)>` - The result of the operation
    func opCMapAsync(_ iceP_c1: CMap, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: CMap, c2: CMap)> {
        return _impl._invokeAsync(operation: "opCMap",
                                  mode: .Normal,
                                  write: { ostr in
                                      CMapHelper.write(to: ostr, value: iceP_c1)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      let iceP_c2: CMap = try CMapHelper.read(from: istr)
                                      let iceP_returnValue: CMap = try CMapHelper.read(from: istr)
                                      try istr.readPendingValues()
                                      return (iceP_returnValue, iceP_c2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func shutdown(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "shutdown",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func shutdownAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "shutdown",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// :nodoc:
public class C_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return C.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_C() -> Ice.ValueTypeResolver {
        return C_TypeResolver()
    }
}

open class C: Ice.Value {
    public var s: S = S()

    public required init() {}

    public init(s: S) {
        self.s = s
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return CTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return CTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.s = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CTraits.staticId, compactId: -1, last: true)
        ostr.write(self.s)
        ostr.endSlice()
    }
}

/// :nodoc:
public class C1_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return C1.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_C1() -> Ice.ValueTypeResolver {
        return C1_TypeResolver()
    }
}

open class C1: Ice.Value {
    public var s: Swift.String = ""

    public required init() {}

    public init(s: Swift.String) {
        self.s = s
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return C1Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return C1Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.s = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: C1Traits.staticId, compactId: -1, last: true)
        ostr.write(self.s)
        ostr.endSlice()
    }
}

/// :nodoc:
public class C2_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return C2.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_C2() -> Ice.ValueTypeResolver {
        return C2_TypeResolver()
    }
}

open class C2: Ice.Value {
    public var E1: E1 = .v1
    typealias Test_S1 = S1
    public var S1: S1 = Test_S1()
    public var C1: C1? = nil
    typealias Test_S1Seq = S1Seq
    public var S1Seq: S1Seq = Test_S1Seq()
    typealias Test_S1Map = S1Map
    public var S1Map: S1Map = Test_S1Map()

    public required init() {}

    public init(E1: E1, S1: S1, C1: C1?, S1Seq: S1Seq, S1Map: S1Map) {
        self.E1 = E1
        self.S1 = S1
        self.C1 = C1
        self.S1Seq = S1Seq
        self.S1Map = S1Map
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return C2Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return C2Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.E1 = try istr.read()
        self.S1 = try istr.read()
        typealias Test_C1 = C1
        try istr.read(Test_C1.self) { self.C1 = $0 }
        self.S1Seq = try S1SeqHelper.read(from: istr)
        self.S1Map = try S1MapHelper.read(from: istr)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: C2Traits.staticId, compactId: -1, last: true)
        ostr.write(self.E1)
        ostr.write(self.S1)
        ostr.write(self.C1)
        S1SeqHelper.write(to: ostr, value: self.S1Seq)
        S1MapHelper.write(to: ostr, value: self.S1Map)
        ostr.endSlice()
    }
}

/// :nodoc:
public class InnerInner2C_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return InnerInner2C.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Inner_Inner2_C() -> Ice.ValueTypeResolver {
        return InnerInner2C_TypeResolver()
    }
}

open class InnerInner2C: Ice.Value {
    public var s: InnerInner2S = InnerInner2S()

    public required init() {}

    public init(s: InnerInner2S) {
        self.s = s
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return InnerInner2CTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return InnerInner2CTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.s = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: InnerInner2CTraits.staticId, compactId: -1, last: true)
        ostr.write(self.s)
        ostr.endSlice()
    }
}

/// :nodoc:
public class InnerC_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return InnerC.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Inner_C() -> Ice.ValueTypeResolver {
        return InnerC_TypeResolver()
    }
}

open class InnerC: Ice.Value {
    public var s: InnerS = InnerS()

    public required init() {}

    public init(s: InnerS) {
        self.s = s
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return InnerCTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return InnerCTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.s = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: InnerCTraits.staticId, compactId: -1, last: true)
        ostr.write(self.s)
        ostr.endSlice()
    }
}


/// Dispatcher for `I` servants.
public struct IDisp: Ice.Disp {
    public let servant: I
    private static let defaultObject = Ice.ObjectI<ITraits>()

    public init(_ servant: I) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "ice_id":
            return try (servant as? Object ?? IDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? IDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? IDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? IDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "opC":
            return try servant._iceD_opC(incoming: request, current: current)
        case "opC1":
            return try servant._iceD_opC1(incoming: request, current: current)
        case "opCMap":
            return try servant._iceD_opCMap(incoming: request, current: current)
        case "opCSeq":
            return try servant._iceD_opCSeq(incoming: request, current: current)
        case "opE1":
            return try servant._iceD_opE1(incoming: request, current: current)
        case "opS":
            return try servant._iceD_opS(incoming: request, current: current)
        case "opS1":
            return try servant._iceD_opS1(incoming: request, current: current)
        case "opS1Map":
            return try servant._iceD_opS1Map(incoming: request, current: current)
        case "opS1Seq":
            return try servant._iceD_opS1Seq(incoming: request, current: current)
        case "opSMap":
            return try servant._iceD_opSMap(incoming: request, current: current)
        case "opSSeq":
            return try servant._iceD_opSSeq(incoming: request, current: current)
        case "shutdown":
            return try servant._iceD_shutdown(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol I {
    ///
    /// - parameter s1: `S`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: S, s2: S)`:
    ///
    ///   - returnValue: `S`
    ///
    ///   - s2: `S`
    func opS(s1: S, current: Ice.Current) throws -> (returnValue: S, s2: S)

    ///
    /// - parameter s1: `SSeq`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: SSeq, s2: SSeq)`:
    ///
    ///   - returnValue: `SSeq`
    ///
    ///   - s2: `SSeq`
    func opSSeq(s1: SSeq, current: Ice.Current) throws -> (returnValue: SSeq, s2: SSeq)

    ///
    /// - parameter s1: `SMap`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: SMap, s2: SMap)`:
    ///
    ///   - returnValue: `SMap`
    ///
    ///   - s2: `SMap`
    func opSMap(s1: SMap, current: Ice.Current) throws -> (returnValue: SMap, s2: SMap)

    ///
    /// - parameter c1: `C?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: C?, c2: C?)`:
    ///
    ///   - returnValue: `C?`
    ///
    ///   - c2: `C?`
    func opC(c1: C?, current: Ice.Current) throws -> (returnValue: C?, c2: C?)

    ///
    /// - parameter s1: `CSeq`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: CSeq, s2: CSeq)`:
    ///
    ///   - returnValue: `CSeq`
    ///
    ///   - s2: `CSeq`
    func opCSeq(s1: CSeq, current: Ice.Current) throws -> (returnValue: CSeq, s2: CSeq)

    ///
    /// - parameter c1: `CMap`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: CMap, c2: CMap)`:
    ///
    ///   - returnValue: `CMap`
    ///
    ///   - c2: `CMap`
    func opCMap(c1: CMap, current: Ice.Current) throws -> (returnValue: CMap, c2: CMap)

    ///
    /// - parameter E1: `E1`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `E1`
    func opE1(E1: E1, current: Ice.Current) throws -> E1

    ///
    /// - parameter S1: `S1`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `S1`
    func opS1(S1: S1, current: Ice.Current) throws -> S1

    ///
    /// - parameter C1: `C1?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `C1?`
    func opC1(C1: C1?, current: Ice.Current) throws -> C1?

    ///
    /// - parameter S1Seq: `S1Seq`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `S1Seq`
    func opS1Seq(S1Seq: S1Seq, current: Ice.Current) throws -> S1Seq

    ///
    /// - parameter S1Map: `S1Map`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `S1Map`
    func opS1Map(S1Map: S1Map, current: Ice.Current) throws -> S1Map

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func shutdown(current: Ice.Current) throws
}


/// Dispatcher for `InnerInner2I` servants.
public struct InnerInner2IDisp: Ice.Disp {
    public let servant: InnerInner2I
    private static let defaultObject = Ice.ObjectI<InnerInner2ITraits>()

    public init(_ servant: InnerInner2I) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "ice_id":
            return try (servant as? Object ?? InnerInner2IDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? InnerInner2IDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? InnerInner2IDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? InnerInner2IDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "opC":
            return try servant._iceD_opC(incoming: request, current: current)
        case "opCMap":
            return try servant._iceD_opCMap(incoming: request, current: current)
        case "opCSeq":
            return try servant._iceD_opCSeq(incoming: request, current: current)
        case "opS":
            return try servant._iceD_opS(incoming: request, current: current)
        case "opSMap":
            return try servant._iceD_opSMap(incoming: request, current: current)
        case "opSSeq":
            return try servant._iceD_opSSeq(incoming: request, current: current)
        case "shutdown":
            return try servant._iceD_shutdown(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol InnerInner2I {
    ///
    /// - parameter s1: `InnerInner2S`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: InnerInner2S, s2: InnerInner2S)`:
    ///
    ///   - returnValue: `InnerInner2S`
    ///
    ///   - s2: `InnerInner2S`
    func opS(s1: InnerInner2S, current: Ice.Current) throws -> (returnValue: InnerInner2S, s2: InnerInner2S)

    ///
    /// - parameter s1: `InnerInner2SSeq`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: InnerInner2SSeq, s2: InnerInner2SSeq)`:
    ///
    ///   - returnValue: `InnerInner2SSeq`
    ///
    ///   - s2: `InnerInner2SSeq`
    func opSSeq(s1: InnerInner2SSeq, current: Ice.Current) throws -> (returnValue: InnerInner2SSeq, s2: InnerInner2SSeq)

    ///
    /// - parameter s1: `InnerInner2SMap`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: InnerInner2SMap, s2: InnerInner2SMap)`:
    ///
    ///   - returnValue: `InnerInner2SMap`
    ///
    ///   - s2: `InnerInner2SMap`
    func opSMap(s1: InnerInner2SMap, current: Ice.Current) throws -> (returnValue: InnerInner2SMap, s2: InnerInner2SMap)

    ///
    /// - parameter c1: `InnerInner2C?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: InnerInner2C?, c2: InnerInner2C?)`:
    ///
    ///   - returnValue: `InnerInner2C?`
    ///
    ///   - c2: `InnerInner2C?`
    func opC(c1: InnerInner2C?, current: Ice.Current) throws -> (returnValue: InnerInner2C?, c2: InnerInner2C?)

    ///
    /// - parameter c1: `InnerInner2CSeq`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: InnerInner2CSeq, c2: InnerInner2CSeq)`:
    ///
    ///   - returnValue: `InnerInner2CSeq`
    ///
    ///   - c2: `InnerInner2CSeq`
    func opCSeq(c1: InnerInner2CSeq, current: Ice.Current) throws -> (returnValue: InnerInner2CSeq, c2: InnerInner2CSeq)

    ///
    /// - parameter c1: `InnerInner2CMap`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: InnerInner2CMap, c2: InnerInner2CMap)`:
    ///
    ///   - returnValue: `InnerInner2CMap`
    ///
    ///   - c2: `InnerInner2CMap`
    func opCMap(c1: InnerInner2CMap, current: Ice.Current) throws -> (returnValue: InnerInner2CMap, c2: InnerInner2CMap)

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func shutdown(current: Ice.Current) throws
}


/// Dispatcher for `InnerI` servants.
public struct InnerIDisp: Ice.Disp {
    public let servant: InnerI
    private static let defaultObject = Ice.ObjectI<InnerITraits>()

    public init(_ servant: InnerI) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "ice_id":
            return try (servant as? Object ?? InnerIDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? InnerIDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? InnerIDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? InnerIDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "opC":
            return try servant._iceD_opC(incoming: request, current: current)
        case "opCMap":
            return try servant._iceD_opCMap(incoming: request, current: current)
        case "opCSeq":
            return try servant._iceD_opCSeq(incoming: request, current: current)
        case "opS":
            return try servant._iceD_opS(incoming: request, current: current)
        case "opSMap":
            return try servant._iceD_opSMap(incoming: request, current: current)
        case "opSSeq":
            return try servant._iceD_opSSeq(incoming: request, current: current)
        case "shutdown":
            return try servant._iceD_shutdown(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol InnerI {
    ///
    /// - parameter s1: `InnerInner2S`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: InnerInner2S, s2: InnerInner2S)`:
    ///
    ///   - returnValue: `InnerInner2S`
    ///
    ///   - s2: `InnerInner2S`
    func opS(s1: InnerInner2S, current: Ice.Current) throws -> (returnValue: InnerInner2S, s2: InnerInner2S)

    ///
    /// - parameter s1: `InnerInner2SSeq`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: InnerInner2SSeq, s2: InnerInner2SSeq)`:
    ///
    ///   - returnValue: `InnerInner2SSeq`
    ///
    ///   - s2: `InnerInner2SSeq`
    func opSSeq(s1: InnerInner2SSeq, current: Ice.Current) throws -> (returnValue: InnerInner2SSeq, s2: InnerInner2SSeq)

    ///
    /// - parameter s1: `InnerInner2SMap`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: InnerInner2SMap, s2: InnerInner2SMap)`:
    ///
    ///   - returnValue: `InnerInner2SMap`
    ///
    ///   - s2: `InnerInner2SMap`
    func opSMap(s1: InnerInner2SMap, current: Ice.Current) throws -> (returnValue: InnerInner2SMap, s2: InnerInner2SMap)

    ///
    /// - parameter c1: `InnerInner2C?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: InnerInner2C?, c2: InnerInner2C?)`:
    ///
    ///   - returnValue: `InnerInner2C?`
    ///
    ///   - c2: `InnerInner2C?`
    func opC(c1: InnerInner2C?, current: Ice.Current) throws -> (returnValue: InnerInner2C?, c2: InnerInner2C?)

    ///
    /// - parameter c1: `InnerInner2CSeq`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: InnerInner2CSeq, c2: InnerInner2CSeq)`:
    ///
    ///   - returnValue: `InnerInner2CSeq`
    ///
    ///   - c2: `InnerInner2CSeq`
    func opCSeq(c1: InnerInner2CSeq, current: Ice.Current) throws -> (returnValue: InnerInner2CSeq, c2: InnerInner2CSeq)

    ///
    /// - parameter c1: `InnerInner2CMap`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: InnerInner2CMap, c2: InnerInner2CMap)`:
    ///
    ///   - returnValue: `InnerInner2CMap`
    ///
    ///   - c2: `InnerInner2CMap`
    func opCMap(c1: InnerInner2CMap, current: Ice.Current) throws -> (returnValue: InnerInner2CMap, c2: InnerInner2CMap)

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func shutdown(current: Ice.Current) throws
}


/// Dispatcher for `InnerTestInner2I` servants.
public struct InnerTestInner2IDisp: Ice.Disp {
    public let servant: InnerTestInner2I
    private static let defaultObject = Ice.ObjectI<InnerTestInner2ITraits>()

    public init(_ servant: InnerTestInner2I) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "ice_id":
            return try (servant as? Object ?? InnerTestInner2IDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? InnerTestInner2IDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? InnerTestInner2IDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? InnerTestInner2IDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "opC":
            return try servant._iceD_opC(incoming: request, current: current)
        case "opCMap":
            return try servant._iceD_opCMap(incoming: request, current: current)
        case "opCSeq":
            return try servant._iceD_opCSeq(incoming: request, current: current)
        case "opS":
            return try servant._iceD_opS(incoming: request, current: current)
        case "opSMap":
            return try servant._iceD_opSMap(incoming: request, current: current)
        case "opSSeq":
            return try servant._iceD_opSSeq(incoming: request, current: current)
        case "shutdown":
            return try servant._iceD_shutdown(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol InnerTestInner2I {
    ///
    /// - parameter s1: `S`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: S, s2: S)`:
    ///
    ///   - returnValue: `S`
    ///
    ///   - s2: `S`
    func opS(s1: S, current: Ice.Current) throws -> (returnValue: S, s2: S)

    ///
    /// - parameter s1: `SSeq`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: SSeq, s2: SSeq)`:
    ///
    ///   - returnValue: `SSeq`
    ///
    ///   - s2: `SSeq`
    func opSSeq(s1: SSeq, current: Ice.Current) throws -> (returnValue: SSeq, s2: SSeq)

    ///
    /// - parameter s1: `SMap`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: SMap, s2: SMap)`:
    ///
    ///   - returnValue: `SMap`
    ///
    ///   - s2: `SMap`
    func opSMap(s1: SMap, current: Ice.Current) throws -> (returnValue: SMap, s2: SMap)

    ///
    /// - parameter c1: `C?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: C?, c2: C?)`:
    ///
    ///   - returnValue: `C?`
    ///
    ///   - c2: `C?`
    func opC(c1: C?, current: Ice.Current) throws -> (returnValue: C?, c2: C?)

    ///
    /// - parameter c1: `CSeq`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: CSeq, c2: CSeq)`:
    ///
    ///   - returnValue: `CSeq`
    ///
    ///   - c2: `CSeq`
    func opCSeq(c1: CSeq, current: Ice.Current) throws -> (returnValue: CSeq, c2: CSeq)

    ///
    /// - parameter c1: `CMap`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: CMap, c2: CMap)`:
    ///
    ///   - returnValue: `CMap`
    ///
    ///   - c2: `CMap`
    func opCMap(c1: CMap, current: Ice.Current) throws -> (returnValue: CMap, c2: CMap)

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func shutdown(current: Ice.Current) throws
}

/// I overview.
///
/// I Methods:
///
///  - opS: 
///
///  - opSSeq: 
///
///  - opSMap: 
///
///  - opC: 
///
///  - opCSeq: 
///
///  - opCMap: 
///
///  - opE1: 
///
///  - opS1: 
///
///  - opC1: 
///
///  - opS1Seq: 
///
///  - opS1Map: 
///
///  - shutdown: 
public extension I {
    func _iceD_opS(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_s1: S = try inS.read { istr in
            let iceP_s1: S = try istr.read()
            return iceP_s1
        }

        let (iceP_returnValue, iceP_s2) = try self.opS(s1: iceP_s1, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_s2)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opSSeq(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_s1: SSeq = try inS.read { istr in
            let iceP_s1: SSeq = try SSeqHelper.read(from: istr)
            return iceP_s1
        }

        let (iceP_returnValue, iceP_s2) = try self.opSSeq(s1: iceP_s1, current: current)

        return inS.setResult{ ostr in
            SSeqHelper.write(to: ostr, value: iceP_s2)
            SSeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opSMap(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_s1: SMap = try inS.read { istr in
            let iceP_s1: SMap = try SMapHelper.read(from: istr)
            return iceP_s1
        }

        let (iceP_returnValue, iceP_s2) = try self.opSMap(s1: iceP_s1, current: current)

        return inS.setResult{ ostr in
            SMapHelper.write(to: ostr, value: iceP_s2)
            SMapHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opC(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_c1: C? = try inS.read { istr in
            var iceP_c1: C?
            try istr.read(C.self) { iceP_c1 = $0 }
            try istr.readPendingValues()
            return iceP_c1
        }

        let (iceP_returnValue, iceP_c2) = try self.opC(c1: iceP_c1, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_c2)
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_opCSeq(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_s1: CSeq = try inS.read { istr in
            let iceP_s1: CSeq = try CSeqHelper.read(from: istr)
            try istr.readPendingValues()
            return iceP_s1
        }

        let (iceP_returnValue, iceP_s2) = try self.opCSeq(s1: iceP_s1, current: current)

        return inS.setResult{ ostr in
            CSeqHelper.write(to: ostr, value: iceP_s2)
            CSeqHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_opCMap(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_c1: CMap = try inS.read { istr in
            let iceP_c1: CMap = try CMapHelper.read(from: istr)
            try istr.readPendingValues()
            return iceP_c1
        }

        let (iceP_returnValue, iceP_c2) = try self.opCMap(c1: iceP_c1, current: current)

        return inS.setResult{ ostr in
            CMapHelper.write(to: ostr, value: iceP_c2)
            CMapHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_opE1(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_E1: E1 = try inS.read { istr in
            let iceP_E1: E1 = try istr.read()
            return iceP_E1
        }

        let iceP_returnValue = try self.opE1(E1: iceP_E1, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opS1(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_S1: S1 = try inS.read { istr in
            let iceP_S1: S1 = try istr.read()
            return iceP_S1
        }

        let iceP_returnValue = try self.opS1(S1: iceP_S1, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opC1(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_C1: C1? = try inS.read { istr in
            var iceP_C1: C1?
            try istr.read(C1.self) { iceP_C1 = $0 }
            try istr.readPendingValues()
            return iceP_C1
        }

        let iceP_returnValue = try self.opC1(C1: iceP_C1, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_opS1Seq(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_S1Seq: S1Seq = try inS.read { istr in
            let iceP_S1Seq: S1Seq = try S1SeqHelper.read(from: istr)
            return iceP_S1Seq
        }

        let iceP_returnValue = try self.opS1Seq(S1Seq: iceP_S1Seq, current: current)

        return inS.setResult{ ostr in
            S1SeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opS1Map(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_S1Map: S1Map = try inS.read { istr in
            let iceP_S1Map: S1Map = try S1MapHelper.read(from: istr)
            return iceP_S1Map
        }

        let iceP_returnValue = try self.opS1Map(S1Map: iceP_S1Map, current: current)

        return inS.setResult{ ostr in
            S1MapHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_shutdown(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.shutdown(current: current)

        return inS.setResult()
    }
}

/// InnerInner2I overview.
///
/// InnerInner2I Methods:
///
///  - opS: 
///
///  - opSSeq: 
///
///  - opSMap: 
///
///  - opC: 
///
///  - opCSeq: 
///
///  - opCMap: 
///
///  - shutdown: 
public extension InnerInner2I {
    func _iceD_opS(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_s1: InnerInner2S = try inS.read { istr in
            let iceP_s1: InnerInner2S = try istr.read()
            return iceP_s1
        }

        let (iceP_returnValue, iceP_s2) = try self.opS(s1: iceP_s1, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_s2)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opSSeq(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_s1: InnerInner2SSeq = try inS.read { istr in
            let iceP_s1: InnerInner2SSeq = try InnerInner2SSeqHelper.read(from: istr)
            return iceP_s1
        }

        let (iceP_returnValue, iceP_s2) = try self.opSSeq(s1: iceP_s1, current: current)

        return inS.setResult{ ostr in
            InnerInner2SSeqHelper.write(to: ostr, value: iceP_s2)
            InnerInner2SSeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opSMap(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_s1: InnerInner2SMap = try inS.read { istr in
            let iceP_s1: InnerInner2SMap = try InnerInner2SMapHelper.read(from: istr)
            return iceP_s1
        }

        let (iceP_returnValue, iceP_s2) = try self.opSMap(s1: iceP_s1, current: current)

        return inS.setResult{ ostr in
            InnerInner2SMapHelper.write(to: ostr, value: iceP_s2)
            InnerInner2SMapHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opC(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_c1: InnerInner2C? = try inS.read { istr in
            var iceP_c1: InnerInner2C?
            try istr.read(InnerInner2C.self) { iceP_c1 = $0 }
            try istr.readPendingValues()
            return iceP_c1
        }

        let (iceP_returnValue, iceP_c2) = try self.opC(c1: iceP_c1, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_c2)
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_opCSeq(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_c1: InnerInner2CSeq = try inS.read { istr in
            let iceP_c1: InnerInner2CSeq = try InnerInner2CSeqHelper.read(from: istr)
            try istr.readPendingValues()
            return iceP_c1
        }

        let (iceP_returnValue, iceP_c2) = try self.opCSeq(c1: iceP_c1, current: current)

        return inS.setResult{ ostr in
            InnerInner2CSeqHelper.write(to: ostr, value: iceP_c2)
            InnerInner2CSeqHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_opCMap(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_c1: InnerInner2CMap = try inS.read { istr in
            let iceP_c1: InnerInner2CMap = try InnerInner2CMapHelper.read(from: istr)
            try istr.readPendingValues()
            return iceP_c1
        }

        let (iceP_returnValue, iceP_c2) = try self.opCMap(c1: iceP_c1, current: current)

        return inS.setResult{ ostr in
            InnerInner2CMapHelper.write(to: ostr, value: iceP_c2)
            InnerInner2CMapHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_shutdown(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.shutdown(current: current)

        return inS.setResult()
    }
}

/// InnerI overview.
///
/// InnerI Methods:
///
///  - opS: 
///
///  - opSSeq: 
///
///  - opSMap: 
///
///  - opC: 
///
///  - opCSeq: 
///
///  - opCMap: 
///
///  - shutdown: 
public extension InnerI {
    func _iceD_opS(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_s1: InnerInner2S = try inS.read { istr in
            let iceP_s1: InnerInner2S = try istr.read()
            return iceP_s1
        }

        let (iceP_returnValue, iceP_s2) = try self.opS(s1: iceP_s1, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_s2)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opSSeq(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_s1: InnerInner2SSeq = try inS.read { istr in
            let iceP_s1: InnerInner2SSeq = try InnerInner2SSeqHelper.read(from: istr)
            return iceP_s1
        }

        let (iceP_returnValue, iceP_s2) = try self.opSSeq(s1: iceP_s1, current: current)

        return inS.setResult{ ostr in
            InnerInner2SSeqHelper.write(to: ostr, value: iceP_s2)
            InnerInner2SSeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opSMap(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_s1: InnerInner2SMap = try inS.read { istr in
            let iceP_s1: InnerInner2SMap = try InnerInner2SMapHelper.read(from: istr)
            return iceP_s1
        }

        let (iceP_returnValue, iceP_s2) = try self.opSMap(s1: iceP_s1, current: current)

        return inS.setResult{ ostr in
            InnerInner2SMapHelper.write(to: ostr, value: iceP_s2)
            InnerInner2SMapHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opC(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_c1: InnerInner2C? = try inS.read { istr in
            var iceP_c1: InnerInner2C?
            try istr.read(InnerInner2C.self) { iceP_c1 = $0 }
            try istr.readPendingValues()
            return iceP_c1
        }

        let (iceP_returnValue, iceP_c2) = try self.opC(c1: iceP_c1, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_c2)
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_opCSeq(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_c1: InnerInner2CSeq = try inS.read { istr in
            let iceP_c1: InnerInner2CSeq = try InnerInner2CSeqHelper.read(from: istr)
            try istr.readPendingValues()
            return iceP_c1
        }

        let (iceP_returnValue, iceP_c2) = try self.opCSeq(c1: iceP_c1, current: current)

        return inS.setResult{ ostr in
            InnerInner2CSeqHelper.write(to: ostr, value: iceP_c2)
            InnerInner2CSeqHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_opCMap(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_c1: InnerInner2CMap = try inS.read { istr in
            let iceP_c1: InnerInner2CMap = try InnerInner2CMapHelper.read(from: istr)
            try istr.readPendingValues()
            return iceP_c1
        }

        let (iceP_returnValue, iceP_c2) = try self.opCMap(c1: iceP_c1, current: current)

        return inS.setResult{ ostr in
            InnerInner2CMapHelper.write(to: ostr, value: iceP_c2)
            InnerInner2CMapHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_shutdown(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.shutdown(current: current)

        return inS.setResult()
    }
}

/// InnerTestInner2I overview.
///
/// InnerTestInner2I Methods:
///
///  - opS: 
///
///  - opSSeq: 
///
///  - opSMap: 
///
///  - opC: 
///
///  - opCSeq: 
///
///  - opCMap: 
///
///  - shutdown: 
public extension InnerTestInner2I {
    func _iceD_opS(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_s1: S = try inS.read { istr in
            let iceP_s1: S = try istr.read()
            return iceP_s1
        }

        let (iceP_returnValue, iceP_s2) = try self.opS(s1: iceP_s1, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_s2)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opSSeq(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_s1: SSeq = try inS.read { istr in
            let iceP_s1: SSeq = try SSeqHelper.read(from: istr)
            return iceP_s1
        }

        let (iceP_returnValue, iceP_s2) = try self.opSSeq(s1: iceP_s1, current: current)

        return inS.setResult{ ostr in
            SSeqHelper.write(to: ostr, value: iceP_s2)
            SSeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opSMap(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_s1: SMap = try inS.read { istr in
            let iceP_s1: SMap = try SMapHelper.read(from: istr)
            return iceP_s1
        }

        let (iceP_returnValue, iceP_s2) = try self.opSMap(s1: iceP_s1, current: current)

        return inS.setResult{ ostr in
            SMapHelper.write(to: ostr, value: iceP_s2)
            SMapHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opC(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_c1: C? = try inS.read { istr in
            var iceP_c1: C?
            try istr.read(C.self) { iceP_c1 = $0 }
            try istr.readPendingValues()
            return iceP_c1
        }

        let (iceP_returnValue, iceP_c2) = try self.opC(c1: iceP_c1, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_c2)
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_opCSeq(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_c1: CSeq = try inS.read { istr in
            let iceP_c1: CSeq = try CSeqHelper.read(from: istr)
            try istr.readPendingValues()
            return iceP_c1
        }

        let (iceP_returnValue, iceP_c2) = try self.opCSeq(c1: iceP_c1, current: current)

        return inS.setResult{ ostr in
            CSeqHelper.write(to: ostr, value: iceP_c2)
            CSeqHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_opCMap(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_c1: CMap = try inS.read { istr in
            let iceP_c1: CMap = try CMapHelper.read(from: istr)
            try istr.readPendingValues()
            return iceP_c1
        }

        let (iceP_returnValue, iceP_c2) = try self.opCMap(c1: iceP_c1, current: current)

        return inS.setResult{ ostr in
            CMapHelper.write(to: ostr, value: iceP_c2)
            CMapHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_shutdown(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.shutdown(current: current)

        return inS.setResult()
    }
}
