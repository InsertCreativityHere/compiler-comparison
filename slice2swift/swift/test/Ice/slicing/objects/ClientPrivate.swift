//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `ClientPrivate.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice

/// Traits for Slice class `D3`.
public struct D3Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::B", "::Test::D3"]
    public static let staticId = "::Test::D3"
}

/// Traits for Slice class `PCUnknown`.
public struct PCUnknownTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::PBase", "::Test::PCUnknown"]
    public static let staticId = "::Test::PCUnknown"
}

/// Traits for Slice class `PCDerived`.
public struct PCDerivedTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::PBase", "::Test::PCDerived", "::Test::PDerived", "::Test::Preserved"]
    public static let staticId = "::Test::PCDerived"
}

/// Traits for Slice class `PCDerived2`.
public struct PCDerived2Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::PBase", "::Test::PCDerived", "::Test::PCDerived2", "::Test::PDerived", "::Test::Preserved"]
    public static let staticId = "::Test::PCDerived2"
}

/// Traits for Slice class `PCDerived3`.
public struct PCDerived3Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::PBase", "::Test::PCDerived", "::Test::PCDerived2", "::Test::PCDerived3", "::Test::PDerived", "::Test::Preserved"]
    public static let staticId = "::Test::PCDerived3"
}

/// Traits for Slice class `CompactPCDerived`.
public struct CompactPCDerivedTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::CompactPCDerived", "::Test::CompactPDerived", "::Test::PBase", "::Test::Preserved"]
    public static let staticId = "::Test::CompactPCDerived"
}

/// :nodoc:
public class D3_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return D3.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceSlicingObjectsClientTest_D3() -> Ice.ValueTypeResolver {
        return D3_TypeResolver()
    }
}

open class D3: B {
    public var sd3: Swift.String = ""
    public var pd3: B? = nil

    public required init() {
        super.init()
    }

    public init(sb: Swift.String, pb: B?, sd3: Swift.String, pd3: B?) {
        self.sd3 = sd3
        self.pd3 = pd3
        super.init(sb: sb, pb: pb)
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return D3Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return D3Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.sd3 = try istr.read()
        try istr.read(B.self) { self.pd3 = $0 }
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: D3Traits.staticId, compactId: -1, last: false)
        ostr.write(self.sd3)
        ostr.write(self.pd3)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}

/// :nodoc:
public class PCUnknown_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return PCUnknown.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceSlicingObjectsClientTest_PCUnknown() -> Ice.ValueTypeResolver {
        return PCUnknown_TypeResolver()
    }
}

open class PCUnknown: PBase {
    public var pu: Swift.String = ""
    var _slicedData: Ice.SlicedData?

    public required init() {
        super.init()
    }

    public init(pi: Swift.Int32, pu: Swift.String) {
        self.pu = pu
        super.init(pi: pi)
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return PCUnknownTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return PCUnknownTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.pu = try istr.read()
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: PCUnknownTraits.staticId, compactId: -1, last: false)
        ostr.write(self.pu)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }

    /// Returns the sliced data if the value has a preserved-slice base class and has been sliced
    /// during un-marshaling of the value, nil is returned otherwise.
    ///
    /// returns: `Ice.SlicedData?` - The sliced data or nil
    open override func ice_getSlicedData() -> Ice.SlicedData? {
        return _slicedData
    }

    open override func _iceRead(from istr: Ice.InputStream) throws {
        istr.startValue()
        try _iceReadImpl(from: istr)
        _slicedData = try istr.endValue(preserve: true)
    }

    open override func _iceWrite(to ostr: Ice.OutputStream) {
        ostr.startValue(data: _slicedData)
        _iceWriteImpl(to: ostr)
        ostr.endValue()
    }
}

/// :nodoc:
public class PCDerived_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return PCDerived.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceSlicingObjectsClientTest_PCDerived() -> Ice.ValueTypeResolver {
        return PCDerived_TypeResolver()
    }
}

open class PCDerived: PDerived {
    public var pbs: PBaseSeq = PBaseSeq()

    public required init() {
        super.init()
    }

    public init(pi: Swift.Int32, ps: Swift.String, pb: PBase?, pbs: PBaseSeq) {
        self.pbs = pbs
        super.init(pi: pi, ps: ps, pb: pb)
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return PCDerivedTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return PCDerivedTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.pbs = try PBaseSeqHelper.read(from: istr)
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: PCDerivedTraits.staticId, compactId: -1, last: false)
        PBaseSeqHelper.write(to: ostr, value: self.pbs)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}

/// :nodoc:
public class PCDerived2_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return PCDerived2.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceSlicingObjectsClientTest_PCDerived2() -> Ice.ValueTypeResolver {
        return PCDerived2_TypeResolver()
    }
}

open class PCDerived2: PCDerived {
    public var pcd2: Swift.Int32 = 0

    public required init() {
        super.init()
    }

    public init(pi: Swift.Int32, ps: Swift.String, pb: PBase?, pbs: PBaseSeq, pcd2: Swift.Int32) {
        self.pcd2 = pcd2
        super.init(pi: pi, ps: ps, pb: pb, pbs: pbs)
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return PCDerived2Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return PCDerived2Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.pcd2 = try istr.read()
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: PCDerived2Traits.staticId, compactId: -1, last: false)
        ostr.write(self.pcd2)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}

/// :nodoc:
public class PCDerived3_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return PCDerived3.self
    }
}

public extension Ice.ClassResolver {
    @objc static func IceSlicingObjectsClientTest_PCDerived3() -> Ice.ValueTypeResolver {
        return PCDerived3_TypeResolver()
    }
}

open class PCDerived3: PCDerived2 {
    public var pcd3: Ice.Value? = nil

    public required init() {
        super.init()
    }

    public init(pi: Swift.Int32, ps: Swift.String, pb: PBase?, pbs: PBaseSeq, pcd2: Swift.Int32, pcd3: Ice.Value?) {
        self.pcd3 = pcd3
        super.init(pi: pi, ps: ps, pb: pb, pbs: pbs, pcd2: pcd2)
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return PCDerived3Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return PCDerived3Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read() { self.pcd3 = $0 }
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: PCDerived3Traits.staticId, compactId: -1, last: false)
        ostr.write(self.pcd3)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}

/// :nodoc:
public class CompactPCDerived_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return CompactPCDerived.self
    }
}

public extension Ice.TypeIdResolver {
    @objc static func TypeId_57() -> Swift.String {
        return "::Test::CompactPCDerived"
    }
}

public extension Ice.ClassResolver {
    @objc static func IceSlicingObjectsClientTest_CompactPCDerived() -> Ice.ValueTypeResolver {
        return CompactPCDerived_TypeResolver()
    }
}

open class CompactPCDerived: CompactPDerived {
    public var pbs: PBaseSeq = PBaseSeq()

    public required init() {
        super.init()
    }

    public init(pi: Swift.Int32, ps: Swift.String, pb: PBase?, pbs: PBaseSeq) {
        self.pbs = pbs
        super.init(pi: pi, ps: ps, pb: pb)
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return CompactPCDerivedTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return CompactPCDerivedTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.pbs = try PBaseSeqHelper.read(from: istr)
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CompactPCDerivedTraits.staticId, compactId: 57, last: false)
        PBaseSeqHelper.write(to: ostr, value: self.pbs)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}
