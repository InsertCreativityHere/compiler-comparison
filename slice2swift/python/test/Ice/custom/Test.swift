//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice

/// By default, sequence is received as a string.
public typealias ByteString = Foundation.Data

public typealias ByteList = Foundation.Data

/// By default, a sequence is received as a list.
public typealias StringList = [Swift.String]

public typealias StringTuple = [Swift.String]

public typealias BoolSeq1 = [Swift.Bool]

public typealias BoolSeq2 = [Swift.Bool]

public typealias ByteSeq1 = Foundation.Data

public typealias ByteSeq2 = Foundation.Data

public typealias ShortSeq1 = [Swift.Int16]

public typealias ShortSeq2 = [Swift.Int16]

public typealias IntSeq1 = [Swift.Int32]

public typealias IntSeq2 = [Swift.Int32]

public typealias LongSeq1 = [Swift.Int64]

public typealias LongSeq2 = [Swift.Int64]

public typealias FloatSeq1 = [Swift.Float]

public typealias FloatSeq2 = [Swift.Float]

public typealias DoubleSeq1 = [Swift.Double]

public typealias DoubleSeq2 = [Swift.Double]

public struct S {
    public var b1: ByteString = ByteString()
    public var b2: ByteString = ByteString()
    public var b3: ByteList = ByteList()
    public var b4: ByteList = ByteList()
    public var s1: StringList = StringList()
    public var s2: StringList = StringList()
    public var s3: StringTuple = StringTuple()
    public var s4: StringTuple = StringTuple()

    public init() {}

    public init(b1: ByteString, b2: ByteString, b3: ByteList, b4: ByteList, s1: StringList, s2: StringList, s3: StringTuple, s4: StringTuple) {
        self.b1 = b1
        self.b2 = b2
        self.b3 = b3
        self.b4 = b4
        self.s1 = s1
        self.s2 = s2
        self.s3 = s3
        self.s4 = s4
    }
}

/// An `Ice.InputStream` extension to read `S` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `S` structured value from the stream.
    ///
    /// - Returns: The structured value read from the stream.
    func read() throws -> S {
        var v = S()
        v.b1 = try self.read()
        v.b2 = try self.read()
        v.b3 = try self.read()
        v.b4 = try self.read()
        v.s1 = try self.read()
        v.s2 = try self.read()
        v.s3 = try self.read()
        v.s4 = try self.read()
        return v
    }

    /// Read an optional `S?` structured value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> S? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as S
    }
}

/// An `Ice.OutputStream` extension to write `S` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `S` structured value to the stream.
    ///
    /// - Parameter v: The value to write to the stream.
    func write(_ v: S) {
        self.write(v.b1)
        self.write(v.b2)
        self.write(v.b3)
        self.write(v.b4)
        self.write(v.s1)
        self.write(v.s2)
        self.write(v.s3)
        self.write(v.s4)
    }

    /// Write an optional `S?` structured value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The value to write to the stream.
    func write(tag: Swift.Int32, value: S?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// Traits for Slice interface `Custom`.
public struct CustomTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Custom"]
    public static let staticId = "::Test::Custom"
}

public protocol CustomPrx: Ice.ObjectPrx {}

private final class CustomPrxI: Ice.ObjectPrxI, CustomPrx {
    public override class func ice_staticId() -> Swift.String {
        return CustomTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: CustomPrx.Protocol) throws -> CustomPrx {
    try communicator.makeProxyImpl(proxyString) as CustomPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: CustomPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> CustomPrx? {
    return try await CustomPrxI.checkedCast(prx: prx, facet: facet, context: context) as CustomPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: CustomPrx.Protocol, facet: Swift.String? = nil) -> CustomPrx {
    return CustomPrxI.uncheckedCast(prx: prx, facet: facet) as CustomPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: CustomPrx.Protocol) -> Swift.String {
    return CustomTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `CustomPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: CustomPrx.Protocol) throws -> CustomPrx? {
        return try read() as CustomPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: CustomPrx.Protocol) throws -> CustomPrx? {
        return try read(tag: tag) as CustomPrxI?
    }
}

public extension CustomPrx {
    func opByteString1(_ iceP_b1: ByteString, context: Ice.Context? = nil) async throws -> (returnValue: ByteString, b2: ByteString) {
        return try await _impl._invoke(operation: "opByteString1",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_b1)
                                       },
                                       read: { istr in
                                           let iceP_b2: ByteString = try istr.read()
                                           let iceP_returnValue: ByteString = try istr.read()
                                           return (iceP_returnValue, iceP_b2)
                                       },
                                       context: context)
    }

    func opByteString2(_ iceP_b1: ByteString, context: Ice.Context? = nil) async throws -> (returnValue: ByteString, b2: ByteString) {
        return try await _impl._invoke(operation: "opByteString2",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_b1)
                                       },
                                       read: { istr in
                                           let iceP_b2: ByteString = try istr.read()
                                           let iceP_returnValue: ByteString = try istr.read()
                                           return (iceP_returnValue, iceP_b2)
                                       },
                                       context: context)
    }

    func opByteList1(_ iceP_b1: ByteList, context: Ice.Context? = nil) async throws -> (returnValue: ByteList, b2: ByteList) {
        return try await _impl._invoke(operation: "opByteList1",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_b1)
                                       },
                                       read: { istr in
                                           let iceP_b2: ByteList = try istr.read()
                                           let iceP_returnValue: ByteList = try istr.read()
                                           return (iceP_returnValue, iceP_b2)
                                       },
                                       context: context)
    }

    func opByteList2(_ iceP_b1: ByteList, context: Ice.Context? = nil) async throws -> (returnValue: ByteList, b2: ByteList) {
        return try await _impl._invoke(operation: "opByteList2",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_b1)
                                       },
                                       read: { istr in
                                           let iceP_b2: ByteList = try istr.read()
                                           let iceP_returnValue: ByteList = try istr.read()
                                           return (iceP_returnValue, iceP_b2)
                                       },
                                       context: context)
    }

    func opStringList1(_ iceP_s1: StringList, context: Ice.Context? = nil) async throws -> (returnValue: StringList, s2: StringList) {
        return try await _impl._invoke(operation: "opStringList1",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_s1)
                                       },
                                       read: { istr in
                                           let iceP_s2: StringList = try istr.read()
                                           let iceP_returnValue: StringList = try istr.read()
                                           return (iceP_returnValue, iceP_s2)
                                       },
                                       context: context)
    }

    func opStringList2(_ iceP_s1: StringList, context: Ice.Context? = nil) async throws -> (returnValue: StringList, s2: StringList) {
        return try await _impl._invoke(operation: "opStringList2",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_s1)
                                       },
                                       read: { istr in
                                           let iceP_s2: StringList = try istr.read()
                                           let iceP_returnValue: StringList = try istr.read()
                                           return (iceP_returnValue, iceP_s2)
                                       },
                                       context: context)
    }

    func opStringTuple1(_ iceP_s1: StringTuple, context: Ice.Context? = nil) async throws -> (returnValue: StringTuple, s2: StringTuple) {
        return try await _impl._invoke(operation: "opStringTuple1",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_s1)
                                       },
                                       read: { istr in
                                           let iceP_s2: StringTuple = try istr.read()
                                           let iceP_returnValue: StringTuple = try istr.read()
                                           return (iceP_returnValue, iceP_s2)
                                       },
                                       context: context)
    }

    func opStringTuple2(_ iceP_s1: StringTuple, context: Ice.Context? = nil) async throws -> (returnValue: StringTuple, s2: StringTuple) {
        return try await _impl._invoke(operation: "opStringTuple2",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_s1)
                                       },
                                       read: { istr in
                                           let iceP_s2: StringTuple = try istr.read()
                                           let iceP_returnValue: StringTuple = try istr.read()
                                           return (iceP_returnValue, iceP_s2)
                                       },
                                       context: context)
    }

    func sendS(_ iceP_val: S, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "sendS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_val)
                                       },
                                       context: context)
    }

    func sendC(_ iceP_val: C?, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "sendC",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_val)
                                           ostr.writePendingValues()
                                       },
                                       context: context)
    }

    func opBoolSeq(_ iceP_v1: BoolSeq1, context: Ice.Context? = nil) async throws -> (returnValue: BoolSeq1, v2: BoolSeq2) {
        return try await _impl._invoke(operation: "opBoolSeq",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_v1)
                                       },
                                       read: { istr in
                                           let iceP_v2: BoolSeq2 = try istr.read()
                                           let iceP_returnValue: BoolSeq1 = try istr.read()
                                           return (iceP_returnValue, iceP_v2)
                                       },
                                       context: context)
    }

    func opByteSeq(_ iceP_v1: ByteSeq1, context: Ice.Context? = nil) async throws -> (returnValue: ByteSeq1, v2: ByteSeq2) {
        return try await _impl._invoke(operation: "opByteSeq",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_v1)
                                       },
                                       read: { istr in
                                           let iceP_v2: ByteSeq2 = try istr.read()
                                           let iceP_returnValue: ByteSeq1 = try istr.read()
                                           return (iceP_returnValue, iceP_v2)
                                       },
                                       context: context)
    }

    func opShortSeq(_ iceP_v1: ShortSeq1, context: Ice.Context? = nil) async throws -> (returnValue: ShortSeq1, v2: ShortSeq2) {
        return try await _impl._invoke(operation: "opShortSeq",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_v1)
                                       },
                                       read: { istr in
                                           let iceP_v2: ShortSeq2 = try istr.read()
                                           let iceP_returnValue: ShortSeq1 = try istr.read()
                                           return (iceP_returnValue, iceP_v2)
                                       },
                                       context: context)
    }

    func opIntSeq(_ iceP_v1: IntSeq1, context: Ice.Context? = nil) async throws -> (returnValue: IntSeq1, v2: IntSeq2) {
        return try await _impl._invoke(operation: "opIntSeq",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_v1)
                                       },
                                       read: { istr in
                                           let iceP_v2: IntSeq2 = try istr.read()
                                           let iceP_returnValue: IntSeq1 = try istr.read()
                                           return (iceP_returnValue, iceP_v2)
                                       },
                                       context: context)
    }

    func opLongSeq(_ iceP_v1: LongSeq1, context: Ice.Context? = nil) async throws -> (returnValue: LongSeq1, v2: LongSeq2) {
        return try await _impl._invoke(operation: "opLongSeq",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_v1)
                                       },
                                       read: { istr in
                                           let iceP_v2: LongSeq2 = try istr.read()
                                           let iceP_returnValue: LongSeq1 = try istr.read()
                                           return (iceP_returnValue, iceP_v2)
                                       },
                                       context: context)
    }

    func opFloatSeq(_ iceP_v1: FloatSeq1, context: Ice.Context? = nil) async throws -> (returnValue: FloatSeq1, v2: FloatSeq2) {
        return try await _impl._invoke(operation: "opFloatSeq",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_v1)
                                       },
                                       read: { istr in
                                           let iceP_v2: FloatSeq2 = try istr.read()
                                           let iceP_returnValue: FloatSeq1 = try istr.read()
                                           return (iceP_returnValue, iceP_v2)
                                       },
                                       context: context)
    }

    func opDoubleSeq(_ iceP_v1: DoubleSeq1, context: Ice.Context? = nil) async throws -> (returnValue: DoubleSeq1, v2: DoubleSeq2) {
        return try await _impl._invoke(operation: "opDoubleSeq",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_v1)
                                       },
                                       read: { istr in
                                           let iceP_v2: DoubleSeq2 = try istr.read()
                                           let iceP_returnValue: DoubleSeq1 = try istr.read()
                                           return (iceP_returnValue, iceP_v2)
                                       },
                                       context: context)
    }

    func opBogusArrayNotExistsFactory(context: Ice.Context? = nil) async throws -> BoolSeq1 {
        return try await _impl._invoke(operation: "opBogusArrayNotExistsFactory",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: BoolSeq1 = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opBogusArrayThrowFactory(context: Ice.Context? = nil) async throws -> BoolSeq1 {
        return try await _impl._invoke(operation: "opBogusArrayThrowFactory",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: BoolSeq1 = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opBogusArrayType(context: Ice.Context? = nil) async throws -> BoolSeq1 {
        return try await _impl._invoke(operation: "opBogusArrayType",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: BoolSeq1 = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opBogusArrayNoneFactory(context: Ice.Context? = nil) async throws -> BoolSeq1 {
        return try await _impl._invoke(operation: "opBogusArrayNoneFactory",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: BoolSeq1 = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opBogusArraySignatureFactory(context: Ice.Context? = nil) async throws -> BoolSeq1 {
        return try await _impl._invoke(operation: "opBogusArraySignatureFactory",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: BoolSeq1 = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opBogusArrayNoCallableFactory(context: Ice.Context? = nil) async throws -> BoolSeq1 {
        return try await _impl._invoke(operation: "opBogusArrayNoCallableFactory",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: BoolSeq1 = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opD(_ iceP_d: D?, context: Ice.Context? = nil) async throws -> D? {
        return try await _impl._invoke(operation: "opD",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_d)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           var iceP_returnValue: D?
                                           try istr.read(D.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func shutdown(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "shutdown",
                                       mode: .Normal,
                                       context: context)
    }
}

@_documentation(visibility: internal)
public class C_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return C.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_C() -> Ice.ValueTypeResolver {
        return C_TypeResolver()
    }
}

open class C: Ice.Value {
    public var b1: ByteString = ByteString()
    public var b2: ByteString = ByteString()
    public var b3: ByteList = ByteList()
    public var b4: ByteList = ByteList()
    public var s1: StringList = StringList()
    public var s2: StringList = StringList()
    public var s3: StringTuple = StringTuple()
    public var s4: StringTuple = StringTuple()

    public required init() {}

    public init(b1: ByteString, b2: ByteString, b3: ByteList, b4: ByteList, s1: StringList, s2: StringList, s3: StringTuple, s4: StringTuple) {
        self.b1 = b1
        self.b2 = b2
        self.b3 = b3
        self.b4 = b4
        self.s1 = s1
        self.s2 = s2
        self.s3 = s3
        self.s4 = s4
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::C" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.b1 = try istr.read()
        self.b2 = try istr.read()
        self.b3 = try istr.read()
        self.b4 = try istr.read()
        self.s1 = try istr.read()
        self.s2 = try istr.read()
        self.s3 = try istr.read()
        self.s4 = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: C.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.b1)
        ostr.write(self.b2)
        ostr.write(self.b3)
        ostr.write(self.b4)
        ostr.write(self.s1)
        ostr.write(self.s2)
        ostr.write(self.s3)
        ostr.write(self.s4)
        ostr.endSlice()
    }
}

@_documentation(visibility: internal)
public class D_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return D.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_D() -> Ice.ValueTypeResolver {
        return D_TypeResolver()
    }
}

open class D: Ice.Value {
    public var boolSeq: BoolSeq1? = nil
    public var byteSeq: ByteSeq1? = nil
    public var shortSeq: ShortSeq1? = nil
    public var intSeq: IntSeq1? = nil
    public var longSeq: LongSeq1? = nil
    public var floatSeq: FloatSeq1? = nil
    public var doubleSeq: DoubleSeq1? = nil

    public required init() {}

    public init(boolSeq: BoolSeq1?, byteSeq: ByteSeq1?, shortSeq: ShortSeq1?, intSeq: IntSeq1?, longSeq: LongSeq1?, floatSeq: FloatSeq1?, doubleSeq: DoubleSeq1?) {
        self.boolSeq = boolSeq
        self.byteSeq = byteSeq
        self.shortSeq = shortSeq
        self.intSeq = intSeq
        self.longSeq = longSeq
        self.floatSeq = floatSeq
        self.doubleSeq = doubleSeq
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::D" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.boolSeq = try istr.read(tag: 1)
        self.byteSeq = try istr.read(tag: 2)
        self.shortSeq = try istr.read(tag: 3)
        self.intSeq = try istr.read(tag: 4)
        self.longSeq = try istr.read(tag: 5)
        self.floatSeq = try istr.read(tag: 6)
        self.doubleSeq = try istr.read(tag: 7)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: D.ice_staticId(), compactId: -1, last: true)
        ostr.write(tag: 1, value: self.boolSeq)
        ostr.write(tag: 2, value: self.byteSeq)
        ostr.write(tag: 3, value: self.shortSeq)
        ostr.write(tag: 4, value: self.intSeq)
        ostr.write(tag: 5, value: self.longSeq)
        ostr.write(tag: 6, value: self.floatSeq)
        ostr.write(tag: 7, value: self.doubleSeq)
        ostr.endSlice()
    }
}


/// Dispatcher for `Custom` servants.
public struct CustomDisp: Ice.Dispatcher {
    public let servant: Custom
    private static let defaultObject = Ice.ObjectI<CustomTraits>()

    public init(_ servant: Custom) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "ice_id":
            try await (servant as? Ice.Object ?? CustomDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? CustomDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? CustomDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? CustomDisp.defaultObject)._iceD_ice_ping(request)
        case "opBogusArrayNoCallableFactory":
            try await servant._iceD_opBogusArrayNoCallableFactory(request)
        case "opBogusArrayNoneFactory":
            try await servant._iceD_opBogusArrayNoneFactory(request)
        case "opBogusArrayNotExistsFactory":
            try await servant._iceD_opBogusArrayNotExistsFactory(request)
        case "opBogusArraySignatureFactory":
            try await servant._iceD_opBogusArraySignatureFactory(request)
        case "opBogusArrayThrowFactory":
            try await servant._iceD_opBogusArrayThrowFactory(request)
        case "opBogusArrayType":
            try await servant._iceD_opBogusArrayType(request)
        case "opBoolSeq":
            try await servant._iceD_opBoolSeq(request)
        case "opByteList1":
            try await servant._iceD_opByteList1(request)
        case "opByteList2":
            try await servant._iceD_opByteList2(request)
        case "opByteSeq":
            try await servant._iceD_opByteSeq(request)
        case "opByteString1":
            try await servant._iceD_opByteString1(request)
        case "opByteString2":
            try await servant._iceD_opByteString2(request)
        case "opD":
            try await servant._iceD_opD(request)
        case "opDoubleSeq":
            try await servant._iceD_opDoubleSeq(request)
        case "opFloatSeq":
            try await servant._iceD_opFloatSeq(request)
        case "opIntSeq":
            try await servant._iceD_opIntSeq(request)
        case "opLongSeq":
            try await servant._iceD_opLongSeq(request)
        case "opShortSeq":
            try await servant._iceD_opShortSeq(request)
        case "opStringList1":
            try await servant._iceD_opStringList1(request)
        case "opStringList2":
            try await servant._iceD_opStringList2(request)
        case "opStringTuple1":
            try await servant._iceD_opStringTuple1(request)
        case "opStringTuple2":
            try await servant._iceD_opStringTuple2(request)
        case "sendC":
            try await servant._iceD_sendC(request)
        case "sendS":
            try await servant._iceD_sendS(request)
        case "shutdown":
            try await servant._iceD_shutdown(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol Custom {
    func opByteString1(b1: ByteString, current: Ice.Current) async throws -> (returnValue: ByteString, b2: ByteString)

    func opByteString2(b1: ByteString, current: Ice.Current) async throws -> (returnValue: ByteString, b2: ByteString)

    func opByteList1(b1: ByteList, current: Ice.Current) async throws -> (returnValue: ByteList, b2: ByteList)

    func opByteList2(b1: ByteList, current: Ice.Current) async throws -> (returnValue: ByteList, b2: ByteList)

    func opStringList1(s1: StringList, current: Ice.Current) async throws -> (returnValue: StringList, s2: StringList)

    func opStringList2(s1: StringList, current: Ice.Current) async throws -> (returnValue: StringList, s2: StringList)

    func opStringTuple1(s1: StringTuple, current: Ice.Current) async throws -> (returnValue: StringTuple, s2: StringTuple)

    func opStringTuple2(s1: StringTuple, current: Ice.Current) async throws -> (returnValue: StringTuple, s2: StringTuple)

    func sendS(val: S, current: Ice.Current) async throws

    func sendC(val: C?, current: Ice.Current) async throws

    func opBoolSeq(v1: BoolSeq1, current: Ice.Current) async throws -> (returnValue: BoolSeq1, v2: BoolSeq2)

    func opByteSeq(v1: ByteSeq1, current: Ice.Current) async throws -> (returnValue: ByteSeq1, v2: ByteSeq2)

    func opShortSeq(v1: ShortSeq1, current: Ice.Current) async throws -> (returnValue: ShortSeq1, v2: ShortSeq2)

    func opIntSeq(v1: IntSeq1, current: Ice.Current) async throws -> (returnValue: IntSeq1, v2: IntSeq2)

    func opLongSeq(v1: LongSeq1, current: Ice.Current) async throws -> (returnValue: LongSeq1, v2: LongSeq2)

    func opFloatSeq(v1: FloatSeq1, current: Ice.Current) async throws -> (returnValue: FloatSeq1, v2: FloatSeq2)

    func opDoubleSeq(v1: DoubleSeq1, current: Ice.Current) async throws -> (returnValue: DoubleSeq1, v2: DoubleSeq2)

    func opBogusArrayNotExistsFactory(current: Ice.Current) async throws -> BoolSeq1

    func opBogusArrayThrowFactory(current: Ice.Current) async throws -> BoolSeq1

    func opBogusArrayType(current: Ice.Current) async throws -> BoolSeq1

    func opBogusArrayNoneFactory(current: Ice.Current) async throws -> BoolSeq1

    func opBogusArraySignatureFactory(current: Ice.Current) async throws -> BoolSeq1

    func opBogusArrayNoCallableFactory(current: Ice.Current) async throws -> BoolSeq1

    func opD(d: D?, current: Ice.Current) async throws -> D?

    func shutdown(current: Ice.Current) async throws
}

extension Custom {
    public func _iceD_opByteString1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_b1: ByteString = try istr.read()
        let result = try await self.opByteString1(b1: iceP_b1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_b2) = value
            ostr.write(iceP_b2)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opByteString2(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_b1: ByteString = try istr.read()
        let result = try await self.opByteString2(b1: iceP_b1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_b2) = value
            ostr.write(iceP_b2)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opByteList1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_b1: ByteList = try istr.read()
        let result = try await self.opByteList1(b1: iceP_b1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_b2) = value
            ostr.write(iceP_b2)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opByteList2(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_b1: ByteList = try istr.read()
        let result = try await self.opByteList2(b1: iceP_b1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_b2) = value
            ostr.write(iceP_b2)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opStringList1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_s1: StringList = try istr.read()
        let result = try await self.opStringList1(s1: iceP_s1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_s2) = value
            ostr.write(iceP_s2)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opStringList2(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_s1: StringList = try istr.read()
        let result = try await self.opStringList2(s1: iceP_s1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_s2) = value
            ostr.write(iceP_s2)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opStringTuple1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_s1: StringTuple = try istr.read()
        let result = try await self.opStringTuple1(s1: iceP_s1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_s2) = value
            ostr.write(iceP_s2)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opStringTuple2(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_s1: StringTuple = try istr.read()
        let result = try await self.opStringTuple2(s1: iceP_s1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_s2) = value
            ostr.write(iceP_s2)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_sendS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_val: S = try istr.read()
        try await self.sendS(val: iceP_val, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_sendC(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_val: C?
        try istr.read(C.self) { iceP_val = $0 }
        try istr.readPendingValues()
        try await self.sendC(val: iceP_val, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_opBoolSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_v1: BoolSeq1 = try istr.read()
        let result = try await self.opBoolSeq(v1: iceP_v1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_v2) = value
            ostr.write(iceP_v2)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opByteSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_v1: ByteSeq1 = try istr.read()
        let result = try await self.opByteSeq(v1: iceP_v1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_v2) = value
            ostr.write(iceP_v2)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opShortSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_v1: ShortSeq1 = try istr.read()
        let result = try await self.opShortSeq(v1: iceP_v1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_v2) = value
            ostr.write(iceP_v2)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opIntSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_v1: IntSeq1 = try istr.read()
        let result = try await self.opIntSeq(v1: iceP_v1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_v2) = value
            ostr.write(iceP_v2)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opLongSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_v1: LongSeq1 = try istr.read()
        let result = try await self.opLongSeq(v1: iceP_v1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_v2) = value
            ostr.write(iceP_v2)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opFloatSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_v1: FloatSeq1 = try istr.read()
        let result = try await self.opFloatSeq(v1: iceP_v1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_v2) = value
            ostr.write(iceP_v2)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opDoubleSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_v1: DoubleSeq1 = try istr.read()
        let result = try await self.opDoubleSeq(v1: iceP_v1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_v2) = value
            ostr.write(iceP_v2)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opBogusArrayNotExistsFactory(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.opBogusArrayNotExistsFactory(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opBogusArrayThrowFactory(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.opBogusArrayThrowFactory(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opBogusArrayType(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.opBogusArrayType(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opBogusArrayNoneFactory(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.opBogusArrayNoneFactory(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opBogusArraySignatureFactory(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.opBogusArraySignatureFactory(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opBogusArrayNoCallableFactory(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.opBogusArrayNoCallableFactory(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opD(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_d: D?
        try istr.read(D.self) { iceP_d = $0 }
        try istr.readPendingValues()
        let result = try await self.opD(d: iceP_d, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_shutdown(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.shutdown(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}
