//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice

/// Traits for Slice interface `MyInterface`.
public struct MyInterfaceTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::MyInterface"]
    public static let staticId = "::Test::MyInterface"
}

public enum MyEnum: Swift.UInt8 {
    case MyEnumMember = 0
    public init() {
        self = .MyEnumMember
    }
}

/// An `Ice.InputStream` extension to read `MyEnum` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - Returns:  The enumerated value.
    func read() throws -> MyEnum {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 0)
        guard let val = MyEnum(rawValue: rawValue) else {
            throw Ice.MarshalException("invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The enumerated value.
    func read(tag: Swift.Int32) throws -> MyEnum? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as MyEnum
    }
}

/// An `Ice.OutputStream` extension to write `MyEnum` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// - Parameter v: The enumerator to write.
    func write(_ v: MyEnum) {
        write(enum: v.rawValue, maxValue: 0)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The enumerator to write.
    func write(tag: Swift.Int32, value: MyEnum?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 0)
    }
}

public struct SmallStruct: Swift.Hashable {
    public var m: Swift.UInt8 = 0

    public init() {}

    public init(m: Swift.UInt8) {
        self.m = m
    }
}

/// An `Ice.InputStream` extension to read `SmallStruct` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `SmallStruct` structured value from the stream.
    ///
    /// - Returns: The structured value read from the stream.
    func read() throws -> SmallStruct {
        var v = SmallStruct()
        v.m = try self.read()
        return v
    }

    /// Read an optional `SmallStruct?` structured value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> SmallStruct? {
        guard try readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try skipSize()
        return try read() as SmallStruct
    }
}

/// An `Ice.OutputStream` extension to write `SmallStruct` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `SmallStruct` structured value to the stream.
    ///
    /// - Parameter v: The value to write to the stream.
    func write(_ v: SmallStruct) {
        self.write(v.m)
    }

    /// Write an optional `SmallStruct?` structured value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The value to write to the stream.
    func write(tag: Swift.Int32, value: SmallStruct?) {
        if let v = value {
            if writeOptional(tag: tag, format: .VSize) {
                write(size: 1)
                write(v)
            }
        }
    }
}

public struct FixedStruct: Swift.Hashable {
    public var m: Swift.Int32 = 0

    public init() {}

    public init(m: Swift.Int32) {
        self.m = m
    }
}

/// An `Ice.InputStream` extension to read `FixedStruct` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `FixedStruct` structured value from the stream.
    ///
    /// - Returns: The structured value read from the stream.
    func read() throws -> FixedStruct {
        var v = FixedStruct()
        v.m = try self.read()
        return v
    }

    /// Read an optional `FixedStruct?` structured value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> FixedStruct? {
        guard try readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try skipSize()
        return try read() as FixedStruct
    }
}

/// An `Ice.OutputStream` extension to write `FixedStruct` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `FixedStruct` structured value to the stream.
    ///
    /// - Parameter v: The value to write to the stream.
    func write(_ v: FixedStruct) {
        self.write(v.m)
    }

    /// Write an optional `FixedStruct?` structured value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The value to write to the stream.
    func write(tag: Swift.Int32, value: FixedStruct?) {
        if let v = value {
            if writeOptional(tag: tag, format: .VSize) {
                write(size: 4)
                write(v)
            }
        }
    }
}

public struct VarStruct: Swift.Hashable {
    public var m: Swift.String = ""

    public init() {}

    public init(m: Swift.String) {
        self.m = m
    }
}

/// An `Ice.InputStream` extension to read `VarStruct` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `VarStruct` structured value from the stream.
    ///
    /// - Returns: The structured value read from the stream.
    func read() throws -> VarStruct {
        var v = VarStruct()
        v.m = try self.read()
        return v
    }

    /// Read an optional `VarStruct?` structured value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> VarStruct? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as VarStruct
    }
}

/// An `Ice.OutputStream` extension to write `VarStruct` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `VarStruct` structured value to the stream.
    ///
    /// - Parameter v: The value to write to the stream.
    func write(_ v: VarStruct) {
        self.write(v.m)
    }

    /// Write an optional `VarStruct?` structured value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The value to write to the stream.
    func write(tag: Swift.Int32, value: VarStruct?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public typealias ByteSeq = Foundation.Data

public typealias BoolSeq = [Swift.Bool]

public typealias ShortSeq = [Swift.Int16]

public typealias IntSeq = [Swift.Int32]

public typealias LongSeq = [Swift.Int64]

public typealias FloatSeq = [Swift.Float]

public typealias DoubleSeq = [Swift.Double]

public typealias StringSeq = [Swift.String]

public typealias MyEnumSeq = [MyEnum]

/// Helper class to read and write `MyEnumSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyEnumSeqHelper {
    /// Read a `MyEnumSeq` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyEnumSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = MyEnumSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: MyEnum = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `MyEnumSeq?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyEnumSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `MyEnumSeq` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyEnumSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `MyEnumSeq?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: MyEnumSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias SmallStructSeq = [SmallStruct]

/// Helper class to read and write `SmallStructSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct SmallStructSeqHelper {
    /// Read a `SmallStructSeq` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> SmallStructSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = SmallStructSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: SmallStruct = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `SmallStructSeq?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> SmallStructSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        return try read(from: istr)
    }

    /// Write a `SmallStructSeq` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: SmallStructSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `SmallStructSeq?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: SmallStructSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .VSize) {
            write(to: ostr, value: val)
        }
    }
}

public typealias SmallStructList = [SmallStruct]

/// Helper class to read and write `SmallStructList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct SmallStructListHelper {
    /// Read a `SmallStructList` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> SmallStructList {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = SmallStructList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: SmallStruct = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `SmallStructList?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> SmallStructList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        return try read(from: istr)
    }

    /// Write a `SmallStructList` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: SmallStructList) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `SmallStructList?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: SmallStructList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .VSize) {
            write(to: ostr, value: val)
        }
    }
}

public typealias FixedStructSeq = [FixedStruct]

/// Helper class to read and write `FixedStructSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct FixedStructSeqHelper {
    /// Read a `FixedStructSeq` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> FixedStructSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 4)
        var v = FixedStructSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: FixedStruct = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `FixedStructSeq?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> FixedStructSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Write a `FixedStructSeq` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: FixedStructSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `FixedStructSeq?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: FixedStructSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 4) {
            write(to: ostr, value: val)
        }
    }
}

public typealias FixedStructList = [FixedStruct]

/// Helper class to read and write `FixedStructList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct FixedStructListHelper {
    /// Read a `FixedStructList` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> FixedStructList {
        let sz = try istr.readAndCheckSeqSize(minSize: 4)
        var v = FixedStructList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: FixedStruct = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `FixedStructList?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> FixedStructList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Write a `FixedStructList` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: FixedStructList) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `FixedStructList?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: FixedStructList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 4) {
            write(to: ostr, value: val)
        }
    }
}

public typealias VarStructSeq = [VarStruct]

/// Helper class to read and write `VarStructSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct VarStructSeqHelper {
    /// Read a `VarStructSeq` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> VarStructSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = VarStructSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: VarStruct = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `VarStructSeq?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> VarStructSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `VarStructSeq` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: VarStructSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `VarStructSeq?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: VarStructSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias MyInterfacePrxSeq = [MyInterfacePrx?]

/// Helper class to read and write `MyInterfacePrxSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyInterfacePrxSeqHelper {
    /// Read a `MyInterfacePrxSeq` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyInterfacePrxSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = MyInterfacePrxSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: MyInterfacePrx? = try istr.read(MyInterfacePrx.self)
            v.append(j)
        }
        return v
    }

    /// Read an optional `MyInterfacePrxSeq?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyInterfacePrxSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `MyInterfacePrxSeq` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyInterfacePrxSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `MyInterfacePrxSeq?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: MyInterfacePrxSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias Serializable = Foundation.Data

public typealias IntIntDict = [Swift.Int32: Swift.Int32]

/// Helper class to read and write `IntIntDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct IntIntDictHelper {
    /// Read a `IntIntDict` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> IntIntDict {
        let sz = try Swift.Int(istr.readSize())
        var v = IntIntDict()
        for _ in 0 ..< sz {
            let key: Swift.Int32 = try istr.read()
            let value: Swift.Int32 = try istr.read()
            v[key] = value
        }
        return v
    }

    /// Read an optional `IntIntDict?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> IntIntDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Write a `IntIntDict` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: IntIntDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `IntIntDict?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: IntIntDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 8) {
            write(to: ostr, value: val)
        }
    }
}

public typealias StringIntDict = [Swift.String: Swift.Int32]

/// Helper class to read and write `StringIntDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringIntDictHelper {
    /// Read a `StringIntDict` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringIntDict {
        let sz = try Swift.Int(istr.readSize())
        var v = StringIntDict()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: Swift.Int32 = try istr.read()
            v[key] = value
        }
        return v
    }

    /// Read an optional `StringIntDict?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringIntDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `StringIntDict` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringIntDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `StringIntDict?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: StringIntDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias IntEnumDict = [Swift.Int32: MyEnum]

/// Helper class to read and write `IntEnumDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct IntEnumDictHelper {
    /// Read a `IntEnumDict` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> IntEnumDict {
        let sz = try Swift.Int(istr.readSize())
        var v = IntEnumDict()
        for _ in 0 ..< sz {
            let key: Swift.Int32 = try istr.read()
            let value: MyEnum = try istr.read()
            v[key] = value
        }
        return v
    }

    /// Read an optional `IntEnumDict?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> IntEnumDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `IntEnumDict` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: IntEnumDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `IntEnumDict?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: IntEnumDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias IntFixedStructDict = [Swift.Int32: FixedStruct]

/// Helper class to read and write `IntFixedStructDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct IntFixedStructDictHelper {
    /// Read a `IntFixedStructDict` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> IntFixedStructDict {
        let sz = try Swift.Int(istr.readSize())
        var v = IntFixedStructDict()
        for _ in 0 ..< sz {
            let key: Swift.Int32 = try istr.read()
            let value: FixedStruct = try istr.read()
            v[key] = value
        }
        return v
    }

    /// Read an optional `IntFixedStructDict?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> IntFixedStructDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Write a `IntFixedStructDict` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: IntFixedStructDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `IntFixedStructDict?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: IntFixedStructDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 8) {
            write(to: ostr, value: val)
        }
    }
}

public typealias IntVarStructDict = [Swift.Int32: VarStruct]

/// Helper class to read and write `IntVarStructDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct IntVarStructDictHelper {
    /// Read a `IntVarStructDict` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> IntVarStructDict {
        let sz = try Swift.Int(istr.readSize())
        var v = IntVarStructDict()
        for _ in 0 ..< sz {
            let key: Swift.Int32 = try istr.read()
            let value: VarStruct = try istr.read()
            v[key] = value
        }
        return v
    }

    /// Read an optional `IntVarStructDict?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> IntVarStructDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `IntVarStructDict` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: IntVarStructDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `IntVarStructDict?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: IntVarStructDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias IntMyInterfacePrxDict = [Swift.Int32: MyInterfacePrx?]

/// Helper class to read and write `IntMyInterfacePrxDict` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct IntMyInterfacePrxDictHelper {
    /// Read a `IntMyInterfacePrxDict` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> IntMyInterfacePrxDict {
        let sz = try Swift.Int(istr.readSize())
        var v = IntMyInterfacePrxDict()
        for _ in 0 ..< sz {
            let key: Swift.Int32 = try istr.read()
            let value: MyInterfacePrx? = try istr.read(MyInterfacePrx.self)
            v[key] = value
        }
        return v
    }

    /// Read an optional `IntMyInterfacePrxDict?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> IntMyInterfacePrxDict? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `IntMyInterfacePrxDict` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: IntMyInterfacePrxDict) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `IntMyInterfacePrxDict?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: IntMyInterfacePrxDict?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

@_documentation(visibility: internal)
public class OptionalException_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return OptionalException.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_OptionalException() -> Ice.UserExceptionTypeResolver {
        return OptionalException_TypeResolver()
    }
}

open class OptionalException: Ice.UserException, @unchecked Sendable {
    public var req: Swift.Bool = false
    public var a: Swift.Int32? = 5
    public var b: Swift.String? = nil

    public required init() {}

    public init(req: Swift.Bool, a: Swift.Int32?, b: Swift.String?) {
        self.req = req
        self.a = a
        self.b = b
    }

    /// - Returns: The Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Test::OptionalException" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: OptionalException.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.req)
        ostr.write(tag: 1, value: self.a)
        ostr.write(tag: 2, value: self.b)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.req = try istr.read()
        self.a = try istr.read(tag: 1)
        self.b = try istr.read(tag: 2)
        try istr.endSlice()
    }
}

@_documentation(visibility: internal)
public class DerivedException_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return DerivedException.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_DerivedException() -> Ice.UserExceptionTypeResolver {
        return DerivedException_TypeResolver()
    }
}

open class DerivedException: OptionalException, @unchecked Sendable {
    public var d1: Swift.String = ""
    public var ss: Swift.String? = "test"
    public var d2: Swift.String = ""

    public required init() {
        super.init()
    }

    public init(req: Swift.Bool, a: Swift.Int32?, b: Swift.String?, d1: Swift.String, ss: Swift.String?, d2: Swift.String) {
        self.d1 = d1
        self.ss = ss
        self.d2 = d2
        super.init(req: req, a: a, b: b)
    }

    /// - Returns: The Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Test::DerivedException" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: DerivedException.ice_staticId(), compactId: -1, last: false)
        ostr.write(self.d1)
        ostr.write(self.d2)
        ostr.write(tag: 600, value: self.ss)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.d1 = try istr.read()
        self.d2 = try istr.read()
        self.ss = try istr.read(tag: 600)
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }
}

@_documentation(visibility: internal)
public class RequiredException_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return RequiredException.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_RequiredException() -> Ice.UserExceptionTypeResolver {
        return RequiredException_TypeResolver()
    }
}

open class RequiredException: OptionalException, @unchecked Sendable {
    public var ss: Swift.String = "test"

    public required init() {
        super.init()
    }

    public init(req: Swift.Bool, a: Swift.Int32?, b: Swift.String?, ss: Swift.String) {
        self.ss = ss
        super.init(req: req, a: a, b: b)
    }

    /// - Returns: The Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Test::RequiredException" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: RequiredException.ice_staticId(), compactId: -1, last: false)
        ostr.write(self.ss)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.ss = try istr.read()
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }
}

public struct G1: Swift.Hashable {
    public var a: Swift.String = ""

    public init() {}

    public init(a: Swift.String) {
        self.a = a
    }
}

/// An `Ice.InputStream` extension to read `G1` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `G1` structured value from the stream.
    ///
    /// - Returns: The structured value read from the stream.
    func read() throws -> G1 {
        var v = G1()
        v.a = try self.read()
        return v
    }

    /// Read an optional `G1?` structured value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> G1? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as G1
    }
}

/// An `Ice.OutputStream` extension to write `G1` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `G1` structured value to the stream.
    ///
    /// - Parameter v: The value to write to the stream.
    func write(_ v: G1) {
        self.write(v.a)
    }

    /// Write an optional `G1?` structured value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The value to write to the stream.
    func write(tag: Swift.Int32, value: G1?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public struct G2: Swift.Hashable {
    public var a: Swift.Int64 = 0

    public init() {}

    public init(a: Swift.Int64) {
        self.a = a
    }
}

/// An `Ice.InputStream` extension to read `G2` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `G2` structured value from the stream.
    ///
    /// - Returns: The structured value read from the stream.
    func read() throws -> G2 {
        var v = G2()
        v.a = try self.read()
        return v
    }

    /// Read an optional `G2?` structured value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> G2? {
        guard try readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try skipSize()
        return try read() as G2
    }
}

/// An `Ice.OutputStream` extension to write `G2` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `G2` structured value to the stream.
    ///
    /// - Parameter v: The value to write to the stream.
    func write(_ v: G2) {
        self.write(v.a)
    }

    /// Write an optional `G2?` structured value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The value to write to the stream.
    func write(tag: Swift.Int32, value: G2?) {
        if let v = value {
            if writeOptional(tag: tag, format: .VSize) {
                write(size: 8)
                write(v)
            }
        }
    }
}

/// Traits for Slice interface `Initial`.
public struct InitialTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Initial"]
    public static let staticId = "::Test::Initial"
}

public protocol MyInterfacePrx: Ice.ObjectPrx {}

private final class MyInterfacePrxI: Ice.ObjectPrxI, MyInterfacePrx {
    public override class func ice_staticId() -> Swift.String {
        return MyInterfaceTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: MyInterfacePrx.Protocol) throws -> MyInterfacePrx {
    try communicator.makeProxyImpl(proxyString) as MyInterfacePrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: MyInterfacePrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> MyInterfacePrx? {
    return try await MyInterfacePrxI.checkedCast(prx: prx, facet: facet, context: context) as MyInterfacePrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: MyInterfacePrx.Protocol, facet: Swift.String? = nil) -> MyInterfacePrx {
    return MyInterfacePrxI.uncheckedCast(prx: prx, facet: facet) as MyInterfacePrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: MyInterfacePrx.Protocol) -> Swift.String {
    return MyInterfaceTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `MyInterfacePrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: MyInterfacePrx.Protocol) throws -> MyInterfacePrx? {
        return try read() as MyInterfacePrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: MyInterfacePrx.Protocol) throws -> MyInterfacePrx? {
        return try read(tag: tag) as MyInterfacePrxI?
    }
}

public extension MyInterfacePrx {
    func op(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "op",
                                       mode: .Normal,
                                       context: context)
    }
}

public protocol InitialPrx: Ice.ObjectPrx {}

private final class InitialPrxI: Ice.ObjectPrxI, InitialPrx {
    public override class func ice_staticId() -> Swift.String {
        return InitialTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: InitialPrx.Protocol) throws -> InitialPrx {
    try communicator.makeProxyImpl(proxyString) as InitialPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: InitialPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> InitialPrx? {
    return try await InitialPrxI.checkedCast(prx: prx, facet: facet, context: context) as InitialPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: InitialPrx.Protocol, facet: Swift.String? = nil) -> InitialPrx {
    return InitialPrxI.uncheckedCast(prx: prx, facet: facet) as InitialPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: InitialPrx.Protocol) -> Swift.String {
    return InitialTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `InitialPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: InitialPrx.Protocol) throws -> InitialPrx? {
        return try read() as InitialPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: InitialPrx.Protocol) throws -> InitialPrx? {
        return try read(tag: tag) as InitialPrxI?
    }
}

public extension InitialPrx {
    func shutdown(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "shutdown",
                                       mode: .Normal,
                                       context: context)
    }

    func pingPong(_ iceP_o: Ice.Value?, context: Ice.Context? = nil) async throws -> Ice.Value? {
        return try await _impl._invoke(operation: "pingPong",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_o)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           var iceP_returnValue: Ice.Value?
                                           try istr.read() { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opOptionalException(a iceP_a: Swift.Int32? = nil, b iceP_b: Swift.String? = nil, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "opOptionalException",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(tag: 1, value: iceP_a)
                                           ostr.write(tag: 2, value: iceP_b)
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as OptionalException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    func opDerivedException(a iceP_a: Swift.Int32? = nil, b iceP_b: Swift.String? = nil, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "opDerivedException",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(tag: 1, value: iceP_a)
                                           ostr.write(tag: 2, value: iceP_b)
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as OptionalException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    func opRequiredException(a iceP_a: Swift.Int32? = nil, b iceP_b: Swift.String? = nil, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "opRequiredException",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(tag: 1, value: iceP_a)
                                           ostr.write(tag: 2, value: iceP_b)
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as OptionalException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    func opByte(_ iceP_p1: Swift.UInt8? = nil, context: Ice.Context? = nil) async throws -> (returnValue: Swift.UInt8?, p3: Swift.UInt8?) {
        return try await _impl._invoke(operation: "opByte",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Swift.UInt8? = try istr.read(tag: 1)
                                           let iceP_p3: Swift.UInt8? = try istr.read(tag: 3)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opBool(_ iceP_p1: Swift.Bool? = nil, context: Ice.Context? = nil) async throws -> (returnValue: Swift.Bool?, p3: Swift.Bool?) {
        return try await _impl._invoke(operation: "opBool",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Swift.Bool? = try istr.read(tag: 1)
                                           let iceP_p3: Swift.Bool? = try istr.read(tag: 3)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opShort(_ iceP_p1: Swift.Int16? = nil, context: Ice.Context? = nil) async throws -> (returnValue: Swift.Int16?, p3: Swift.Int16?) {
        return try await _impl._invoke(operation: "opShort",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Swift.Int16? = try istr.read(tag: 1)
                                           let iceP_p3: Swift.Int16? = try istr.read(tag: 3)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opInt(_ iceP_p1: Swift.Int32? = nil, context: Ice.Context? = nil) async throws -> (returnValue: Swift.Int32?, p3: Swift.Int32?) {
        return try await _impl._invoke(operation: "opInt",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Swift.Int32? = try istr.read(tag: 1)
                                           let iceP_p3: Swift.Int32? = try istr.read(tag: 3)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opLong(_ iceP_p1: Swift.Int64? = nil, context: Ice.Context? = nil) async throws -> (returnValue: Swift.Int64?, p3: Swift.Int64?) {
        return try await _impl._invoke(operation: "opLong",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(tag: 1, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_p3: Swift.Int64? = try istr.read(tag: 2)
                                           let iceP_returnValue: Swift.Int64? = try istr.read(tag: 3)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opFloat(_ iceP_p1: Swift.Float? = nil, context: Ice.Context? = nil) async throws -> (returnValue: Swift.Float?, p3: Swift.Float?) {
        return try await _impl._invoke(operation: "opFloat",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Swift.Float? = try istr.read(tag: 1)
                                           let iceP_p3: Swift.Float? = try istr.read(tag: 3)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opDouble(_ iceP_p1: Swift.Double? = nil, context: Ice.Context? = nil) async throws -> (returnValue: Swift.Double?, p3: Swift.Double?) {
        return try await _impl._invoke(operation: "opDouble",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Swift.Double? = try istr.read(tag: 1)
                                           let iceP_p3: Swift.Double? = try istr.read(tag: 3)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opString(_ iceP_p1: Swift.String? = nil, context: Ice.Context? = nil) async throws -> (returnValue: Swift.String?, p3: Swift.String?) {
        return try await _impl._invoke(operation: "opString",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Swift.String? = try istr.read(tag: 1)
                                           let iceP_p3: Swift.String? = try istr.read(tag: 3)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opMyEnum(_ iceP_p1: MyEnum? = nil, context: Ice.Context? = nil) async throws -> (returnValue: MyEnum?, p3: MyEnum?) {
        return try await _impl._invoke(operation: "opMyEnum",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: MyEnum? = try istr.read(tag: 1)
                                           let iceP_p3: MyEnum? = try istr.read(tag: 3)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opSmallStruct(_ iceP_p1: SmallStruct? = nil, context: Ice.Context? = nil) async throws -> (returnValue: SmallStruct?, p3: SmallStruct?) {
        return try await _impl._invoke(operation: "opSmallStruct",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: SmallStruct? = try istr.read(tag: 1)
                                           let iceP_p3: SmallStruct? = try istr.read(tag: 3)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opFixedStruct(_ iceP_p1: FixedStruct? = nil, context: Ice.Context? = nil) async throws -> (returnValue: FixedStruct?, p3: FixedStruct?) {
        return try await _impl._invoke(operation: "opFixedStruct",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: FixedStruct? = try istr.read(tag: 1)
                                           let iceP_p3: FixedStruct? = try istr.read(tag: 3)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opVarStruct(_ iceP_p1: VarStruct? = nil, context: Ice.Context? = nil) async throws -> (returnValue: VarStruct?, p3: VarStruct?) {
        return try await _impl._invoke(operation: "opVarStruct",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: VarStruct? = try istr.read(tag: 1)
                                           let iceP_p3: VarStruct? = try istr.read(tag: 3)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opMyInterfaceProxy(_ iceP_p1: MyInterfacePrx? = nil, context: Ice.Context? = nil) async throws -> (returnValue: MyInterfacePrx?, p3: MyInterfacePrx?) {
        return try await _impl._invoke(operation: "opMyInterfaceProxy",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: MyInterfacePrx? = try istr.read(tag: 1, type: MyInterfacePrx.self)
                                           let iceP_p3: MyInterfacePrx? = try istr.read(tag: 3, type: MyInterfacePrx.self)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opOneOptional(_ iceP_p1: OneOptional?, context: Ice.Context? = nil) async throws -> (returnValue: OneOptional?, p3: OneOptional?) {
        return try await _impl._invoke(operation: "opOneOptional",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_p1)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           var iceP_p3: OneOptional?
                                           try istr.read(OneOptional.self) { iceP_p3 = $0 }
                                           var iceP_returnValue: OneOptional?
                                           try istr.read(OneOptional.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opByteSeq(_ iceP_p1: ByteSeq? = nil, context: Ice.Context? = nil) async throws -> (returnValue: ByteSeq?, p3: ByteSeq?) {
        return try await _impl._invoke(operation: "opByteSeq",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: ByteSeq? = try istr.read(tag: 1)
                                           let iceP_p3: ByteSeq? = try istr.read(tag: 3)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opBoolSeq(_ iceP_p1: BoolSeq? = nil, context: Ice.Context? = nil) async throws -> (returnValue: BoolSeq?, p3: BoolSeq?) {
        return try await _impl._invoke(operation: "opBoolSeq",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: BoolSeq? = try istr.read(tag: 1)
                                           let iceP_p3: BoolSeq? = try istr.read(tag: 3)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opShortSeq(_ iceP_p1: ShortSeq? = nil, context: Ice.Context? = nil) async throws -> (returnValue: ShortSeq?, p3: ShortSeq?) {
        return try await _impl._invoke(operation: "opShortSeq",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: ShortSeq? = try istr.read(tag: 1)
                                           let iceP_p3: ShortSeq? = try istr.read(tag: 3)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opIntSeq(_ iceP_p1: IntSeq? = nil, context: Ice.Context? = nil) async throws -> (returnValue: IntSeq?, p3: IntSeq?) {
        return try await _impl._invoke(operation: "opIntSeq",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: IntSeq? = try istr.read(tag: 1)
                                           let iceP_p3: IntSeq? = try istr.read(tag: 3)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opLongSeq(_ iceP_p1: LongSeq? = nil, context: Ice.Context? = nil) async throws -> (returnValue: LongSeq?, p3: LongSeq?) {
        return try await _impl._invoke(operation: "opLongSeq",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: LongSeq? = try istr.read(tag: 1)
                                           let iceP_p3: LongSeq? = try istr.read(tag: 3)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opFloatSeq(_ iceP_p1: FloatSeq? = nil, context: Ice.Context? = nil) async throws -> (returnValue: FloatSeq?, p3: FloatSeq?) {
        return try await _impl._invoke(operation: "opFloatSeq",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: FloatSeq? = try istr.read(tag: 1)
                                           let iceP_p3: FloatSeq? = try istr.read(tag: 3)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opDoubleSeq(_ iceP_p1: DoubleSeq? = nil, context: Ice.Context? = nil) async throws -> (returnValue: DoubleSeq?, p3: DoubleSeq?) {
        return try await _impl._invoke(operation: "opDoubleSeq",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: DoubleSeq? = try istr.read(tag: 1)
                                           let iceP_p3: DoubleSeq? = try istr.read(tag: 3)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opStringSeq(_ iceP_p1: StringSeq? = nil, context: Ice.Context? = nil) async throws -> (returnValue: StringSeq?, p3: StringSeq?) {
        return try await _impl._invoke(operation: "opStringSeq",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: StringSeq? = try istr.read(tag: 1)
                                           let iceP_p3: StringSeq? = try istr.read(tag: 3)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opSmallStructSeq(_ iceP_p1: SmallStructSeq? = nil, context: Ice.Context? = nil) async throws -> (returnValue: SmallStructSeq?, p3: SmallStructSeq?) {
        return try await _impl._invoke(operation: "opSmallStructSeq",
                                       mode: .Normal,
                                       write: { ostr in
                                           SmallStructSeqHelper.write(to: ostr, tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: SmallStructSeq? = try SmallStructSeqHelper.read(from: istr, tag: 1)
                                           let iceP_p3: SmallStructSeq? = try SmallStructSeqHelper.read(from: istr, tag: 3)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opSmallStructList(_ iceP_p1: SmallStructList? = nil, context: Ice.Context? = nil) async throws -> (returnValue: SmallStructList?, p3: SmallStructList?) {
        return try await _impl._invoke(operation: "opSmallStructList",
                                       mode: .Normal,
                                       write: { ostr in
                                           SmallStructListHelper.write(to: ostr, tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: SmallStructList? = try SmallStructListHelper.read(from: istr, tag: 1)
                                           let iceP_p3: SmallStructList? = try SmallStructListHelper.read(from: istr, tag: 3)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opFixedStructSeq(_ iceP_p1: FixedStructSeq? = nil, context: Ice.Context? = nil) async throws -> (returnValue: FixedStructSeq?, p3: FixedStructSeq?) {
        return try await _impl._invoke(operation: "opFixedStructSeq",
                                       mode: .Normal,
                                       write: { ostr in
                                           FixedStructSeqHelper.write(to: ostr, tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: FixedStructSeq? = try FixedStructSeqHelper.read(from: istr, tag: 1)
                                           let iceP_p3: FixedStructSeq? = try FixedStructSeqHelper.read(from: istr, tag: 3)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opFixedStructList(_ iceP_p1: FixedStructList? = nil, context: Ice.Context? = nil) async throws -> (returnValue: FixedStructList?, p3: FixedStructList?) {
        return try await _impl._invoke(operation: "opFixedStructList",
                                       mode: .Normal,
                                       write: { ostr in
                                           FixedStructListHelper.write(to: ostr, tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: FixedStructList? = try FixedStructListHelper.read(from: istr, tag: 1)
                                           let iceP_p3: FixedStructList? = try FixedStructListHelper.read(from: istr, tag: 3)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opVarStructSeq(_ iceP_p1: VarStructSeq? = nil, context: Ice.Context? = nil) async throws -> (returnValue: VarStructSeq?, p3: VarStructSeq?) {
        return try await _impl._invoke(operation: "opVarStructSeq",
                                       mode: .Normal,
                                       write: { ostr in
                                           VarStructSeqHelper.write(to: ostr, tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: VarStructSeq? = try VarStructSeqHelper.read(from: istr, tag: 1)
                                           let iceP_p3: VarStructSeq? = try VarStructSeqHelper.read(from: istr, tag: 3)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opSerializable(_ iceP_p1: Serializable? = nil, context: Ice.Context? = nil) async throws -> (returnValue: Serializable?, p3: Serializable?) {
        return try await _impl._invoke(operation: "opSerializable",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Serializable? = try istr.read(tag: 1)
                                           let iceP_p3: Serializable? = try istr.read(tag: 3)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opIntIntDict(_ iceP_p1: IntIntDict? = nil, context: Ice.Context? = nil) async throws -> (returnValue: IntIntDict?, p3: IntIntDict?) {
        return try await _impl._invoke(operation: "opIntIntDict",
                                       mode: .Normal,
                                       write: { ostr in
                                           IntIntDictHelper.write(to: ostr, tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: IntIntDict? = try IntIntDictHelper.read(from: istr, tag: 1)
                                           let iceP_p3: IntIntDict? = try IntIntDictHelper.read(from: istr, tag: 3)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opStringIntDict(_ iceP_p1: StringIntDict? = nil, context: Ice.Context? = nil) async throws -> (returnValue: StringIntDict?, p3: StringIntDict?) {
        return try await _impl._invoke(operation: "opStringIntDict",
                                       mode: .Normal,
                                       write: { ostr in
                                           StringIntDictHelper.write(to: ostr, tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: StringIntDict? = try StringIntDictHelper.read(from: istr, tag: 1)
                                           let iceP_p3: StringIntDict? = try StringIntDictHelper.read(from: istr, tag: 3)
                                           return (iceP_returnValue, iceP_p3)
                                       },
                                       context: context)
    }

    func opClassAndUnknownOptional(_ iceP_p: A?, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "opClassAndUnknownOptional",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_p)
                                           ostr.writePendingValues()
                                       },
                                       context: context)
    }

    func opRequiredAfterOptional(p1 iceP_p1: Swift.Int32, p2 iceP_p2: Swift.Int32? = nil, p3 iceP_p3: Swift.Int32, context: Ice.Context? = nil) async throws -> (p4: Swift.Int32, p5: Swift.Int32?, p6: Swift.Int32) {
        return try await _impl._invoke(operation: "opRequiredAfterOptional",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_p1)
                                           ostr.write(iceP_p3)
                                           ostr.write(tag: 1, value: iceP_p2)
                                       },
                                       read: { istr in
                                           let iceP_p4: Swift.Int32 = try istr.read()
                                           let iceP_p6: Swift.Int32 = try istr.read()
                                           let iceP_p5: Swift.Int32? = try istr.read(tag: 2)
                                           return (iceP_p4, iceP_p5, iceP_p6)
                                       },
                                       context: context)
    }

    func opOptionalAfterRequired(p1 iceP_p1: Swift.Int32, p2 iceP_p2: Swift.Int32? = nil, p3 iceP_p3: Swift.Int32? = nil, context: Ice.Context? = nil) async throws -> (p4: Swift.Int32, p5: Swift.Int32?, p6: Swift.Int32?) {
        return try await _impl._invoke(operation: "opOptionalAfterRequired",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_p1)
                                           ostr.write(tag: 1, value: iceP_p2)
                                           ostr.write(tag: 2, value: iceP_p3)
                                       },
                                       read: { istr in
                                           let iceP_p4: Swift.Int32 = try istr.read()
                                           let iceP_p5: Swift.Int32? = try istr.read(tag: 3)
                                           let iceP_p6: Swift.Int32? = try istr.read(tag: 4)
                                           return (iceP_p4, iceP_p5, iceP_p6)
                                       },
                                       context: context)
    }

    func opG(_ iceP_g: G?, context: Ice.Context? = nil) async throws -> G? {
        return try await _impl._invoke(operation: "opG",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_g)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           var iceP_returnValue: G?
                                           try istr.read(G.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opVoid(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "opVoid",
                                       mode: .Normal,
                                       context: context)
    }

    func opMStruct1(context: Ice.Context? = nil) async throws -> SmallStruct? {
        return try await _impl._invoke(operation: "opMStruct1",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: SmallStruct? = try istr.read(tag: 1)
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opMStruct2(_ iceP_p1: SmallStruct? = nil, context: Ice.Context? = nil) async throws -> (returnValue: SmallStruct?, p2: SmallStruct?) {
        return try await _impl._invoke(operation: "opMStruct2",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: SmallStruct? = try istr.read(tag: 1)
                                           let iceP_p2: SmallStruct? = try istr.read(tag: 3)
                                           return (iceP_returnValue, iceP_p2)
                                       },
                                       context: context)
    }

    func opMSeq1(context: Ice.Context? = nil) async throws -> StringSeq? {
        return try await _impl._invoke(operation: "opMSeq1",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: StringSeq? = try istr.read(tag: 1)
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opMSeq2(_ iceP_p1: StringSeq? = nil, context: Ice.Context? = nil) async throws -> (returnValue: StringSeq?, p2: StringSeq?) {
        return try await _impl._invoke(operation: "opMSeq2",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: StringSeq? = try istr.read(tag: 1)
                                           let iceP_p2: StringSeq? = try istr.read(tag: 3)
                                           return (iceP_returnValue, iceP_p2)
                                       },
                                       context: context)
    }

    func opMDict1(context: Ice.Context? = nil) async throws -> StringIntDict? {
        return try await _impl._invoke(operation: "opMDict1",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: StringIntDict? = try StringIntDictHelper.read(from: istr, tag: 1)
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opMDict2(_ iceP_p1: StringIntDict? = nil, context: Ice.Context? = nil) async throws -> (returnValue: StringIntDict?, p2: StringIntDict?) {
        return try await _impl._invoke(operation: "opMDict2",
                                       mode: .Normal,
                                       write: { ostr in
                                           StringIntDictHelper.write(to: ostr, tag: 2, value: iceP_p1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: StringIntDict? = try StringIntDictHelper.read(from: istr, tag: 1)
                                           let iceP_p2: StringIntDict? = try StringIntDictHelper.read(from: istr, tag: 3)
                                           return (iceP_returnValue, iceP_p2)
                                       },
                                       context: context)
    }

    func supportsJavaSerializable(context: Ice.Context? = nil) async throws -> Swift.Bool {
        return try await _impl._invoke(operation: "supportsJavaSerializable",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: Swift.Bool = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}

@_documentation(visibility: internal)
public class OneOptional_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return OneOptional.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_OneOptional() -> Ice.ValueTypeResolver {
        return OneOptional_TypeResolver()
    }
}

open class OneOptional: Ice.Value {
    public var a: Swift.Int32? = nil

    public required init() {}

    public init(a: Swift.Int32?) {
        self.a = a
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::OneOptional" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.a = try istr.read(tag: 1)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: OneOptional.ice_staticId(), compactId: -1, last: true)
        ostr.write(tag: 1, value: self.a)
        ostr.endSlice()
    }
}

@_documentation(visibility: internal)
public class MultiOptional_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return MultiOptional.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_MultiOptional() -> Ice.ValueTypeResolver {
        return MultiOptional_TypeResolver()
    }
}

open class MultiOptional: Ice.Value {
    public var a: Swift.UInt8? = nil
    public var b: Swift.Bool? = nil
    public var c: Swift.Int16? = nil
    public var d: Swift.Int32? = nil
    public var e: Swift.Int64? = nil
    public var f: Swift.Float? = nil
    public var g: Swift.Double? = nil
    public var h: Swift.String? = nil
    public var i: MyEnum? = nil
    public var j: MyInterfacePrx? = nil
    public var bs: ByteSeq? = nil
    public var ss: StringSeq? = nil
    public var iid: IntIntDict? = nil
    public var sid: StringIntDict? = nil
    public var fs: FixedStruct? = nil
    public var vs: VarStruct? = nil
    public var shs: ShortSeq? = nil
    public var es: MyEnumSeq? = nil
    public var fss: FixedStructSeq? = nil
    public var vss: VarStructSeq? = nil
    public var mips: MyInterfacePrxSeq? = nil
    public var ied: IntEnumDict? = nil
    public var ifsd: IntFixedStructDict? = nil
    public var ivsd: IntVarStructDict? = nil
    public var imipd: IntMyInterfacePrxDict? = nil
    public var bos: BoolSeq? = nil
    public var ser: Serializable? = nil

    public required init() {}

    public init(a: Swift.UInt8?, b: Swift.Bool?, c: Swift.Int16?, d: Swift.Int32?, e: Swift.Int64?, f: Swift.Float?, g: Swift.Double?, h: Swift.String?, i: MyEnum?, j: MyInterfacePrx?, bs: ByteSeq?, ss: StringSeq?, iid: IntIntDict?, sid: StringIntDict?, fs: FixedStruct?, vs: VarStruct?, shs: ShortSeq?, es: MyEnumSeq?, fss: FixedStructSeq?, vss: VarStructSeq?, mips: MyInterfacePrxSeq?, ied: IntEnumDict?, ifsd: IntFixedStructDict?, ivsd: IntVarStructDict?, imipd: IntMyInterfacePrxDict?, bos: BoolSeq?, ser: Serializable?) {
        self.a = a
        self.b = b
        self.c = c
        self.d = d
        self.e = e
        self.f = f
        self.g = g
        self.h = h
        self.i = i
        self.j = j
        self.bs = bs
        self.ss = ss
        self.iid = iid
        self.sid = sid
        self.fs = fs
        self.vs = vs
        self.shs = shs
        self.es = es
        self.fss = fss
        self.vss = vss
        self.mips = mips
        self.ied = ied
        self.ifsd = ifsd
        self.ivsd = ivsd
        self.imipd = imipd
        self.bos = bos
        self.ser = ser
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::MultiOptional" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.a = try istr.read(tag: 1)
        self.b = try istr.read(tag: 2)
        self.c = try istr.read(tag: 3)
        self.d = try istr.read(tag: 4)
        self.e = try istr.read(tag: 5)
        self.f = try istr.read(tag: 6)
        self.g = try istr.read(tag: 7)
        self.h = try istr.read(tag: 8)
        self.i = try istr.read(tag: 9)
        self.j = try istr.read(tag: 10, type: MyInterfacePrx.self)
        self.bs = try istr.read(tag: 12)
        self.ss = try istr.read(tag: 13)
        self.iid = try IntIntDictHelper.read(from: istr, tag: 14)
        self.sid = try StringIntDictHelper.read(from: istr, tag: 15)
        self.fs = try istr.read(tag: 16)
        self.vs = try istr.read(tag: 17)
        self.shs = try istr.read(tag: 18)
        self.es = try MyEnumSeqHelper.read(from: istr, tag: 19)
        self.fss = try FixedStructSeqHelper.read(from: istr, tag: 20)
        self.vss = try VarStructSeqHelper.read(from: istr, tag: 21)
        self.mips = try MyInterfacePrxSeqHelper.read(from: istr, tag: 23)
        self.ied = try IntEnumDictHelper.read(from: istr, tag: 24)
        self.ifsd = try IntFixedStructDictHelper.read(from: istr, tag: 25)
        self.ivsd = try IntVarStructDictHelper.read(from: istr, tag: 26)
        self.imipd = try IntMyInterfacePrxDictHelper.read(from: istr, tag: 28)
        self.bos = try istr.read(tag: 29)
        self.ser = try istr.read(tag: 30)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: MultiOptional.ice_staticId(), compactId: -1, last: true)
        ostr.write(tag: 1, value: self.a)
        ostr.write(tag: 2, value: self.b)
        ostr.write(tag: 3, value: self.c)
        ostr.write(tag: 4, value: self.d)
        ostr.write(tag: 5, value: self.e)
        ostr.write(tag: 6, value: self.f)
        ostr.write(tag: 7, value: self.g)
        ostr.write(tag: 8, value: self.h)
        ostr.write(tag: 9, value: self.i)
        ostr.write(tag: 10, value: self.j)
        ostr.write(tag: 12, value: self.bs)
        ostr.write(tag: 13, value: self.ss)
        IntIntDictHelper.write(to: ostr, tag: 14, value: self.iid)
        StringIntDictHelper.write(to: ostr, tag: 15, value: self.sid)
        ostr.write(tag: 16, value: self.fs)
        ostr.write(tag: 17, value: self.vs)
        ostr.write(tag: 18, value: self.shs)
        MyEnumSeqHelper.write(to: ostr, tag: 19, value: self.es)
        FixedStructSeqHelper.write(to: ostr, tag: 20, value: self.fss)
        VarStructSeqHelper.write(to: ostr, tag: 21, value: self.vss)
        MyInterfacePrxSeqHelper.write(to: ostr, tag: 23, value: self.mips)
        IntEnumDictHelper.write(to: ostr, tag: 24, value: self.ied)
        IntFixedStructDictHelper.write(to: ostr, tag: 25, value: self.ifsd)
        IntVarStructDictHelper.write(to: ostr, tag: 26, value: self.ivsd)
        IntMyInterfacePrxDictHelper.write(to: ostr, tag: 28, value: self.imipd)
        ostr.write(tag: 29, value: self.bos)
        ostr.write(tag: 30, value: self.ser)
        ostr.endSlice()
    }
}

@_documentation(visibility: internal)
public class A_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return A.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_A() -> Ice.ValueTypeResolver {
        return A_TypeResolver()
    }
}

open class A: Ice.Value {
    public var requiredA: Swift.Int32 = 0
    public var ma: Swift.Int32? = nil
    public var mb: Swift.Int32? = nil
    public var mc: Swift.Int32? = nil

    public required init() {}

    public init(requiredA: Swift.Int32, ma: Swift.Int32?, mb: Swift.Int32?, mc: Swift.Int32?) {
        self.requiredA = requiredA
        self.ma = ma
        self.mb = mb
        self.mc = mc
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::A" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.requiredA = try istr.read()
        self.ma = try istr.read(tag: 1)
        self.mb = try istr.read(tag: 50)
        self.mc = try istr.read(tag: 500)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: A.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.requiredA)
        ostr.write(tag: 1, value: self.ma)
        ostr.write(tag: 50, value: self.mb)
        ostr.write(tag: 500, value: self.mc)
        ostr.endSlice()
    }
}

@_documentation(visibility: internal)
public class B_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return B.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_B() -> Ice.ValueTypeResolver {
        return B_TypeResolver()
    }
}

open class B: A {
    public var requiredB: Swift.Int32 = 0
    public var md: Swift.Int32? = nil

    public required init() {
        super.init()
    }

    public init(requiredA: Swift.Int32, ma: Swift.Int32?, mb: Swift.Int32?, mc: Swift.Int32?, requiredB: Swift.Int32, md: Swift.Int32?) {
        self.requiredB = requiredB
        self.md = md
        super.init(requiredA: requiredA, ma: ma, mb: mb, mc: mc)
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::B" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.requiredB = try istr.read()
        self.md = try istr.read(tag: 10)
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: B.ice_staticId(), compactId: -1, last: false)
        ostr.write(self.requiredB)
        ostr.write(tag: 10, value: self.md)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}

@_documentation(visibility: internal)
public class C_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return C.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_C() -> Ice.ValueTypeResolver {
        return C_TypeResolver()
    }
}

open class C: B {
    public var ss: Swift.String = ""
    public var ms: Swift.String? = nil

    public required init() {
        super.init()
    }

    public init(requiredA: Swift.Int32, ma: Swift.Int32?, mb: Swift.Int32?, mc: Swift.Int32?, requiredB: Swift.Int32, md: Swift.Int32?, ss: Swift.String, ms: Swift.String?) {
        self.ss = ss
        self.ms = ms
        super.init(requiredA: requiredA, ma: ma, mb: mb, mc: mc, requiredB: requiredB, md: md)
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::C" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.ss = try istr.read()
        self.ms = try istr.read(tag: 890)
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: C.ice_staticId(), compactId: -1, last: false)
        ostr.write(self.ss)
        ostr.write(tag: 890, value: self.ms)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}

@_documentation(visibility: internal)
public class WD_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return WD.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_WD() -> Ice.ValueTypeResolver {
        return WD_TypeResolver()
    }
}

open class WD: Ice.Value {
    public var a: Swift.Int32? = 5
    public var s: Swift.String? = "test"

    public required init() {}

    public init(a: Swift.Int32?, s: Swift.String?) {
        self.a = a
        self.s = s
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::WD" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.a = try istr.read(tag: 1)
        self.s = try istr.read(tag: 2)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: WD.ice_staticId(), compactId: -1, last: true)
        ostr.write(tag: 1, value: self.a)
        ostr.write(tag: 2, value: self.s)
        ostr.endSlice()
    }
}

@_documentation(visibility: internal)
public class OptionalWithCustom_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return OptionalWithCustom.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_OptionalWithCustom() -> Ice.ValueTypeResolver {
        return OptionalWithCustom_TypeResolver()
    }
}

open class OptionalWithCustom: Ice.Value {
    public var l: SmallStructList? = nil
    public var lp: SmallStructList? = nil

    public required init() {}

    public init(l: SmallStructList?, lp: SmallStructList?) {
        self.l = l
        self.lp = lp
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::OptionalWithCustom" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.l = try SmallStructListHelper.read(from: istr, tag: 1)
        self.lp = try SmallStructListHelper.read(from: istr, tag: 2)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: OptionalWithCustom.ice_staticId(), compactId: -1, last: true)
        SmallStructListHelper.write(to: ostr, tag: 1, value: self.l)
        SmallStructListHelper.write(to: ostr, tag: 2, value: self.lp)
        ostr.endSlice()
    }
}

@_documentation(visibility: internal)
public class E_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return E.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_E() -> Ice.ValueTypeResolver {
        return E_TypeResolver()
    }
}

open class E: Ice.Value {
    public var fse: FixedStruct = FixedStruct()

    public required init() {}

    public init(fse: FixedStruct) {
        self.fse = fse
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::E" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.fse = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: E.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.fse)
        ostr.endSlice()
    }
}

@_documentation(visibility: internal)
public class F_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return F.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_F() -> Ice.ValueTypeResolver {
        return F_TypeResolver()
    }
}

open class F: E {
    public var fsf: FixedStruct? = nil

    public required init() {
        super.init()
    }

    public init(fse: FixedStruct, fsf: FixedStruct?) {
        self.fsf = fsf
        super.init(fse: fse)
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::F" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.fsf = try istr.read(tag: 1)
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: F.ice_staticId(), compactId: -1, last: false)
        ostr.write(tag: 1, value: self.fsf)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}

@_documentation(visibility: internal)
public class G_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return G.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_G() -> Ice.ValueTypeResolver {
        return G_TypeResolver()
    }
}

open class G: Ice.Value {
    public var gg1Opt: G1? = nil
    public var gg2: G2 = G2()
    public var gg2Opt: G2? = nil
    public var gg1: G1 = G1()

    public required init() {}

    public init(gg1Opt: G1?, gg2: G2, gg2Opt: G2?, gg1: G1) {
        self.gg1Opt = gg1Opt
        self.gg2 = gg2
        self.gg2Opt = gg2Opt
        self.gg1 = gg1
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::G" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.gg2 = try istr.read()
        self.gg1 = try istr.read()
        self.gg2Opt = try istr.read(tag: 0)
        self.gg1Opt = try istr.read(tag: 1)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: G.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.gg2)
        ostr.write(self.gg1)
        ostr.write(tag: 0, value: self.gg2Opt)
        ostr.write(tag: 1, value: self.gg1Opt)
        ostr.endSlice()
    }
}


/// Dispatcher for `MyInterface` servants.
public struct MyInterfaceDisp: Ice.Dispatcher {
    public let servant: MyInterface
    private static let defaultObject = Ice.ObjectI<MyInterfaceTraits>()

    public init(_ servant: MyInterface) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "ice_id":
            try await (servant as? Ice.Object ?? MyInterfaceDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? MyInterfaceDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? MyInterfaceDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? MyInterfaceDisp.defaultObject)._iceD_ice_ping(request)
        case "op":
            try await servant._iceD_op(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol MyInterface {
    func op(current: Ice.Current) async throws
}


/// Dispatcher for `Initial` servants.
public struct InitialDisp: Ice.Dispatcher {
    public let servant: Initial
    private static let defaultObject = Ice.ObjectI<InitialTraits>()

    public init(_ servant: Initial) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "ice_id":
            try await (servant as? Ice.Object ?? InitialDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? InitialDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? InitialDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? InitialDisp.defaultObject)._iceD_ice_ping(request)
        case "opBool":
            try await servant._iceD_opBool(request)
        case "opBoolSeq":
            try await servant._iceD_opBoolSeq(request)
        case "opByte":
            try await servant._iceD_opByte(request)
        case "opByteSeq":
            try await servant._iceD_opByteSeq(request)
        case "opClassAndUnknownOptional":
            try await servant._iceD_opClassAndUnknownOptional(request)
        case "opDerivedException":
            try await servant._iceD_opDerivedException(request)
        case "opDouble":
            try await servant._iceD_opDouble(request)
        case "opDoubleSeq":
            try await servant._iceD_opDoubleSeq(request)
        case "opFixedStruct":
            try await servant._iceD_opFixedStruct(request)
        case "opFixedStructList":
            try await servant._iceD_opFixedStructList(request)
        case "opFixedStructSeq":
            try await servant._iceD_opFixedStructSeq(request)
        case "opFloat":
            try await servant._iceD_opFloat(request)
        case "opFloatSeq":
            try await servant._iceD_opFloatSeq(request)
        case "opG":
            try await servant._iceD_opG(request)
        case "opInt":
            try await servant._iceD_opInt(request)
        case "opIntIntDict":
            try await servant._iceD_opIntIntDict(request)
        case "opIntSeq":
            try await servant._iceD_opIntSeq(request)
        case "opLong":
            try await servant._iceD_opLong(request)
        case "opLongSeq":
            try await servant._iceD_opLongSeq(request)
        case "opMDict1":
            try await servant._iceD_opMDict1(request)
        case "opMDict2":
            try await servant._iceD_opMDict2(request)
        case "opMSeq1":
            try await servant._iceD_opMSeq1(request)
        case "opMSeq2":
            try await servant._iceD_opMSeq2(request)
        case "opMStruct1":
            try await servant._iceD_opMStruct1(request)
        case "opMStruct2":
            try await servant._iceD_opMStruct2(request)
        case "opMyEnum":
            try await servant._iceD_opMyEnum(request)
        case "opMyInterfaceProxy":
            try await servant._iceD_opMyInterfaceProxy(request)
        case "opOneOptional":
            try await servant._iceD_opOneOptional(request)
        case "opOptionalAfterRequired":
            try await servant._iceD_opOptionalAfterRequired(request)
        case "opOptionalException":
            try await servant._iceD_opOptionalException(request)
        case "opRequiredAfterOptional":
            try await servant._iceD_opRequiredAfterOptional(request)
        case "opRequiredException":
            try await servant._iceD_opRequiredException(request)
        case "opSerializable":
            try await servant._iceD_opSerializable(request)
        case "opShort":
            try await servant._iceD_opShort(request)
        case "opShortSeq":
            try await servant._iceD_opShortSeq(request)
        case "opSmallStruct":
            try await servant._iceD_opSmallStruct(request)
        case "opSmallStructList":
            try await servant._iceD_opSmallStructList(request)
        case "opSmallStructSeq":
            try await servant._iceD_opSmallStructSeq(request)
        case "opString":
            try await servant._iceD_opString(request)
        case "opStringIntDict":
            try await servant._iceD_opStringIntDict(request)
        case "opStringSeq":
            try await servant._iceD_opStringSeq(request)
        case "opVarStruct":
            try await servant._iceD_opVarStruct(request)
        case "opVarStructSeq":
            try await servant._iceD_opVarStructSeq(request)
        case "opVoid":
            try await servant._iceD_opVoid(request)
        case "pingPong":
            try await servant._iceD_pingPong(request)
        case "shutdown":
            try await servant._iceD_shutdown(request)
        case "supportsJavaSerializable":
            try await servant._iceD_supportsJavaSerializable(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol Initial {
    func shutdown(current: Ice.Current) async throws

    func pingPong(o: Ice.Value?, current: Ice.Current) async throws -> Ice.Value?

    func opOptionalException(a: Swift.Int32?, b: Swift.String?, current: Ice.Current) async throws

    func opDerivedException(a: Swift.Int32?, b: Swift.String?, current: Ice.Current) async throws

    func opRequiredException(a: Swift.Int32?, b: Swift.String?, current: Ice.Current) async throws

    func opByte(p1: Swift.UInt8?, current: Ice.Current) async throws -> (returnValue: Swift.UInt8?, p3: Swift.UInt8?)

    func opBool(p1: Swift.Bool?, current: Ice.Current) async throws -> (returnValue: Swift.Bool?, p3: Swift.Bool?)

    func opShort(p1: Swift.Int16?, current: Ice.Current) async throws -> (returnValue: Swift.Int16?, p3: Swift.Int16?)

    func opInt(p1: Swift.Int32?, current: Ice.Current) async throws -> (returnValue: Swift.Int32?, p3: Swift.Int32?)

    func opLong(p1: Swift.Int64?, current: Ice.Current) async throws -> (returnValue: Swift.Int64?, p3: Swift.Int64?)

    func opFloat(p1: Swift.Float?, current: Ice.Current) async throws -> (returnValue: Swift.Float?, p3: Swift.Float?)

    func opDouble(p1: Swift.Double?, current: Ice.Current) async throws -> (returnValue: Swift.Double?, p3: Swift.Double?)

    func opString(p1: Swift.String?, current: Ice.Current) async throws -> (returnValue: Swift.String?, p3: Swift.String?)

    func opMyEnum(p1: MyEnum?, current: Ice.Current) async throws -> (returnValue: MyEnum?, p3: MyEnum?)

    func opSmallStruct(p1: SmallStruct?, current: Ice.Current) async throws -> (returnValue: SmallStruct?, p3: SmallStruct?)

    func opFixedStruct(p1: FixedStruct?, current: Ice.Current) async throws -> (returnValue: FixedStruct?, p3: FixedStruct?)

    func opVarStruct(p1: VarStruct?, current: Ice.Current) async throws -> (returnValue: VarStruct?, p3: VarStruct?)

    func opMyInterfaceProxy(p1: MyInterfacePrx?, current: Ice.Current) async throws -> (returnValue: MyInterfacePrx?, p3: MyInterfacePrx?)

    func opOneOptional(p1: OneOptional?, current: Ice.Current) async throws -> (returnValue: OneOptional?, p3: OneOptional?)

    func opByteSeq(p1: ByteSeq?, current: Ice.Current) async throws -> (returnValue: ByteSeq?, p3: ByteSeq?)

    func opBoolSeq(p1: BoolSeq?, current: Ice.Current) async throws -> (returnValue: BoolSeq?, p3: BoolSeq?)

    func opShortSeq(p1: ShortSeq?, current: Ice.Current) async throws -> (returnValue: ShortSeq?, p3: ShortSeq?)

    func opIntSeq(p1: IntSeq?, current: Ice.Current) async throws -> (returnValue: IntSeq?, p3: IntSeq?)

    func opLongSeq(p1: LongSeq?, current: Ice.Current) async throws -> (returnValue: LongSeq?, p3: LongSeq?)

    func opFloatSeq(p1: FloatSeq?, current: Ice.Current) async throws -> (returnValue: FloatSeq?, p3: FloatSeq?)

    func opDoubleSeq(p1: DoubleSeq?, current: Ice.Current) async throws -> (returnValue: DoubleSeq?, p3: DoubleSeq?)

    func opStringSeq(p1: StringSeq?, current: Ice.Current) async throws -> (returnValue: StringSeq?, p3: StringSeq?)

    func opSmallStructSeq(p1: SmallStructSeq?, current: Ice.Current) async throws -> (returnValue: SmallStructSeq?, p3: SmallStructSeq?)

    func opSmallStructList(p1: SmallStructList?, current: Ice.Current) async throws -> (returnValue: SmallStructList?, p3: SmallStructList?)

    func opFixedStructSeq(p1: FixedStructSeq?, current: Ice.Current) async throws -> (returnValue: FixedStructSeq?, p3: FixedStructSeq?)

    func opFixedStructList(p1: FixedStructList?, current: Ice.Current) async throws -> (returnValue: FixedStructList?, p3: FixedStructList?)

    func opVarStructSeq(p1: VarStructSeq?, current: Ice.Current) async throws -> (returnValue: VarStructSeq?, p3: VarStructSeq?)

    func opSerializable(p1: Serializable?, current: Ice.Current) async throws -> (returnValue: Serializable?, p3: Serializable?)

    func opIntIntDict(p1: IntIntDict?, current: Ice.Current) async throws -> (returnValue: IntIntDict?, p3: IntIntDict?)

    func opStringIntDict(p1: StringIntDict?, current: Ice.Current) async throws -> (returnValue: StringIntDict?, p3: StringIntDict?)

    func opClassAndUnknownOptional(p: A?, current: Ice.Current) async throws

    func opRequiredAfterOptional(p1: Swift.Int32, p2: Swift.Int32?, p3: Swift.Int32, current: Ice.Current) async throws -> (p4: Swift.Int32, p5: Swift.Int32?, p6: Swift.Int32)

    func opOptionalAfterRequired(p1: Swift.Int32, p2: Swift.Int32?, p3: Swift.Int32?, current: Ice.Current) async throws -> (p4: Swift.Int32, p5: Swift.Int32?, p6: Swift.Int32?)

    func opG(g: G?, current: Ice.Current) async throws -> G?

    func opVoid(current: Ice.Current) async throws

    func opMStruct1(current: Ice.Current) async throws -> SmallStruct?

    func opMStruct2(p1: SmallStruct?, current: Ice.Current) async throws -> (returnValue: SmallStruct?, p2: SmallStruct?)

    func opMSeq1(current: Ice.Current) async throws -> StringSeq?

    func opMSeq2(p1: StringSeq?, current: Ice.Current) async throws -> (returnValue: StringSeq?, p2: StringSeq?)

    func opMDict1(current: Ice.Current) async throws -> StringIntDict?

    func opMDict2(p1: StringIntDict?, current: Ice.Current) async throws -> (returnValue: StringIntDict?, p2: StringIntDict?)

    func supportsJavaSerializable(current: Ice.Current) async throws -> Swift.Bool
}

extension MyInterface {
    public func _iceD_op(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.op(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}

extension Initial {
    public func _iceD_shutdown(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.shutdown(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_pingPong(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_o: Ice.Value?
        try istr.read() { iceP_o = $0 }
        try istr.readPendingValues()
        let result = try await self.pingPong(o: iceP_o, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_opOptionalException(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_a: Swift.Int32? = try istr.read(tag: 1)
        let iceP_b: Swift.String? = try istr.read(tag: 2)
        try await self.opOptionalException(a: iceP_a, b: iceP_b, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_opDerivedException(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_a: Swift.Int32? = try istr.read(tag: 1)
        let iceP_b: Swift.String? = try istr.read(tag: 2)
        try await self.opDerivedException(a: iceP_a, b: iceP_b, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_opRequiredException(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_a: Swift.Int32? = try istr.read(tag: 1)
        let iceP_b: Swift.String? = try istr.read(tag: 2)
        try await self.opRequiredException(a: iceP_a, b: iceP_b, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_opByte(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: Swift.UInt8? = try istr.read(tag: 2)
        let result = try await self.opByte(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(tag: 1, value: iceP_returnValue)
            ostr.write(tag: 3, value: iceP_p3)
        }
    }

    public func _iceD_opBool(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: Swift.Bool? = try istr.read(tag: 2)
        let result = try await self.opBool(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(tag: 1, value: iceP_returnValue)
            ostr.write(tag: 3, value: iceP_p3)
        }
    }

    public func _iceD_opShort(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: Swift.Int16? = try istr.read(tag: 2)
        let result = try await self.opShort(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(tag: 1, value: iceP_returnValue)
            ostr.write(tag: 3, value: iceP_p3)
        }
    }

    public func _iceD_opInt(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: Swift.Int32? = try istr.read(tag: 2)
        let result = try await self.opInt(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(tag: 1, value: iceP_returnValue)
            ostr.write(tag: 3, value: iceP_p3)
        }
    }

    public func _iceD_opLong(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: Swift.Int64? = try istr.read(tag: 1)
        let result = try await self.opLong(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(tag: 2, value: iceP_p3)
            ostr.write(tag: 3, value: iceP_returnValue)
        }
    }

    public func _iceD_opFloat(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: Swift.Float? = try istr.read(tag: 2)
        let result = try await self.opFloat(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(tag: 1, value: iceP_returnValue)
            ostr.write(tag: 3, value: iceP_p3)
        }
    }

    public func _iceD_opDouble(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: Swift.Double? = try istr.read(tag: 2)
        let result = try await self.opDouble(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(tag: 1, value: iceP_returnValue)
            ostr.write(tag: 3, value: iceP_p3)
        }
    }

    public func _iceD_opString(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: Swift.String? = try istr.read(tag: 2)
        let result = try await self.opString(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(tag: 1, value: iceP_returnValue)
            ostr.write(tag: 3, value: iceP_p3)
        }
    }

    public func _iceD_opMyEnum(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: MyEnum? = try istr.read(tag: 2)
        let result = try await self.opMyEnum(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(tag: 1, value: iceP_returnValue)
            ostr.write(tag: 3, value: iceP_p3)
        }
    }

    public func _iceD_opSmallStruct(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: SmallStruct? = try istr.read(tag: 2)
        let result = try await self.opSmallStruct(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(tag: 1, value: iceP_returnValue)
            ostr.write(tag: 3, value: iceP_p3)
        }
    }

    public func _iceD_opFixedStruct(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: FixedStruct? = try istr.read(tag: 2)
        let result = try await self.opFixedStruct(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(tag: 1, value: iceP_returnValue)
            ostr.write(tag: 3, value: iceP_p3)
        }
    }

    public func _iceD_opVarStruct(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: VarStruct? = try istr.read(tag: 2)
        let result = try await self.opVarStruct(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(tag: 1, value: iceP_returnValue)
            ostr.write(tag: 3, value: iceP_p3)
        }
    }

    public func _iceD_opMyInterfaceProxy(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: MyInterfacePrx? = try istr.read(tag: 2, type: MyInterfacePrx.self)
        let result = try await self.opMyInterfaceProxy(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(tag: 1, value: iceP_returnValue)
            ostr.write(tag: 3, value: iceP_p3)
        }
    }

    public func _iceD_opOneOptional(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_p1: OneOptional?
        try istr.read(OneOptional.self) { iceP_p1 = $0 }
        try istr.readPendingValues()
        let result = try await self.opOneOptional(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(iceP_p3)
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_opByteSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: ByteSeq? = try istr.read(tag: 2)
        let result = try await self.opByteSeq(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(tag: 1, value: iceP_returnValue)
            ostr.write(tag: 3, value: iceP_p3)
        }
    }

    public func _iceD_opBoolSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: BoolSeq? = try istr.read(tag: 2)
        let result = try await self.opBoolSeq(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(tag: 1, value: iceP_returnValue)
            ostr.write(tag: 3, value: iceP_p3)
        }
    }

    public func _iceD_opShortSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: ShortSeq? = try istr.read(tag: 2)
        let result = try await self.opShortSeq(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(tag: 1, value: iceP_returnValue)
            ostr.write(tag: 3, value: iceP_p3)
        }
    }

    public func _iceD_opIntSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: IntSeq? = try istr.read(tag: 2)
        let result = try await self.opIntSeq(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(tag: 1, value: iceP_returnValue)
            ostr.write(tag: 3, value: iceP_p3)
        }
    }

    public func _iceD_opLongSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: LongSeq? = try istr.read(tag: 2)
        let result = try await self.opLongSeq(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(tag: 1, value: iceP_returnValue)
            ostr.write(tag: 3, value: iceP_p3)
        }
    }

    public func _iceD_opFloatSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: FloatSeq? = try istr.read(tag: 2)
        let result = try await self.opFloatSeq(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(tag: 1, value: iceP_returnValue)
            ostr.write(tag: 3, value: iceP_p3)
        }
    }

    public func _iceD_opDoubleSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: DoubleSeq? = try istr.read(tag: 2)
        let result = try await self.opDoubleSeq(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(tag: 1, value: iceP_returnValue)
            ostr.write(tag: 3, value: iceP_p3)
        }
    }

    public func _iceD_opStringSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: StringSeq? = try istr.read(tag: 2)
        let result = try await self.opStringSeq(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(tag: 1, value: iceP_returnValue)
            ostr.write(tag: 3, value: iceP_p3)
        }
    }

    public func _iceD_opSmallStructSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: SmallStructSeq? = try SmallStructSeqHelper.read(from: istr, tag: 2)
        let result = try await self.opSmallStructSeq(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            SmallStructSeqHelper.write(to: ostr, tag: 1, value: iceP_returnValue)
            SmallStructSeqHelper.write(to: ostr, tag: 3, value: iceP_p3)
        }
    }

    public func _iceD_opSmallStructList(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: SmallStructList? = try SmallStructListHelper.read(from: istr, tag: 2)
        let result = try await self.opSmallStructList(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            SmallStructListHelper.write(to: ostr, tag: 1, value: iceP_returnValue)
            SmallStructListHelper.write(to: ostr, tag: 3, value: iceP_p3)
        }
    }

    public func _iceD_opFixedStructSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: FixedStructSeq? = try FixedStructSeqHelper.read(from: istr, tag: 2)
        let result = try await self.opFixedStructSeq(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            FixedStructSeqHelper.write(to: ostr, tag: 1, value: iceP_returnValue)
            FixedStructSeqHelper.write(to: ostr, tag: 3, value: iceP_p3)
        }
    }

    public func _iceD_opFixedStructList(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: FixedStructList? = try FixedStructListHelper.read(from: istr, tag: 2)
        let result = try await self.opFixedStructList(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            FixedStructListHelper.write(to: ostr, tag: 1, value: iceP_returnValue)
            FixedStructListHelper.write(to: ostr, tag: 3, value: iceP_p3)
        }
    }

    public func _iceD_opVarStructSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: VarStructSeq? = try VarStructSeqHelper.read(from: istr, tag: 2)
        let result = try await self.opVarStructSeq(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            VarStructSeqHelper.write(to: ostr, tag: 1, value: iceP_returnValue)
            VarStructSeqHelper.write(to: ostr, tag: 3, value: iceP_p3)
        }
    }

    public func _iceD_opSerializable(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: Serializable? = try istr.read(tag: 2)
        let result = try await self.opSerializable(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            ostr.write(tag: 1, value: iceP_returnValue)
            ostr.write(tag: 3, value: iceP_p3)
        }
    }

    public func _iceD_opIntIntDict(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: IntIntDict? = try IntIntDictHelper.read(from: istr, tag: 2)
        let result = try await self.opIntIntDict(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            IntIntDictHelper.write(to: ostr, tag: 1, value: iceP_returnValue)
            IntIntDictHelper.write(to: ostr, tag: 3, value: iceP_p3)
        }
    }

    public func _iceD_opStringIntDict(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: StringIntDict? = try StringIntDictHelper.read(from: istr, tag: 2)
        let result = try await self.opStringIntDict(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p3) = value
            StringIntDictHelper.write(to: ostr, tag: 1, value: iceP_returnValue)
            StringIntDictHelper.write(to: ostr, tag: 3, value: iceP_p3)
        }
    }

    public func _iceD_opClassAndUnknownOptional(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_p: A?
        try istr.read(A.self) { iceP_p = $0 }
        try istr.readPendingValues()
        try await self.opClassAndUnknownOptional(p: iceP_p, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_opRequiredAfterOptional(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: Swift.Int32 = try istr.read()
        let iceP_p3: Swift.Int32 = try istr.read()
        let iceP_p2: Swift.Int32? = try istr.read(tag: 1)
        let result = try await self.opRequiredAfterOptional(p1: iceP_p1, p2: iceP_p2, p3: iceP_p3, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_p4, iceP_p5, iceP_p6) = value
            ostr.write(iceP_p4)
            ostr.write(iceP_p6)
            ostr.write(tag: 2, value: iceP_p5)
        }
    }

    public func _iceD_opOptionalAfterRequired(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: Swift.Int32 = try istr.read()
        let iceP_p2: Swift.Int32? = try istr.read(tag: 1)
        let iceP_p3: Swift.Int32? = try istr.read(tag: 2)
        let result = try await self.opOptionalAfterRequired(p1: iceP_p1, p2: iceP_p2, p3: iceP_p3, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_p4, iceP_p5, iceP_p6) = value
            ostr.write(iceP_p4)
            ostr.write(tag: 3, value: iceP_p5)
            ostr.write(tag: 4, value: iceP_p6)
        }
    }

    public func _iceD_opG(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_g: G?
        try istr.read(G.self) { iceP_g = $0 }
        try istr.readPendingValues()
        let result = try await self.opG(g: iceP_g, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_opVoid(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.opVoid(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_opMStruct1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.opMStruct1(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(tag: 1, value: iceP_returnValue)
        }
    }

    public func _iceD_opMStruct2(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: SmallStruct? = try istr.read(tag: 2)
        let result = try await self.opMStruct2(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p2) = value
            ostr.write(tag: 1, value: iceP_returnValue)
            ostr.write(tag: 3, value: iceP_p2)
        }
    }

    public func _iceD_opMSeq1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.opMSeq1(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(tag: 1, value: iceP_returnValue)
        }
    }

    public func _iceD_opMSeq2(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: StringSeq? = try istr.read(tag: 2)
        let result = try await self.opMSeq2(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p2) = value
            ostr.write(tag: 1, value: iceP_returnValue)
            ostr.write(tag: 3, value: iceP_p2)
        }
    }

    public func _iceD_opMDict1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.opMDict1(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            StringIntDictHelper.write(to: ostr, tag: 1, value: iceP_returnValue)
        }
    }

    public func _iceD_opMDict2(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_p1: StringIntDict? = try StringIntDictHelper.read(from: istr, tag: 2)
        let result = try await self.opMDict2(p1: iceP_p1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_p2) = value
            StringIntDictHelper.write(to: ostr, tag: 1, value: iceP_returnValue)
            StringIntDictHelper.write(to: ostr, tag: 3, value: iceP_p2)
        }
    }

    public func _iceD_supportsJavaSerializable(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.supportsJavaSerializable(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }
}
