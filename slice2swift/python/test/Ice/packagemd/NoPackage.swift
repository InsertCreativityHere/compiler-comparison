//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `NoPackage.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice

/// :nodoc:
public class E1_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return E1.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test1_E1() -> Ice.UserExceptionTypeResolver {
        return E1_TypeResolver()
    }
}

open class E1: Ice.UserException, @unchecked Sendable {
    public var i: Swift.Int32 = 0

    public required init() {}

    public init(i: Swift.Int32) {
        self.i = i
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Test1::E1" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: E1.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.i)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.i = try istr.read()
        try istr.endSlice()
    }
}

/// :nodoc:
public class E2_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return E2.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test1_E2() -> Ice.UserExceptionTypeResolver {
        return E2_TypeResolver()
    }
}

open class E2: E1, @unchecked Sendable {
    public var l: Swift.Int64 = 0

    public required init() {
        super.init()
    }

    public init(i: Swift.Int32, l: Swift.Int64) {
        self.l = l
        super.init(i: i)
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Test1::E2" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: E2.ice_staticId(), compactId: -1, last: false)
        ostr.write(self.l)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.l = try istr.read()
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }
}

/// :nodoc:
public class def_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return def.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test1_def() -> Ice.UserExceptionTypeResolver {
        return def_TypeResolver()
    }
}

/// Test keyword escape.
open class def: Ice.UserException, @unchecked Sendable {
    public var i: Swift.Int32 = 0

    public required init() {}

    public init(i: Swift.Int32) {
        self.i = i
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Test1::def" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: def.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.i)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.i = try istr.read()
        try istr.endSlice()
    }
}

/// :nodoc:
public class C1_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return C1.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test1_C1() -> Ice.ValueTypeResolver {
        return C1_TypeResolver()
    }
}

open class C1: Ice.Value {
    public var i: Swift.Int32 = 0

    public required init() {}

    public init(i: Swift.Int32) {
        self.i = i
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test1::C1" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.i = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: C1.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.i)
        ostr.endSlice()
    }
}

/// :nodoc:
public class C2_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return C2.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test1_C2() -> Ice.ValueTypeResolver {
        return C2_TypeResolver()
    }
}

open class C2: C1 {
    public var l: Swift.Int64 = 0

    public required init() {
        super.init()
    }

    public init(i: Swift.Int32, l: Swift.Int64) {
        self.l = l
        super.init(i: i)
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test1::C2" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.l = try istr.read()
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: C2.ice_staticId(), compactId: -1, last: false)
        ostr.write(self.l)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}
