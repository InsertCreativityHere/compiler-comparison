//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.9
//
// <auto-generated>
//
// Generated from file `ServerTypes.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice
import PromiseKit
public let IntConst1: Swift.Int32 = 100

public let IntConst2: Swift.Int32 = 1000

public let IntConst3: Swift.Int16 = 100


public enum Enum1: Swift.UInt8 {
    /// Enum11
    case Enum11 = 0
    /// Enum12
    case Enum12 = 1
    /// Enum13
    case Enum13 = 2
    public init() {
        self = .Enum11
    }
}

/// An `Ice.InputStream` extension to read `Enum1` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - returns: `Enum1` - The enumarated value.
    func read() throws -> Enum1 {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 2)
        guard let val = Enum1(rawValue: rawValue) else {
            throw Ice.MarshalException(reason: "invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `Enum1` - The enumerated value.
    func read(tag: Swift.Int32) throws -> Enum1? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as Enum1
    }
}

/// An `Ice.OutputStream` extension to write `Enum1` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// parameter _: `Enum1` - The enumerator to write.
    func write(_ v: Enum1) {
        write(enum: v.rawValue, maxValue: 2)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// parameter _: `Enum1` - The enumerator to write.
    func write(tag: Swift.Int32, value: Enum1?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 2)
    }
}

public enum Enum2: Swift.UInt8 {
    /// Enum21
    case Enum21 = 0
    /// Enum22
    case Enum22 = 1
    /// Enum23
    case Enum23 = 2
    /// Enum24
    case Enum24 = 3
    public init() {
        self = .Enum21
    }
}

/// An `Ice.InputStream` extension to read `Enum2` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - returns: `Enum2` - The enumarated value.
    func read() throws -> Enum2 {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 3)
        guard let val = Enum2(rawValue: rawValue) else {
            throw Ice.MarshalException(reason: "invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `Enum2` - The enumerated value.
    func read(tag: Swift.Int32) throws -> Enum2? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as Enum2
    }
}

/// An `Ice.OutputStream` extension to write `Enum2` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// parameter _: `Enum2` - The enumerator to write.
    func write(_ v: Enum2) {
        write(enum: v.rawValue, maxValue: 3)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// parameter _: `Enum2` - The enumerator to write.
    func write(tag: Swift.Int32, value: Enum2?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 3)
    }
}

public enum Enum3: Swift.UInt8 {
    /// Enum32
    case Enum32 = 0
    /// Enum33
    case Enum33 = 1
    public init() {
        self = .Enum32
    }
}

/// An `Ice.InputStream` extension to read `Enum3` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - returns: `Enum3` - The enumarated value.
    func read() throws -> Enum3 {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 1)
        guard let val = Enum3(rawValue: rawValue) else {
            throw Ice.MarshalException(reason: "invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `Enum3` - The enumerated value.
    func read(tag: Swift.Int32) throws -> Enum3? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as Enum3
    }
}

/// An `Ice.OutputStream` extension to write `Enum3` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// parameter _: `Enum3` - The enumerator to write.
    func write(_ v: Enum3) {
        write(enum: v.rawValue, maxValue: 1)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// parameter _: `Enum3` - The enumerator to write.
    func write(tag: Swift.Int32, value: Enum3?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 1)
    }
}

public enum EnumExplicit0: Swift.UInt8 {
    /// EnumExplicit01
    case EnumExplicit01 = 1
    /// EnumExplicit02
    case EnumExplicit02 = 2
    /// EnumExplicit03
    case EnumExplicit03 = 3
    public init() {
        self = .EnumExplicit01
    }
}

/// An `Ice.InputStream` extension to read `EnumExplicit0` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - returns: `EnumExplicit0` - The enumarated value.
    func read() throws -> EnumExplicit0 {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 3)
        guard let val = EnumExplicit0(rawValue: rawValue) else {
            throw Ice.MarshalException(reason: "invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `EnumExplicit0` - The enumerated value.
    func read(tag: Swift.Int32) throws -> EnumExplicit0? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as EnumExplicit0
    }
}

/// An `Ice.OutputStream` extension to write `EnumExplicit0` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// parameter _: `EnumExplicit0` - The enumerator to write.
    func write(_ v: EnumExplicit0) {
        write(enum: v.rawValue, maxValue: 3)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// parameter _: `EnumExplicit0` - The enumerator to write.
    func write(tag: Swift.Int32, value: EnumExplicit0?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 3)
    }
}

public enum EnumExplicit1: Swift.UInt8 {
    /// EnumExplicit11
    case EnumExplicit11 = 1
    /// EnumExplicit13
    case EnumExplicit13 = 3
    /// EnumExplicit12
    case EnumExplicit12 = 2
    public init() {
        self = .EnumExplicit11
    }
}

/// An `Ice.InputStream` extension to read `EnumExplicit1` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - returns: `EnumExplicit1` - The enumarated value.
    func read() throws -> EnumExplicit1 {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 3)
        guard let val = EnumExplicit1(rawValue: rawValue) else {
            throw Ice.MarshalException(reason: "invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `EnumExplicit1` - The enumerated value.
    func read(tag: Swift.Int32) throws -> EnumExplicit1? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as EnumExplicit1
    }
}

/// An `Ice.OutputStream` extension to write `EnumExplicit1` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// parameter _: `EnumExplicit1` - The enumerator to write.
    func write(_ v: EnumExplicit1) {
        write(enum: v.rawValue, maxValue: 3)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// parameter _: `EnumExplicit1` - The enumerator to write.
    func write(tag: Swift.Int32, value: EnumExplicit1?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 3)
    }
}

public enum EnumExplicit2: Swift.UInt8 {
    /// EnumExplicit21
    case EnumExplicit21 = 1
    /// EnumExplicit22
    case EnumExplicit22 = 3
    /// EnumExplicit23
    case EnumExplicit23 = 4
    public init() {
        self = .EnumExplicit21
    }
}

/// An `Ice.InputStream` extension to read `EnumExplicit2` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - returns: `EnumExplicit2` - The enumarated value.
    func read() throws -> EnumExplicit2 {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 4)
        guard let val = EnumExplicit2(rawValue: rawValue) else {
            throw Ice.MarshalException(reason: "invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `EnumExplicit2` - The enumerated value.
    func read(tag: Swift.Int32) throws -> EnumExplicit2? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as EnumExplicit2
    }
}

/// An `Ice.OutputStream` extension to write `EnumExplicit2` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// parameter _: `EnumExplicit2` - The enumerator to write.
    func write(_ v: EnumExplicit2) {
        write(enum: v.rawValue, maxValue: 4)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// parameter _: `EnumExplicit2` - The enumerator to write.
    func write(tag: Swift.Int32, value: EnumExplicit2?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 4)
    }
}

public enum EnumExplicit3: Swift.UInt8 {
    /// EnumExplicit31
    case EnumExplicit31 = 1
    /// EnumExplicit32
    case EnumExplicit32 = 2
    public init() {
        self = .EnumExplicit31
    }
}

/// An `Ice.InputStream` extension to read `EnumExplicit3` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - returns: `EnumExplicit3` - The enumarated value.
    func read() throws -> EnumExplicit3 {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 2)
        guard let val = EnumExplicit3(rawValue: rawValue) else {
            throw Ice.MarshalException(reason: "invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `EnumExplicit3` - The enumerated value.
    func read(tag: Swift.Int32) throws -> EnumExplicit3? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as EnumExplicit3
    }
}

/// An `Ice.OutputStream` extension to write `EnumExplicit3` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// parameter _: `EnumExplicit3` - The enumerator to write.
    func write(_ v: EnumExplicit3) {
        write(enum: v.rawValue, maxValue: 2)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// parameter _: `EnumExplicit3` - The enumerator to write.
    func write(tag: Swift.Int32, value: EnumExplicit3?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 2)
    }
}

/// Traits for Slice class `Enum4`.
public struct Enum4Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Enum4"]
    public static let staticId = "::Test::Enum4"
}

public typealias Sequence1 = [Swift.Int32]

public typealias Sequence2 = [Swift.Int16]

/// Traits for Slice class `Sequence3`.
public struct Sequence3Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Sequence3"]
    public static let staticId = "::Test::Sequence3"
}

public typealias Dictionary1 = [Swift.String: Swift.Int32]

/// Helper class to read and write `Dictionary1` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct Dictionary1Helper {
    /// Read a `Dictionary1` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `Dictionary1` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> Dictionary1 {
        let sz = try Swift.Int(istr.readSize())
        var v = Dictionary1()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: Swift.Int32 = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `Dictionary1?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `Dictionary1` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> Dictionary1? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `Dictionary1` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `Dictionary1` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: Dictionary1) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `Dictionary1?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `Dictionary1` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: Dictionary1?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias Dictionary2 = [Swift.Int64: Swift.Int32]

/// Helper class to read and write `Dictionary2` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct Dictionary2Helper {
    /// Read a `Dictionary2` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `Dictionary2` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> Dictionary2 {
        let sz = try Swift.Int(istr.readSize())
        var v = Dictionary2()
        for _ in 0 ..< sz {
            let key: Swift.Int64 = try istr.read()
            let value: Swift.Int32 = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `Dictionary2?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `Dictionary2` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> Dictionary2? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Wite a `Dictionary2` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `Dictionary2` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: Dictionary2) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `Dictionary2?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `Dictionary2` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: Dictionary2?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 12) {
            write(to: ostr, value: val)
        }
    }
}

public typealias Dictionary3 = [Swift.String: Swift.Bool]

/// Helper class to read and write `Dictionary3` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct Dictionary3Helper {
    /// Read a `Dictionary3` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `Dictionary3` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> Dictionary3 {
        let sz = try Swift.Int(istr.readSize())
        var v = Dictionary3()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: Swift.Bool = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `Dictionary3?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `Dictionary3` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> Dictionary3? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `Dictionary3` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `Dictionary3` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: Dictionary3) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `Dictionary3?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `Dictionary3` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: Dictionary3?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice class `Dictionary4`.
public struct Dictionary4Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Dictionary4"]
    public static let staticId = "::Test::Dictionary4"
}

public struct Struct1: Swift.Hashable {
    public var str: Swift.String = ""
    public var b: Swift.Bool = false

    public init() {}

    public init(str: Swift.String, b: Swift.Bool) {
        self.str = str
        self.b = b
    }
}

/// An `Ice.InputStream` extension to read `Struct1` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `Struct1` structured value from the stream.
    ///
    /// - returns: `Struct1` - The structured value read from the stream.
    func read() throws -> Struct1 {
        var v = Struct1()
        v.str = try self.read()
        v.b = try self.read()
        return v
    }

    /// Read an optional `Struct1?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `Struct1?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> Struct1? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as Struct1
    }
}

/// An `Ice.OutputStream` extension to write `Struct1` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `Struct1` structured value to the stream.
    ///
    /// - parameter _: `Struct1` - The value to write to the stream.
    func write(_ v: Struct1) {
        self.write(v.str)
        self.write(v.b)
    }

    /// Write an optional `Struct1?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `Struct1?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: Struct1?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public struct Struct2 {
    public var str: Swift.String = ""
    public var b: Swift.Bool = false
    public var f: Swift.Float = 0.0

    public init() {}

    public init(str: Swift.String, b: Swift.Bool, f: Swift.Float) {
        self.str = str
        self.b = b
        self.f = f
    }
}

/// An `Ice.InputStream` extension to read `Struct2` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `Struct2` structured value from the stream.
    ///
    /// - returns: `Struct2` - The structured value read from the stream.
    func read() throws -> Struct2 {
        var v = Struct2()
        v.str = try self.read()
        v.b = try self.read()
        v.f = try self.read()
        return v
    }

    /// Read an optional `Struct2?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `Struct2?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> Struct2? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as Struct2
    }
}

/// An `Ice.OutputStream` extension to write `Struct2` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `Struct2` structured value to the stream.
    ///
    /// - parameter _: `Struct2` - The value to write to the stream.
    func write(_ v: Struct2) {
        self.write(v.str)
        self.write(v.b)
        self.write(v.f)
    }

    /// Write an optional `Struct2?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `Struct2?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: Struct2?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public struct Struct3 {
    public var str: Swift.String = ""
    public var b: Swift.Double = 0.0

    public init() {}

    public init(str: Swift.String, b: Swift.Double) {
        self.str = str
        self.b = b
    }
}

/// An `Ice.InputStream` extension to read `Struct3` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `Struct3` structured value from the stream.
    ///
    /// - returns: `Struct3` - The structured value read from the stream.
    func read() throws -> Struct3 {
        var v = Struct3()
        v.str = try self.read()
        v.b = try self.read()
        return v
    }

    /// Read an optional `Struct3?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `Struct3?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> Struct3? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as Struct3
    }
}

/// An `Ice.OutputStream` extension to write `Struct3` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `Struct3` structured value to the stream.
    ///
    /// - parameter _: `Struct3` - The value to write to the stream.
    func write(_ v: Struct3) {
        self.write(v.str)
        self.write(v.b)
    }

    /// Write an optional `Struct3?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `Struct3?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: Struct3?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public struct Struct4: Swift.Hashable {
    public var b: Swift.Bool = false

    public init() {}

    public init(b: Swift.Bool) {
        self.b = b
    }
}

/// An `Ice.InputStream` extension to read `Struct4` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `Struct4` structured value from the stream.
    ///
    /// - returns: `Struct4` - The structured value read from the stream.
    func read() throws -> Struct4 {
        var v = Struct4()
        v.b = try self.read()
        return v
    }

    /// Read an optional `Struct4?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `Struct4?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> Struct4? {
        guard try readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try skipSize()
        return try read() as Struct4
    }
}

/// An `Ice.OutputStream` extension to write `Struct4` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `Struct4` structured value to the stream.
    ///
    /// - parameter _: `Struct4` - The value to write to the stream.
    func write(_ v: Struct4) {
        self.write(v.b)
    }

    /// Write an optional `Struct4?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `Struct4?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: Struct4?) {
        if let v = value {
            if writeOptional(tag: tag, format: .VSize) {
                write(size: 1)
                write(v)
            }
        }
    }
}

/// Traits for Slice class `Struct5`.
public struct Struct5Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Struct5"]
    public static let staticId = "::Test::Struct5"
}

/// Traits for Slice interface `Interface1`.
public struct Interface1Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Interface1"]
    public static let staticId = "::Test::Interface1"
}

/// Traits for Slice class `Interface2`.
public struct Interface2Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Interface2"]
    public static let staticId = "::Test::Interface2"
}

/// Traits for Slice interface `Interface3`.
public struct Interface3Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Interface1", "::Test::Interface3"]
    public static let staticId = "::Test::Interface3"
}

/// Traits for Slice interface `Interface4`.
public struct Interface4Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Interface4"]
    public static let staticId = "::Test::Interface4"
}

/// Traits for Slice class `EmptyClass1`.
public struct EmptyClass1Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::EmptyClass1"]
    public static let staticId = "::Test::EmptyClass1"
}

/// Traits for Slice class `EmptyClass2`.
public struct EmptyClass2Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::EmptyClass2"]
    public static let staticId = "::Test::EmptyClass2"
}

/// Traits for Slice class `EmptyClass3`.
public struct EmptyClass3Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::EmptyClass3"]
    public static let staticId = "::Test::EmptyClass3"
}

/// Traits for Slice class `EmptyClass4`.
public struct EmptyClass4Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::EmptyClass1", "::Test::EmptyClass4"]
    public static let staticId = "::Test::EmptyClass4"
}

/// Traits for Slice class `EmptyClass5`.
public struct EmptyClass5Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::EmptyClass5", "::Test::Interface1"]
    public static let staticId = "::Test::EmptyClass5"
}

/// Traits for Slice class `SimpleClass1`.
public struct SimpleClass1Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::SimpleClass1"]
    public static let staticId = "::Test::SimpleClass1"
}

/// Traits for Slice class `SimpleClass2`.
public struct SimpleClass2Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::SimpleClass2"]
    public static let staticId = "::Test::SimpleClass2"
}

/// Traits for Slice class `SimpleClass3`.
public struct SimpleClass3Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::SimpleClass3"]
    public static let staticId = "::Test::SimpleClass3"
}

/// Traits for Slice class `SimpleClass4`.
public struct SimpleClass4Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::SimpleClass4"]
    public static let staticId = "::Test::SimpleClass4"
}

/// Traits for Slice class `SimpleClass5`.
public struct SimpleClass5Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::SimpleClass5"]
    public static let staticId = "::Test::SimpleClass5"
}

/// Traits for Slice class `SimpleClass6`.
public struct SimpleClass6Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::SimpleClass6"]
    public static let staticId = "::Test::SimpleClass6"
}

/// Traits for Slice class `SimpleClass7`.
public struct SimpleClass7Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::SimpleClass7"]
    public static let staticId = "::Test::SimpleClass7"
}

/// :nodoc:
public class Exception1_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return Exception1.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Exception1() -> Ice.UserExceptionTypeResolver {
        return Exception1_TypeResolver()
    }
}

open class Exception1: Ice.UserException {
    public var str: Swift.String = ""
    public var b: Swift.Bool = false

    public required init() {}

    public init(str: Swift.String, b: Swift.Bool) {
        self.str = str
        self.b = b
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::Test::Exception1"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Exception1.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.str)
        ostr.write(self.b)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.str = try istr.read()
        self.b = try istr.read()
        try istr.endSlice()
    }
}

/// :nodoc:
public class Exception2_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return Exception2.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Exception2() -> Ice.UserExceptionTypeResolver {
        return Exception2_TypeResolver()
    }
}

open class Exception2: Ice.UserException {
    public var str: Swift.String = ""
    public var b: Swift.Bool = false
    public var f: Swift.Float = 0.0

    public required init() {}

    public init(str: Swift.String, b: Swift.Bool, f: Swift.Float) {
        self.str = str
        self.b = b
        self.f = f
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::Test::Exception2"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Exception2.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.str)
        ostr.write(self.b)
        ostr.write(self.f)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.str = try istr.read()
        self.b = try istr.read()
        self.f = try istr.read()
        try istr.endSlice()
    }
}

/// :nodoc:
public class Exception3_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return Exception3.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Exception3() -> Ice.UserExceptionTypeResolver {
        return Exception3_TypeResolver()
    }
}

open class Exception3: Ice.UserException {
    public var str: Swift.String = ""
    public var b: Swift.Double = 0.0

    public required init() {}

    public init(str: Swift.String, b: Swift.Double) {
        self.str = str
        self.b = b
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::Test::Exception3"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Exception3.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.str)
        ostr.write(self.b)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.str = try istr.read()
        self.b = try istr.read()
        try istr.endSlice()
    }
}

/// :nodoc:
public class Exception4_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return Exception4.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Exception4() -> Ice.UserExceptionTypeResolver {
        return Exception4_TypeResolver()
    }
}

open class Exception4: Ice.UserException {
    public var b: Swift.Bool = false

    public required init() {}

    public init(b: Swift.Bool) {
        self.b = b
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::Test::Exception4"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Exception4.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.b)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.b = try istr.read()
        try istr.endSlice()
    }
}

/// :nodoc:
public class Exception5_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return Exception5.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Exception5() -> Ice.UserExceptionTypeResolver {
        return Exception5_TypeResolver()
    }
}

open class Exception5: Exception1 {
    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::Test::Exception5"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Exception5.ice_staticId(), compactId: -1, last: false)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }
}

/// Traits for Slice class `Exception6`.
public struct Exception6Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Exception6"]
    public static let staticId = "::Test::Exception6"
}

/// :nodoc:
public class OptionalEx0_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return OptionalEx0.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_OptionalEx0() -> Ice.UserExceptionTypeResolver {
        return OptionalEx0_TypeResolver()
    }
}

open class OptionalEx0: Ice.UserException {
    public var firstName: Swift.String = ""
    public var secondName: Swift.String? = nil
    public var emailAddress: Swift.String? = nil

    public required init() {}

    public init(firstName: Swift.String, secondName: Swift.String?, emailAddress: Swift.String?) {
        self.firstName = firstName
        self.secondName = secondName
        self.emailAddress = emailAddress
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::Test::OptionalEx0"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: OptionalEx0.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.firstName)
        ostr.write(tag: 1, value: self.secondName)
        ostr.write(tag: 2, value: self.emailAddress)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.firstName = try istr.read()
        self.secondName = try istr.read(tag: 1)
        self.emailAddress = try istr.read(tag: 2)
        try istr.endSlice()
    }
}

/// :nodoc:
public class OptionalEx1_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return OptionalEx1.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_OptionalEx1() -> Ice.UserExceptionTypeResolver {
        return OptionalEx1_TypeResolver()
    }
}

open class OptionalEx1: Ice.UserException {
    public var firstName: Swift.String = ""
    public var emailAddress: Swift.String? = nil
    public var secondName: Swift.String? = nil

    public required init() {}

    public init(firstName: Swift.String, emailAddress: Swift.String?, secondName: Swift.String?) {
        self.firstName = firstName
        self.emailAddress = emailAddress
        self.secondName = secondName
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::Test::OptionalEx1"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: OptionalEx1.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.firstName)
        ostr.write(tag: 1, value: self.secondName)
        ostr.write(tag: 2, value: self.emailAddress)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.firstName = try istr.read()
        self.secondName = try istr.read(tag: 1)
        self.emailAddress = try istr.read(tag: 2)
        try istr.endSlice()
    }
}

/// :nodoc:
public class OptionalEx2_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return OptionalEx2.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_OptionalEx2() -> Ice.UserExceptionTypeResolver {
        return OptionalEx2_TypeResolver()
    }
}

open class OptionalEx2: Ice.UserException {
    public var firstName: Swift.String = ""
    public var secondName: Swift.String? = nil
    public var emailAddress: Swift.String = ""

    public required init() {}

    public init(firstName: Swift.String, secondName: Swift.String?, emailAddress: Swift.String) {
        self.firstName = firstName
        self.secondName = secondName
        self.emailAddress = emailAddress
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::Test::OptionalEx2"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: OptionalEx2.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.firstName)
        ostr.write(self.emailAddress)
        ostr.write(tag: 1, value: self.secondName)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.firstName = try istr.read()
        self.emailAddress = try istr.read()
        self.secondName = try istr.read(tag: 1)
        try istr.endSlice()
    }
}

/// :nodoc:
public class OptionalEx3_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return OptionalEx3.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_OptionalEx3() -> Ice.UserExceptionTypeResolver {
        return OptionalEx3_TypeResolver()
    }
}

open class OptionalEx3: Ice.UserException {
    public var firstName: Swift.String = ""
    public var secondName: Swift.String? = nil
    public var emailAddress: Swift.String? = nil
    public var phoneNumber: Swift.String? = nil

    public required init() {}

    public init(firstName: Swift.String, secondName: Swift.String?, emailAddress: Swift.String?, phoneNumber: Swift.String?) {
        self.firstName = firstName
        self.secondName = secondName
        self.emailAddress = emailAddress
        self.phoneNumber = phoneNumber
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::Test::OptionalEx3"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: OptionalEx3.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.firstName)
        ostr.write(tag: 1, value: self.secondName)
        ostr.write(tag: 2, value: self.emailAddress)
        ostr.write(tag: 3, value: self.phoneNumber)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.firstName = try istr.read()
        self.secondName = try istr.read(tag: 1)
        self.emailAddress = try istr.read(tag: 2)
        self.phoneNumber = try istr.read(tag: 3)
        try istr.endSlice()
    }
}

/// :nodoc:
public class OptionalEx4_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return OptionalEx4.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_OptionalEx4() -> Ice.UserExceptionTypeResolver {
        return OptionalEx4_TypeResolver()
    }
}

open class OptionalEx4: Ice.UserException {
    public var firstName: Swift.String = ""
    public var secondName: Swift.String? = nil
    public var emailAddress: Swift.String? = nil

    public required init() {}

    public init(firstName: Swift.String, secondName: Swift.String?, emailAddress: Swift.String?) {
        self.firstName = firstName
        self.secondName = secondName
        self.emailAddress = emailAddress
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::Test::OptionalEx4"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: OptionalEx4.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.firstName)
        ostr.write(tag: 1, value: self.emailAddress)
        ostr.write(tag: 2, value: self.secondName)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.firstName = try istr.read()
        self.emailAddress = try istr.read(tag: 1)
        self.secondName = try istr.read(tag: 2)
        try istr.endSlice()
    }
}

/// Traits for Slice interface `BaseInterface1`.
public struct BaseInterface1Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::BaseInterface1"]
    public static let staticId = "::Test::BaseInterface1"
}

/// Traits for Slice interface `BaseInterface2`.
public struct BaseInterface2Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::BaseInterface2"]
    public static let staticId = "::Test::BaseInterface2"
}

/// Traits for Slice interface `BaseInterface3`.
public struct BaseInterface3Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::BaseInterface3"]
    public static let staticId = "::Test::BaseInterface3"
}

/// Traits for Slice interface `BaseInterface4`.
public struct BaseInterface4Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::BaseInterface4"]
    public static let staticId = "::Test::BaseInterface4"
}

/// Traits for Slice interface `BaseInterface5`.
public struct BaseInterface5Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::BaseInterface5"]
    public static let staticId = "::Test::BaseInterface5"
}

/// Traits for Slice interface `BaseInterface6`.
public struct BaseInterface6Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::BaseInterface6"]
    public static let staticId = "::Test::BaseInterface6"
}

/// Traits for Slice interface `BaseInterface7`.
public struct BaseInterface7Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::BaseInterface7"]
    public static let staticId = "::Test::BaseInterface7"
}

/// Traits for Slice interface `BaseInterface8`.
public struct BaseInterface8Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::BaseInterface8"]
    public static let staticId = "::Test::BaseInterface8"
}

/// Traits for Slice interface `BaseInterface9`.
public struct BaseInterface9Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::BaseInterface9", "::Test::Interface1"]
    public static let staticId = "::Test::BaseInterface9"
}

/// Traits for Slice interface `BaseInterface10`.
public struct BaseInterface10Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::BaseInterface10", "::Test::Interface1"]
    public static let staticId = "::Test::BaseInterface10"
}

/// Traits for Slice class `Compact1`.
public struct Compact1Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Compact1"]
    public static let staticId = "::Test::Compact1"
}

/// Traits for Slice class `Derived1`.
public struct Derived1Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Compact1", "::Test::Derived1"]
    public static let staticId = "::Test::Derived1"
}

/// Traits for Slice class `Compact2`.
public struct Compact2Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Compact2"]
    public static let staticId = "::Test::Compact2"
}

/// Traits for Slice class `Optional0`.
public struct Optional0Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Optional0"]
    public static let staticId = "::Test::Optional0"
}

/// Traits for Slice class `Optional1`.
public struct Optional1Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Optional1"]
    public static let staticId = "::Test::Optional1"
}

/// Traits for Slice class `Optional2`.
public struct Optional2Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Optional2"]
    public static let staticId = "::Test::Optional2"
}

/// Traits for Slice class `Optional3`.
public struct Optional3Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Optional3"]
    public static let staticId = "::Test::Optional3"
}

/// Traits for Slice class `Optional4`.
public struct Optional4Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Optional4"]
    public static let staticId = "::Test::Optional4"
}

/// Traits for Slice interface `OptionalParameters0`.
public struct OptionalParameters0Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::OptionalParameters0"]
    public static let staticId = "::Test::OptionalParameters0"
}

/// Traits for Slice interface `OptionalParameters1`.
public struct OptionalParameters1Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::OptionalParameters1"]
    public static let staticId = "::Test::OptionalParameters1"
}

/// Traits for Slice interface `OptionalParameters2`.
public struct OptionalParameters2Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::OptionalParameters2"]
    public static let staticId = "::Test::OptionalParameters2"
}

/// Traits for Slice interface `OptionalParameters3`.
public struct OptionalParameters3Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::OptionalParameters3"]
    public static let staticId = "::Test::OptionalParameters3"
}

/// Traits for Slice interface `OptionalReturn0`.
public struct OptionalReturn0Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::OptionalReturn0"]
    public static let staticId = "::Test::OptionalReturn0"
}

/// Traits for Slice interface `OptionalReturn2`.
public struct OptionalReturn2Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::OptionalReturn2"]
    public static let staticId = "::Test::OptionalReturn2"
}

public enum LocalEnum: Swift.UInt8 {
    /// LocalEnum1
    case LocalEnum1 = 0
    /// LocalEnum2
    case LocalEnum2 = 1
    /// LocalEnum3
    case LocalEnum3 = 2
    public init() {
        self = .LocalEnum1
    }
}

/// An `Ice.InputStream` extension to read `LocalEnum` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - returns: `LocalEnum` - The enumarated value.
    func read() throws -> LocalEnum {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 2)
        guard let val = LocalEnum(rawValue: rawValue) else {
            throw Ice.MarshalException(reason: "invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LocalEnum` - The enumerated value.
    func read(tag: Swift.Int32) throws -> LocalEnum? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as LocalEnum
    }
}

/// An `Ice.OutputStream` extension to write `LocalEnum` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// parameter _: `LocalEnum` - The enumerator to write.
    func write(_ v: LocalEnum) {
        write(enum: v.rawValue, maxValue: 2)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// parameter _: `LocalEnum` - The enumerator to write.
    func write(tag: Swift.Int32, value: LocalEnum?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 2)
    }
}

public typealias LocalSequence = [Swift.String]

public typealias LocalDictionary = [Swift.String: Swift.String]

public struct LocalStruct: Swift.Hashable {
    public var str: Swift.String = ""

    public init() {}

    public init(str: Swift.String) {
        self.str = str
    }
}

/// Interface1Prx overview.
public protocol Interface1Prx: Ice.ObjectPrx {}

private final class Interface1PrxI: Ice.ObjectPrxI, Interface1Prx {
    public override class func ice_staticId() -> Swift.String {
        return Interface1Traits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `Interface1Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `Interface1Prx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: Interface1Prx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> Interface1Prx? {
    return try Interface1PrxI.checkedCast(prx: prx, facet: facet, context: context) as Interface1PrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `Interface1Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `Interface1Prx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: Interface1Prx.Protocol, facet: Swift.String? = nil) -> Interface1Prx {
    return Interface1PrxI.uncheckedCast(prx: prx, facet: facet) as Interface1PrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `Interface1Prx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: Interface1Prx.Protocol) -> Swift.String {
    return Interface1Traits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `Interface1Prx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `Interface1Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `Interface1Prx?` - The extracted proxy
    func read(_ type: Interface1Prx.Protocol) throws -> Interface1Prx? {
        return try read() as Interface1PrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `Interface1Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `Interface1Prx` - The extracted proxy.
    func read(tag: Swift.Int32, type: Interface1Prx.Protocol) throws -> Interface1Prx? {
        return try read(tag: tag) as Interface1PrxI?
    }
}

/// Interface1Prx overview.
public extension Interface1Prx {}

/// Interface3Prx overview.
public protocol Interface3Prx: Interface1Prx {}

private final class Interface3PrxI: Ice.ObjectPrxI, Interface3Prx {
    public override class func ice_staticId() -> Swift.String {
        return Interface3Traits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `Interface3Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `Interface3Prx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: Interface3Prx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> Interface3Prx? {
    return try Interface3PrxI.checkedCast(prx: prx, facet: facet, context: context) as Interface3PrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `Interface3Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `Interface3Prx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: Interface3Prx.Protocol, facet: Swift.String? = nil) -> Interface3Prx {
    return Interface3PrxI.uncheckedCast(prx: prx, facet: facet) as Interface3PrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `Interface3Prx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: Interface3Prx.Protocol) -> Swift.String {
    return Interface3Traits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `Interface3Prx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `Interface3Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `Interface3Prx?` - The extracted proxy
    func read(_ type: Interface3Prx.Protocol) throws -> Interface3Prx? {
        return try read() as Interface3PrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `Interface3Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `Interface3Prx` - The extracted proxy.
    func read(tag: Swift.Int32, type: Interface3Prx.Protocol) throws -> Interface3Prx? {
        return try read(tag: tag) as Interface3PrxI?
    }
}

/// Interface3Prx overview.
public extension Interface3Prx {}

/// Interface4Prx overview.
///
/// Interface4Prx Methods:
///
///  - opInterface4: 
///
///  - opInterface4Async: 
public protocol Interface4Prx: Ice.ObjectPrx {}

private final class Interface4PrxI: Ice.ObjectPrxI, Interface4Prx {
    public override class func ice_staticId() -> Swift.String {
        return Interface4Traits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `Interface4Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `Interface4Prx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: Interface4Prx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> Interface4Prx? {
    return try Interface4PrxI.checkedCast(prx: prx, facet: facet, context: context) as Interface4PrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `Interface4Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `Interface4Prx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: Interface4Prx.Protocol, facet: Swift.String? = nil) -> Interface4Prx {
    return Interface4PrxI.uncheckedCast(prx: prx, facet: facet) as Interface4PrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `Interface4Prx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: Interface4Prx.Protocol) -> Swift.String {
    return Interface4Traits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `Interface4Prx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `Interface4Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `Interface4Prx?` - The extracted proxy
    func read(_ type: Interface4Prx.Protocol) throws -> Interface4Prx? {
        return try read() as Interface4PrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `Interface4Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `Interface4Prx` - The extracted proxy.
    func read(tag: Swift.Int32, type: Interface4Prx.Protocol) throws -> Interface4Prx? {
        return try read(tag: tag) as Interface4PrxI?
    }
}

/// Interface4Prx overview.
///
/// Interface4Prx Methods:
///
///  - opInterface4: 
///
///  - opInterface4Async: 
public extension Interface4Prx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func opInterface4(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "opInterface4",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func opInterface4Async(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "opInterface4",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// EmptyClass3Prx overview.
///
/// EmptyClass3Prx Methods:
///
///  - newOp: 
///
///  - newOpAsync: 
public protocol EmptyClass3Prx: Ice.ObjectPrx {}

private final class EmptyClass3PrxI: Ice.ObjectPrxI, EmptyClass3Prx {
    public override class func ice_staticId() -> Swift.String {
        return EmptyClass3Traits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `EmptyClass3Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `EmptyClass3Prx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: EmptyClass3Prx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> EmptyClass3Prx? {
    return try EmptyClass3PrxI.checkedCast(prx: prx, facet: facet, context: context) as EmptyClass3PrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `EmptyClass3Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `EmptyClass3Prx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: EmptyClass3Prx.Protocol, facet: Swift.String? = nil) -> EmptyClass3Prx {
    return EmptyClass3PrxI.uncheckedCast(prx: prx, facet: facet) as EmptyClass3PrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `EmptyClass3Prx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: EmptyClass3Prx.Protocol) -> Swift.String {
    return EmptyClass3Traits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `EmptyClass3Prx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `EmptyClass3Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `EmptyClass3Prx?` - The extracted proxy
    func read(_ type: EmptyClass3Prx.Protocol) throws -> EmptyClass3Prx? {
        return try read() as EmptyClass3PrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `EmptyClass3Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `EmptyClass3Prx` - The extracted proxy.
    func read(tag: Swift.Int32, type: EmptyClass3Prx.Protocol) throws -> EmptyClass3Prx? {
        return try read(tag: tag) as EmptyClass3PrxI?
    }
}

/// EmptyClass3Prx overview.
///
/// EmptyClass3Prx Methods:
///
///  - newOp: 
///
///  - newOpAsync: 
public extension EmptyClass3Prx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func newOp(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "newOp",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func newOpAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "newOp",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// SimpleClass2Prx overview.
///
/// SimpleClass2Prx Methods:
///
///  - newOp: 
///
///  - newOpAsync: 
public protocol SimpleClass2Prx: Ice.ObjectPrx {}

private final class SimpleClass2PrxI: Ice.ObjectPrxI, SimpleClass2Prx {
    public override class func ice_staticId() -> Swift.String {
        return SimpleClass2Traits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `SimpleClass2Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `SimpleClass2Prx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: SimpleClass2Prx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> SimpleClass2Prx? {
    return try SimpleClass2PrxI.checkedCast(prx: prx, facet: facet, context: context) as SimpleClass2PrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `SimpleClass2Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `SimpleClass2Prx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: SimpleClass2Prx.Protocol, facet: Swift.String? = nil) -> SimpleClass2Prx {
    return SimpleClass2PrxI.uncheckedCast(prx: prx, facet: facet) as SimpleClass2PrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `SimpleClass2Prx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: SimpleClass2Prx.Protocol) -> Swift.String {
    return SimpleClass2Traits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `SimpleClass2Prx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `SimpleClass2Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `SimpleClass2Prx?` - The extracted proxy
    func read(_ type: SimpleClass2Prx.Protocol) throws -> SimpleClass2Prx? {
        return try read() as SimpleClass2PrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `SimpleClass2Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `SimpleClass2Prx` - The extracted proxy.
    func read(tag: Swift.Int32, type: SimpleClass2Prx.Protocol) throws -> SimpleClass2Prx? {
        return try read(tag: tag) as SimpleClass2PrxI?
    }
}

/// SimpleClass2Prx overview.
///
/// SimpleClass2Prx Methods:
///
///  - newOp: 
///
///  - newOpAsync: 
public extension SimpleClass2Prx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func newOp(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "newOp",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func newOpAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "newOp",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// BaseInterface1Prx overview.
///
/// BaseInterface1Prx Methods:
///
///  - baseOp1: 
///
///  - baseOp1Async: 
///
///  - baseOp2: 
///
///  - baseOp2Async: 
public protocol BaseInterface1Prx: Ice.ObjectPrx {}

private final class BaseInterface1PrxI: Ice.ObjectPrxI, BaseInterface1Prx {
    public override class func ice_staticId() -> Swift.String {
        return BaseInterface1Traits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `BaseInterface1Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `BaseInterface1Prx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: BaseInterface1Prx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> BaseInterface1Prx? {
    return try BaseInterface1PrxI.checkedCast(prx: prx, facet: facet, context: context) as BaseInterface1PrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `BaseInterface1Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `BaseInterface1Prx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: BaseInterface1Prx.Protocol, facet: Swift.String? = nil) -> BaseInterface1Prx {
    return BaseInterface1PrxI.uncheckedCast(prx: prx, facet: facet) as BaseInterface1PrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `BaseInterface1Prx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: BaseInterface1Prx.Protocol) -> Swift.String {
    return BaseInterface1Traits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `BaseInterface1Prx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `BaseInterface1Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `BaseInterface1Prx?` - The extracted proxy
    func read(_ type: BaseInterface1Prx.Protocol) throws -> BaseInterface1Prx? {
        return try read() as BaseInterface1PrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `BaseInterface1Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `BaseInterface1Prx` - The extracted proxy.
    func read(tag: Swift.Int32, type: BaseInterface1Prx.Protocol) throws -> BaseInterface1Prx? {
        return try read(tag: tag) as BaseInterface1PrxI?
    }
}

/// BaseInterface1Prx overview.
///
/// BaseInterface1Prx Methods:
///
///  - baseOp1: 
///
///  - baseOp1Async: 
///
///  - baseOp2: 
///
///  - baseOp2Async: 
public extension BaseInterface1Prx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func baseOp1(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "baseOp1",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func baseOp1Async(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "baseOp1",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String`
    func baseOp2(_ iceP_i: Swift.Int32, context: Ice.Context? = nil) throws -> Swift.String {
        return try _impl._invoke(operation: "baseOp2",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_i)
                                 },
                                 read: { istr in
                                     let iceP_s: Swift.String = try istr.read()
                                     return iceP_s
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as Exception1 {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.String>` - The result of the operation
    func baseOp2Async(_ iceP_i: Swift.Int32, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.String> {
        return _impl._invokeAsync(operation: "baseOp2",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_i)
                                  },
                                  read: { istr in
                                      let iceP_s: Swift.String = try istr.read()
                                      return iceP_s
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as Exception1 {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// BaseInterface2Prx overview.
///
/// BaseInterface2Prx Methods:
///
///  - baseOp: 
///
///  - baseOpAsync: 
///
///  - baseOp2: 
///
///  - baseOp2Async: 
public protocol BaseInterface2Prx: Ice.ObjectPrx {}

private final class BaseInterface2PrxI: Ice.ObjectPrxI, BaseInterface2Prx {
    public override class func ice_staticId() -> Swift.String {
        return BaseInterface2Traits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `BaseInterface2Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `BaseInterface2Prx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: BaseInterface2Prx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> BaseInterface2Prx? {
    return try BaseInterface2PrxI.checkedCast(prx: prx, facet: facet, context: context) as BaseInterface2PrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `BaseInterface2Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `BaseInterface2Prx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: BaseInterface2Prx.Protocol, facet: Swift.String? = nil) -> BaseInterface2Prx {
    return BaseInterface2PrxI.uncheckedCast(prx: prx, facet: facet) as BaseInterface2PrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `BaseInterface2Prx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: BaseInterface2Prx.Protocol) -> Swift.String {
    return BaseInterface2Traits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `BaseInterface2Prx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `BaseInterface2Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `BaseInterface2Prx?` - The extracted proxy
    func read(_ type: BaseInterface2Prx.Protocol) throws -> BaseInterface2Prx? {
        return try read() as BaseInterface2PrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `BaseInterface2Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `BaseInterface2Prx` - The extracted proxy.
    func read(tag: Swift.Int32, type: BaseInterface2Prx.Protocol) throws -> BaseInterface2Prx? {
        return try read(tag: tag) as BaseInterface2PrxI?
    }
}

/// BaseInterface2Prx overview.
///
/// BaseInterface2Prx Methods:
///
///  - baseOp: 
///
///  - baseOpAsync: 
///
///  - baseOp2: 
///
///  - baseOp2Async: 
public extension BaseInterface2Prx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Int32`
    func baseOp(context: Ice.Context? = nil) throws -> Swift.Int32 {
        return try _impl._invoke(operation: "baseOp",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: Swift.Int32 = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Int32>` - The result of the operation
    func baseOpAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Int32> {
        return _impl._invokeAsync(operation: "baseOp",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_returnValue: Swift.Int32 = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String`
    func baseOp2(_ iceP_i: Swift.Int32, context: Ice.Context? = nil) throws -> Swift.String {
        return try _impl._invoke(operation: "baseOp2",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_i)
                                 },
                                 read: { istr in
                                     let iceP_s: Swift.String = try istr.read()
                                     return iceP_s
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as Exception1 {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.String>` - The result of the operation
    func baseOp2Async(_ iceP_i: Swift.Int32, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.String> {
        return _impl._invokeAsync(operation: "baseOp2",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_i)
                                  },
                                  read: { istr in
                                      let iceP_s: Swift.String = try istr.read()
                                      return iceP_s
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as Exception1 {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// BaseInterface3Prx overview.
///
/// BaseInterface3Prx Methods:
///
///  - baseOp: 
///
///  - baseOpAsync: 
///
///  - baseOp2: 
///
///  - baseOp2Async: 
public protocol BaseInterface3Prx: Ice.ObjectPrx {}

private final class BaseInterface3PrxI: Ice.ObjectPrxI, BaseInterface3Prx {
    public override class func ice_staticId() -> Swift.String {
        return BaseInterface3Traits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `BaseInterface3Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `BaseInterface3Prx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: BaseInterface3Prx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> BaseInterface3Prx? {
    return try BaseInterface3PrxI.checkedCast(prx: prx, facet: facet, context: context) as BaseInterface3PrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `BaseInterface3Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `BaseInterface3Prx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: BaseInterface3Prx.Protocol, facet: Swift.String? = nil) -> BaseInterface3Prx {
    return BaseInterface3PrxI.uncheckedCast(prx: prx, facet: facet) as BaseInterface3PrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `BaseInterface3Prx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: BaseInterface3Prx.Protocol) -> Swift.String {
    return BaseInterface3Traits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `BaseInterface3Prx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `BaseInterface3Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `BaseInterface3Prx?` - The extracted proxy
    func read(_ type: BaseInterface3Prx.Protocol) throws -> BaseInterface3Prx? {
        return try read() as BaseInterface3PrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `BaseInterface3Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `BaseInterface3Prx` - The extracted proxy.
    func read(tag: Swift.Int32, type: BaseInterface3Prx.Protocol) throws -> BaseInterface3Prx? {
        return try read(tag: tag) as BaseInterface3PrxI?
    }
}

/// BaseInterface3Prx overview.
///
/// BaseInterface3Prx Methods:
///
///  - baseOp: 
///
///  - baseOpAsync: 
///
///  - baseOp2: 
///
///  - baseOp2Async: 
public extension BaseInterface3Prx {
    ///
    /// - parameter _: `Ice.Value?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func baseOp(_ iceP_o: Ice.Value?, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "baseOp",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_o)
                              ostr.writePendingValues()
                          },
                          context: context)
    }

    ///
    /// - parameter _: `Ice.Value?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func baseOpAsync(_ iceP_o: Ice.Value?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "baseOp",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_o)
                                      ostr.writePendingValues()
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String`
    func baseOp2(_ iceP_i: Swift.Int32, context: Ice.Context? = nil) throws -> Swift.String {
        return try _impl._invoke(operation: "baseOp2",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_i)
                                 },
                                 read: { istr in
                                     let iceP_s: Swift.String = try istr.read()
                                     return iceP_s
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as Exception1 {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.String>` - The result of the operation
    func baseOp2Async(_ iceP_i: Swift.Int32, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.String> {
        return _impl._invokeAsync(operation: "baseOp2",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_i)
                                  },
                                  read: { istr in
                                      let iceP_s: Swift.String = try istr.read()
                                      return iceP_s
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as Exception1 {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// BaseInterface4Prx overview.
///
/// BaseInterface4Prx Methods:
///
///  - baseOp: 
///
///  - baseOpAsync: 
///
///  - baseOp2: 
///
///  - baseOp2Async: 
public protocol BaseInterface4Prx: Ice.ObjectPrx {}

private final class BaseInterface4PrxI: Ice.ObjectPrxI, BaseInterface4Prx {
    public override class func ice_staticId() -> Swift.String {
        return BaseInterface4Traits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `BaseInterface4Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `BaseInterface4Prx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: BaseInterface4Prx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> BaseInterface4Prx? {
    return try BaseInterface4PrxI.checkedCast(prx: prx, facet: facet, context: context) as BaseInterface4PrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `BaseInterface4Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `BaseInterface4Prx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: BaseInterface4Prx.Protocol, facet: Swift.String? = nil) -> BaseInterface4Prx {
    return BaseInterface4PrxI.uncheckedCast(prx: prx, facet: facet) as BaseInterface4PrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `BaseInterface4Prx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: BaseInterface4Prx.Protocol) -> Swift.String {
    return BaseInterface4Traits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `BaseInterface4Prx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `BaseInterface4Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `BaseInterface4Prx?` - The extracted proxy
    func read(_ type: BaseInterface4Prx.Protocol) throws -> BaseInterface4Prx? {
        return try read() as BaseInterface4PrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `BaseInterface4Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `BaseInterface4Prx` - The extracted proxy.
    func read(tag: Swift.Int32, type: BaseInterface4Prx.Protocol) throws -> BaseInterface4Prx? {
        return try read(tag: tag) as BaseInterface4PrxI?
    }
}

/// BaseInterface4Prx overview.
///
/// BaseInterface4Prx Methods:
///
///  - baseOp: 
///
///  - baseOpAsync: 
///
///  - baseOp2: 
///
///  - baseOp2Async: 
public extension BaseInterface4Prx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func baseOp(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "baseOp",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func baseOpAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "baseOp",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String`
    func baseOp2(_ iceP_i: Swift.Int32, context: Ice.Context? = nil) throws -> Swift.String {
        return try _impl._invoke(operation: "baseOp2",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_i)
                                 },
                                 read: { istr in
                                     let iceP_s: Swift.String = try istr.read()
                                     return iceP_s
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as Exception1 {
                                         throw error
                                     } catch let error as Exception2 {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.String>` - The result of the operation
    func baseOp2Async(_ iceP_i: Swift.Int32, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.String> {
        return _impl._invokeAsync(operation: "baseOp2",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_i)
                                  },
                                  read: { istr in
                                      let iceP_s: Swift.String = try istr.read()
                                      return iceP_s
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as Exception1 {
                                          throw error
                                      } catch let error as Exception2 {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// BaseInterface5Prx overview.
///
/// BaseInterface5Prx Methods:
///
///  - baseOp: 
///
///  - baseOpAsync: 
///
///  - baseOp2: 
///
///  - baseOp2Async: 
public protocol BaseInterface5Prx: Ice.ObjectPrx {}

private final class BaseInterface5PrxI: Ice.ObjectPrxI, BaseInterface5Prx {
    public override class func ice_staticId() -> Swift.String {
        return BaseInterface5Traits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `BaseInterface5Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `BaseInterface5Prx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: BaseInterface5Prx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> BaseInterface5Prx? {
    return try BaseInterface5PrxI.checkedCast(prx: prx, facet: facet, context: context) as BaseInterface5PrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `BaseInterface5Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `BaseInterface5Prx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: BaseInterface5Prx.Protocol, facet: Swift.String? = nil) -> BaseInterface5Prx {
    return BaseInterface5PrxI.uncheckedCast(prx: prx, facet: facet) as BaseInterface5PrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `BaseInterface5Prx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: BaseInterface5Prx.Protocol) -> Swift.String {
    return BaseInterface5Traits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `BaseInterface5Prx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `BaseInterface5Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `BaseInterface5Prx?` - The extracted proxy
    func read(_ type: BaseInterface5Prx.Protocol) throws -> BaseInterface5Prx? {
        return try read() as BaseInterface5PrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `BaseInterface5Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `BaseInterface5Prx` - The extracted proxy.
    func read(tag: Swift.Int32, type: BaseInterface5Prx.Protocol) throws -> BaseInterface5Prx? {
        return try read(tag: tag) as BaseInterface5PrxI?
    }
}

/// BaseInterface5Prx overview.
///
/// BaseInterface5Prx Methods:
///
///  - baseOp: 
///
///  - baseOpAsync: 
///
///  - baseOp2: 
///
///  - baseOp2Async: 
public extension BaseInterface5Prx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func baseOp(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "baseOp",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func baseOpAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "baseOp",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter i: `Swift.Int32`
    ///
    /// - parameter s: `Swift.String`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func baseOp2(i iceP_i: Swift.Int32, s iceP_s: Swift.String, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "baseOp2",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_i)
                              ostr.write(iceP_s)
                          },
                          userException:{ ex in
                              do  {
                                  throw ex
                              } catch let error as Exception1 {
                                  throw error
                              } catch is Ice.UserException {}
                          },
                          context: context)
    }

    ///
    /// - parameter i: `Swift.Int32`
    ///
    /// - parameter s: `Swift.String`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func baseOp2Async(i iceP_i: Swift.Int32, s iceP_s: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "baseOp2",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_i)
                                      ostr.write(iceP_s)
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as Exception1 {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// BaseInterface6Prx overview.
///
/// BaseInterface6Prx Methods:
///
///  - baseOp: 
///
///  - baseOpAsync: 
///
///  - baseOp2: 
///
///  - baseOp2Async: 
public protocol BaseInterface6Prx: Ice.ObjectPrx {}

private final class BaseInterface6PrxI: Ice.ObjectPrxI, BaseInterface6Prx {
    public override class func ice_staticId() -> Swift.String {
        return BaseInterface6Traits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `BaseInterface6Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `BaseInterface6Prx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: BaseInterface6Prx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> BaseInterface6Prx? {
    return try BaseInterface6PrxI.checkedCast(prx: prx, facet: facet, context: context) as BaseInterface6PrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `BaseInterface6Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `BaseInterface6Prx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: BaseInterface6Prx.Protocol, facet: Swift.String? = nil) -> BaseInterface6Prx {
    return BaseInterface6PrxI.uncheckedCast(prx: prx, facet: facet) as BaseInterface6PrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `BaseInterface6Prx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: BaseInterface6Prx.Protocol) -> Swift.String {
    return BaseInterface6Traits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `BaseInterface6Prx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `BaseInterface6Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `BaseInterface6Prx?` - The extracted proxy
    func read(_ type: BaseInterface6Prx.Protocol) throws -> BaseInterface6Prx? {
        return try read() as BaseInterface6PrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `BaseInterface6Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `BaseInterface6Prx` - The extracted proxy.
    func read(tag: Swift.Int32, type: BaseInterface6Prx.Protocol) throws -> BaseInterface6Prx? {
        return try read(tag: tag) as BaseInterface6PrxI?
    }
}

/// BaseInterface6Prx overview.
///
/// BaseInterface6Prx Methods:
///
///  - baseOp: 
///
///  - baseOpAsync: 
///
///  - baseOp2: 
///
///  - baseOp2Async: 
public extension BaseInterface6Prx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func baseOp(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "baseOp",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func baseOpAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "baseOp",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String`
    func baseOp2(context: Ice.Context? = nil) throws -> Swift.String {
        return try _impl._invoke(operation: "baseOp2",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_s: Swift.String = try istr.read()
                                     return iceP_s
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as Exception1 {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.String>` - The result of the operation
    func baseOp2Async(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.String> {
        return _impl._invokeAsync(operation: "baseOp2",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_s: Swift.String = try istr.read()
                                      return iceP_s
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as Exception1 {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// BaseInterface7Prx overview.
///
/// BaseInterface7Prx Methods:
///
///  - baseOp: 
///
///  - baseOpAsync: 
///
///  - baseOp2: 
///
///  - baseOp2Async: 
public protocol BaseInterface7Prx: Ice.ObjectPrx {}

private final class BaseInterface7PrxI: Ice.ObjectPrxI, BaseInterface7Prx {
    public override class func ice_staticId() -> Swift.String {
        return BaseInterface7Traits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `BaseInterface7Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `BaseInterface7Prx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: BaseInterface7Prx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> BaseInterface7Prx? {
    return try BaseInterface7PrxI.checkedCast(prx: prx, facet: facet, context: context) as BaseInterface7PrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `BaseInterface7Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `BaseInterface7Prx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: BaseInterface7Prx.Protocol, facet: Swift.String? = nil) -> BaseInterface7Prx {
    return BaseInterface7PrxI.uncheckedCast(prx: prx, facet: facet) as BaseInterface7PrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `BaseInterface7Prx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: BaseInterface7Prx.Protocol) -> Swift.String {
    return BaseInterface7Traits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `BaseInterface7Prx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `BaseInterface7Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `BaseInterface7Prx?` - The extracted proxy
    func read(_ type: BaseInterface7Prx.Protocol) throws -> BaseInterface7Prx? {
        return try read() as BaseInterface7PrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `BaseInterface7Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `BaseInterface7Prx` - The extracted proxy.
    func read(tag: Swift.Int32, type: BaseInterface7Prx.Protocol) throws -> BaseInterface7Prx? {
        return try read(tag: tag) as BaseInterface7PrxI?
    }
}

/// BaseInterface7Prx overview.
///
/// BaseInterface7Prx Methods:
///
///  - baseOp: 
///
///  - baseOpAsync: 
///
///  - baseOp2: 
///
///  - baseOp2Async: 
public extension BaseInterface7Prx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func baseOp(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "baseOp",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func baseOpAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "baseOp",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String`
    func baseOp2(_ iceP_i: Swift.Int32, context: Ice.Context? = nil) throws -> Swift.String {
        return try _impl._invoke(operation: "baseOp2",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_i)
                                 },
                                 read: { istr in
                                     let iceP_s: Swift.String = try istr.read()
                                     return iceP_s
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.String>` - The result of the operation
    func baseOp2Async(_ iceP_i: Swift.Int32, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.String> {
        return _impl._invokeAsync(operation: "baseOp2",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_i)
                                  },
                                  read: { istr in
                                      let iceP_s: Swift.String = try istr.read()
                                      return iceP_s
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// BaseInterface8Prx overview.
///
/// BaseInterface8Prx Methods:
///
///  - baseOp2: 
///
///  - baseOp2Async: 
public protocol BaseInterface8Prx: Ice.ObjectPrx {}

private final class BaseInterface8PrxI: Ice.ObjectPrxI, BaseInterface8Prx {
    public override class func ice_staticId() -> Swift.String {
        return BaseInterface8Traits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `BaseInterface8Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `BaseInterface8Prx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: BaseInterface8Prx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> BaseInterface8Prx? {
    return try BaseInterface8PrxI.checkedCast(prx: prx, facet: facet, context: context) as BaseInterface8PrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `BaseInterface8Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `BaseInterface8Prx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: BaseInterface8Prx.Protocol, facet: Swift.String? = nil) -> BaseInterface8Prx {
    return BaseInterface8PrxI.uncheckedCast(prx: prx, facet: facet) as BaseInterface8PrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `BaseInterface8Prx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: BaseInterface8Prx.Protocol) -> Swift.String {
    return BaseInterface8Traits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `BaseInterface8Prx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `BaseInterface8Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `BaseInterface8Prx?` - The extracted proxy
    func read(_ type: BaseInterface8Prx.Protocol) throws -> BaseInterface8Prx? {
        return try read() as BaseInterface8PrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `BaseInterface8Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `BaseInterface8Prx` - The extracted proxy.
    func read(tag: Swift.Int32, type: BaseInterface8Prx.Protocol) throws -> BaseInterface8Prx? {
        return try read(tag: tag) as BaseInterface8PrxI?
    }
}

/// BaseInterface8Prx overview.
///
/// BaseInterface8Prx Methods:
///
///  - baseOp2: 
///
///  - baseOp2Async: 
public extension BaseInterface8Prx {
    ///
    /// - parameter _: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String`
    func baseOp2(_ iceP_i: Swift.Int32, context: Ice.Context? = nil) throws -> Swift.String {
        return try _impl._invoke(operation: "baseOp2",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_i)
                                 },
                                 read: { istr in
                                     let iceP_s: Swift.String = try istr.read()
                                     return iceP_s
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as Exception1 {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.String>` - The result of the operation
    func baseOp2Async(_ iceP_i: Swift.Int32, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.String> {
        return _impl._invokeAsync(operation: "baseOp2",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_i)
                                  },
                                  read: { istr in
                                      let iceP_s: Swift.String = try istr.read()
                                      return iceP_s
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as Exception1 {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// BaseInterface9Prx overview.
///
/// BaseInterface9Prx Methods:
///
///  - baseOp: 
///
///  - baseOpAsync: 
///
///  - baseOp2: 
///
///  - baseOp2Async: 
public protocol BaseInterface9Prx: Interface1Prx {}

private final class BaseInterface9PrxI: Ice.ObjectPrxI, BaseInterface9Prx {
    public override class func ice_staticId() -> Swift.String {
        return BaseInterface9Traits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `BaseInterface9Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `BaseInterface9Prx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: BaseInterface9Prx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> BaseInterface9Prx? {
    return try BaseInterface9PrxI.checkedCast(prx: prx, facet: facet, context: context) as BaseInterface9PrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `BaseInterface9Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `BaseInterface9Prx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: BaseInterface9Prx.Protocol, facet: Swift.String? = nil) -> BaseInterface9Prx {
    return BaseInterface9PrxI.uncheckedCast(prx: prx, facet: facet) as BaseInterface9PrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `BaseInterface9Prx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: BaseInterface9Prx.Protocol) -> Swift.String {
    return BaseInterface9Traits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `BaseInterface9Prx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `BaseInterface9Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `BaseInterface9Prx?` - The extracted proxy
    func read(_ type: BaseInterface9Prx.Protocol) throws -> BaseInterface9Prx? {
        return try read() as BaseInterface9PrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `BaseInterface9Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `BaseInterface9Prx` - The extracted proxy.
    func read(tag: Swift.Int32, type: BaseInterface9Prx.Protocol) throws -> BaseInterface9Prx? {
        return try read(tag: tag) as BaseInterface9PrxI?
    }
}

/// BaseInterface9Prx overview.
///
/// BaseInterface9Prx Methods:
///
///  - baseOp: 
///
///  - baseOpAsync: 
///
///  - baseOp2: 
///
///  - baseOp2Async: 
public extension BaseInterface9Prx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func baseOp(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "baseOp",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func baseOpAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "baseOp",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String`
    func baseOp2(_ iceP_i: Swift.Int32, context: Ice.Context? = nil) throws -> Swift.String {
        return try _impl._invoke(operation: "baseOp2",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_i)
                                 },
                                 read: { istr in
                                     let iceP_s: Swift.String = try istr.read()
                                     return iceP_s
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as Exception1 {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.String>` - The result of the operation
    func baseOp2Async(_ iceP_i: Swift.Int32, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.String> {
        return _impl._invokeAsync(operation: "baseOp2",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_i)
                                  },
                                  read: { istr in
                                      let iceP_s: Swift.String = try istr.read()
                                      return iceP_s
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as Exception1 {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// BaseInterface10Prx overview.
///
/// BaseInterface10Prx Methods:
///
///  - baseOp: 
///
///  - baseOpAsync: 
///
///  - baseOp2: 
///
///  - baseOp2Async: 
public protocol BaseInterface10Prx: Interface1Prx {}

private final class BaseInterface10PrxI: Ice.ObjectPrxI, BaseInterface10Prx {
    public override class func ice_staticId() -> Swift.String {
        return BaseInterface10Traits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `BaseInterface10Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `BaseInterface10Prx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: BaseInterface10Prx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> BaseInterface10Prx? {
    return try BaseInterface10PrxI.checkedCast(prx: prx, facet: facet, context: context) as BaseInterface10PrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `BaseInterface10Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `BaseInterface10Prx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: BaseInterface10Prx.Protocol, facet: Swift.String? = nil) -> BaseInterface10Prx {
    return BaseInterface10PrxI.uncheckedCast(prx: prx, facet: facet) as BaseInterface10PrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `BaseInterface10Prx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: BaseInterface10Prx.Protocol) -> Swift.String {
    return BaseInterface10Traits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `BaseInterface10Prx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `BaseInterface10Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `BaseInterface10Prx?` - The extracted proxy
    func read(_ type: BaseInterface10Prx.Protocol) throws -> BaseInterface10Prx? {
        return try read() as BaseInterface10PrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `BaseInterface10Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `BaseInterface10Prx` - The extracted proxy.
    func read(tag: Swift.Int32, type: BaseInterface10Prx.Protocol) throws -> BaseInterface10Prx? {
        return try read(tag: tag) as BaseInterface10PrxI?
    }
}

/// BaseInterface10Prx overview.
///
/// BaseInterface10Prx Methods:
///
///  - baseOp: 
///
///  - baseOpAsync: 
///
///  - baseOp2: 
///
///  - baseOp2Async: 
public extension BaseInterface10Prx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func baseOp(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "baseOp",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func baseOpAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "baseOp",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String`
    func baseOp2(_ iceP_i: Swift.Int32, context: Ice.Context? = nil) throws -> Swift.String {
        return try _impl._invoke(operation: "baseOp2",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_i)
                                 },
                                 read: { istr in
                                     let iceP_s: Swift.String = try istr.read()
                                     return iceP_s
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as Exception1 {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.String>` - The result of the operation
    func baseOp2Async(_ iceP_i: Swift.Int32, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.String> {
        return _impl._invokeAsync(operation: "baseOp2",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_i)
                                  },
                                  read: { istr in
                                      let iceP_s: Swift.String = try istr.read()
                                      return iceP_s
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as Exception1 {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// OptionalParameters0Prx overview.
///
/// OptionalParameters0Prx Methods:
///
///  - op1: 
///
///  - op1Async: 
public protocol OptionalParameters0Prx: Ice.ObjectPrx {}

private final class OptionalParameters0PrxI: Ice.ObjectPrxI, OptionalParameters0Prx {
    public override class func ice_staticId() -> Swift.String {
        return OptionalParameters0Traits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `OptionalParameters0Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `OptionalParameters0Prx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: OptionalParameters0Prx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> OptionalParameters0Prx? {
    return try OptionalParameters0PrxI.checkedCast(prx: prx, facet: facet, context: context) as OptionalParameters0PrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `OptionalParameters0Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `OptionalParameters0Prx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: OptionalParameters0Prx.Protocol, facet: Swift.String? = nil) -> OptionalParameters0Prx {
    return OptionalParameters0PrxI.uncheckedCast(prx: prx, facet: facet) as OptionalParameters0PrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `OptionalParameters0Prx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: OptionalParameters0Prx.Protocol) -> Swift.String {
    return OptionalParameters0Traits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `OptionalParameters0Prx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `OptionalParameters0Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `OptionalParameters0Prx?` - The extracted proxy
    func read(_ type: OptionalParameters0Prx.Protocol) throws -> OptionalParameters0Prx? {
        return try read() as OptionalParameters0PrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `OptionalParameters0Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `OptionalParameters0Prx` - The extracted proxy.
    func read(tag: Swift.Int32, type: OptionalParameters0Prx.Protocol) throws -> OptionalParameters0Prx? {
        return try read(tag: tag) as OptionalParameters0PrxI?
    }
}

/// OptionalParameters0Prx overview.
///
/// OptionalParameters0Prx Methods:
///
///  - op1: 
///
///  - op1Async: 
public extension OptionalParameters0Prx {
    ///
    /// - parameter firstName: `Swift.String`
    ///
    /// - parameter secondName: `Swift.String?`
    ///
    /// - parameter emailAddress: `Swift.String?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func op1(firstName iceP_firstName: Swift.String, secondName iceP_secondName: Swift.String? = nil, emailAddress iceP_emailAddress: Swift.String? = nil, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "op1",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_firstName)
                              ostr.write(tag: 1, value: iceP_secondName)
                              ostr.write(tag: 2, value: iceP_emailAddress)
                          },
                          context: context)
    }

    ///
    /// - parameter firstName: `Swift.String`
    ///
    /// - parameter secondName: `Swift.String?`
    ///
    /// - parameter emailAddress: `Swift.String?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func op1Async(firstName iceP_firstName: Swift.String, secondName iceP_secondName: Swift.String? = nil, emailAddress iceP_emailAddress: Swift.String? = nil, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "op1",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_firstName)
                                      ostr.write(tag: 1, value: iceP_secondName)
                                      ostr.write(tag: 2, value: iceP_emailAddress)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// OptionalParameters1Prx overview.
///
/// OptionalParameters1Prx Methods:
///
///  - op1: 
///
///  - op1Async: 
public protocol OptionalParameters1Prx: Ice.ObjectPrx {}

private final class OptionalParameters1PrxI: Ice.ObjectPrxI, OptionalParameters1Prx {
    public override class func ice_staticId() -> Swift.String {
        return OptionalParameters1Traits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `OptionalParameters1Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `OptionalParameters1Prx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: OptionalParameters1Prx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> OptionalParameters1Prx? {
    return try OptionalParameters1PrxI.checkedCast(prx: prx, facet: facet, context: context) as OptionalParameters1PrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `OptionalParameters1Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `OptionalParameters1Prx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: OptionalParameters1Prx.Protocol, facet: Swift.String? = nil) -> OptionalParameters1Prx {
    return OptionalParameters1PrxI.uncheckedCast(prx: prx, facet: facet) as OptionalParameters1PrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `OptionalParameters1Prx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: OptionalParameters1Prx.Protocol) -> Swift.String {
    return OptionalParameters1Traits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `OptionalParameters1Prx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `OptionalParameters1Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `OptionalParameters1Prx?` - The extracted proxy
    func read(_ type: OptionalParameters1Prx.Protocol) throws -> OptionalParameters1Prx? {
        return try read() as OptionalParameters1PrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `OptionalParameters1Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `OptionalParameters1Prx` - The extracted proxy.
    func read(tag: Swift.Int32, type: OptionalParameters1Prx.Protocol) throws -> OptionalParameters1Prx? {
        return try read(tag: tag) as OptionalParameters1PrxI?
    }
}

/// OptionalParameters1Prx overview.
///
/// OptionalParameters1Prx Methods:
///
///  - op1: 
///
///  - op1Async: 
public extension OptionalParameters1Prx {
    ///
    /// - parameter firstName: `Swift.String`
    ///
    /// - parameter emailAddress: `Swift.String?`
    ///
    /// - parameter secondName: `Swift.String?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func op1(firstName iceP_firstName: Swift.String, emailAddress iceP_emailAddress: Swift.String? = nil, secondName iceP_secondName: Swift.String? = nil, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "op1",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_firstName)
                              ostr.write(tag: 1, value: iceP_secondName)
                              ostr.write(tag: 2, value: iceP_emailAddress)
                          },
                          context: context)
    }

    ///
    /// - parameter firstName: `Swift.String`
    ///
    /// - parameter emailAddress: `Swift.String?`
    ///
    /// - parameter secondName: `Swift.String?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func op1Async(firstName iceP_firstName: Swift.String, emailAddress iceP_emailAddress: Swift.String? = nil, secondName iceP_secondName: Swift.String? = nil, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "op1",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_firstName)
                                      ostr.write(tag: 1, value: iceP_secondName)
                                      ostr.write(tag: 2, value: iceP_emailAddress)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// OptionalParameters2Prx overview.
///
/// OptionalParameters2Prx Methods:
///
///  - op1: 
///
///  - op1Async: 
public protocol OptionalParameters2Prx: Ice.ObjectPrx {}

private final class OptionalParameters2PrxI: Ice.ObjectPrxI, OptionalParameters2Prx {
    public override class func ice_staticId() -> Swift.String {
        return OptionalParameters2Traits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `OptionalParameters2Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `OptionalParameters2Prx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: OptionalParameters2Prx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> OptionalParameters2Prx? {
    return try OptionalParameters2PrxI.checkedCast(prx: prx, facet: facet, context: context) as OptionalParameters2PrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `OptionalParameters2Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `OptionalParameters2Prx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: OptionalParameters2Prx.Protocol, facet: Swift.String? = nil) -> OptionalParameters2Prx {
    return OptionalParameters2PrxI.uncheckedCast(prx: prx, facet: facet) as OptionalParameters2PrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `OptionalParameters2Prx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: OptionalParameters2Prx.Protocol) -> Swift.String {
    return OptionalParameters2Traits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `OptionalParameters2Prx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `OptionalParameters2Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `OptionalParameters2Prx?` - The extracted proxy
    func read(_ type: OptionalParameters2Prx.Protocol) throws -> OptionalParameters2Prx? {
        return try read() as OptionalParameters2PrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `OptionalParameters2Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `OptionalParameters2Prx` - The extracted proxy.
    func read(tag: Swift.Int32, type: OptionalParameters2Prx.Protocol) throws -> OptionalParameters2Prx? {
        return try read(tag: tag) as OptionalParameters2PrxI?
    }
}

/// OptionalParameters2Prx overview.
///
/// OptionalParameters2Prx Methods:
///
///  - op1: 
///
///  - op1Async: 
public extension OptionalParameters2Prx {
    ///
    /// - parameter firstName: `Swift.String`
    ///
    /// - parameter emailAddress: `Swift.String?`
    ///
    /// - parameter secondName: `Swift.String?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func op1(firstName iceP_firstName: Swift.String, emailAddress iceP_emailAddress: Swift.String? = nil, secondName iceP_secondName: Swift.String? = nil, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "op1",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_firstName)
                              ostr.write(tag: 1, value: iceP_secondName)
                              ostr.write(tag: 2, value: iceP_emailAddress)
                          },
                          context: context)
    }

    ///
    /// - parameter firstName: `Swift.String`
    ///
    /// - parameter emailAddress: `Swift.String?`
    ///
    /// - parameter secondName: `Swift.String?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func op1Async(firstName iceP_firstName: Swift.String, emailAddress iceP_emailAddress: Swift.String? = nil, secondName iceP_secondName: Swift.String? = nil, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "op1",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_firstName)
                                      ostr.write(tag: 1, value: iceP_secondName)
                                      ostr.write(tag: 2, value: iceP_emailAddress)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// OptionalParameters3Prx overview.
///
/// OptionalParameters3Prx Methods:
///
///  - op1: 
///
///  - op1Async: 
public protocol OptionalParameters3Prx: Ice.ObjectPrx {}

private final class OptionalParameters3PrxI: Ice.ObjectPrxI, OptionalParameters3Prx {
    public override class func ice_staticId() -> Swift.String {
        return OptionalParameters3Traits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `OptionalParameters3Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `OptionalParameters3Prx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: OptionalParameters3Prx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> OptionalParameters3Prx? {
    return try OptionalParameters3PrxI.checkedCast(prx: prx, facet: facet, context: context) as OptionalParameters3PrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `OptionalParameters3Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `OptionalParameters3Prx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: OptionalParameters3Prx.Protocol, facet: Swift.String? = nil) -> OptionalParameters3Prx {
    return OptionalParameters3PrxI.uncheckedCast(prx: prx, facet: facet) as OptionalParameters3PrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `OptionalParameters3Prx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: OptionalParameters3Prx.Protocol) -> Swift.String {
    return OptionalParameters3Traits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `OptionalParameters3Prx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `OptionalParameters3Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `OptionalParameters3Prx?` - The extracted proxy
    func read(_ type: OptionalParameters3Prx.Protocol) throws -> OptionalParameters3Prx? {
        return try read() as OptionalParameters3PrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `OptionalParameters3Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `OptionalParameters3Prx` - The extracted proxy.
    func read(tag: Swift.Int32, type: OptionalParameters3Prx.Protocol) throws -> OptionalParameters3Prx? {
        return try read(tag: tag) as OptionalParameters3PrxI?
    }
}

/// OptionalParameters3Prx overview.
///
/// OptionalParameters3Prx Methods:
///
///  - op1: 
///
///  - op1Async: 
public extension OptionalParameters3Prx {
    ///
    /// - parameter firstName: `Swift.String`
    ///
    /// - parameter emailAddress: `Swift.String`
    ///
    /// - parameter secondName: `Swift.String?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func op1(firstName iceP_firstName: Swift.String, emailAddress iceP_emailAddress: Swift.String, secondName iceP_secondName: Swift.String? = nil, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "op1",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_firstName)
                              ostr.write(iceP_emailAddress)
                              ostr.write(tag: 1, value: iceP_secondName)
                          },
                          context: context)
    }

    ///
    /// - parameter firstName: `Swift.String`
    ///
    /// - parameter emailAddress: `Swift.String`
    ///
    /// - parameter secondName: `Swift.String?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func op1Async(firstName iceP_firstName: Swift.String, emailAddress iceP_emailAddress: Swift.String, secondName iceP_secondName: Swift.String? = nil, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "op1",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_firstName)
                                      ostr.write(iceP_emailAddress)
                                      ostr.write(tag: 1, value: iceP_secondName)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// OptionalReturn0Prx overview.
///
/// OptionalReturn0Prx Methods:
///
///  - op: 
///
///  - opAsync: 
public protocol OptionalReturn0Prx: Ice.ObjectPrx {}

private final class OptionalReturn0PrxI: Ice.ObjectPrxI, OptionalReturn0Prx {
    public override class func ice_staticId() -> Swift.String {
        return OptionalReturn0Traits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `OptionalReturn0Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `OptionalReturn0Prx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: OptionalReturn0Prx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> OptionalReturn0Prx? {
    return try OptionalReturn0PrxI.checkedCast(prx: prx, facet: facet, context: context) as OptionalReturn0PrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `OptionalReturn0Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `OptionalReturn0Prx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: OptionalReturn0Prx.Protocol, facet: Swift.String? = nil) -> OptionalReturn0Prx {
    return OptionalReturn0PrxI.uncheckedCast(prx: prx, facet: facet) as OptionalReturn0PrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `OptionalReturn0Prx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: OptionalReturn0Prx.Protocol) -> Swift.String {
    return OptionalReturn0Traits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `OptionalReturn0Prx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `OptionalReturn0Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `OptionalReturn0Prx?` - The extracted proxy
    func read(_ type: OptionalReturn0Prx.Protocol) throws -> OptionalReturn0Prx? {
        return try read() as OptionalReturn0PrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `OptionalReturn0Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `OptionalReturn0Prx` - The extracted proxy.
    func read(tag: Swift.Int32, type: OptionalReturn0Prx.Protocol) throws -> OptionalReturn0Prx? {
        return try read(tag: tag) as OptionalReturn0PrxI?
    }
}

/// OptionalReturn0Prx overview.
///
/// OptionalReturn0Prx Methods:
///
///  - op: 
///
///  - opAsync: 
public extension OptionalReturn0Prx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Int32?`
    func op(context: Ice.Context? = nil) throws -> Swift.Int32? {
        return try _impl._invoke(operation: "op",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: Swift.Int32? = try istr.read(tag: 1)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Int32?>` - The result of the operation
    func opAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Int32?> {
        return _impl._invokeAsync(operation: "op",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_returnValue: Swift.Int32? = try istr.read(tag: 1)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// OptionalReturn2Prx overview.
///
/// OptionalReturn2Prx Methods:
///
///  - op: 
///
///  - opAsync: 
public protocol OptionalReturn2Prx: Ice.ObjectPrx {}

private final class OptionalReturn2PrxI: Ice.ObjectPrxI, OptionalReturn2Prx {
    public override class func ice_staticId() -> Swift.String {
        return OptionalReturn2Traits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `OptionalReturn2Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `OptionalReturn2Prx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: OptionalReturn2Prx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> OptionalReturn2Prx? {
    return try OptionalReturn2PrxI.checkedCast(prx: prx, facet: facet, context: context) as OptionalReturn2PrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `OptionalReturn2Prx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `OptionalReturn2Prx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: OptionalReturn2Prx.Protocol, facet: Swift.String? = nil) -> OptionalReturn2Prx {
    return OptionalReturn2PrxI.uncheckedCast(prx: prx, facet: facet) as OptionalReturn2PrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `OptionalReturn2Prx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: OptionalReturn2Prx.Protocol) -> Swift.String {
    return OptionalReturn2Traits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `OptionalReturn2Prx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `OptionalReturn2Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `OptionalReturn2Prx?` - The extracted proxy
    func read(_ type: OptionalReturn2Prx.Protocol) throws -> OptionalReturn2Prx? {
        return try read() as OptionalReturn2PrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `OptionalReturn2Prx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `OptionalReturn2Prx` - The extracted proxy.
    func read(tag: Swift.Int32, type: OptionalReturn2Prx.Protocol) throws -> OptionalReturn2Prx? {
        return try read(tag: tag) as OptionalReturn2PrxI?
    }
}

/// OptionalReturn2Prx overview.
///
/// OptionalReturn2Prx Methods:
///
///  - op: 
///
///  - opAsync: 
public extension OptionalReturn2Prx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Int32`
    func op(context: Ice.Context? = nil) throws -> Swift.Int32 {
        return try _impl._invoke(operation: "op",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: Swift.Int32 = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Int32>` - The result of the operation
    func opAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Int32> {
        return _impl._invokeAsync(operation: "op",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_returnValue: Swift.Int32 = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// :nodoc:
public class Enum4_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Enum4.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Enum4() -> Ice.ValueTypeResolver {
        return Enum4_TypeResolver()
    }
}

open class Enum4: Ice.Value {
    public required init() {}

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return Enum4Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return Enum4Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Enum4Traits.staticId, compactId: -1, last: true)
        ostr.endSlice()
    }
}

/// :nodoc:
public class Sequence3_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Sequence3.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Sequence3() -> Ice.ValueTypeResolver {
        return Sequence3_TypeResolver()
    }
}

open class Sequence3: Ice.Value {
    public required init() {}

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return Sequence3Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return Sequence3Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Sequence3Traits.staticId, compactId: -1, last: true)
        ostr.endSlice()
    }
}

/// :nodoc:
public class Dictionary4_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Dictionary4.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Dictionary4() -> Ice.ValueTypeResolver {
        return Dictionary4_TypeResolver()
    }
}

open class Dictionary4: Ice.Value {
    public required init() {}

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return Dictionary4Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return Dictionary4Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Dictionary4Traits.staticId, compactId: -1, last: true)
        ostr.endSlice()
    }
}

/// :nodoc:
public class Struct5_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Struct5.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Struct5() -> Ice.ValueTypeResolver {
        return Struct5_TypeResolver()
    }
}

open class Struct5: Ice.Value {
    public required init() {}

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return Struct5Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return Struct5Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Struct5Traits.staticId, compactId: -1, last: true)
        ostr.endSlice()
    }
}

/// :nodoc:
public class Interface2_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Interface2.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Interface2() -> Ice.ValueTypeResolver {
        return Interface2_TypeResolver()
    }
}

open class Interface2: Ice.Value {
    public required init() {}

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return Interface2Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return Interface2Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Interface2Traits.staticId, compactId: -1, last: true)
        ostr.endSlice()
    }
}

/// :nodoc:
public class EmptyClass1_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return EmptyClass1.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_EmptyClass1() -> Ice.ValueTypeResolver {
        return EmptyClass1_TypeResolver()
    }
}

open class EmptyClass1: Ice.Value {
    public required init() {}

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return EmptyClass1Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return EmptyClass1Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: EmptyClass1Traits.staticId, compactId: -1, last: true)
        ostr.endSlice()
    }
}

/// :nodoc:
public class EmptyClass2_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return EmptyClass2.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_EmptyClass2() -> Ice.ValueTypeResolver {
        return EmptyClass2_TypeResolver()
    }
}

open class EmptyClass2: Ice.Value {
    public var d: Swift.Double = 0.0

    public required init() {}

    public init(d: Swift.Double) {
        self.d = d
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return EmptyClass2Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return EmptyClass2Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.d = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: EmptyClass2Traits.staticId, compactId: -1, last: true)
        ostr.write(self.d)
        ostr.endSlice()
    }
}

/// :nodoc:
public class EmptyClass3_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return EmptyClass3.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_EmptyClass3() -> Ice.ValueTypeResolver {
        return EmptyClass3_TypeResolver()
    }
}

open class EmptyClass3: Ice.Value {
    public required init() {}

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return EmptyClass3Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return EmptyClass3Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: EmptyClass3Traits.staticId, compactId: -1, last: true)
        ostr.endSlice()
    }
}

/// :nodoc:
public class EmptyClass4_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return EmptyClass4.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_EmptyClass4() -> Ice.ValueTypeResolver {
        return EmptyClass4_TypeResolver()
    }
}

open class EmptyClass4: EmptyClass1 {
    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return EmptyClass4Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return EmptyClass4Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: EmptyClass4Traits.staticId, compactId: -1, last: false)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}

/// :nodoc:
public class EmptyClass5_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return EmptyClass5.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_EmptyClass5() -> Ice.ValueTypeResolver {
        return EmptyClass5_TypeResolver()
    }
}

open class EmptyClass5: Ice.Value {
    public required init() {}

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return EmptyClass5Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return EmptyClass5Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: EmptyClass5Traits.staticId, compactId: -1, last: true)
        ostr.endSlice()
    }
}

/// :nodoc:
public class SimpleClass1_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return SimpleClass1.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_SimpleClass1() -> Ice.ValueTypeResolver {
        return SimpleClass1_TypeResolver()
    }
}

open class SimpleClass1: Ice.Value {
    public var str: Swift.String = ""
    public var f: Swift.Float = 0.0

    public required init() {}

    public init(str: Swift.String, f: Swift.Float) {
        self.str = str
        self.f = f
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return SimpleClass1Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return SimpleClass1Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.str = try istr.read()
        self.f = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: SimpleClass1Traits.staticId, compactId: -1, last: true)
        ostr.write(self.str)
        ostr.write(self.f)
        ostr.endSlice()
    }
}

/// :nodoc:
public class SimpleClass2_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return SimpleClass2.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_SimpleClass2() -> Ice.ValueTypeResolver {
        return SimpleClass2_TypeResolver()
    }
}

open class SimpleClass2: Ice.Value {
    public var str: Swift.String = ""
    public var f: Swift.Float = 0.0

    public required init() {}

    public init(str: Swift.String, f: Swift.Float) {
        self.str = str
        self.f = f
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return SimpleClass2Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return SimpleClass2Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.str = try istr.read()
        self.f = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: SimpleClass2Traits.staticId, compactId: -1, last: true)
        ostr.write(self.str)
        ostr.write(self.f)
        ostr.endSlice()
    }
}

/// :nodoc:
public class SimpleClass3_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return SimpleClass3.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_SimpleClass3() -> Ice.ValueTypeResolver {
        return SimpleClass3_TypeResolver()
    }
}

open class SimpleClass3: Ice.Value {
    public var str: Swift.String = ""
    public var g: Swift.Float = 0.0

    public required init() {}

    public init(str: Swift.String, g: Swift.Float) {
        self.str = str
        self.g = g
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return SimpleClass3Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return SimpleClass3Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.str = try istr.read()
        self.g = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: SimpleClass3Traits.staticId, compactId: -1, last: true)
        ostr.write(self.str)
        ostr.write(self.g)
        ostr.endSlice()
    }
}

/// :nodoc:
public class SimpleClass4_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return SimpleClass4.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_SimpleClass4() -> Ice.ValueTypeResolver {
        return SimpleClass4_TypeResolver()
    }
}

open class SimpleClass4: Ice.Value {
    public var str: Swift.String = ""
    public var f: Swift.Float = 0.0
    public var b: Swift.Bool = false

    public required init() {}

    public init(str: Swift.String, f: Swift.Float, b: Swift.Bool) {
        self.str = str
        self.f = f
        self.b = b
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return SimpleClass4Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return SimpleClass4Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.str = try istr.read()
        self.f = try istr.read()
        self.b = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: SimpleClass4Traits.staticId, compactId: -1, last: true)
        ostr.write(self.str)
        ostr.write(self.f)
        ostr.write(self.b)
        ostr.endSlice()
    }
}

/// :nodoc:
public class SimpleClass5_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return SimpleClass5.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_SimpleClass5() -> Ice.ValueTypeResolver {
        return SimpleClass5_TypeResolver()
    }
}

open class SimpleClass5: Ice.Value {
    public var str: Swift.String = ""

    public required init() {}

    public init(str: Swift.String) {
        self.str = str
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return SimpleClass5Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return SimpleClass5Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.str = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: SimpleClass5Traits.staticId, compactId: -1, last: true)
        ostr.write(self.str)
        ostr.endSlice()
    }
}

/// :nodoc:
public class SimpleClass6_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return SimpleClass6.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_SimpleClass6() -> Ice.ValueTypeResolver {
        return SimpleClass6_TypeResolver()
    }
}

open class SimpleClass6: Ice.Value {
    public var f: Swift.Float = 0.0
    public var str: Swift.String = ""

    public required init() {}

    public init(f: Swift.Float, str: Swift.String) {
        self.f = f
        self.str = str
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return SimpleClass6Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return SimpleClass6Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.f = try istr.read()
        self.str = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: SimpleClass6Traits.staticId, compactId: -1, last: true)
        ostr.write(self.f)
        ostr.write(self.str)
        ostr.endSlice()
    }
}

/// :nodoc:
public class SimpleClass7_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return SimpleClass7.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_SimpleClass7() -> Ice.ValueTypeResolver {
        return SimpleClass7_TypeResolver()
    }
}

open class SimpleClass7: Ice.Value {
    public var str: Swift.String = ""
    public var f: Swift.Double = 0.0

    public required init() {}

    public init(str: Swift.String, f: Swift.Double) {
        self.str = str
        self.f = f
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return SimpleClass7Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return SimpleClass7Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.str = try istr.read()
        self.f = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: SimpleClass7Traits.staticId, compactId: -1, last: true)
        ostr.write(self.str)
        ostr.write(self.f)
        ostr.endSlice()
    }
}

/// :nodoc:
public class Exception6_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Exception6.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Exception6() -> Ice.ValueTypeResolver {
        return Exception6_TypeResolver()
    }
}

open class Exception6: Ice.Value {
    public required init() {}

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return Exception6Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return Exception6Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Exception6Traits.staticId, compactId: -1, last: true)
        ostr.endSlice()
    }
}

/// :nodoc:
public class Compact1_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Compact1.self
    }
}

public extension Ice.TypeIdResolver {
    @objc static func TypeId_1() -> Swift.String {
        return "::Test::Compact1"
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Compact1() -> Ice.ValueTypeResolver {
        return Compact1_TypeResolver()
    }
}

open class Compact1: Ice.Value {
    public var id: Swift.Int32 = 0

    public required init() {}

    public init(id: Swift.Int32) {
        self.id = id
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return Compact1Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return Compact1Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.id = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Compact1Traits.staticId, compactId: 1, last: true)
        ostr.write(self.id)
        ostr.endSlice()
    }
}

/// :nodoc:
public class Derived1_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Derived1.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Derived1() -> Ice.ValueTypeResolver {
        return Derived1_TypeResolver()
    }
}

open class Derived1: Compact1 {
    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return Derived1Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return Derived1Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Derived1Traits.staticId, compactId: -1, last: false)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}

/// :nodoc:
public class Compact2_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Compact2.self
    }
}

public extension Ice.TypeIdResolver {
    @objc static func TypeId_3() -> Swift.String {
        return "::Test::Compact2"
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Compact2() -> Ice.ValueTypeResolver {
        return Compact2_TypeResolver()
    }
}

open class Compact2: Ice.Value {
    public var id: Swift.Int32 = 0

    public required init() {}

    public init(id: Swift.Int32) {
        self.id = id
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return Compact2Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return Compact2Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.id = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Compact2Traits.staticId, compactId: 3, last: true)
        ostr.write(self.id)
        ostr.endSlice()
    }
}

/// :nodoc:
public class Optional0_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Optional0.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Optional0() -> Ice.ValueTypeResolver {
        return Optional0_TypeResolver()
    }
}

open class Optional0: Ice.Value {
    public var firstName: Swift.String = ""
    public var secondName: Swift.String? = nil
    public var emailAddress: Swift.String? = nil

    public required init() {}

    public init(firstName: Swift.String, secondName: Swift.String?, emailAddress: Swift.String?) {
        self.firstName = firstName
        self.secondName = secondName
        self.emailAddress = emailAddress
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return Optional0Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return Optional0Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.firstName = try istr.read()
        self.secondName = try istr.read(tag: 1)
        self.emailAddress = try istr.read(tag: 2)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Optional0Traits.staticId, compactId: -1, last: true)
        ostr.write(self.firstName)
        ostr.write(tag: 1, value: self.secondName)
        ostr.write(tag: 2, value: self.emailAddress)
        ostr.endSlice()
    }
}

/// :nodoc:
public class Optional1_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Optional1.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Optional1() -> Ice.ValueTypeResolver {
        return Optional1_TypeResolver()
    }
}

open class Optional1: Ice.Value {
    public var firstName: Swift.String = ""
    public var emailAddress: Swift.String? = nil
    public var secondName: Swift.String? = nil

    public required init() {}

    public init(firstName: Swift.String, emailAddress: Swift.String?, secondName: Swift.String?) {
        self.firstName = firstName
        self.emailAddress = emailAddress
        self.secondName = secondName
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return Optional1Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return Optional1Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.firstName = try istr.read()
        self.secondName = try istr.read(tag: 1)
        self.emailAddress = try istr.read(tag: 2)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Optional1Traits.staticId, compactId: -1, last: true)
        ostr.write(self.firstName)
        ostr.write(tag: 1, value: self.secondName)
        ostr.write(tag: 2, value: self.emailAddress)
        ostr.endSlice()
    }
}

/// :nodoc:
public class Optional2_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Optional2.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Optional2() -> Ice.ValueTypeResolver {
        return Optional2_TypeResolver()
    }
}

open class Optional2: Ice.Value {
    public var firstName: Swift.String = ""
    public var secondName: Swift.String? = nil
    public var emailAddress: Swift.String = ""

    public required init() {}

    public init(firstName: Swift.String, secondName: Swift.String?, emailAddress: Swift.String) {
        self.firstName = firstName
        self.secondName = secondName
        self.emailAddress = emailAddress
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return Optional2Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return Optional2Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.firstName = try istr.read()
        self.emailAddress = try istr.read()
        self.secondName = try istr.read(tag: 1)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Optional2Traits.staticId, compactId: -1, last: true)
        ostr.write(self.firstName)
        ostr.write(self.emailAddress)
        ostr.write(tag: 1, value: self.secondName)
        ostr.endSlice()
    }
}

/// :nodoc:
public class Optional3_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Optional3.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Optional3() -> Ice.ValueTypeResolver {
        return Optional3_TypeResolver()
    }
}

open class Optional3: Ice.Value {
    public var firstName: Swift.String = ""
    public var secondName: Swift.String? = nil
    public var emailAddress: Swift.String? = nil
    public var phoneNumber: Swift.String? = nil

    public required init() {}

    public init(firstName: Swift.String, secondName: Swift.String?, emailAddress: Swift.String?, phoneNumber: Swift.String?) {
        self.firstName = firstName
        self.secondName = secondName
        self.emailAddress = emailAddress
        self.phoneNumber = phoneNumber
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return Optional3Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return Optional3Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.firstName = try istr.read()
        self.secondName = try istr.read(tag: 1)
        self.emailAddress = try istr.read(tag: 2)
        self.phoneNumber = try istr.read(tag: 3)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Optional3Traits.staticId, compactId: -1, last: true)
        ostr.write(self.firstName)
        ostr.write(tag: 1, value: self.secondName)
        ostr.write(tag: 2, value: self.emailAddress)
        ostr.write(tag: 3, value: self.phoneNumber)
        ostr.endSlice()
    }
}

/// :nodoc:
public class Optional4_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Optional4.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Optional4() -> Ice.ValueTypeResolver {
        return Optional4_TypeResolver()
    }
}

open class Optional4: Ice.Value {
    public var firstName: Swift.String = ""
    public var secondName: Swift.String? = nil
    public var emailAddress: Swift.String? = nil

    public required init() {}

    public init(firstName: Swift.String, secondName: Swift.String?, emailAddress: Swift.String?) {
        self.firstName = firstName
        self.secondName = secondName
        self.emailAddress = emailAddress
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return Optional4Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return Optional4Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.firstName = try istr.read()
        self.emailAddress = try istr.read(tag: 1)
        self.secondName = try istr.read(tag: 2)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Optional4Traits.staticId, compactId: -1, last: true)
        ostr.write(self.firstName)
        ostr.write(tag: 1, value: self.emailAddress)
        ostr.write(tag: 2, value: self.secondName)
        ostr.endSlice()
    }
}


/// Dispatcher for `Interface1` servants.
public struct Interface1Disp: Ice.Disp {
    public let servant: Interface1
    private static let defaultObject = Ice.ObjectI<Interface1Traits>()

    public init(_ servant: Interface1) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "ice_id":
            return try (servant as? Object ?? Interface1Disp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? Interface1Disp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? Interface1Disp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? Interface1Disp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol Interface1 {}


/// Dispatcher for `Interface3` servants.
public struct Interface3Disp: Ice.Disp {
    public let servant: Interface3
    private static let defaultObject = Ice.ObjectI<Interface3Traits>()

    public init(_ servant: Interface3) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "ice_id":
            return try (servant as? Object ?? Interface3Disp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? Interface3Disp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? Interface3Disp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? Interface3Disp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol Interface3: Interface1 {}


/// Dispatcher for `Interface4` servants.
public struct Interface4Disp: Ice.Disp {
    public let servant: Interface4
    private static let defaultObject = Ice.ObjectI<Interface4Traits>()

    public init(_ servant: Interface4) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "ice_id":
            return try (servant as? Object ?? Interface4Disp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? Interface4Disp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? Interface4Disp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? Interface4Disp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "opInterface4":
            return try servant._iceD_opInterface4(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol Interface4 {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func opInterface4(current: Ice.Current) throws
}


/// Dispatcher for `EmptyClass3Operations` servants.
public struct EmptyClass3Disp: Ice.Disp {
    public let servant: EmptyClass3Operations
    private static let defaultObject = Ice.ObjectI<EmptyClass3Traits>()

    public init(_ servant: EmptyClass3Operations) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "ice_id":
            return try (servant as? Object ?? EmptyClass3Disp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? EmptyClass3Disp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? EmptyClass3Disp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? EmptyClass3Disp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "newOp":
            return try servant._iceD_newOp(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol EmptyClass3Operations {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func newOp(current: Ice.Current) throws
}


/// Dispatcher for `SimpleClass2Operations` servants.
public struct SimpleClass2Disp: Ice.Disp {
    public let servant: SimpleClass2Operations
    private static let defaultObject = Ice.ObjectI<SimpleClass2Traits>()

    public init(_ servant: SimpleClass2Operations) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "ice_id":
            return try (servant as? Object ?? SimpleClass2Disp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? SimpleClass2Disp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? SimpleClass2Disp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? SimpleClass2Disp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "newOp":
            return try servant._iceD_newOp(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol SimpleClass2Operations {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func newOp(current: Ice.Current) throws
}


/// Dispatcher for `BaseInterface1` servants.
public struct BaseInterface1Disp: Ice.Disp {
    public let servant: BaseInterface1
    private static let defaultObject = Ice.ObjectI<BaseInterface1Traits>()

    public init(_ servant: BaseInterface1) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "baseOp1":
            return try servant._iceD_baseOp1(incoming: request, current: current)
        case "baseOp2":
            return try servant._iceD_baseOp2(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? BaseInterface1Disp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? BaseInterface1Disp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? BaseInterface1Disp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? BaseInterface1Disp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol BaseInterface1 {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func baseOp1(current: Ice.Current) throws

    ///
    /// - parameter i: `Swift.Int32`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String`
    func baseOp2(i: Swift.Int32, current: Ice.Current) throws -> Swift.String
}


/// Dispatcher for `BaseInterface2` servants.
public struct BaseInterface2Disp: Ice.Disp {
    public let servant: BaseInterface2
    private static let defaultObject = Ice.ObjectI<BaseInterface2Traits>()

    public init(_ servant: BaseInterface2) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "baseOp":
            return try servant._iceD_baseOp(incoming: request, current: current)
        case "baseOp2":
            return try servant._iceD_baseOp2(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? BaseInterface2Disp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? BaseInterface2Disp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? BaseInterface2Disp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? BaseInterface2Disp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol BaseInterface2 {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Int32`
    func baseOp(current: Ice.Current) throws -> Swift.Int32

    ///
    /// - parameter i: `Swift.Int32`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String`
    func baseOp2(i: Swift.Int32, current: Ice.Current) throws -> Swift.String
}


/// Dispatcher for `BaseInterface3` servants.
public struct BaseInterface3Disp: Ice.Disp {
    public let servant: BaseInterface3
    private static let defaultObject = Ice.ObjectI<BaseInterface3Traits>()

    public init(_ servant: BaseInterface3) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "baseOp":
            return try servant._iceD_baseOp(incoming: request, current: current)
        case "baseOp2":
            return try servant._iceD_baseOp2(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? BaseInterface3Disp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? BaseInterface3Disp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? BaseInterface3Disp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? BaseInterface3Disp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol BaseInterface3 {
    ///
    /// - parameter o: `Ice.Value?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func baseOp(o: Ice.Value?, current: Ice.Current) throws

    ///
    /// - parameter i: `Swift.Int32`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String`
    func baseOp2(i: Swift.Int32, current: Ice.Current) throws -> Swift.String
}


/// Dispatcher for `BaseInterface4` servants.
public struct BaseInterface4Disp: Ice.Disp {
    public let servant: BaseInterface4
    private static let defaultObject = Ice.ObjectI<BaseInterface4Traits>()

    public init(_ servant: BaseInterface4) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "baseOp":
            return try servant._iceD_baseOp(incoming: request, current: current)
        case "baseOp2":
            return try servant._iceD_baseOp2(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? BaseInterface4Disp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? BaseInterface4Disp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? BaseInterface4Disp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? BaseInterface4Disp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol BaseInterface4 {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func baseOp(current: Ice.Current) throws

    ///
    /// - parameter i: `Swift.Int32`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String`
    func baseOp2(i: Swift.Int32, current: Ice.Current) throws -> Swift.String
}


/// Dispatcher for `BaseInterface5` servants.
public struct BaseInterface5Disp: Ice.Disp {
    public let servant: BaseInterface5
    private static let defaultObject = Ice.ObjectI<BaseInterface5Traits>()

    public init(_ servant: BaseInterface5) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "baseOp":
            return try servant._iceD_baseOp(incoming: request, current: current)
        case "baseOp2":
            return try servant._iceD_baseOp2(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? BaseInterface5Disp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? BaseInterface5Disp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? BaseInterface5Disp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? BaseInterface5Disp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol BaseInterface5 {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func baseOp(current: Ice.Current) throws

    ///
    /// - parameter i: `Swift.Int32`
    ///
    /// - parameter s: `Swift.String`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func baseOp2(i: Swift.Int32, s: Swift.String, current: Ice.Current) throws
}


/// Dispatcher for `BaseInterface6` servants.
public struct BaseInterface6Disp: Ice.Disp {
    public let servant: BaseInterface6
    private static let defaultObject = Ice.ObjectI<BaseInterface6Traits>()

    public init(_ servant: BaseInterface6) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "baseOp":
            return try servant._iceD_baseOp(incoming: request, current: current)
        case "baseOp2":
            return try servant._iceD_baseOp2(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? BaseInterface6Disp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? BaseInterface6Disp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? BaseInterface6Disp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? BaseInterface6Disp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol BaseInterface6 {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func baseOp(current: Ice.Current) throws

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String`
    func baseOp2(current: Ice.Current) throws -> Swift.String
}


/// Dispatcher for `BaseInterface7` servants.
public struct BaseInterface7Disp: Ice.Disp {
    public let servant: BaseInterface7
    private static let defaultObject = Ice.ObjectI<BaseInterface7Traits>()

    public init(_ servant: BaseInterface7) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "baseOp":
            return try servant._iceD_baseOp(incoming: request, current: current)
        case "baseOp2":
            return try servant._iceD_baseOp2(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? BaseInterface7Disp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? BaseInterface7Disp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? BaseInterface7Disp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? BaseInterface7Disp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol BaseInterface7 {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func baseOp(current: Ice.Current) throws

    ///
    /// - parameter i: `Swift.Int32`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String`
    func baseOp2(i: Swift.Int32, current: Ice.Current) throws -> Swift.String
}


/// Dispatcher for `BaseInterface8` servants.
public struct BaseInterface8Disp: Ice.Disp {
    public let servant: BaseInterface8
    private static let defaultObject = Ice.ObjectI<BaseInterface8Traits>()

    public init(_ servant: BaseInterface8) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "baseOp2":
            return try servant._iceD_baseOp2(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? BaseInterface8Disp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? BaseInterface8Disp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? BaseInterface8Disp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? BaseInterface8Disp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol BaseInterface8 {
    ///
    /// - parameter i: `Swift.Int32`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String`
    func baseOp2(i: Swift.Int32, current: Ice.Current) throws -> Swift.String
}


/// Dispatcher for `BaseInterface9` servants.
public struct BaseInterface9Disp: Ice.Disp {
    public let servant: BaseInterface9
    private static let defaultObject = Ice.ObjectI<BaseInterface9Traits>()

    public init(_ servant: BaseInterface9) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "baseOp":
            return try servant._iceD_baseOp(incoming: request, current: current)
        case "baseOp2":
            return try servant._iceD_baseOp2(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? BaseInterface9Disp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? BaseInterface9Disp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? BaseInterface9Disp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? BaseInterface9Disp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol BaseInterface9: Interface1 {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func baseOp(current: Ice.Current) throws

    ///
    /// - parameter i: `Swift.Int32`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String`
    func baseOp2(i: Swift.Int32, current: Ice.Current) throws -> Swift.String
}


/// Dispatcher for `BaseInterface10` servants.
public struct BaseInterface10Disp: Ice.Disp {
    public let servant: BaseInterface10
    private static let defaultObject = Ice.ObjectI<BaseInterface10Traits>()

    public init(_ servant: BaseInterface10) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "baseOp":
            return try servant._iceD_baseOp(incoming: request, current: current)
        case "baseOp2":
            return try servant._iceD_baseOp2(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? BaseInterface10Disp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? BaseInterface10Disp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? BaseInterface10Disp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? BaseInterface10Disp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol BaseInterface10: Interface1 {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func baseOp(current: Ice.Current) throws

    ///
    /// - parameter i: `Swift.Int32`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String`
    func baseOp2(i: Swift.Int32, current: Ice.Current) throws -> Swift.String
}


/// Dispatcher for `OptionalParameters0` servants.
public struct OptionalParameters0Disp: Ice.Disp {
    public let servant: OptionalParameters0
    private static let defaultObject = Ice.ObjectI<OptionalParameters0Traits>()

    public init(_ servant: OptionalParameters0) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "ice_id":
            return try (servant as? Object ?? OptionalParameters0Disp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? OptionalParameters0Disp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? OptionalParameters0Disp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? OptionalParameters0Disp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "op1":
            return try servant._iceD_op1(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol OptionalParameters0 {
    ///
    /// - parameter firstName: `Swift.String`
    ///
    /// - parameter secondName: `Swift.String?`
    ///
    /// - parameter emailAddress: `Swift.String?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func op1(firstName: Swift.String, secondName: Swift.String?, emailAddress: Swift.String?, current: Ice.Current) throws
}


/// Dispatcher for `OptionalParameters1` servants.
public struct OptionalParameters1Disp: Ice.Disp {
    public let servant: OptionalParameters1
    private static let defaultObject = Ice.ObjectI<OptionalParameters1Traits>()

    public init(_ servant: OptionalParameters1) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "ice_id":
            return try (servant as? Object ?? OptionalParameters1Disp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? OptionalParameters1Disp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? OptionalParameters1Disp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? OptionalParameters1Disp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "op1":
            return try servant._iceD_op1(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol OptionalParameters1 {
    ///
    /// - parameter firstName: `Swift.String`
    ///
    /// - parameter emailAddress: `Swift.String?`
    ///
    /// - parameter secondName: `Swift.String?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func op1(firstName: Swift.String, emailAddress: Swift.String?, secondName: Swift.String?, current: Ice.Current) throws
}


/// Dispatcher for `OptionalParameters2` servants.
public struct OptionalParameters2Disp: Ice.Disp {
    public let servant: OptionalParameters2
    private static let defaultObject = Ice.ObjectI<OptionalParameters2Traits>()

    public init(_ servant: OptionalParameters2) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "ice_id":
            return try (servant as? Object ?? OptionalParameters2Disp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? OptionalParameters2Disp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? OptionalParameters2Disp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? OptionalParameters2Disp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "op1":
            return try servant._iceD_op1(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol OptionalParameters2 {
    ///
    /// - parameter firstName: `Swift.String`
    ///
    /// - parameter emailAddress: `Swift.String?`
    ///
    /// - parameter secondName: `Swift.String?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func op1(firstName: Swift.String, emailAddress: Swift.String?, secondName: Swift.String?, current: Ice.Current) throws
}


/// Dispatcher for `OptionalParameters3` servants.
public struct OptionalParameters3Disp: Ice.Disp {
    public let servant: OptionalParameters3
    private static let defaultObject = Ice.ObjectI<OptionalParameters3Traits>()

    public init(_ servant: OptionalParameters3) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "ice_id":
            return try (servant as? Object ?? OptionalParameters3Disp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? OptionalParameters3Disp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? OptionalParameters3Disp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? OptionalParameters3Disp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "op1":
            return try servant._iceD_op1(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol OptionalParameters3 {
    ///
    /// - parameter firstName: `Swift.String`
    ///
    /// - parameter emailAddress: `Swift.String`
    ///
    /// - parameter secondName: `Swift.String?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func op1(firstName: Swift.String, emailAddress: Swift.String, secondName: Swift.String?, current: Ice.Current) throws
}


/// Dispatcher for `OptionalReturn0` servants.
public struct OptionalReturn0Disp: Ice.Disp {
    public let servant: OptionalReturn0
    private static let defaultObject = Ice.ObjectI<OptionalReturn0Traits>()

    public init(_ servant: OptionalReturn0) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "ice_id":
            return try (servant as? Object ?? OptionalReturn0Disp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? OptionalReturn0Disp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? OptionalReturn0Disp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? OptionalReturn0Disp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "op":
            return try servant._iceD_op(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol OptionalReturn0 {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Int32?`
    func op(current: Ice.Current) throws -> Swift.Int32?
}


/// Dispatcher for `OptionalReturn2` servants.
public struct OptionalReturn2Disp: Ice.Disp {
    public let servant: OptionalReturn2
    private static let defaultObject = Ice.ObjectI<OptionalReturn2Traits>()

    public init(_ servant: OptionalReturn2) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "ice_id":
            return try (servant as? Object ?? OptionalReturn2Disp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? OptionalReturn2Disp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? OptionalReturn2Disp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? OptionalReturn2Disp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "op":
            return try servant._iceD_op(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol OptionalReturn2 {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Int32`
    func op(current: Ice.Current) throws -> Swift.Int32
}

/// Interface1 overview.
public extension Interface1 {}

/// Interface3 overview.
public extension Interface3 {}

/// Interface4 overview.
///
/// Interface4 Methods:
///
///  - opInterface4: 
public extension Interface4 {
    func _iceD_opInterface4(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.opInterface4(current: current)

        return inS.setResult()
    }
}

/// EmptyClass3 overview.
///
/// EmptyClass3 Methods:
///
///  - newOp: 
public extension EmptyClass3Operations {
    func _iceD_newOp(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.newOp(current: current)

        return inS.setResult()
    }
}

/// SimpleClass2 overview.
///
/// SimpleClass2 Methods:
///
///  - newOp: 
public extension SimpleClass2Operations {
    func _iceD_newOp(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.newOp(current: current)

        return inS.setResult()
    }
}

/// BaseInterface1 overview.
///
/// BaseInterface1 Methods:
///
///  - baseOp1: 
///
///  - baseOp2: 
public extension BaseInterface1 {
    func _iceD_baseOp1(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.baseOp1(current: current)

        return inS.setResult()
    }

    func _iceD_baseOp2(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_i: Swift.Int32 = try inS.read { istr in
            let iceP_i: Swift.Int32 = try istr.read()
            return iceP_i
        }

        let iceP_s = try self.baseOp2(i: iceP_i, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_s)
        }
    }
}

/// BaseInterface2 overview.
///
/// BaseInterface2 Methods:
///
///  - baseOp: 
///
///  - baseOp2: 
public extension BaseInterface2 {
    func _iceD_baseOp(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.baseOp(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_baseOp2(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_i: Swift.Int32 = try inS.read { istr in
            let iceP_i: Swift.Int32 = try istr.read()
            return iceP_i
        }

        let iceP_s = try self.baseOp2(i: iceP_i, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_s)
        }
    }
}

/// BaseInterface3 overview.
///
/// BaseInterface3 Methods:
///
///  - baseOp: 
///
///  - baseOp2: 
public extension BaseInterface3 {
    func _iceD_baseOp(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_o: Ice.Value? = try inS.read { istr in
            var iceP_o: Ice.Value?
            try istr.read() { iceP_o = $0 }
            try istr.readPendingValues()
            return iceP_o
        }

        try self.baseOp(o: iceP_o, current: current)

        return inS.setResult()
    }

    func _iceD_baseOp2(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_i: Swift.Int32 = try inS.read { istr in
            let iceP_i: Swift.Int32 = try istr.read()
            return iceP_i
        }

        let iceP_s = try self.baseOp2(i: iceP_i, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_s)
        }
    }
}

/// BaseInterface4 overview.
///
/// BaseInterface4 Methods:
///
///  - baseOp: 
///
///  - baseOp2: 
public extension BaseInterface4 {
    func _iceD_baseOp(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.baseOp(current: current)

        return inS.setResult()
    }

    func _iceD_baseOp2(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_i: Swift.Int32 = try inS.read { istr in
            let iceP_i: Swift.Int32 = try istr.read()
            return iceP_i
        }

        let iceP_s = try self.baseOp2(i: iceP_i, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_s)
        }
    }
}

/// BaseInterface5 overview.
///
/// BaseInterface5 Methods:
///
///  - baseOp: 
///
///  - baseOp2: 
public extension BaseInterface5 {
    func _iceD_baseOp(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.baseOp(current: current)

        return inS.setResult()
    }

    func _iceD_baseOp2(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_i, iceP_s): (Swift.Int32, Swift.String) = try inS.read { istr in
            let iceP_i: Swift.Int32 = try istr.read()
            let iceP_s: Swift.String = try istr.read()
            return (iceP_i, iceP_s)
        }

        try self.baseOp2(i: iceP_i, s: iceP_s, current: current)

        return inS.setResult()
    }
}

/// BaseInterface6 overview.
///
/// BaseInterface6 Methods:
///
///  - baseOp: 
///
///  - baseOp2: 
public extension BaseInterface6 {
    func _iceD_baseOp(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.baseOp(current: current)

        return inS.setResult()
    }

    func _iceD_baseOp2(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_s = try self.baseOp2(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_s)
        }
    }
}

/// BaseInterface7 overview.
///
/// BaseInterface7 Methods:
///
///  - baseOp: 
///
///  - baseOp2: 
public extension BaseInterface7 {
    func _iceD_baseOp(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.baseOp(current: current)

        return inS.setResult()
    }

    func _iceD_baseOp2(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_i: Swift.Int32 = try inS.read { istr in
            let iceP_i: Swift.Int32 = try istr.read()
            return iceP_i
        }

        let iceP_s = try self.baseOp2(i: iceP_i, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_s)
        }
    }
}

/// BaseInterface8 overview.
///
/// BaseInterface8 Methods:
///
///  - baseOp2: 
public extension BaseInterface8 {
    func _iceD_baseOp2(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_i: Swift.Int32 = try inS.read { istr in
            let iceP_i: Swift.Int32 = try istr.read()
            return iceP_i
        }

        let iceP_s = try self.baseOp2(i: iceP_i, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_s)
        }
    }
}

/// BaseInterface9 overview.
///
/// BaseInterface9 Methods:
///
///  - baseOp: 
///
///  - baseOp2: 
public extension BaseInterface9 {
    func _iceD_baseOp(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.baseOp(current: current)

        return inS.setResult()
    }

    func _iceD_baseOp2(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_i: Swift.Int32 = try inS.read { istr in
            let iceP_i: Swift.Int32 = try istr.read()
            return iceP_i
        }

        let iceP_s = try self.baseOp2(i: iceP_i, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_s)
        }
    }
}

/// BaseInterface10 overview.
///
/// BaseInterface10 Methods:
///
///  - baseOp: 
///
///  - baseOp2: 
public extension BaseInterface10 {
    func _iceD_baseOp(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.baseOp(current: current)

        return inS.setResult()
    }

    func _iceD_baseOp2(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_i: Swift.Int32 = try inS.read { istr in
            let iceP_i: Swift.Int32 = try istr.read()
            return iceP_i
        }

        let iceP_s = try self.baseOp2(i: iceP_i, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_s)
        }
    }
}

/// OptionalParameters0 overview.
///
/// OptionalParameters0 Methods:
///
///  - op1: 
public extension OptionalParameters0 {
    func _iceD_op1(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_firstName, iceP_secondName, iceP_emailAddress): (Swift.String, Swift.String?, Swift.String?) = try inS.read { istr in
            let iceP_firstName: Swift.String = try istr.read()
            let iceP_secondName: Swift.String? = try istr.read(tag: 1)
            let iceP_emailAddress: Swift.String? = try istr.read(tag: 2)
            return (iceP_firstName, iceP_secondName, iceP_emailAddress)
        }

        try self.op1(firstName: iceP_firstName, secondName: iceP_secondName, emailAddress: iceP_emailAddress, current: current)

        return inS.setResult()
    }
}

/// OptionalParameters1 overview.
///
/// OptionalParameters1 Methods:
///
///  - op1: 
public extension OptionalParameters1 {
    func _iceD_op1(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_firstName, iceP_emailAddress, iceP_secondName): (Swift.String, Swift.String?, Swift.String?) = try inS.read { istr in
            let iceP_firstName: Swift.String = try istr.read()
            let iceP_secondName: Swift.String? = try istr.read(tag: 1)
            let iceP_emailAddress: Swift.String? = try istr.read(tag: 2)
            return (iceP_firstName, iceP_emailAddress, iceP_secondName)
        }

        try self.op1(firstName: iceP_firstName, emailAddress: iceP_emailAddress, secondName: iceP_secondName, current: current)

        return inS.setResult()
    }
}

/// OptionalParameters2 overview.
///
/// OptionalParameters2 Methods:
///
///  - op1: 
public extension OptionalParameters2 {
    func _iceD_op1(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_firstName, iceP_emailAddress, iceP_secondName): (Swift.String, Swift.String?, Swift.String?) = try inS.read { istr in
            let iceP_firstName: Swift.String = try istr.read()
            let iceP_secondName: Swift.String? = try istr.read(tag: 1)
            let iceP_emailAddress: Swift.String? = try istr.read(tag: 2)
            return (iceP_firstName, iceP_emailAddress, iceP_secondName)
        }

        try self.op1(firstName: iceP_firstName, emailAddress: iceP_emailAddress, secondName: iceP_secondName, current: current)

        return inS.setResult()
    }
}

/// OptionalParameters3 overview.
///
/// OptionalParameters3 Methods:
///
///  - op1: 
public extension OptionalParameters3 {
    func _iceD_op1(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_firstName, iceP_emailAddress, iceP_secondName): (Swift.String, Swift.String, Swift.String?) = try inS.read { istr in
            let iceP_firstName: Swift.String = try istr.read()
            let iceP_emailAddress: Swift.String = try istr.read()
            let iceP_secondName: Swift.String? = try istr.read(tag: 1)
            return (iceP_firstName, iceP_emailAddress, iceP_secondName)
        }

        try self.op1(firstName: iceP_firstName, emailAddress: iceP_emailAddress, secondName: iceP_secondName, current: current)

        return inS.setResult()
    }
}

/// OptionalReturn0 overview.
///
/// OptionalReturn0 Methods:
///
///  - op: 
public extension OptionalReturn0 {
    func _iceD_op(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.op(current: current)

        return inS.setResult{ ostr in
            ostr.write(tag: 1, value: iceP_returnValue)
        }
    }
}

/// OptionalReturn2 overview.
///
/// OptionalReturn2 Methods:
///
///  - op: 
public extension OptionalReturn2 {
    func _iceD_op(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.op(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }
}

public protocol LocalClass:  Swift.AnyObject {}
