//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice
import PromiseKit

public enum MyEnum: Swift.UInt8 {
    /// enum1
    case enum1 = 0
    /// enum2
    case enum2 = 1
    /// enum3
    case enum3 = 2
    public init() {
        self = .enum1
    }
}

/// An `Ice.InputStream` extension to read `MyEnum` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - returns: `MyEnum` - The enumarated value.
    func read() throws -> MyEnum {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 2)
        guard let val = MyEnum(rawValue: rawValue) else {
            throw Ice.MarshalException("invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyEnum` - The enumerated value.
    func read(tag: Swift.Int32) throws -> MyEnum? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as MyEnum
    }
}

/// An `Ice.OutputStream` extension to write `MyEnum` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// parameter _: `MyEnum` - The enumerator to write.
    func write(_ v: MyEnum) {
        write(enum: v.rawValue, maxValue: 2)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// parameter _: `MyEnum` - The enumerator to write.
    func write(tag: Swift.Int32, value: MyEnum?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 2)
    }
}

public struct LargeStruct {
    public var bo: Swift.Bool = false
    public var by: Swift.UInt8 = 0
    public var sh: Swift.Int16 = 0
    public var i: Swift.Int32 = 0
    public var l: Swift.Int64 = 0
    public var f: Swift.Float = 0.0
    public var d: Swift.Double = 0.0
    public var str: Swift.String = ""
    public var e: MyEnum = .enum1
    public var p: MyInterfacePrx? = nil

    public init() {}

    public init(bo: Swift.Bool, by: Swift.UInt8, sh: Swift.Int16, i: Swift.Int32, l: Swift.Int64, f: Swift.Float, d: Swift.Double, str: Swift.String, e: MyEnum, p: MyInterfacePrx?) {
        self.bo = bo
        self.by = by
        self.sh = sh
        self.i = i
        self.l = l
        self.f = f
        self.d = d
        self.str = str
        self.e = e
        self.p = p
    }
}

/// An `Ice.InputStream` extension to read `LargeStruct` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `LargeStruct` structured value from the stream.
    ///
    /// - returns: `LargeStruct` - The structured value read from the stream.
    func read() throws -> LargeStruct {
        var v = LargeStruct()
        v.bo = try self.read()
        v.by = try self.read()
        v.sh = try self.read()
        v.i = try self.read()
        v.l = try self.read()
        v.f = try self.read()
        v.d = try self.read()
        v.str = try self.read()
        v.e = try self.read()
        v.p = try self.read(MyInterfacePrx.self)
        return v
    }

    /// Read an optional `LargeStruct?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LargeStruct?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> LargeStruct? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as LargeStruct
    }
}

/// An `Ice.OutputStream` extension to write `LargeStruct` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `LargeStruct` structured value to the stream.
    ///
    /// - parameter _: `LargeStruct` - The value to write to the stream.
    func write(_ v: LargeStruct) {
        self.write(v.bo)
        self.write(v.by)
        self.write(v.sh)
        self.write(v.i)
        self.write(v.l)
        self.write(v.f)
        self.write(v.d)
        self.write(v.str)
        self.write(v.e)
        self.write(v.p)
    }

    /// Write an optional `LargeStruct?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LargeStruct?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: LargeStruct?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// Traits for Slice class`OptionalClass`.
public struct OptionalClassTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::OptionalClass"]
    public static let staticId = "::Test::OptionalClass"
}

public typealias MyEnumS = [MyEnum]

/// Helper class to read and write `MyEnumS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyEnumSHelper {
    /// Read a `MyEnumS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `MyEnumS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyEnumS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = MyEnumS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: MyEnum = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `MyEnumS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyEnumS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyEnumS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `MyEnumS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `MyEnumS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyEnumS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `MyEnumS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `MyEnumS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: MyEnumS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias MyClassS = [MyClass?]

/// Helper class to read and write `MyClassS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyClassSHelper {
    /// Read a `MyClassS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `MyClassS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyClassS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = MyClassS(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(MyClass.self) { p.pointee = $0 }
            }
        }
        return v
    }
    /// Read an optional `MyClassS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyClassS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyClassS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `MyClassS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `MyClassS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyClassS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `MyClassS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `MyClassS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: MyClassS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias BoolSS = [Ice.BoolSeq]

/// Helper class to read and write `BoolSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct BoolSSHelper {
    /// Read a `BoolSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `BoolSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> BoolSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = BoolSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: Ice.BoolSeq = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `BoolSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `BoolSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> BoolSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `BoolSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `BoolSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: BoolSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `BoolSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `BoolSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: BoolSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ByteSS = [Ice.ByteSeq]

/// Helper class to read and write `ByteSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ByteSSHelper {
    /// Read a `ByteSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ByteSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ByteSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = ByteSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: Ice.ByteSeq = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `ByteSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ByteSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ByteSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ByteSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ByteSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ByteSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `ByteSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ByteSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ByteSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ShortSS = [Ice.ShortSeq]

/// Helper class to read and write `ShortSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ShortSSHelper {
    /// Read a `ShortSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ShortSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ShortSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = ShortSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: Ice.ShortSeq = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `ShortSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ShortSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ShortSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ShortSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ShortSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ShortSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `ShortSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ShortSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ShortSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias IntSS = [Ice.IntSeq]

/// Helper class to read and write `IntSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct IntSSHelper {
    /// Read a `IntSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `IntSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> IntSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = IntSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: Ice.IntSeq = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `IntSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `IntSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> IntSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `IntSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `IntSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: IntSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `IntSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `IntSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: IntSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias LongSS = [Ice.LongSeq]

/// Helper class to read and write `LongSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LongSSHelper {
    /// Read a `LongSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `LongSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LongSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = LongSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: Ice.LongSeq = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `LongSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LongSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LongSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `LongSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `LongSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LongSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `LongSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LongSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: LongSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias FloatSS = [Ice.FloatSeq]

/// Helper class to read and write `FloatSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct FloatSSHelper {
    /// Read a `FloatSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `FloatSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> FloatSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = FloatSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: Ice.FloatSeq = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `FloatSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `FloatSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> FloatSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `FloatSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `FloatSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: FloatSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `FloatSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `FloatSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: FloatSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias DoubleSS = [Ice.DoubleSeq]

/// Helper class to read and write `DoubleSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct DoubleSSHelper {
    /// Read a `DoubleSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `DoubleSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> DoubleSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = DoubleSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: Ice.DoubleSeq = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `DoubleSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `DoubleSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> DoubleSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `DoubleSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `DoubleSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: DoubleSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `DoubleSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `DoubleSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: DoubleSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringSS = [Ice.StringSeq]

/// Helper class to read and write `StringSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringSSHelper {
    /// Read a `StringSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = StringSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: Ice.StringSeq = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `StringSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `StringSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: StringSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias MyEnumSS = [MyEnumS]

/// Helper class to read and write `MyEnumSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyEnumSSHelper {
    /// Read a `MyEnumSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `MyEnumSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyEnumSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = MyEnumSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: MyEnumS = try MyEnumSHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `MyEnumSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyEnumSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyEnumSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `MyEnumSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `MyEnumSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyEnumSS) {
        ostr.write(size: v.count)
        for item in v {
            MyEnumSHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `MyEnumSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `MyEnumSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: MyEnumSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias MyClassSS = [MyClassS]

/// Helper class to read and write `MyClassSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyClassSSHelper {
    /// Read a `MyClassSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `MyClassSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyClassSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = MyClassSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: MyClassS = try MyClassSHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `MyClassSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyClassSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyClassSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `MyClassSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `MyClassSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyClassSS) {
        ostr.write(size: v.count)
        for item in v {
            MyClassSHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `MyClassSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `MyClassSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: MyClassSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ByteBoolD = [Swift.UInt8: Swift.Bool]

/// Helper class to read and write `ByteBoolD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ByteBoolDHelper {
    /// Read a `ByteBoolD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ByteBoolD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ByteBoolD {
        let sz = try Swift.Int(istr.readSize())
        var v = ByteBoolD()
        for _ in 0 ..< sz {
            let key: Swift.UInt8 = try istr.read()
            let value: Swift.Bool = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `ByteBoolD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ByteBoolD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ByteBoolD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Wite a `ByteBoolD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ByteBoolD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ByteBoolD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `ByteBoolD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ByteBoolD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: ByteBoolD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 2) {
            write(to: ostr, value: val)
        }
    }
}

public typealias ShortIntD = [Swift.Int16: Swift.Int32]

/// Helper class to read and write `ShortIntD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ShortIntDHelper {
    /// Read a `ShortIntD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ShortIntD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ShortIntD {
        let sz = try Swift.Int(istr.readSize())
        var v = ShortIntD()
        for _ in 0 ..< sz {
            let key: Swift.Int16 = try istr.read()
            let value: Swift.Int32 = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `ShortIntD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ShortIntD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ShortIntD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Wite a `ShortIntD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ShortIntD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ShortIntD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `ShortIntD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ShortIntD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: ShortIntD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 6) {
            write(to: ostr, value: val)
        }
    }
}

public typealias LongFloatD = [Swift.Int64: Swift.Float]

/// Helper class to read and write `LongFloatD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LongFloatDHelper {
    /// Read a `LongFloatD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `LongFloatD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LongFloatD {
        let sz = try Swift.Int(istr.readSize())
        var v = LongFloatD()
        for _ in 0 ..< sz {
            let key: Swift.Int64 = try istr.read()
            let value: Swift.Float = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `LongFloatD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LongFloatD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LongFloatD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Wite a `LongFloatD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `LongFloatD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LongFloatD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `LongFloatD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LongFloatD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: LongFloatD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 12) {
            write(to: ostr, value: val)
        }
    }
}

public typealias StringStringD = [Swift.String: Swift.String]

/// Helper class to read and write `StringStringD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringStringDHelper {
    /// Read a `StringStringD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringStringD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringStringD {
        let sz = try Swift.Int(istr.readSize())
        var v = StringStringD()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: Swift.String = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `StringStringD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringStringD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringStringD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringStringD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringStringD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringStringD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `StringStringD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringStringD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: StringStringD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringMyClassD = [Swift.String: MyClass?]

/// Helper class to read and write `StringMyClassD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringMyClassDHelper {
    /// Read a `StringMyClassD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringMyClassD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringMyClassD {
        let sz = try Swift.Int(istr.readSize())
        var v = StringMyClassD()
        let e = Ice.DictEntryArray<Swift.String, MyClass?>(size: sz)
        for i in 0 ..< sz {
            let key: Swift.String = try istr.read()
            v[key] = nil as MyClass?
            Swift.withUnsafeMutablePointer(to: &v[key, default:nil]) {
                e.values[i] = Ice.DictEntry<Swift.String, MyClass?>(key: key, value: $0)
            }
            try istr.read(MyClass.self) { e.values[i].value.pointee = $0 }
        }
        for i in 0..<sz {
            Swift.withUnsafeMutablePointer(to: &v[e.values[i].key, default:nil]) {
                e.values[i].value = $0
            }
        }
        return v
    }
    /// Read an optional `StringMyClassD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringMyClassD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringMyClassD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringMyClassD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringMyClassD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringMyClassD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `StringMyClassD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringMyClassD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: StringMyClassD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias BoolList = [Swift.Bool]

public typealias ByteList = Foundation.Data

public typealias MyEnumList = [MyEnum]

/// Helper class to read and write `MyEnumList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyEnumListHelper {
    /// Read a `MyEnumList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `MyEnumList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyEnumList {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = MyEnumList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: MyEnum = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `MyEnumList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyEnumList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyEnumList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `MyEnumList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `MyEnumList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyEnumList) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `MyEnumList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `MyEnumList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: MyEnumList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias LargeStructList = [LargeStruct]

/// Helper class to read and write `LargeStructList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LargeStructListHelper {
    /// Read a `LargeStructList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `LargeStructList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LargeStructList {
        let sz = try istr.readAndCheckSeqSize(minSize: 32)
        var v = LargeStructList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: LargeStruct = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `LargeStructList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LargeStructList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LargeStructList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `LargeStructList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `LargeStructList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LargeStructList) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `LargeStructList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LargeStructList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: LargeStructList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias MyClassList = [MyClass?]

/// Helper class to read and write `MyClassList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyClassListHelper {
    /// Read a `MyClassList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `MyClassList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyClassList {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = MyClassList(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(MyClass.self) { p.pointee = $0 }
            }
        }
        return v
    }
    /// Read an optional `MyClassList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyClassList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyClassList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `MyClassList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `MyClassList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyClassList) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `MyClassList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `MyClassList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: MyClassList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias MyInterfaceProxyList = [MyInterfacePrx?]

/// Helper class to read and write `MyInterfaceProxyList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyInterfaceProxyListHelper {
    /// Read a `MyInterfaceProxyList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `MyInterfaceProxyList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyInterfaceProxyList {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = MyInterfaceProxyList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: MyInterfacePrx? = try istr.read(MyInterfacePrx.self)
            v.append(j)
        }
        return v
    }
    /// Read an optional `MyInterfaceProxyList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyInterfaceProxyList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyInterfaceProxyList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `MyInterfaceProxyList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `MyInterfaceProxyList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyInterfaceProxyList) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `MyInterfaceProxyList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `MyInterfaceProxyList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: MyInterfaceProxyList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ShortLinkedList = [Swift.Int16]

public typealias IntLinkedList = [Swift.Int32]

public typealias MyEnumLinkedList = [MyEnum]

/// Helper class to read and write `MyEnumLinkedList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyEnumLinkedListHelper {
    /// Read a `MyEnumLinkedList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `MyEnumLinkedList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyEnumLinkedList {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = MyEnumLinkedList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: MyEnum = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `MyEnumLinkedList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyEnumLinkedList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyEnumLinkedList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `MyEnumLinkedList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `MyEnumLinkedList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyEnumLinkedList) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `MyEnumLinkedList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `MyEnumLinkedList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: MyEnumLinkedList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias LargeStructLinkedList = [LargeStruct]

/// Helper class to read and write `LargeStructLinkedList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LargeStructLinkedListHelper {
    /// Read a `LargeStructLinkedList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `LargeStructLinkedList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LargeStructLinkedList {
        let sz = try istr.readAndCheckSeqSize(minSize: 32)
        var v = LargeStructLinkedList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: LargeStruct = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `LargeStructLinkedList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LargeStructLinkedList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LargeStructLinkedList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `LargeStructLinkedList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `LargeStructLinkedList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LargeStructLinkedList) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `LargeStructLinkedList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LargeStructLinkedList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: LargeStructLinkedList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias LongStack = [Swift.Int64]

public typealias FloatStack = [Swift.Float]

public typealias LargeStructStack = [LargeStruct]

/// Helper class to read and write `LargeStructStack` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LargeStructStackHelper {
    /// Read a `LargeStructStack` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `LargeStructStack` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LargeStructStack {
        let sz = try istr.readAndCheckSeqSize(minSize: 32)
        var v = LargeStructStack()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: LargeStruct = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `LargeStructStack?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LargeStructStack` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LargeStructStack? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `LargeStructStack` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `LargeStructStack` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LargeStructStack) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `LargeStructStack?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LargeStructStack` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: LargeStructStack?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias MyInterfaceProxyStack = [MyInterfacePrx?]

/// Helper class to read and write `MyInterfaceProxyStack` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyInterfaceProxyStackHelper {
    /// Read a `MyInterfaceProxyStack` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `MyInterfaceProxyStack` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyInterfaceProxyStack {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = MyInterfaceProxyStack()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: MyInterfacePrx? = try istr.read(MyInterfacePrx.self)
            v.append(j)
        }
        return v
    }
    /// Read an optional `MyInterfaceProxyStack?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyInterfaceProxyStack` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyInterfaceProxyStack? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `MyInterfaceProxyStack` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `MyInterfaceProxyStack` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyInterfaceProxyStack) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `MyInterfaceProxyStack?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `MyInterfaceProxyStack` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: MyInterfaceProxyStack?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ObjectStack = [Ice.Value?]

/// Helper class to read and write `ObjectStack` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ObjectStackHelper {
    /// Read a `ObjectStack` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ObjectStack` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ObjectStack {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = ObjectStack(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read() { p.pointee = $0 }
            }
        }
        return v
    }
    /// Read an optional `ObjectStack?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ObjectStack` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ObjectStack? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ObjectStack` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ObjectStack` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ObjectStack) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `ObjectStack?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ObjectStack` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ObjectStack?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias MyClassStack = [MyClass?]

/// Helper class to read and write `MyClassStack` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyClassStackHelper {
    /// Read a `MyClassStack` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `MyClassStack` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyClassStack {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = MyClassStack(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(MyClass.self) { p.pointee = $0 }
            }
        }
        return v
    }
    /// Read an optional `MyClassStack?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyClassStack` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyClassStack? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `MyClassStack` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `MyClassStack` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyClassStack) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `MyClassStack?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `MyClassStack` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: MyClassStack?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias DoubleQueue = [Swift.Double]

public typealias StringQueue = [Swift.String]

public typealias LargeStructQueue = [LargeStruct]

/// Helper class to read and write `LargeStructQueue` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LargeStructQueueHelper {
    /// Read a `LargeStructQueue` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `LargeStructQueue` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LargeStructQueue {
        let sz = try istr.readAndCheckSeqSize(minSize: 32)
        var v = LargeStructQueue()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: LargeStruct = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `LargeStructQueue?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LargeStructQueue` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LargeStructQueue? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `LargeStructQueue` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `LargeStructQueue` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LargeStructQueue) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `LargeStructQueue?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LargeStructQueue` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: LargeStructQueue?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringSList = [Ice.StringSeq]

/// Helper class to read and write `StringSList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringSListHelper {
    /// Read a `StringSList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringSList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringSList {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = StringSList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: Ice.StringSeq = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `StringSList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringSList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringSList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringSList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringSList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringSList) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `StringSList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringSList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: StringSList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringSStack = [Ice.StringSeq]

/// Helper class to read and write `StringSStack` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringSStackHelper {
    /// Read a `StringSStack` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringSStack` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringSStack {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = StringSStack()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: Ice.StringSeq = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `StringSStack?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringSStack` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringSStack? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringSStack` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringSStack` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringSStack) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `StringSStack?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringSStack` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: StringSStack?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias SortedStringStringD = [Swift.String: Swift.String]

/// Helper class to read and write `SortedStringStringD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct SortedStringStringDHelper {
    /// Read a `SortedStringStringD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `SortedStringStringD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> SortedStringStringD {
        let sz = try Swift.Int(istr.readSize())
        var v = SortedStringStringD()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: Swift.String = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `SortedStringStringD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `SortedStringStringD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> SortedStringStringD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `SortedStringStringD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `SortedStringStringD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: SortedStringStringD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `SortedStringStringD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `SortedStringStringD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: SortedStringStringD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice class`MyClass`.
public struct MyClassTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::MyClass"]
    public static let staticId = "::Test::MyClass"
}

/// :nodoc:
public class MyException_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return MyException.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_MyException() -> Ice.UserExceptionTypeResolver {
        return MyException_TypeResolver()
    }
}

open class MyException: Ice.UserException {
    public var c: MyClass? = nil

    public required init() {}

    public init(c: MyClass?) {
        self.c = c
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::Test::MyException"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: MyException.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.c)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(MyClass.self) { self.c = $0 }
        try istr.endSlice()
    }

    open override func _usesClasses() -> Swift.Bool {
        return true
    }
}

/// Traits for Slice interface`MyInterface`.
public struct MyInterfaceTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::MyInterface"]
    public static let staticId = "::Test::MyInterface"
}

/// MyInterfacePrx overview.
public protocol MyInterfacePrx: Ice.ObjectPrx {}

private final class MyInterfacePrxI: Ice.ObjectPrxI, MyInterfacePrx {
    public override class func ice_staticId() -> Swift.String {
        return MyInterfaceTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: MyInterfacePrx.Protocol) throws -> MyInterfacePrx {
    try communicator.makeProxyImpl(proxyString) as MyInterfacePrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `MyInterfacePrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `MyInterfacePrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: MyInterfacePrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> MyInterfacePrx? {
    return try MyInterfacePrxI.checkedCast(prx: prx, facet: facet, context: context) as MyInterfacePrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `MyInterfacePrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `MyInterfacePrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: MyInterfacePrx.Protocol, facet: Swift.String? = nil) -> MyInterfacePrx {
    return MyInterfacePrxI.uncheckedCast(prx: prx, facet: facet) as MyInterfacePrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `MyInterfacePrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: MyInterfacePrx.Protocol) -> Swift.String {
    return MyInterfaceTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `MyInterfacePrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `MyInterfacePrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `MyInterfacePrx?` - The extracted proxy
    func read(_ type: MyInterfacePrx.Protocol) throws -> MyInterfacePrx? {
        return try read() as MyInterfacePrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `MyInterfacePrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `MyInterfacePrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: MyInterfacePrx.Protocol) throws -> MyInterfacePrx? {
        return try read(tag: tag) as MyInterfacePrxI?
    }
}

/// MyInterfacePrx overview.
public extension MyInterfacePrx {}

/// :nodoc:
public class OptionalClass_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return OptionalClass.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_OptionalClass() -> Ice.ValueTypeResolver {
        return OptionalClass_TypeResolver()
    }
}

open class OptionalClass: Ice.Value {
    public var bo: Swift.Bool = false
    public var by: Swift.UInt8 = 0
    public var sh: Swift.Int16? = nil
    public var i: Swift.Int32? = nil

    public required init() {}

    public init(bo: Swift.Bool, by: Swift.UInt8, sh: Swift.Int16?, i: Swift.Int32?) {
        self.bo = bo
        self.by = by
        self.sh = sh
        self.i = i
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return OptionalClassTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return OptionalClassTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.bo = try istr.read()
        self.by = try istr.read()
        self.sh = try istr.read(tag: 1)
        self.i = try istr.read(tag: 2)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: OptionalClassTraits.staticId, compactId: -1, last: true)
        ostr.write(self.bo)
        ostr.write(self.by)
        ostr.write(tag: 1, value: self.sh)
        ostr.write(tag: 2, value: self.i)
        ostr.endSlice()
    }
}

/// :nodoc:
public class MyClass_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return MyClass.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_MyClass() -> Ice.ValueTypeResolver {
        return MyClass_TypeResolver()
    }
}

open class MyClass: Ice.Value {
    public var c: MyClass? = nil
    public var o: Ice.Value? = nil
    public var s: LargeStruct = LargeStruct()
    public var seq1: Ice.BoolSeq = Ice.BoolSeq()
    public var seq2: Ice.ByteSeq = Ice.ByteSeq()
    public var seq3: Ice.ShortSeq = Ice.ShortSeq()
    public var seq4: Ice.IntSeq = Ice.IntSeq()
    public var seq5: Ice.LongSeq = Ice.LongSeq()
    public var seq6: Ice.FloatSeq = Ice.FloatSeq()
    public var seq7: Ice.DoubleSeq = Ice.DoubleSeq()
    public var seq8: Ice.StringSeq = Ice.StringSeq()
    public var seq9: MyEnumS = MyEnumS()
    public var seq10: MyClassS = MyClassS()
    public var d: StringMyClassD = StringMyClassD()

    public required init() {}

    public init(c: MyClass?, o: Ice.Value?, s: LargeStruct, seq1: Ice.BoolSeq, seq2: Ice.ByteSeq, seq3: Ice.ShortSeq, seq4: Ice.IntSeq, seq5: Ice.LongSeq, seq6: Ice.FloatSeq, seq7: Ice.DoubleSeq, seq8: Ice.StringSeq, seq9: MyEnumS, seq10: MyClassS, d: StringMyClassD) {
        self.c = c
        self.o = o
        self.s = s
        self.seq1 = seq1
        self.seq2 = seq2
        self.seq3 = seq3
        self.seq4 = seq4
        self.seq5 = seq5
        self.seq6 = seq6
        self.seq7 = seq7
        self.seq8 = seq8
        self.seq9 = seq9
        self.seq10 = seq10
        self.d = d
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return MyClassTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return MyClassTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(MyClass.self) { self.c = $0 }
        try istr.read() { self.o = $0 }
        self.s = try istr.read()
        self.seq1 = try istr.read()
        self.seq2 = try istr.read()
        self.seq3 = try istr.read()
        self.seq4 = try istr.read()
        self.seq5 = try istr.read()
        self.seq6 = try istr.read()
        self.seq7 = try istr.read()
        self.seq8 = try istr.read()
        self.seq9 = try MyEnumSHelper.read(from: istr)
        self.seq10 = try MyClassSHelper.read(from: istr)
        self.d = try StringMyClassDHelper.read(from: istr)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: MyClassTraits.staticId, compactId: -1, last: true)
        ostr.write(self.c)
        ostr.write(self.o)
        ostr.write(self.s)
        ostr.write(self.seq1)
        ostr.write(self.seq2)
        ostr.write(self.seq3)
        ostr.write(self.seq4)
        ostr.write(self.seq5)
        ostr.write(self.seq6)
        ostr.write(self.seq7)
        ostr.write(self.seq8)
        MyEnumSHelper.write(to: ostr, value: self.seq9)
        MyClassSHelper.write(to: ostr, value: self.seq10)
        StringMyClassDHelper.write(to: ostr, value: self.d)
        ostr.endSlice()
    }
}


/// Dispatcher for `MyInterface` servants.
public struct MyInterfaceDisp: Ice.Dispatcher {
    public let servant: MyInterface
    private static let defaultObject = Ice.ObjectI<MyInterfaceTraits>()

    public init(_ servant: MyInterface) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        switch request.current.operation {
        case "ice_id":
            (servant as? Ice.Object ?? MyInterfaceDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            (servant as? Ice.Object ?? MyInterfaceDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            (servant as? Ice.Object ?? MyInterfaceDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            (servant as? Ice.Object ?? MyInterfaceDisp.defaultObject)._iceD_ice_ping(request)
        default:
            PromiseKit.Promise(error: Ice.OperationNotExistException())
        }
    }
}

public protocol MyInterface {}

/// MyInterface overview.
extension MyInterface {}
