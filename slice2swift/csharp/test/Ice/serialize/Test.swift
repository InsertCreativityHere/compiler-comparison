//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice
import PromiseKit

public enum MyEnum: Swift.UInt8 {
    /// enum1
    case enum1 = 0
    /// enum2
    case enum2 = 1
    /// enum3
    case enum3 = 2
    public init() {
        self = .enum1
    }
}

/// An `Ice.InputStream` extension to read `MyEnum` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - returns: `MyEnum` - The enumarated value.
    func read() throws -> MyEnum {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 2)
        guard let val = MyEnum(rawValue: rawValue) else {
            throw Ice.MarshalException(reason: "invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyEnum` - The enumerated value.
    func read(tag: Swift.Int32) throws -> MyEnum? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as MyEnum
    }
}

/// An `Ice.OutputStream` extension to write `MyEnum` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// parameter _: `MyEnum` - The enumerator to write.
    func write(_ v: MyEnum) {
        write(enum: v.rawValue, maxValue: 2)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// parameter _: `MyEnum` - The enumerator to write.
    func write(tag: Swift.Int32, value: MyEnum?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 2)
    }
}

public struct ValStruct: Swift.Hashable {
    public var bo: Swift.Bool = false
    public var by: Swift.UInt8 = 0
    public var sh: Swift.Int16 = 0
    public var i: Swift.Int32 = 0
    public var l: Swift.Int64 = 0
    public var e: MyEnum = .enum1

    public init() {}

    public init(bo: Swift.Bool, by: Swift.UInt8, sh: Swift.Int16, i: Swift.Int32, l: Swift.Int64, e: MyEnum) {
        self.bo = bo
        self.by = by
        self.sh = sh
        self.i = i
        self.l = l
        self.e = e
    }
}

/// An `Ice.InputStream` extension to read `ValStruct` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `ValStruct` structured value from the stream.
    ///
    /// - returns: `ValStruct` - The structured value read from the stream.
    func read() throws -> ValStruct {
        var v = ValStruct()
        v.bo = try self.read()
        v.by = try self.read()
        v.sh = try self.read()
        v.i = try self.read()
        v.l = try self.read()
        v.e = try self.read()
        return v
    }

    /// Read an optional `ValStruct?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ValStruct?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> ValStruct? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as ValStruct
    }
}

/// An `Ice.OutputStream` extension to write `ValStruct` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `ValStruct` structured value to the stream.
    ///
    /// - parameter _: `ValStruct` - The value to write to the stream.
    func write(_ v: ValStruct) {
        self.write(v.bo)
        self.write(v.by)
        self.write(v.sh)
        self.write(v.i)
        self.write(v.l)
        self.write(v.e)
    }

    /// Write an optional `ValStruct?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ValStruct?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: ValStruct?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// Traits for Slice interface `MyInterface`.
public struct MyInterfaceTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::MyInterface"]
    public static let staticId = "::Test::MyInterface"
}

public typealias ProxySeq = [MyInterfacePrx?]

/// Helper class to read and write `ProxySeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ProxySeqHelper {
    /// Read a `ProxySeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ProxySeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ProxySeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = ProxySeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: MyInterfacePrx? = try istr.read(MyInterfacePrx.self)
            v.append(j)
        }
        return v
    }
    /// Read an optional `ProxySeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ProxySeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ProxySeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ProxySeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ProxySeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ProxySeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `ProxySeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ProxySeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ProxySeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public class RefStruct {
    public var s: Swift.String = ""
    public var sp: Swift.String = ""
    public var c: MyClass? = nil
    public var p: MyInterfacePrx? = nil
    public var seq: ProxySeq = ProxySeq()

    public init() {}

    public init(s: Swift.String, sp: Swift.String, c: MyClass?, p: MyInterfacePrx?, seq: ProxySeq) {
        self.s = s
        self.sp = sp
        self.c = c
        self.p = p
        self.seq = seq
    }
}

/// An `Ice.InputStream` extension to read `RefStruct` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `RefStruct` structured value from the stream.
    ///
    /// - returns: `RefStruct` - The structured value read from the stream.
    func read() throws -> RefStruct {
        let v = RefStruct()
        v.s = try self.read()
        v.sp = try self.read()
        try self.read(MyClass.self) { v.c = $0 }
        v.p = try self.read(MyInterfacePrx.self)
        v.seq = try ProxySeqHelper.read(from: self)
        return v
    }

    /// Read an optional `RefStruct?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `RefStruct?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> RefStruct? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as RefStruct
    }
}

/// An `Ice.OutputStream` extension to write `RefStruct` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `RefStruct` structured value to the stream.
    ///
    /// - parameter _: `RefStruct` - The value to write to the stream.
    func write(_ v: RefStruct) {
        self.write(v.s)
        self.write(v.sp)
        self.write(v.c)
        self.write(v.p)
        ProxySeqHelper.write(to: self, value: v.seq)
    }

    /// Write an optional `RefStruct?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `RefStruct?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: RefStruct?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public typealias ValStructS = [ValStruct]

/// Helper class to read and write `ValStructS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ValStructSHelper {
    /// Read a `ValStructS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ValStructS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ValStructS {
        let sz = try istr.readAndCheckSeqSize(minSize: 17)
        var v = ValStructS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: ValStruct = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `ValStructS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ValStructS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ValStructS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ValStructS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ValStructS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ValStructS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `ValStructS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ValStructS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ValStructS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ValStructList = [ValStruct]

/// Helper class to read and write `ValStructList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ValStructListHelper {
    /// Read a `ValStructList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ValStructList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ValStructList {
        let sz = try istr.readAndCheckSeqSize(minSize: 17)
        var v = ValStructList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: ValStruct = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `ValStructList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ValStructList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ValStructList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ValStructList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ValStructList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ValStructList) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `ValStructList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ValStructList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ValStructList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ValStructLinkedList = [ValStruct]

/// Helper class to read and write `ValStructLinkedList` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ValStructLinkedListHelper {
    /// Read a `ValStructLinkedList` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ValStructLinkedList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ValStructLinkedList {
        let sz = try istr.readAndCheckSeqSize(minSize: 17)
        var v = ValStructLinkedList()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: ValStruct = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `ValStructLinkedList?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ValStructLinkedList` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ValStructLinkedList? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ValStructLinkedList` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ValStructLinkedList` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ValStructLinkedList) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `ValStructLinkedList?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ValStructLinkedList` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ValStructLinkedList?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ValStructStack = [ValStruct]

/// Helper class to read and write `ValStructStack` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ValStructStackHelper {
    /// Read a `ValStructStack` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ValStructStack` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ValStructStack {
        let sz = try istr.readAndCheckSeqSize(minSize: 17)
        var v = ValStructStack()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: ValStruct = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `ValStructStack?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ValStructStack` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ValStructStack? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ValStructStack` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ValStructStack` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ValStructStack) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `ValStructStack?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ValStructStack` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ValStructStack?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ValStructQueue = [ValStruct]

/// Helper class to read and write `ValStructQueue` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ValStructQueueHelper {
    /// Read a `ValStructQueue` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ValStructQueue` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ValStructQueue {
        let sz = try istr.readAndCheckSeqSize(minSize: 17)
        var v = ValStructQueue()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: ValStruct = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `ValStructQueue?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ValStructQueue` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ValStructQueue? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ValStructQueue` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ValStructQueue` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ValStructQueue) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `ValStructQueue?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ValStructQueue` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ValStructQueue?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias IntStringD = [Swift.Int32: Swift.String]

/// Helper class to read and write `IntStringD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct IntStringDHelper {
    /// Read a `IntStringD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `IntStringD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> IntStringD {
        let sz = try Swift.Int(istr.readSize())
        var v = IntStringD()
        for _ in 0 ..< sz {
            let key: Swift.Int32 = try istr.read()
            let value: Swift.String = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `IntStringD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `IntStringD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> IntStringD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `IntStringD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `IntStringD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: IntStringD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `IntStringD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `IntStringD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: IntStringD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias IntValStructD = [Swift.Int32: ValStruct]

/// Helper class to read and write `IntValStructD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct IntValStructDHelper {
    /// Read a `IntValStructD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `IntValStructD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> IntValStructD {
        let sz = try Swift.Int(istr.readSize())
        var v = IntValStructD()
        for _ in 0 ..< sz {
            let key: Swift.Int32 = try istr.read()
            let value: ValStruct = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `IntValStructD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `IntValStructD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> IntValStructD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `IntValStructD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `IntValStructD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: IntValStructD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `IntValStructD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `IntValStructD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: IntValStructD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias IntProxyD = [Swift.Int32: MyInterfacePrx?]

/// Helper class to read and write `IntProxyD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct IntProxyDHelper {
    /// Read a `IntProxyD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `IntProxyD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> IntProxyD {
        let sz = try Swift.Int(istr.readSize())
        var v = IntProxyD()
        for _ in 0 ..< sz {
            let key: Swift.Int32 = try istr.read()
            let value: MyInterfacePrx? = try istr.read(MyInterfacePrx.self)
            v[key] = value
        }
        return v
    }
    /// Read an optional `IntProxyD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `IntProxyD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> IntProxyD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `IntProxyD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `IntProxyD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: IntProxyD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `IntProxyD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `IntProxyD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: IntProxyD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias IntStringSD = [Swift.Int32: Swift.String]

/// Helper class to read and write `IntStringSD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct IntStringSDHelper {
    /// Read a `IntStringSD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `IntStringSD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> IntStringSD {
        let sz = try Swift.Int(istr.readSize())
        var v = IntStringSD()
        for _ in 0 ..< sz {
            let key: Swift.Int32 = try istr.read()
            let value: Swift.String = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `IntStringSD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `IntStringSD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> IntStringSD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `IntStringSD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `IntStringSD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: IntStringSD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `IntStringSD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `IntStringSD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: IntStringSD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice class `Base`.
public struct BaseTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Base"]
    public static let staticId = "::Test::Base"
}

/// Traits for Slice class `MyClass`.
public struct MyClassTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Base", "::Test::MyClass"]
    public static let staticId = "::Test::MyClass"
}

/// :nodoc:
public class MyException_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return MyException.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_MyException() -> Ice.UserExceptionTypeResolver {
        return MyException_TypeResolver()
    }
}

open class MyException: Ice.UserException {
    public var name: Swift.String = ""
    public var b: Swift.UInt8 = 0
    public var s: Swift.Int16 = 0
    public var i: Swift.Int32 = 0
    public var l: Swift.Int64 = 0
    public var vs: ValStruct = ValStruct()
    public var rs: RefStruct = RefStruct()
    public var c: MyClass? = nil
    public var p: MyInterfacePrx? = nil
    public var vss: ValStructS = ValStructS()
    public var vsl: ValStructList = ValStructList()
    public var vsll: ValStructLinkedList = ValStructLinkedList()
    public var vssk: ValStructStack = ValStructStack()
    public var vsq: ValStructQueue = ValStructQueue()
    public var isd: IntStringD = IntStringD()
    public var ivd: IntValStructD = IntValStructD()
    public var ipd: IntProxyD = IntProxyD()
    public var issd: IntStringSD = IntStringSD()
    public var optName: Swift.String? = nil
    public var optInt: Swift.Int32? = nil
    public var optValStruct: ValStruct? = nil
    public var optRefStruct: RefStruct? = nil
    public var optEnum: MyEnum? = nil
    public var optClass: MyClass? = nil
    public var optProxy: MyInterfacePrx? = nil

    public required init() {}

    public init(name: Swift.String, b: Swift.UInt8, s: Swift.Int16, i: Swift.Int32, l: Swift.Int64, vs: ValStruct, rs: RefStruct, c: MyClass?, p: MyInterfacePrx?, vss: ValStructS, vsl: ValStructList, vsll: ValStructLinkedList, vssk: ValStructStack, vsq: ValStructQueue, isd: IntStringD, ivd: IntValStructD, ipd: IntProxyD, issd: IntStringSD, optName: Swift.String?, optInt: Swift.Int32?, optValStruct: ValStruct?, optRefStruct: RefStruct?, optEnum: MyEnum?, optClass: MyClass?, optProxy: MyInterfacePrx?) {
        self.name = name
        self.b = b
        self.s = s
        self.i = i
        self.l = l
        self.vs = vs
        self.rs = rs
        self.c = c
        self.p = p
        self.vss = vss
        self.vsl = vsl
        self.vsll = vsll
        self.vssk = vssk
        self.vsq = vsq
        self.isd = isd
        self.ivd = ivd
        self.ipd = ipd
        self.issd = issd
        self.optName = optName
        self.optInt = optInt
        self.optValStruct = optValStruct
        self.optRefStruct = optRefStruct
        self.optEnum = optEnum
        self.optClass = optClass
        self.optProxy = optProxy
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::Test::MyException"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: MyException.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.name)
        ostr.write(self.b)
        ostr.write(self.s)
        ostr.write(self.i)
        ostr.write(self.l)
        ostr.write(self.vs)
        ostr.write(self.rs)
        ostr.write(self.c)
        ostr.write(self.p)
        ValStructSHelper.write(to: ostr, value: self.vss)
        ValStructListHelper.write(to: ostr, value: self.vsl)
        ValStructLinkedListHelper.write(to: ostr, value: self.vsll)
        ValStructStackHelper.write(to: ostr, value: self.vssk)
        ValStructQueueHelper.write(to: ostr, value: self.vsq)
        IntStringDHelper.write(to: ostr, value: self.isd)
        IntValStructDHelper.write(to: ostr, value: self.ivd)
        IntProxyDHelper.write(to: ostr, value: self.ipd)
        IntStringSDHelper.write(to: ostr, value: self.issd)
        ostr.write(tag: 1, value: self.optName)
        ostr.write(tag: 2, value: self.optInt)
        ostr.write(tag: 3, value: self.optValStruct)
        ostr.write(tag: 4, value: self.optRefStruct)
        ostr.write(tag: 5, value: self.optEnum)
        ostr.write(tag: 6, value: self.optClass)
        ostr.write(tag: 7, value: self.optProxy)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.name = try istr.read()
        self.b = try istr.read()
        self.s = try istr.read()
        self.i = try istr.read()
        self.l = try istr.read()
        self.vs = try istr.read()
        self.rs = try istr.read()
        try istr.read(MyClass.self) { self.c = $0 }
        self.p = try istr.read(MyInterfacePrx.self)
        self.vss = try ValStructSHelper.read(from: istr)
        self.vsl = try ValStructListHelper.read(from: istr)
        self.vsll = try ValStructLinkedListHelper.read(from: istr)
        self.vssk = try ValStructStackHelper.read(from: istr)
        self.vsq = try ValStructQueueHelper.read(from: istr)
        self.isd = try IntStringDHelper.read(from: istr)
        self.ivd = try IntValStructDHelper.read(from: istr)
        self.ipd = try IntProxyDHelper.read(from: istr)
        self.issd = try IntStringSDHelper.read(from: istr)
        self.optName = try istr.read(tag: 1)
        self.optInt = try istr.read(tag: 2)
        self.optValStruct = try istr.read(tag: 3)
        self.optRefStruct = try istr.read(tag: 4)
        self.optEnum = try istr.read(tag: 5)
        try istr.read(tag: 6, value: MyClass.self) { self.optClass = $0 }
        self.optProxy = try istr.read(tag: 7, type: MyInterfacePrx.self)
        try istr.endSlice()
    }

    open override func _usesClasses() -> Swift.Bool {
        return true
    }
}

/// MyInterfacePrx overview.
///
/// MyInterfacePrx Methods:
///
///  - op: 
///
///  - opAsync: 
public protocol MyInterfacePrx: Ice.ObjectPrx {}

private final class MyInterfacePrxI: Ice.ObjectPrxI, MyInterfacePrx {
    public override class func ice_staticId() -> Swift.String {
        return MyInterfaceTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `MyInterfacePrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `MyInterfacePrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: MyInterfacePrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> MyInterfacePrx? {
    return try MyInterfacePrxI.checkedCast(prx: prx, facet: facet, context: context) as MyInterfacePrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `MyInterfacePrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `MyInterfacePrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: MyInterfacePrx.Protocol, facet: Swift.String? = nil) -> MyInterfacePrx {
    return MyInterfacePrxI.uncheckedCast(prx: prx, facet: facet) as MyInterfacePrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `MyInterfacePrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: MyInterfacePrx.Protocol) -> Swift.String {
    return MyInterfaceTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `MyInterfacePrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `MyInterfacePrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `MyInterfacePrx?` - The extracted proxy
    func read(_ type: MyInterfacePrx.Protocol) throws -> MyInterfacePrx? {
        return try read() as MyInterfacePrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `MyInterfacePrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `MyInterfacePrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: MyInterfacePrx.Protocol) throws -> MyInterfacePrx? {
        return try read(tag: tag) as MyInterfacePrxI?
    }
}

/// MyInterfacePrx overview.
///
/// MyInterfacePrx Methods:
///
///  - op: 
///
///  - opAsync: 
public extension MyInterfacePrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func op(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "op",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func opAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "op",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// :nodoc:
public class Base_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Base.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Base() -> Ice.ValueTypeResolver {
        return Base_TypeResolver()
    }
}

open class Base: Ice.Value {
    public var bo: Swift.Bool = false
    public var by: Swift.UInt8 = 0
    public var sh: Swift.Int16 = 0
    public var i: Swift.Int32 = 0
    public var l: Swift.Int64 = 0
    public var e: MyEnum = .enum1

    public required init() {}

    public init(bo: Swift.Bool, by: Swift.UInt8, sh: Swift.Int16, i: Swift.Int32, l: Swift.Int64, e: MyEnum) {
        self.bo = bo
        self.by = by
        self.sh = sh
        self.i = i
        self.l = l
        self.e = e
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return BaseTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return BaseTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.bo = try istr.read()
        self.by = try istr.read()
        self.sh = try istr.read()
        self.i = try istr.read()
        self.l = try istr.read()
        self.e = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: BaseTraits.staticId, compactId: -1, last: true)
        ostr.write(self.bo)
        ostr.write(self.by)
        ostr.write(self.sh)
        ostr.write(self.i)
        ostr.write(self.l)
        ostr.write(self.e)
        ostr.endSlice()
    }
}

/// :nodoc:
public class MyClass_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return MyClass.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_MyClass() -> Ice.ValueTypeResolver {
        return MyClass_TypeResolver()
    }
}

open class MyClass: Base {
    public var c: MyClass? = nil
    public var o: Ice.Value? = nil
    public var s: ValStruct = ValStruct()

    public required init() {
        super.init()
    }

    public init(bo: Swift.Bool, by: Swift.UInt8, sh: Swift.Int16, i: Swift.Int32, l: Swift.Int64, e: MyEnum, c: MyClass?, o: Ice.Value?, s: ValStruct) {
        self.c = c
        self.o = o
        self.s = s
        super.init(bo: bo, by: by, sh: sh, i: i, l: l, e: e)
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return MyClassTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return MyClassTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(MyClass.self) { self.c = $0 }
        try istr.read() { self.o = $0 }
        self.s = try istr.read()
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: MyClassTraits.staticId, compactId: -1, last: false)
        ostr.write(self.c)
        ostr.write(self.o)
        ostr.write(self.s)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}


/// Dispatcher for `MyInterface` servants.
public struct MyInterfaceDisp: Ice.Disp {
    public let servant: MyInterface
    private static let defaultObject = Ice.ObjectI<MyInterfaceTraits>()

    public init(_ servant: MyInterface) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "ice_id":
            return try (servant as? Object ?? MyInterfaceDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? MyInterfaceDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? MyInterfaceDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? MyInterfaceDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "op":
            return try servant._iceD_op(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol MyInterface {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func op(current: Ice.Current) throws
}

/// MyInterface overview.
///
/// MyInterface Methods:
///
///  - op: 
public extension MyInterface {
    func _iceD_op(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.op(current: current)

        return inS.setResult()
    }
}
