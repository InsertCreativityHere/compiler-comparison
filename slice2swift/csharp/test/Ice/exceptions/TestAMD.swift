//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `TestAMD.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice

/// Traits for Slice interface `Empty`.
public struct EmptyTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Empty"]
    public static let staticId = "::Test::Empty"
}

/// :nodoc:
public class A_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return A.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_A() -> Ice.UserExceptionTypeResolver {
        return A_TypeResolver()
    }
}

open class A: Ice.UserException, @unchecked Sendable {
    public var aMem: Swift.Int32 = 0

    public required init() {}

    public init(aMem: Swift.Int32) {
        self.aMem = aMem
    }

    /// - Returns: The Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Test::A" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: A.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.aMem)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.aMem = try istr.read()
        try istr.endSlice()
    }
}

/// :nodoc:
public class B_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return B.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_B() -> Ice.UserExceptionTypeResolver {
        return B_TypeResolver()
    }
}

open class B: A, @unchecked Sendable {
    public var bMem: Swift.Int32 = 0

    public required init() {
        super.init()
    }

    public init(aMem: Swift.Int32, bMem: Swift.Int32) {
        self.bMem = bMem
        super.init(aMem: aMem)
    }

    /// - Returns: The Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Test::B" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: B.ice_staticId(), compactId: -1, last: false)
        ostr.write(self.bMem)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.bMem = try istr.read()
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }
}

/// :nodoc:
public class C_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return C.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_C() -> Ice.UserExceptionTypeResolver {
        return C_TypeResolver()
    }
}

open class C: B, @unchecked Sendable {
    public var cMem: Swift.Int32 = 0

    public required init() {
        super.init()
    }

    public init(aMem: Swift.Int32, bMem: Swift.Int32, cMem: Swift.Int32) {
        self.cMem = cMem
        super.init(aMem: aMem, bMem: bMem)
    }

    /// - Returns: The Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Test::C" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: C.ice_staticId(), compactId: -1, last: false)
        ostr.write(self.cMem)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.cMem = try istr.read()
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }
}

/// :nodoc:
public class D_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return D.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_D() -> Ice.UserExceptionTypeResolver {
        return D_TypeResolver()
    }
}

open class D: Ice.UserException, @unchecked Sendable {
    public var dMem: Swift.Int32 = 0

    public required init() {}

    public init(dMem: Swift.Int32) {
        self.dMem = dMem
    }

    /// - Returns: The Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Test::D" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: D.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.dMem)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.dMem = try istr.read()
        try istr.endSlice()
    }
}

/// Traits for Slice interface `Thrower`.
public struct ThrowerTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Thrower"]
    public static let staticId = "::Test::Thrower"
}

/// Traits for Slice interface `WrongOperation`.
public struct WrongOperationTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::WrongOperation"]
    public static let staticId = "::Test::WrongOperation"
}

public protocol EmptyPrx: Ice.ObjectPrx {}

private final class EmptyPrxI: Ice.ObjectPrxI, EmptyPrx {
    public override class func ice_staticId() -> Swift.String {
        return EmptyTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: EmptyPrx.Protocol) throws -> EmptyPrx {
    try communicator.makeProxyImpl(proxyString) as EmptyPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: EmptyPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> EmptyPrx? {
    return try await EmptyPrxI.checkedCast(prx: prx, facet: facet, context: context) as EmptyPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: EmptyPrx.Protocol, facet: Swift.String? = nil) -> EmptyPrx {
    return EmptyPrxI.uncheckedCast(prx: prx, facet: facet) as EmptyPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: EmptyPrx.Protocol) -> Swift.String {
    return EmptyTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `EmptyPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: EmptyPrx.Protocol) throws -> EmptyPrx? {
        return try read() as EmptyPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: EmptyPrx.Protocol) throws -> EmptyPrx? {
        return try read(tag: tag) as EmptyPrxI?
    }
}

public extension EmptyPrx {}

public protocol ThrowerPrx: Ice.ObjectPrx {}

private final class ThrowerPrxI: Ice.ObjectPrxI, ThrowerPrx {
    public override class func ice_staticId() -> Swift.String {
        return ThrowerTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: ThrowerPrx.Protocol) throws -> ThrowerPrx {
    try communicator.makeProxyImpl(proxyString) as ThrowerPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: ThrowerPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> ThrowerPrx? {
    return try await ThrowerPrxI.checkedCast(prx: prx, facet: facet, context: context) as ThrowerPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: ThrowerPrx.Protocol, facet: Swift.String? = nil) -> ThrowerPrx {
    return ThrowerPrxI.uncheckedCast(prx: prx, facet: facet) as ThrowerPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: ThrowerPrx.Protocol) -> Swift.String {
    return ThrowerTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `ThrowerPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: ThrowerPrx.Protocol) throws -> ThrowerPrx? {
        return try read() as ThrowerPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: ThrowerPrx.Protocol) throws -> ThrowerPrx? {
        return try read(tag: tag) as ThrowerPrxI?
    }
}

public extension ThrowerPrx {
    func shutdown(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "shutdown",
                                       mode: .Normal,
                                       context: context)
    }

    func supportsUndeclaredExceptions(context: Ice.Context? = nil) async throws -> Swift.Bool {
        return try await _impl._invoke(operation: "supportsUndeclaredExceptions",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: Swift.Bool = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func supportsAssertException(context: Ice.Context? = nil) async throws -> Swift.Bool {
        return try await _impl._invoke(operation: "supportsAssertException",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: Swift.Bool = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func throwAasA(_ iceP_a: Swift.Int32, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "throwAasA",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_a)
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as A {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    func throwAorDasAorD(_ iceP_a: Swift.Int32, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "throwAorDasAorD",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_a)
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as A {
                                               throw error
                                           } catch let error as D {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    func throwBasA(a iceP_a: Swift.Int32, b iceP_b: Swift.Int32, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "throwBasA",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_a)
                                           ostr.write(iceP_b)
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as A {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    func throwCasA(a iceP_a: Swift.Int32, b iceP_b: Swift.Int32, c iceP_c: Swift.Int32, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "throwCasA",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_a)
                                           ostr.write(iceP_b)
                                           ostr.write(iceP_c)
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as A {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    func throwBasB(a iceP_a: Swift.Int32, b iceP_b: Swift.Int32, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "throwBasB",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_a)
                                           ostr.write(iceP_b)
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as B {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    func throwCasB(a iceP_a: Swift.Int32, b iceP_b: Swift.Int32, c iceP_c: Swift.Int32, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "throwCasB",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_a)
                                           ostr.write(iceP_b)
                                           ostr.write(iceP_c)
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as B {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    func throwCasC(a iceP_a: Swift.Int32, b iceP_b: Swift.Int32, c iceP_c: Swift.Int32, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "throwCasC",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_a)
                                           ostr.write(iceP_b)
                                           ostr.write(iceP_c)
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as C {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    func throwUndeclaredA(_ iceP_a: Swift.Int32, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "throwUndeclaredA",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_a)
                                       },
                                       context: context)
    }

    func throwUndeclaredB(a iceP_a: Swift.Int32, b iceP_b: Swift.Int32, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "throwUndeclaredB",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_a)
                                           ostr.write(iceP_b)
                                       },
                                       context: context)
    }

    func throwUndeclaredC(a iceP_a: Swift.Int32, b iceP_b: Swift.Int32, c iceP_c: Swift.Int32, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "throwUndeclaredC",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_a)
                                           ostr.write(iceP_b)
                                           ostr.write(iceP_c)
                                       },
                                       context: context)
    }

    func throwLocalException(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "throwLocalException",
                                       mode: .Normal,
                                       context: context)
    }

    func throwNonIceException(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "throwNonIceException",
                                       mode: .Normal,
                                       context: context)
    }

    func throwAssertException(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "throwAssertException",
                                       mode: .Normal,
                                       context: context)
    }

    func throwMemoryLimitException(_ iceP_seq: Ice.ByteSeq, context: Ice.Context? = nil) async throws -> Ice.ByteSeq {
        return try await _impl._invoke(operation: "throwMemoryLimitException",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_seq)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Ice.ByteSeq = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func throwLocalExceptionIdempotent(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "throwLocalExceptionIdempotent",
                                       mode: .Idempotent,
                                       context: context)
    }

    func throwAfterResponse(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "throwAfterResponse",
                                       mode: .Normal,
                                       context: context)
    }

    func throwAfterException(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "throwAfterException",
                                       mode: .Normal,
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as A {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }
}

public protocol WrongOperationPrx: Ice.ObjectPrx {}

private final class WrongOperationPrxI: Ice.ObjectPrxI, WrongOperationPrx {
    public override class func ice_staticId() -> Swift.String {
        return WrongOperationTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: WrongOperationPrx.Protocol) throws -> WrongOperationPrx {
    try communicator.makeProxyImpl(proxyString) as WrongOperationPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: WrongOperationPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> WrongOperationPrx? {
    return try await WrongOperationPrxI.checkedCast(prx: prx, facet: facet, context: context) as WrongOperationPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: WrongOperationPrx.Protocol, facet: Swift.String? = nil) -> WrongOperationPrx {
    return WrongOperationPrxI.uncheckedCast(prx: prx, facet: facet) as WrongOperationPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: WrongOperationPrx.Protocol) -> Swift.String {
    return WrongOperationTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `WrongOperationPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: WrongOperationPrx.Protocol) throws -> WrongOperationPrx? {
        return try read() as WrongOperationPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: WrongOperationPrx.Protocol) throws -> WrongOperationPrx? {
        return try read(tag: tag) as WrongOperationPrxI?
    }
}

public extension WrongOperationPrx {
    func noSuchOperation(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "noSuchOperation",
                                       mode: .Normal,
                                       context: context)
    }
}


/// Dispatcher for `Empty` servants.
public struct EmptyDisp: Ice.Dispatcher {
    public let servant: Empty
    private static let defaultObject = Ice.ObjectI<EmptyTraits>()

    public init(_ servant: Empty) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "ice_id":
            try await (servant as? Ice.Object ?? EmptyDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? EmptyDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? EmptyDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? EmptyDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol Empty {}


/// Dispatcher for `Thrower` servants.
public struct ThrowerDisp: Ice.Dispatcher {
    public let servant: Thrower
    private static let defaultObject = Ice.ObjectI<ThrowerTraits>()

    public init(_ servant: Thrower) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "ice_id":
            try await (servant as? Ice.Object ?? ThrowerDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? ThrowerDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? ThrowerDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? ThrowerDisp.defaultObject)._iceD_ice_ping(request)
        case "shutdown":
            try await servant._iceD_shutdown(request)
        case "supportsAssertException":
            try await servant._iceD_supportsAssertException(request)
        case "supportsUndeclaredExceptions":
            try await servant._iceD_supportsUndeclaredExceptions(request)
        case "throwAasA":
            try await servant._iceD_throwAasA(request)
        case "throwAfterException":
            try await servant._iceD_throwAfterException(request)
        case "throwAfterResponse":
            try await servant._iceD_throwAfterResponse(request)
        case "throwAorDasAorD":
            try await servant._iceD_throwAorDasAorD(request)
        case "throwAssertException":
            try await servant._iceD_throwAssertException(request)
        case "throwBasA":
            try await servant._iceD_throwBasA(request)
        case "throwBasB":
            try await servant._iceD_throwBasB(request)
        case "throwCasA":
            try await servant._iceD_throwCasA(request)
        case "throwCasB":
            try await servant._iceD_throwCasB(request)
        case "throwCasC":
            try await servant._iceD_throwCasC(request)
        case "throwLocalException":
            try await servant._iceD_throwLocalException(request)
        case "throwLocalExceptionIdempotent":
            try await servant._iceD_throwLocalExceptionIdempotent(request)
        case "throwMemoryLimitException":
            try await servant._iceD_throwMemoryLimitException(request)
        case "throwNonIceException":
            try await servant._iceD_throwNonIceException(request)
        case "throwUndeclaredA":
            try await servant._iceD_throwUndeclaredA(request)
        case "throwUndeclaredB":
            try await servant._iceD_throwUndeclaredB(request)
        case "throwUndeclaredC":
            try await servant._iceD_throwUndeclaredC(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol Thrower {
    func shutdown(current: Ice.Current) async throws

    func supportsUndeclaredExceptions(current: Ice.Current) async throws -> Swift.Bool

    func supportsAssertException(current: Ice.Current) async throws -> Swift.Bool

    func throwAasA(a: Swift.Int32, current: Ice.Current) async throws

    func throwAorDasAorD(a: Swift.Int32, current: Ice.Current) async throws

    func throwBasA(a: Swift.Int32, b: Swift.Int32, current: Ice.Current) async throws

    func throwCasA(a: Swift.Int32, b: Swift.Int32, c: Swift.Int32, current: Ice.Current) async throws

    func throwBasB(a: Swift.Int32, b: Swift.Int32, current: Ice.Current) async throws

    func throwCasB(a: Swift.Int32, b: Swift.Int32, c: Swift.Int32, current: Ice.Current) async throws

    func throwCasC(a: Swift.Int32, b: Swift.Int32, c: Swift.Int32, current: Ice.Current) async throws

    func throwUndeclaredA(a: Swift.Int32, current: Ice.Current) async throws

    func throwUndeclaredB(a: Swift.Int32, b: Swift.Int32, current: Ice.Current) async throws

    func throwUndeclaredC(a: Swift.Int32, b: Swift.Int32, c: Swift.Int32, current: Ice.Current) async throws

    func throwLocalException(current: Ice.Current) async throws

    func throwNonIceException(current: Ice.Current) async throws

    func throwAssertException(current: Ice.Current) async throws

    func throwMemoryLimitException(seq: Ice.ByteSeq, current: Ice.Current) async throws -> Ice.ByteSeq

    func throwLocalExceptionIdempotent(current: Ice.Current) async throws

    func throwAfterResponse(current: Ice.Current) async throws

    func throwAfterException(current: Ice.Current) async throws
}


/// Dispatcher for `WrongOperation` servants.
public struct WrongOperationDisp: Ice.Dispatcher {
    public let servant: WrongOperation
    private static let defaultObject = Ice.ObjectI<WrongOperationTraits>()

    public init(_ servant: WrongOperation) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "ice_id":
            try await (servant as? Ice.Object ?? WrongOperationDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? WrongOperationDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? WrongOperationDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? WrongOperationDisp.defaultObject)._iceD_ice_ping(request)
        case "noSuchOperation":
            try await servant._iceD_noSuchOperation(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol WrongOperation {
    func noSuchOperation(current: Ice.Current) async throws
}

extension Empty {}

extension Thrower {
    public func _iceD_shutdown(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.shutdown(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_supportsUndeclaredExceptions(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.supportsUndeclaredExceptions(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_supportsAssertException(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.supportsAssertException(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_throwAasA(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_a: Swift.Int32 = try istr.read()
        try await self.throwAasA(a: iceP_a, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_throwAorDasAorD(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_a: Swift.Int32 = try istr.read()
        try await self.throwAorDasAorD(a: iceP_a, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_throwBasA(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_a: Swift.Int32 = try istr.read()
        let iceP_b: Swift.Int32 = try istr.read()
        try await self.throwBasA(a: iceP_a, b: iceP_b, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_throwCasA(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_a: Swift.Int32 = try istr.read()
        let iceP_b: Swift.Int32 = try istr.read()
        let iceP_c: Swift.Int32 = try istr.read()
        try await self.throwCasA(a: iceP_a, b: iceP_b, c: iceP_c, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_throwBasB(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_a: Swift.Int32 = try istr.read()
        let iceP_b: Swift.Int32 = try istr.read()
        try await self.throwBasB(a: iceP_a, b: iceP_b, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_throwCasB(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_a: Swift.Int32 = try istr.read()
        let iceP_b: Swift.Int32 = try istr.read()
        let iceP_c: Swift.Int32 = try istr.read()
        try await self.throwCasB(a: iceP_a, b: iceP_b, c: iceP_c, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_throwCasC(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_a: Swift.Int32 = try istr.read()
        let iceP_b: Swift.Int32 = try istr.read()
        let iceP_c: Swift.Int32 = try istr.read()
        try await self.throwCasC(a: iceP_a, b: iceP_b, c: iceP_c, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_throwUndeclaredA(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_a: Swift.Int32 = try istr.read()
        try await self.throwUndeclaredA(a: iceP_a, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_throwUndeclaredB(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_a: Swift.Int32 = try istr.read()
        let iceP_b: Swift.Int32 = try istr.read()
        try await self.throwUndeclaredB(a: iceP_a, b: iceP_b, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_throwUndeclaredC(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_a: Swift.Int32 = try istr.read()
        let iceP_b: Swift.Int32 = try istr.read()
        let iceP_c: Swift.Int32 = try istr.read()
        try await self.throwUndeclaredC(a: iceP_a, b: iceP_b, c: iceP_c, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_throwLocalException(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.throwLocalException(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_throwNonIceException(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.throwNonIceException(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_throwAssertException(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.throwAssertException(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_throwMemoryLimitException(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_seq: Ice.ByteSeq = try istr.read()
        let result = try await self.throwMemoryLimitException(seq: iceP_seq, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_throwLocalExceptionIdempotent(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.throwLocalExceptionIdempotent(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_throwAfterResponse(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.throwAfterResponse(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_throwAfterException(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.throwAfterException(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}

extension WrongOperation {
    public func _iceD_noSuchOperation(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.noSuchOperation(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}
