//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.9
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice
import PromiseKit

public enum MyEnum: Swift.UInt8 {
    /// enum1
    case enum1 = 0
    /// enum2
    case enum2 = 1
    /// enum3
    case enum3 = 2
    public init() {
        self = .enum1
    }
}

/// An `Ice.InputStream` extension to read `MyEnum` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - returns: `MyEnum` - The enumarated value.
    func read() throws -> MyEnum {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 2)
        guard let val = MyEnum(rawValue: rawValue) else {
            throw Ice.MarshalException(reason: "invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyEnum` - The enumerated value.
    func read(tag: Swift.Int32) throws -> MyEnum? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as MyEnum
    }
}

/// An `Ice.OutputStream` extension to write `MyEnum` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// parameter _: `MyEnum` - The enumerator to write.
    func write(_ v: MyEnum) {
        write(enum: v.rawValue, maxValue: 2)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// parameter _: `MyEnum` - The enumerator to write.
    func write(tag: Swift.Int32, value: MyEnum?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 2)
    }
}

public struct AnotherStruct: Swift.Hashable {
    public var s: Swift.String = ""

    public init() {}

    public init(s: Swift.String) {
        self.s = s
    }
}

/// An `Ice.InputStream` extension to read `AnotherStruct` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `AnotherStruct` structured value from the stream.
    ///
    /// - returns: `AnotherStruct` - The structured value read from the stream.
    func read() throws -> AnotherStruct {
        var v = AnotherStruct()
        v.s = try self.read()
        return v
    }

    /// Read an optional `AnotherStruct?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `AnotherStruct?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> AnotherStruct? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as AnotherStruct
    }
}

/// An `Ice.OutputStream` extension to write `AnotherStruct` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `AnotherStruct` structured value to the stream.
    ///
    /// - parameter _: `AnotherStruct` - The value to write to the stream.
    func write(_ v: AnotherStruct) {
        self.write(v.s)
    }

    /// Write an optional `AnotherStruct?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `AnotherStruct?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: AnotherStruct?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public struct Structure {
    public var p: MyClassPrx? = nil
    public var e: MyEnum = .enum1
    public var s: AnotherStruct = AnotherStruct()

    public init() {}

    public init(p: MyClassPrx?, e: MyEnum, s: AnotherStruct) {
        self.p = p
        self.e = e
        self.s = s
    }
}

/// An `Ice.InputStream` extension to read `Structure` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `Structure` structured value from the stream.
    ///
    /// - returns: `Structure` - The structured value read from the stream.
    func read() throws -> Structure {
        var v = Structure()
        v.p = try self.read(MyClassPrx.self)
        v.e = try self.read()
        v.s = try self.read()
        return v
    }

    /// Read an optional `Structure?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `Structure?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> Structure? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as Structure
    }
}

/// An `Ice.OutputStream` extension to write `Structure` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `Structure` structured value to the stream.
    ///
    /// - parameter _: `Structure` - The value to write to the stream.
    func write(_ v: Structure) {
        self.write(v.p)
        self.write(v.e)
        self.write(v.s)
    }

    /// Write an optional `Structure?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `Structure?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: Structure?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public typealias ByteS = Foundation.Data

public typealias BoolS = [Swift.Bool]

public typealias ShortS = [Swift.Int16]

public typealias IntS = [Swift.Int32]

public typealias LongS = [Swift.Int64]

public typealias FloatS = [Swift.Float]

public typealias DoubleS = [Swift.Double]

public typealias StringS = [Swift.String]

public typealias MyEnumS = [MyEnum]

/// Helper class to read and write `MyEnumS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyEnumSHelper {
    /// Read a `MyEnumS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `MyEnumS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyEnumS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = MyEnumS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: MyEnum = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `MyEnumS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyEnumS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyEnumS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `MyEnumS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `MyEnumS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyEnumS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `MyEnumS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `MyEnumS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: MyEnumS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias MyClassS = [MyClassPrx?]

/// Helper class to read and write `MyClassS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyClassSHelper {
    /// Read a `MyClassS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `MyClassS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyClassS {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = MyClassS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: MyClassPrx? = try istr.read(MyClassPrx.self)
            v.append(j)
        }
        return v
    }
    /// Read an optional `MyClassS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyClassS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyClassS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `MyClassS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `MyClassS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyClassS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `MyClassS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `MyClassS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: MyClassS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ByteSS = [ByteS]

/// Helper class to read and write `ByteSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ByteSSHelper {
    /// Read a `ByteSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ByteSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ByteSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = ByteSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: ByteS = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `ByteSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ByteSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ByteSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ByteSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ByteSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ByteSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `ByteSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ByteSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ByteSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias BoolSS = [BoolS]

/// Helper class to read and write `BoolSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct BoolSSHelper {
    /// Read a `BoolSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `BoolSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> BoolSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = BoolSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: BoolS = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `BoolSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `BoolSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> BoolSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `BoolSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `BoolSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: BoolSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `BoolSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `BoolSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: BoolSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ShortSS = [ShortS]

/// Helper class to read and write `ShortSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ShortSSHelper {
    /// Read a `ShortSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ShortSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ShortSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = ShortSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: ShortS = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `ShortSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ShortSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ShortSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ShortSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ShortSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ShortSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `ShortSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ShortSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ShortSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias IntSS = [IntS]

/// Helper class to read and write `IntSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct IntSSHelper {
    /// Read a `IntSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `IntSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> IntSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = IntSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: IntS = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `IntSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `IntSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> IntSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `IntSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `IntSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: IntSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `IntSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `IntSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: IntSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias LongSS = [LongS]

/// Helper class to read and write `LongSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LongSSHelper {
    /// Read a `LongSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `LongSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LongSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = LongSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: LongS = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `LongSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LongSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LongSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `LongSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `LongSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LongSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `LongSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LongSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: LongSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias FloatSS = [FloatS]

/// Helper class to read and write `FloatSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct FloatSSHelper {
    /// Read a `FloatSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `FloatSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> FloatSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = FloatSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: FloatS = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `FloatSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `FloatSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> FloatSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `FloatSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `FloatSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: FloatSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `FloatSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `FloatSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: FloatSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias DoubleSS = [DoubleS]

/// Helper class to read and write `DoubleSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct DoubleSSHelper {
    /// Read a `DoubleSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `DoubleSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> DoubleSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = DoubleSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: DoubleS = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `DoubleSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `DoubleSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> DoubleSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `DoubleSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `DoubleSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: DoubleSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `DoubleSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `DoubleSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: DoubleSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringSS = [StringS]

/// Helper class to read and write `StringSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringSSHelper {
    /// Read a `StringSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = StringSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: StringS = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `StringSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `StringSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: StringSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias MyEnumSS = [MyEnumS]

/// Helper class to read and write `MyEnumSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyEnumSSHelper {
    /// Read a `MyEnumSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `MyEnumSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyEnumSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = MyEnumSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: MyEnumS = try MyEnumSHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `MyEnumSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyEnumSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyEnumSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `MyEnumSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `MyEnumSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyEnumSS) {
        ostr.write(size: v.count)
        for item in v {
            MyEnumSHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `MyEnumSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `MyEnumSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: MyEnumSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias MyClassSS = [MyClassS]

/// Helper class to read and write `MyClassSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyClassSSHelper {
    /// Read a `MyClassSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `MyClassSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyClassSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = MyClassSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: MyClassS = try MyClassSHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `MyClassSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyClassSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyClassSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `MyClassSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `MyClassSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyClassSS) {
        ostr.write(size: v.count)
        for item in v {
            MyClassSHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `MyClassSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `MyClassSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: MyClassSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringSSS = [StringSS]

/// Helper class to read and write `StringSSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringSSSHelper {
    /// Read a `StringSSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringSSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringSSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = StringSSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: StringSS = try StringSSHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `StringSSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringSSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringSSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringSSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringSSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringSSS) {
        ostr.write(size: v.count)
        for item in v {
            StringSSHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `StringSSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringSSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: StringSSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public struct MyStruct: Swift.Hashable {
    public var i: Swift.Int32 = 0
    public var j: Swift.Int32 = 0

    public init() {}

    public init(i: Swift.Int32, j: Swift.Int32) {
        self.i = i
        self.j = j
    }
}

/// An `Ice.InputStream` extension to read `MyStruct` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `MyStruct` structured value from the stream.
    ///
    /// - returns: `MyStruct` - The structured value read from the stream.
    func read() throws -> MyStruct {
        var v = MyStruct()
        v.i = try self.read()
        v.j = try self.read()
        return v
    }

    /// Read an optional `MyStruct?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyStruct?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> MyStruct? {
        guard try readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try skipSize()
        return try read() as MyStruct
    }
}

/// An `Ice.OutputStream` extension to write `MyStruct` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `MyStruct` structured value to the stream.
    ///
    /// - parameter _: `MyStruct` - The value to write to the stream.
    func write(_ v: MyStruct) {
        self.write(v.i)
        self.write(v.j)
    }

    /// Write an optional `MyStruct?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `MyStruct?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: MyStruct?) {
        if let v = value {
            if writeOptional(tag: tag, format: .VSize) {
                write(size: 8)
                write(v)
            }
        }
    }
}

public typealias ByteBoolD = [Swift.UInt8: Swift.Bool]

/// Helper class to read and write `ByteBoolD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ByteBoolDHelper {
    /// Read a `ByteBoolD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ByteBoolD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ByteBoolD {
        let sz = try Swift.Int(istr.readSize())
        var v = ByteBoolD()
        for _ in 0 ..< sz {
            let key: Swift.UInt8 = try istr.read()
            let value: Swift.Bool = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `ByteBoolD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ByteBoolD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ByteBoolD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Wite a `ByteBoolD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ByteBoolD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ByteBoolD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `ByteBoolD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ByteBoolD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: ByteBoolD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 2) {
            write(to: ostr, value: val)
        }
    }
}

public typealias ShortIntD = [Swift.Int16: Swift.Int32]

/// Helper class to read and write `ShortIntD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ShortIntDHelper {
    /// Read a `ShortIntD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ShortIntD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ShortIntD {
        let sz = try Swift.Int(istr.readSize())
        var v = ShortIntD()
        for _ in 0 ..< sz {
            let key: Swift.Int16 = try istr.read()
            let value: Swift.Int32 = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `ShortIntD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ShortIntD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ShortIntD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Wite a `ShortIntD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ShortIntD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ShortIntD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `ShortIntD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ShortIntD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: ShortIntD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 6) {
            write(to: ostr, value: val)
        }
    }
}

public typealias LongFloatD = [Swift.Int64: Swift.Float]

/// Helper class to read and write `LongFloatD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LongFloatDHelper {
    /// Read a `LongFloatD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `LongFloatD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LongFloatD {
        let sz = try Swift.Int(istr.readSize())
        var v = LongFloatD()
        for _ in 0 ..< sz {
            let key: Swift.Int64 = try istr.read()
            let value: Swift.Float = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `LongFloatD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LongFloatD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LongFloatD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Wite a `LongFloatD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `LongFloatD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LongFloatD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `LongFloatD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LongFloatD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: LongFloatD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 12) {
            write(to: ostr, value: val)
        }
    }
}

public typealias StringStringD = [Swift.String: Swift.String]

/// Helper class to read and write `StringStringD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringStringDHelper {
    /// Read a `StringStringD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringStringD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringStringD {
        let sz = try Swift.Int(istr.readSize())
        var v = StringStringD()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: Swift.String = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `StringStringD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringStringD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringStringD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringStringD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringStringD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringStringD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `StringStringD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringStringD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: StringStringD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringMyEnumD = [Swift.String: MyEnum]

/// Helper class to read and write `StringMyEnumD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringMyEnumDHelper {
    /// Read a `StringMyEnumD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringMyEnumD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringMyEnumD {
        let sz = try Swift.Int(istr.readSize())
        var v = StringMyEnumD()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: MyEnum = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `StringMyEnumD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringMyEnumD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringMyEnumD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringMyEnumD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringMyEnumD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringMyEnumD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `StringMyEnumD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringMyEnumD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: StringMyEnumD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias MyEnumStringD = [MyEnum: Swift.String]

/// Helper class to read and write `MyEnumStringD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyEnumStringDHelper {
    /// Read a `MyEnumStringD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `MyEnumStringD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyEnumStringD {
        let sz = try Swift.Int(istr.readSize())
        var v = MyEnumStringD()
        for _ in 0 ..< sz {
            let key: MyEnum = try istr.read()
            let value: Swift.String = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `MyEnumStringD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyEnumStringD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyEnumStringD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `MyEnumStringD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `MyEnumStringD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyEnumStringD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `MyEnumStringD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `MyEnumStringD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: MyEnumStringD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias MyStructMyEnumD = [MyStruct: MyEnum]

/// Helper class to read and write `MyStructMyEnumD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyStructMyEnumDHelper {
    /// Read a `MyStructMyEnumD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `MyStructMyEnumD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyStructMyEnumD {
        let sz = try Swift.Int(istr.readSize())
        var v = MyStructMyEnumD()
        for _ in 0 ..< sz {
            let key: MyStruct = try istr.read()
            let value: MyEnum = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `MyStructMyEnumD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyStructMyEnumD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyStructMyEnumD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `MyStructMyEnumD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `MyStructMyEnumD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyStructMyEnumD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `MyStructMyEnumD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `MyStructMyEnumD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: MyStructMyEnumD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ByteBoolDS = [ByteBoolD]

/// Helper class to read and write `ByteBoolDS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ByteBoolDSHelper {
    /// Read a `ByteBoolDS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ByteBoolDS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ByteBoolDS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = ByteBoolDS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: ByteBoolD = try ByteBoolDHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `ByteBoolDS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ByteBoolDS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ByteBoolDS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ByteBoolDS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ByteBoolDS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ByteBoolDS) {
        ostr.write(size: v.count)
        for item in v {
            ByteBoolDHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `ByteBoolDS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ByteBoolDS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ByteBoolDS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ShortIntDS = [ShortIntD]

/// Helper class to read and write `ShortIntDS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ShortIntDSHelper {
    /// Read a `ShortIntDS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ShortIntDS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ShortIntDS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = ShortIntDS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: ShortIntD = try ShortIntDHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `ShortIntDS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ShortIntDS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ShortIntDS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ShortIntDS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ShortIntDS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ShortIntDS) {
        ostr.write(size: v.count)
        for item in v {
            ShortIntDHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `ShortIntDS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ShortIntDS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ShortIntDS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias LongFloatDS = [LongFloatD]

/// Helper class to read and write `LongFloatDS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LongFloatDSHelper {
    /// Read a `LongFloatDS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `LongFloatDS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LongFloatDS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = LongFloatDS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: LongFloatD = try LongFloatDHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `LongFloatDS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LongFloatDS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LongFloatDS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `LongFloatDS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `LongFloatDS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LongFloatDS) {
        ostr.write(size: v.count)
        for item in v {
            LongFloatDHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `LongFloatDS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LongFloatDS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: LongFloatDS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringStringDS = [StringStringD]

/// Helper class to read and write `StringStringDS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringStringDSHelper {
    /// Read a `StringStringDS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringStringDS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringStringDS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = StringStringDS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: StringStringD = try StringStringDHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `StringStringDS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringStringDS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringStringDS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringStringDS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringStringDS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringStringDS) {
        ostr.write(size: v.count)
        for item in v {
            StringStringDHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `StringStringDS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringStringDS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: StringStringDS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringMyEnumDS = [StringMyEnumD]

/// Helper class to read and write `StringMyEnumDS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringMyEnumDSHelper {
    /// Read a `StringMyEnumDS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringMyEnumDS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringMyEnumDS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = StringMyEnumDS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: StringMyEnumD = try StringMyEnumDHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `StringMyEnumDS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringMyEnumDS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringMyEnumDS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringMyEnumDS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringMyEnumDS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringMyEnumDS) {
        ostr.write(size: v.count)
        for item in v {
            StringMyEnumDHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `StringMyEnumDS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringMyEnumDS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: StringMyEnumDS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias MyEnumStringDS = [MyEnumStringD]

/// Helper class to read and write `MyEnumStringDS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyEnumStringDSHelper {
    /// Read a `MyEnumStringDS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `MyEnumStringDS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyEnumStringDS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = MyEnumStringDS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: MyEnumStringD = try MyEnumStringDHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `MyEnumStringDS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyEnumStringDS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyEnumStringDS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `MyEnumStringDS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `MyEnumStringDS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyEnumStringDS) {
        ostr.write(size: v.count)
        for item in v {
            MyEnumStringDHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `MyEnumStringDS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `MyEnumStringDS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: MyEnumStringDS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias MyStructMyEnumDS = [MyStructMyEnumD]

/// Helper class to read and write `MyStructMyEnumDS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyStructMyEnumDSHelper {
    /// Read a `MyStructMyEnumDS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `MyStructMyEnumDS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyStructMyEnumDS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = MyStructMyEnumDS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: MyStructMyEnumD = try MyStructMyEnumDHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `MyStructMyEnumDS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyStructMyEnumDS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyStructMyEnumDS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `MyStructMyEnumDS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `MyStructMyEnumDS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyStructMyEnumDS) {
        ostr.write(size: v.count)
        for item in v {
            MyStructMyEnumDHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `MyStructMyEnumDS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `MyStructMyEnumDS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: MyStructMyEnumDS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ByteByteSD = [Swift.UInt8: ByteS]

/// Helper class to read and write `ByteByteSD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ByteByteSDHelper {
    /// Read a `ByteByteSD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ByteByteSD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ByteByteSD {
        let sz = try Swift.Int(istr.readSize())
        var v = ByteByteSD()
        for _ in 0 ..< sz {
            let key: Swift.UInt8 = try istr.read()
            let value: ByteS = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `ByteByteSD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ByteByteSD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ByteByteSD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ByteByteSD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ByteByteSD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ByteByteSD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `ByteByteSD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ByteByteSD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: ByteByteSD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias BoolBoolSD = [Swift.Bool: BoolS]

/// Helper class to read and write `BoolBoolSD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct BoolBoolSDHelper {
    /// Read a `BoolBoolSD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `BoolBoolSD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> BoolBoolSD {
        let sz = try Swift.Int(istr.readSize())
        var v = BoolBoolSD()
        for _ in 0 ..< sz {
            let key: Swift.Bool = try istr.read()
            let value: BoolS = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `BoolBoolSD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `BoolBoolSD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> BoolBoolSD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `BoolBoolSD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `BoolBoolSD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: BoolBoolSD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `BoolBoolSD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `BoolBoolSD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: BoolBoolSD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ShortShortSD = [Swift.Int16: ShortS]

/// Helper class to read and write `ShortShortSD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ShortShortSDHelper {
    /// Read a `ShortShortSD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ShortShortSD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ShortShortSD {
        let sz = try Swift.Int(istr.readSize())
        var v = ShortShortSD()
        for _ in 0 ..< sz {
            let key: Swift.Int16 = try istr.read()
            let value: ShortS = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `ShortShortSD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ShortShortSD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ShortShortSD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ShortShortSD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ShortShortSD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ShortShortSD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `ShortShortSD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ShortShortSD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: ShortShortSD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias IntIntSD = [Swift.Int32: IntS]

/// Helper class to read and write `IntIntSD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct IntIntSDHelper {
    /// Read a `IntIntSD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `IntIntSD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> IntIntSD {
        let sz = try Swift.Int(istr.readSize())
        var v = IntIntSD()
        for _ in 0 ..< sz {
            let key: Swift.Int32 = try istr.read()
            let value: IntS = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `IntIntSD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `IntIntSD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> IntIntSD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `IntIntSD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `IntIntSD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: IntIntSD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `IntIntSD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `IntIntSD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: IntIntSD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias LongLongSD = [Swift.Int64: LongS]

/// Helper class to read and write `LongLongSD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LongLongSDHelper {
    /// Read a `LongLongSD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `LongLongSD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LongLongSD {
        let sz = try Swift.Int(istr.readSize())
        var v = LongLongSD()
        for _ in 0 ..< sz {
            let key: Swift.Int64 = try istr.read()
            let value: LongS = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `LongLongSD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LongLongSD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LongLongSD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `LongLongSD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `LongLongSD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LongLongSD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `LongLongSD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LongLongSD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: LongLongSD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringFloatSD = [Swift.String: FloatS]

/// Helper class to read and write `StringFloatSD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringFloatSDHelper {
    /// Read a `StringFloatSD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringFloatSD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringFloatSD {
        let sz = try Swift.Int(istr.readSize())
        var v = StringFloatSD()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: FloatS = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `StringFloatSD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringFloatSD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringFloatSD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringFloatSD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringFloatSD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringFloatSD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `StringFloatSD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringFloatSD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: StringFloatSD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringDoubleSD = [Swift.String: DoubleS]

/// Helper class to read and write `StringDoubleSD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringDoubleSDHelper {
    /// Read a `StringDoubleSD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringDoubleSD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringDoubleSD {
        let sz = try Swift.Int(istr.readSize())
        var v = StringDoubleSD()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: DoubleS = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `StringDoubleSD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringDoubleSD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringDoubleSD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringDoubleSD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringDoubleSD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringDoubleSD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `StringDoubleSD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringDoubleSD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: StringDoubleSD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringStringSD = [Swift.String: StringS]

/// Helper class to read and write `StringStringSD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringStringSDHelper {
    /// Read a `StringStringSD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringStringSD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringStringSD {
        let sz = try Swift.Int(istr.readSize())
        var v = StringStringSD()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: StringS = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `StringStringSD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringStringSD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringStringSD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringStringSD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringStringSD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringStringSD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `StringStringSD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringStringSD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: StringStringSD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias MyEnumMyEnumSD = [MyEnum: MyEnumS]

/// Helper class to read and write `MyEnumMyEnumSD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyEnumMyEnumSDHelper {
    /// Read a `MyEnumMyEnumSD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `MyEnumMyEnumSD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyEnumMyEnumSD {
        let sz = try Swift.Int(istr.readSize())
        var v = MyEnumMyEnumSD()
        for _ in 0 ..< sz {
            let key: MyEnum = try istr.read()
            let value: MyEnumS = try MyEnumSHelper.read(from: istr)
            v[key] = value
        }
        return v
    }
    /// Read an optional `MyEnumMyEnumSD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyEnumMyEnumSD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyEnumMyEnumSD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `MyEnumMyEnumSD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `MyEnumMyEnumSD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyEnumMyEnumSD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            MyEnumSHelper.write(to: ostr, value: value)
        }
    }

    /// Wite an optional `MyEnumMyEnumSD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `MyEnumMyEnumSD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: MyEnumMyEnumSD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// :nodoc:
public class SomeException_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return SomeException.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_SomeException() -> Ice.UserExceptionTypeResolver {
        return SomeException_TypeResolver()
    }
}

open class SomeException: Ice.UserException {
    public required init() {}

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::Test::SomeException"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: SomeException.ice_staticId(), compactId: -1, last: true)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }
}

/// Traits for Slice interface `MyClass`.
public struct MyClassTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::MyClass"]
    public static let staticId = "::Test::MyClass"
}

public struct MyStruct1 {
    public var tesT: Swift.String = ""
    public var myClass: MyClassPrx? = nil
    public var myStruct1: Swift.String = ""

    public init() {}

    public init(tesT: Swift.String, myClass: MyClassPrx?, myStruct1: Swift.String) {
        self.tesT = tesT
        self.myClass = myClass
        self.myStruct1 = myStruct1
    }
}

/// An `Ice.InputStream` extension to read `MyStruct1` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `MyStruct1` structured value from the stream.
    ///
    /// - returns: `MyStruct1` - The structured value read from the stream.
    func read() throws -> MyStruct1 {
        var v = MyStruct1()
        v.tesT = try self.read()
        v.myClass = try self.read(MyClassPrx.self)
        v.myStruct1 = try self.read()
        return v
    }

    /// Read an optional `MyStruct1?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyStruct1?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> MyStruct1? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as MyStruct1
    }
}

/// An `Ice.OutputStream` extension to write `MyStruct1` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `MyStruct1` structured value to the stream.
    ///
    /// - parameter _: `MyStruct1` - The value to write to the stream.
    func write(_ v: MyStruct1) {
        self.write(v.tesT)
        self.write(v.myClass)
        self.write(v.myStruct1)
    }

    /// Write an optional `MyStruct1?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `MyStruct1?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: MyStruct1?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

/// Traits for Slice class `MyClass1`.
public struct MyClass1Traits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::MyClass1"]
    public static let staticId = "::Test::MyClass1"
}

/// Traits for Slice interface `MyDerivedClass`.
public struct MyDerivedClassTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::MyClass", "::Test::MyDerivedClass"]
    public static let staticId = "::Test::MyDerivedClass"
}
public let s0: Swift.String = "\\"

public let s1: Swift.String = "A"

public let s2: Swift.String = "Ice"

public let s3: Swift.String = "A21"

public let s4: Swift.String = "\\u0041 \\U00000041"

public let s5: Swift.String = "\u{ff}"

public let s6: Swift.String = "\u{3ff}"

public let s7: Swift.String = "\u{5f0}"

public let s8: Swift.String = "\u{10000}"

public let s9: Swift.String = "\u{1f34c}"

public let s10: Swift.String = "\u{da7}"

public let sw0: Swift.String = "\\"

public let sw1: Swift.String = "A"

public let sw2: Swift.String = "Ice"

public let sw3: Swift.String = "A21"

public let sw4: Swift.String = "\\u0041 \\U00000041"

public let sw5: Swift.String = "\u{ff}"

public let sw6: Swift.String = "\u{3ff}"

public let sw7: Swift.String = "\u{5f0}"

public let sw8: Swift.String = "\u{10000}"

public let sw9: Swift.String = "\u{1f34c}"

public let sw10: Swift.String = "\u{da7}"

/// \'      single quote    byte 0x27 in ASCII encoding
/// \"      double quote    byte 0x22 in ASCII encoding
/// \?      question mark   byte 0x3f in ASCII encoding
/// \\      backslash       byte 0x5c in ASCII encoding
/// \a      audible bell    byte 0x07 in ASCII encoding
/// \b      backspace       byte 0x08 in ASCII encoding
/// \f      form feed - new page    byte 0x0c in ASCII encoding
/// \n      line feed - new line    byte 0x0a in ASCII encoding
/// \r      carriage return byte 0x0d in ASCII encoding
/// \t      horizontal tab  byte 0x09 in ASCII encoding
/// \v      vertical tab    byte 0x0b in ASCII encoding
public let ss0: Swift.String = "'\"?\\\u{0007}\u{0008}\u{000c}\n\r\t\u{000b}\u{0006}"

public let ss1: Swift.String = "'\"?\\\u{0007}\u{0008}\u{000c}\n\r\t\u{000b}\u{0006}"

public let ss2: Swift.String = "'\"?\\\u{0007}\u{0008}\u{000c}\n\r\t\u{000b}\u{0006}"

public let ss3: Swift.String = "\\\\U\\u\\"

public let ss4: Swift.String = "\\A\\"

public let ss5: Swift.String = "\\u0041\\"

public let su0: Swift.String = "\u{128}\u{178}\u{ff}\u{100}\u{1f00}\u{10194}\u{1016a}\u{10198}\u{1f340}\u{1f341}\u{1f342}\u{1f343}"

public let su1: Swift.String = "\u{128}\u{178}\u{ff}\u{100}\u{1f00}\u{10194}\u{1016a}\u{10198}\u{1f340}\u{1f341}\u{1f342}\u{1f343}"

public let su2: Swift.String = "\u{128}\u{178}\u{ff}\u{100}\u{1f00}\u{10194}\u{1016a}\u{10198}\u{1f340}\u{1f341}\u{1f342}\u{1f343}"


/// MyClassPrx overview.
///
/// MyClassPrx Methods:
///
///  - shutdown: 
///
///  - shutdownAsync: 
///
///  - opVoid: 
///
///  - opVoidAsync: 
///
///  - opByte: 
///
///  - opByteAsync: 
///
///  - opBool: 
///
///  - opBoolAsync: 
///
///  - opShortIntLong: 
///
///  - opShortIntLongAsync: 
///
///  - opFloatDouble: 
///
///  - opFloatDoubleAsync: 
///
///  - opString: 
///
///  - opStringAsync: 
///
///  - opMyEnum: 
///
///  - opMyEnumAsync: 
///
///  - opMyClass: 
///
///  - opMyClassAsync: 
///
///  - opStruct: 
///
///  - opStructAsync: 
///
///  - opByteS: 
///
///  - opByteSAsync: 
///
///  - opBoolS: 
///
///  - opBoolSAsync: 
///
///  - opShortIntLongS: 
///
///  - opShortIntLongSAsync: 
///
///  - opFloatDoubleS: 
///
///  - opFloatDoubleSAsync: 
///
///  - opStringS: 
///
///  - opStringSAsync: 
///
///  - opByteSS: 
///
///  - opByteSSAsync: 
///
///  - opBoolSS: 
///
///  - opBoolSSAsync: 
///
///  - opShortIntLongSS: 
///
///  - opShortIntLongSSAsync: 
///
///  - opFloatDoubleSS: 
///
///  - opFloatDoubleSSAsync: 
///
///  - opStringSS: 
///
///  - opStringSSAsync: 
///
///  - opStringSSS: 
///
///  - opStringSSSAsync: 
///
///  - opByteBoolD: 
///
///  - opByteBoolDAsync: 
///
///  - opShortIntD: 
///
///  - opShortIntDAsync: 
///
///  - opLongFloatD: 
///
///  - opLongFloatDAsync: 
///
///  - opStringStringD: 
///
///  - opStringStringDAsync: 
///
///  - opStringMyEnumD: 
///
///  - opStringMyEnumDAsync: 
///
///  - opMyEnumStringD: 
///
///  - opMyEnumStringDAsync: 
///
///  - opMyStructMyEnumD: 
///
///  - opMyStructMyEnumDAsync: 
///
///  - opByteBoolDS: 
///
///  - opByteBoolDSAsync: 
///
///  - opShortIntDS: 
///
///  - opShortIntDSAsync: 
///
///  - opLongFloatDS: 
///
///  - opLongFloatDSAsync: 
///
///  - opStringStringDS: 
///
///  - opStringStringDSAsync: 
///
///  - opStringMyEnumDS: 
///
///  - opStringMyEnumDSAsync: 
///
///  - opMyEnumStringDS: 
///
///  - opMyEnumStringDSAsync: 
///
///  - opMyStructMyEnumDS: 
///
///  - opMyStructMyEnumDSAsync: 
///
///  - opByteByteSD: 
///
///  - opByteByteSDAsync: 
///
///  - opBoolBoolSD: 
///
///  - opBoolBoolSDAsync: 
///
///  - opShortShortSD: 
///
///  - opShortShortSDAsync: 
///
///  - opIntIntSD: 
///
///  - opIntIntSDAsync: 
///
///  - opLongLongSD: 
///
///  - opLongLongSDAsync: 
///
///  - opStringFloatSD: 
///
///  - opStringFloatSDAsync: 
///
///  - opStringDoubleSD: 
///
///  - opStringDoubleSDAsync: 
///
///  - opStringStringSD: 
///
///  - opStringStringSDAsync: 
///
///  - opMyEnumMyEnumSD: 
///
///  - opMyEnumMyEnumSDAsync: 
///
///  - opIntS: 
///
///  - opIntSAsync: 
///
///  - opByteSOneway: 
///
///  - opByteSOnewayAsync: 
///
///  - opByteSOnewayCallCount: 
///
///  - opByteSOnewayCallCountAsync: 
///
///  - opContext: 
///
///  - opContextAsync: 
///
///  - opDoubleMarshaling: 
///
///  - opDoubleMarshalingAsync: 
///
///  - opIdempotent: 
///
///  - opIdempotentAsync: 
///
///  - opNonmutating: 
///
///  - opNonmutatingAsync: 
///
///  - opByte1: 
///
///  - opByte1Async: 
///
///  - opShort1: 
///
///  - opShort1Async: 
///
///  - opInt1: 
///
///  - opInt1Async: 
///
///  - opLong1: 
///
///  - opLong1Async: 
///
///  - opFloat1: 
///
///  - opFloat1Async: 
///
///  - opDouble1: 
///
///  - opDouble1Async: 
///
///  - opString1: 
///
///  - opString1Async: 
///
///  - opStringS1: 
///
///  - opStringS1Async: 
///
///  - opByteBoolD1: 
///
///  - opByteBoolD1Async: 
///
///  - opStringS2: 
///
///  - opStringS2Async: 
///
///  - opByteBoolD2: 
///
///  - opByteBoolD2Async: 
///
///  - opStringLiterals: 
///
///  - opStringLiteralsAsync: 
///
///  - opWStringLiterals: 
///
///  - opWStringLiteralsAsync: 
///
///  - opMStruct1: 
///
///  - opMStruct1Async: 
///
///  - opMStruct2: 
///
///  - opMStruct2Async: 
///
///  - opMSeq1: 
///
///  - opMSeq1Async: 
///
///  - opMSeq2: 
///
///  - opMSeq2Async: 
///
///  - opMDict1: 
///
///  - opMDict1Async: 
///
///  - opMDict2: 
///
///  - opMDict2Async: 
public protocol MyClassPrx: Ice.ObjectPrx {}

private final class MyClassPrxI: Ice.ObjectPrxI, MyClassPrx {
    public override class func ice_staticId() -> Swift.String {
        return MyClassTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `MyClassPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `MyClassPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: MyClassPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> MyClassPrx? {
    return try MyClassPrxI.checkedCast(prx: prx, facet: facet, context: context) as MyClassPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `MyClassPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `MyClassPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: MyClassPrx.Protocol, facet: Swift.String? = nil) -> MyClassPrx {
    return MyClassPrxI.uncheckedCast(prx: prx, facet: facet) as MyClassPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `MyClassPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: MyClassPrx.Protocol) -> Swift.String {
    return MyClassTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `MyClassPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `MyClassPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `MyClassPrx?` - The extracted proxy
    func read(_ type: MyClassPrx.Protocol) throws -> MyClassPrx? {
        return try read() as MyClassPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `MyClassPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `MyClassPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: MyClassPrx.Protocol) throws -> MyClassPrx? {
        return try read(tag: tag) as MyClassPrxI?
    }
}

/// MyClassPrx overview.
///
/// MyClassPrx Methods:
///
///  - shutdown: 
///
///  - shutdownAsync: 
///
///  - opVoid: 
///
///  - opVoidAsync: 
///
///  - opByte: 
///
///  - opByteAsync: 
///
///  - opBool: 
///
///  - opBoolAsync: 
///
///  - opShortIntLong: 
///
///  - opShortIntLongAsync: 
///
///  - opFloatDouble: 
///
///  - opFloatDoubleAsync: 
///
///  - opString: 
///
///  - opStringAsync: 
///
///  - opMyEnum: 
///
///  - opMyEnumAsync: 
///
///  - opMyClass: 
///
///  - opMyClassAsync: 
///
///  - opStruct: 
///
///  - opStructAsync: 
///
///  - opByteS: 
///
///  - opByteSAsync: 
///
///  - opBoolS: 
///
///  - opBoolSAsync: 
///
///  - opShortIntLongS: 
///
///  - opShortIntLongSAsync: 
///
///  - opFloatDoubleS: 
///
///  - opFloatDoubleSAsync: 
///
///  - opStringS: 
///
///  - opStringSAsync: 
///
///  - opByteSS: 
///
///  - opByteSSAsync: 
///
///  - opBoolSS: 
///
///  - opBoolSSAsync: 
///
///  - opShortIntLongSS: 
///
///  - opShortIntLongSSAsync: 
///
///  - opFloatDoubleSS: 
///
///  - opFloatDoubleSSAsync: 
///
///  - opStringSS: 
///
///  - opStringSSAsync: 
///
///  - opStringSSS: 
///
///  - opStringSSSAsync: 
///
///  - opByteBoolD: 
///
///  - opByteBoolDAsync: 
///
///  - opShortIntD: 
///
///  - opShortIntDAsync: 
///
///  - opLongFloatD: 
///
///  - opLongFloatDAsync: 
///
///  - opStringStringD: 
///
///  - opStringStringDAsync: 
///
///  - opStringMyEnumD: 
///
///  - opStringMyEnumDAsync: 
///
///  - opMyEnumStringD: 
///
///  - opMyEnumStringDAsync: 
///
///  - opMyStructMyEnumD: 
///
///  - opMyStructMyEnumDAsync: 
///
///  - opByteBoolDS: 
///
///  - opByteBoolDSAsync: 
///
///  - opShortIntDS: 
///
///  - opShortIntDSAsync: 
///
///  - opLongFloatDS: 
///
///  - opLongFloatDSAsync: 
///
///  - opStringStringDS: 
///
///  - opStringStringDSAsync: 
///
///  - opStringMyEnumDS: 
///
///  - opStringMyEnumDSAsync: 
///
///  - opMyEnumStringDS: 
///
///  - opMyEnumStringDSAsync: 
///
///  - opMyStructMyEnumDS: 
///
///  - opMyStructMyEnumDSAsync: 
///
///  - opByteByteSD: 
///
///  - opByteByteSDAsync: 
///
///  - opBoolBoolSD: 
///
///  - opBoolBoolSDAsync: 
///
///  - opShortShortSD: 
///
///  - opShortShortSDAsync: 
///
///  - opIntIntSD: 
///
///  - opIntIntSDAsync: 
///
///  - opLongLongSD: 
///
///  - opLongLongSDAsync: 
///
///  - opStringFloatSD: 
///
///  - opStringFloatSDAsync: 
///
///  - opStringDoubleSD: 
///
///  - opStringDoubleSDAsync: 
///
///  - opStringStringSD: 
///
///  - opStringStringSDAsync: 
///
///  - opMyEnumMyEnumSD: 
///
///  - opMyEnumMyEnumSDAsync: 
///
///  - opIntS: 
///
///  - opIntSAsync: 
///
///  - opByteSOneway: 
///
///  - opByteSOnewayAsync: 
///
///  - opByteSOnewayCallCount: 
///
///  - opByteSOnewayCallCountAsync: 
///
///  - opContext: 
///
///  - opContextAsync: 
///
///  - opDoubleMarshaling: 
///
///  - opDoubleMarshalingAsync: 
///
///  - opIdempotent: 
///
///  - opIdempotentAsync: 
///
///  - opNonmutating: 
///
///  - opNonmutatingAsync: 
///
///  - opByte1: 
///
///  - opByte1Async: 
///
///  - opShort1: 
///
///  - opShort1Async: 
///
///  - opInt1: 
///
///  - opInt1Async: 
///
///  - opLong1: 
///
///  - opLong1Async: 
///
///  - opFloat1: 
///
///  - opFloat1Async: 
///
///  - opDouble1: 
///
///  - opDouble1Async: 
///
///  - opString1: 
///
///  - opString1Async: 
///
///  - opStringS1: 
///
///  - opStringS1Async: 
///
///  - opByteBoolD1: 
///
///  - opByteBoolD1Async: 
///
///  - opStringS2: 
///
///  - opStringS2Async: 
///
///  - opByteBoolD2: 
///
///  - opByteBoolD2Async: 
///
///  - opStringLiterals: 
///
///  - opStringLiteralsAsync: 
///
///  - opWStringLiterals: 
///
///  - opWStringLiteralsAsync: 
///
///  - opMStruct1: 
///
///  - opMStruct1Async: 
///
///  - opMStruct2: 
///
///  - opMStruct2Async: 
///
///  - opMSeq1: 
///
///  - opMSeq1Async: 
///
///  - opMSeq2: 
///
///  - opMSeq2Async: 
///
///  - opMDict1: 
///
///  - opMDict1Async: 
///
///  - opMDict2: 
///
///  - opMDict2Async: 
public extension MyClassPrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func shutdown(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "shutdown",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func shutdownAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "shutdown",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func opVoid(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "opVoid",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func opVoidAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "opVoid",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `Swift.UInt8`
    ///
    /// - parameter p2: `Swift.UInt8`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: Swift.UInt8, p3: Swift.UInt8)`:
    ///
    ///   - returnValue: `Swift.UInt8`
    ///
    ///   - p3: `Swift.UInt8`
    func opByte(p1 iceP_p1: Swift.UInt8, p2 iceP_p2: Swift.UInt8, context: Ice.Context? = nil) throws -> (returnValue: Swift.UInt8, p3: Swift.UInt8) {
        return try _impl._invoke(operation: "opByte",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_p1)
                                     ostr.write(iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: Swift.UInt8 = try istr.read()
                                     let iceP_returnValue: Swift.UInt8 = try istr.read()
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `Swift.UInt8`
    ///
    /// - parameter p2: `Swift.UInt8`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: Swift.UInt8, p3: Swift.UInt8)>` - The result of the operation
    func opByteAsync(p1 iceP_p1: Swift.UInt8, p2 iceP_p2: Swift.UInt8, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: Swift.UInt8, p3: Swift.UInt8)> {
        return _impl._invokeAsync(operation: "opByte",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_p1)
                                      ostr.write(iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: Swift.UInt8 = try istr.read()
                                      let iceP_returnValue: Swift.UInt8 = try istr.read()
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `Swift.Bool`
    ///
    /// - parameter p2: `Swift.Bool`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: Swift.Bool, p3: Swift.Bool)`:
    ///
    ///   - returnValue: `Swift.Bool`
    ///
    ///   - p3: `Swift.Bool`
    func opBool(p1 iceP_p1: Swift.Bool, p2 iceP_p2: Swift.Bool, context: Ice.Context? = nil) throws -> (returnValue: Swift.Bool, p3: Swift.Bool) {
        return try _impl._invoke(operation: "opBool",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_p1)
                                     ostr.write(iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: Swift.Bool = try istr.read()
                                     let iceP_returnValue: Swift.Bool = try istr.read()
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `Swift.Bool`
    ///
    /// - parameter p2: `Swift.Bool`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: Swift.Bool, p3: Swift.Bool)>` - The result of the operation
    func opBoolAsync(p1 iceP_p1: Swift.Bool, p2 iceP_p2: Swift.Bool, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: Swift.Bool, p3: Swift.Bool)> {
        return _impl._invokeAsync(operation: "opBool",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_p1)
                                      ostr.write(iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: Swift.Bool = try istr.read()
                                      let iceP_returnValue: Swift.Bool = try istr.read()
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `Swift.Int16`
    ///
    /// - parameter p2: `Swift.Int32`
    ///
    /// - parameter p3: `Swift.Int64`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: Swift.Int64, p4: Swift.Int16, p5: Swift.Int32, p6: Swift.Int64)`:
    ///
    ///   - returnValue: `Swift.Int64`
    ///
    ///   - p4: `Swift.Int16`
    ///
    ///   - p5: `Swift.Int32`
    ///
    ///   - p6: `Swift.Int64`
    func opShortIntLong(p1 iceP_p1: Swift.Int16, p2 iceP_p2: Swift.Int32, p3 iceP_p3: Swift.Int64, context: Ice.Context? = nil) throws -> (returnValue: Swift.Int64, p4: Swift.Int16, p5: Swift.Int32, p6: Swift.Int64) {
        return try _impl._invoke(operation: "opShortIntLong",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_p1)
                                     ostr.write(iceP_p2)
                                     ostr.write(iceP_p3)
                                 },
                                 read: { istr in
                                     let iceP_p4: Swift.Int16 = try istr.read()
                                     let iceP_p5: Swift.Int32 = try istr.read()
                                     let iceP_p6: Swift.Int64 = try istr.read()
                                     let iceP_returnValue: Swift.Int64 = try istr.read()
                                     return (iceP_returnValue, iceP_p4, iceP_p5, iceP_p6)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `Swift.Int16`
    ///
    /// - parameter p2: `Swift.Int32`
    ///
    /// - parameter p3: `Swift.Int64`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: Swift.Int64, p4: Swift.Int16, p5: Swift.Int32, p6: Swift.Int64)>` - The result of the operation
    func opShortIntLongAsync(p1 iceP_p1: Swift.Int16, p2 iceP_p2: Swift.Int32, p3 iceP_p3: Swift.Int64, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: Swift.Int64, p4: Swift.Int16, p5: Swift.Int32, p6: Swift.Int64)> {
        return _impl._invokeAsync(operation: "opShortIntLong",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_p1)
                                      ostr.write(iceP_p2)
                                      ostr.write(iceP_p3)
                                  },
                                  read: { istr in
                                      let iceP_p4: Swift.Int16 = try istr.read()
                                      let iceP_p5: Swift.Int32 = try istr.read()
                                      let iceP_p6: Swift.Int64 = try istr.read()
                                      let iceP_returnValue: Swift.Int64 = try istr.read()
                                      return (iceP_returnValue, iceP_p4, iceP_p5, iceP_p6)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `Swift.Float`
    ///
    /// - parameter p2: `Swift.Double`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: Swift.Double, p3: Swift.Float, p4: Swift.Double)`:
    ///
    ///   - returnValue: `Swift.Double`
    ///
    ///   - p3: `Swift.Float`
    ///
    ///   - p4: `Swift.Double`
    func opFloatDouble(p1 iceP_p1: Swift.Float, p2 iceP_p2: Swift.Double, context: Ice.Context? = nil) throws -> (returnValue: Swift.Double, p3: Swift.Float, p4: Swift.Double) {
        return try _impl._invoke(operation: "opFloatDouble",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_p1)
                                     ostr.write(iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: Swift.Float = try istr.read()
                                     let iceP_p4: Swift.Double = try istr.read()
                                     let iceP_returnValue: Swift.Double = try istr.read()
                                     return (iceP_returnValue, iceP_p3, iceP_p4)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `Swift.Float`
    ///
    /// - parameter p2: `Swift.Double`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: Swift.Double, p3: Swift.Float, p4: Swift.Double)>` - The result of the operation
    func opFloatDoubleAsync(p1 iceP_p1: Swift.Float, p2 iceP_p2: Swift.Double, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: Swift.Double, p3: Swift.Float, p4: Swift.Double)> {
        return _impl._invokeAsync(operation: "opFloatDouble",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_p1)
                                      ostr.write(iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: Swift.Float = try istr.read()
                                      let iceP_p4: Swift.Double = try istr.read()
                                      let iceP_returnValue: Swift.Double = try istr.read()
                                      return (iceP_returnValue, iceP_p3, iceP_p4)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `Swift.String`
    ///
    /// - parameter p2: `Swift.String`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: Swift.String, p3: Swift.String)`:
    ///
    ///   - returnValue: `Swift.String`
    ///
    ///   - p3: `Swift.String`
    func opString(p1 iceP_p1: Swift.String, p2 iceP_p2: Swift.String, context: Ice.Context? = nil) throws -> (returnValue: Swift.String, p3: Swift.String) {
        return try _impl._invoke(operation: "opString",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_p1)
                                     ostr.write(iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: Swift.String = try istr.read()
                                     let iceP_returnValue: Swift.String = try istr.read()
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `Swift.String`
    ///
    /// - parameter p2: `Swift.String`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: Swift.String, p3: Swift.String)>` - The result of the operation
    func opStringAsync(p1 iceP_p1: Swift.String, p2 iceP_p2: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: Swift.String, p3: Swift.String)> {
        return _impl._invokeAsync(operation: "opString",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_p1)
                                      ostr.write(iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: Swift.String = try istr.read()
                                      let iceP_returnValue: Swift.String = try istr.read()
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `MyEnum`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: MyEnum, p2: MyEnum)`:
    ///
    ///   - returnValue: `MyEnum`
    ///
    ///   - p2: `MyEnum`
    func opMyEnum(_ iceP_p1: MyEnum, context: Ice.Context? = nil) throws -> (returnValue: MyEnum, p2: MyEnum) {
        return try _impl._invoke(operation: "opMyEnum",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_p1)
                                 },
                                 read: { istr in
                                     let iceP_p2: MyEnum = try istr.read()
                                     let iceP_returnValue: MyEnum = try istr.read()
                                     return (iceP_returnValue, iceP_p2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `MyEnum`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: MyEnum, p2: MyEnum)>` - The result of the operation
    func opMyEnumAsync(_ iceP_p1: MyEnum, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: MyEnum, p2: MyEnum)> {
        return _impl._invokeAsync(operation: "opMyEnum",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_p1)
                                  },
                                  read: { istr in
                                      let iceP_p2: MyEnum = try istr.read()
                                      let iceP_returnValue: MyEnum = try istr.read()
                                      return (iceP_returnValue, iceP_p2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `MyClassPrx?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: MyClassPrx?, p2: MyClassPrx?, p3: MyClassPrx?)`:
    ///
    ///   - returnValue: `MyClassPrx?`
    ///
    ///   - p2: `MyClassPrx?`
    ///
    ///   - p3: `MyClassPrx?`
    func opMyClass(_ iceP_p1: MyClassPrx?, context: Ice.Context? = nil) throws -> (returnValue: MyClassPrx?, p2: MyClassPrx?, p3: MyClassPrx?) {
        return try _impl._invoke(operation: "opMyClass",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_p1)
                                 },
                                 read: { istr in
                                     let iceP_p2: MyClassPrx? = try istr.read(MyClassPrx.self)
                                     let iceP_p3: MyClassPrx? = try istr.read(MyClassPrx.self)
                                     let iceP_returnValue: MyClassPrx? = try istr.read(MyClassPrx.self)
                                     return (iceP_returnValue, iceP_p2, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `MyClassPrx?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: MyClassPrx?, p2: MyClassPrx?, p3: MyClassPrx?)>` - The result of the operation
    func opMyClassAsync(_ iceP_p1: MyClassPrx?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: MyClassPrx?, p2: MyClassPrx?, p3: MyClassPrx?)> {
        return _impl._invokeAsync(operation: "opMyClass",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_p1)
                                  },
                                  read: { istr in
                                      let iceP_p2: MyClassPrx? = try istr.read(MyClassPrx.self)
                                      let iceP_p3: MyClassPrx? = try istr.read(MyClassPrx.self)
                                      let iceP_returnValue: MyClassPrx? = try istr.read(MyClassPrx.self)
                                      return (iceP_returnValue, iceP_p2, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `Structure`
    ///
    /// - parameter p2: `Structure`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: Structure, p3: Structure)`:
    ///
    ///   - returnValue: `Structure`
    ///
    ///   - p3: `Structure`
    func opStruct(p1 iceP_p1: Structure, p2 iceP_p2: Structure, context: Ice.Context? = nil) throws -> (returnValue: Structure, p3: Structure) {
        return try _impl._invoke(operation: "opStruct",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_p1)
                                     ostr.write(iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: Structure = try istr.read()
                                     let iceP_returnValue: Structure = try istr.read()
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `Structure`
    ///
    /// - parameter p2: `Structure`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: Structure, p3: Structure)>` - The result of the operation
    func opStructAsync(p1 iceP_p1: Structure, p2 iceP_p2: Structure, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: Structure, p3: Structure)> {
        return _impl._invokeAsync(operation: "opStruct",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_p1)
                                      ostr.write(iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: Structure = try istr.read()
                                      let iceP_returnValue: Structure = try istr.read()
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `ByteS`
    ///
    /// - parameter p2: `ByteS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: ByteS, p3: ByteS)`:
    ///
    ///   - returnValue: `ByteS`
    ///
    ///   - p3: `ByteS`
    func opByteS(p1 iceP_p1: ByteS, p2 iceP_p2: ByteS, context: Ice.Context? = nil) throws -> (returnValue: ByteS, p3: ByteS) {
        return try _impl._invoke(operation: "opByteS",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_p1)
                                     ostr.write(iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: ByteS = try istr.read()
                                     let iceP_returnValue: ByteS = try istr.read()
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `ByteS`
    ///
    /// - parameter p2: `ByteS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: ByteS, p3: ByteS)>` - The result of the operation
    func opByteSAsync(p1 iceP_p1: ByteS, p2 iceP_p2: ByteS, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: ByteS, p3: ByteS)> {
        return _impl._invokeAsync(operation: "opByteS",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_p1)
                                      ostr.write(iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: ByteS = try istr.read()
                                      let iceP_returnValue: ByteS = try istr.read()
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `BoolS`
    ///
    /// - parameter p2: `BoolS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: BoolS, p3: BoolS)`:
    ///
    ///   - returnValue: `BoolS`
    ///
    ///   - p3: `BoolS`
    func opBoolS(p1 iceP_p1: BoolS, p2 iceP_p2: BoolS, context: Ice.Context? = nil) throws -> (returnValue: BoolS, p3: BoolS) {
        return try _impl._invoke(operation: "opBoolS",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_p1)
                                     ostr.write(iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: BoolS = try istr.read()
                                     let iceP_returnValue: BoolS = try istr.read()
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `BoolS`
    ///
    /// - parameter p2: `BoolS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: BoolS, p3: BoolS)>` - The result of the operation
    func opBoolSAsync(p1 iceP_p1: BoolS, p2 iceP_p2: BoolS, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: BoolS, p3: BoolS)> {
        return _impl._invokeAsync(operation: "opBoolS",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_p1)
                                      ostr.write(iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: BoolS = try istr.read()
                                      let iceP_returnValue: BoolS = try istr.read()
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `ShortS`
    ///
    /// - parameter p2: `IntS`
    ///
    /// - parameter p3: `LongS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: LongS, p4: ShortS, p5: IntS, p6: LongS)`:
    ///
    ///   - returnValue: `LongS`
    ///
    ///   - p4: `ShortS`
    ///
    ///   - p5: `IntS`
    ///
    ///   - p6: `LongS`
    func opShortIntLongS(p1 iceP_p1: ShortS, p2 iceP_p2: IntS, p3 iceP_p3: LongS, context: Ice.Context? = nil) throws -> (returnValue: LongS, p4: ShortS, p5: IntS, p6: LongS) {
        return try _impl._invoke(operation: "opShortIntLongS",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_p1)
                                     ostr.write(iceP_p2)
                                     ostr.write(iceP_p3)
                                 },
                                 read: { istr in
                                     let iceP_p4: ShortS = try istr.read()
                                     let iceP_p5: IntS = try istr.read()
                                     let iceP_p6: LongS = try istr.read()
                                     let iceP_returnValue: LongS = try istr.read()
                                     return (iceP_returnValue, iceP_p4, iceP_p5, iceP_p6)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `ShortS`
    ///
    /// - parameter p2: `IntS`
    ///
    /// - parameter p3: `LongS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: LongS, p4: ShortS, p5: IntS, p6: LongS)>` - The result of the operation
    func opShortIntLongSAsync(p1 iceP_p1: ShortS, p2 iceP_p2: IntS, p3 iceP_p3: LongS, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: LongS, p4: ShortS, p5: IntS, p6: LongS)> {
        return _impl._invokeAsync(operation: "opShortIntLongS",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_p1)
                                      ostr.write(iceP_p2)
                                      ostr.write(iceP_p3)
                                  },
                                  read: { istr in
                                      let iceP_p4: ShortS = try istr.read()
                                      let iceP_p5: IntS = try istr.read()
                                      let iceP_p6: LongS = try istr.read()
                                      let iceP_returnValue: LongS = try istr.read()
                                      return (iceP_returnValue, iceP_p4, iceP_p5, iceP_p6)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `FloatS`
    ///
    /// - parameter p2: `DoubleS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: DoubleS, p3: FloatS, p4: DoubleS)`:
    ///
    ///   - returnValue: `DoubleS`
    ///
    ///   - p3: `FloatS`
    ///
    ///   - p4: `DoubleS`
    func opFloatDoubleS(p1 iceP_p1: FloatS, p2 iceP_p2: DoubleS, context: Ice.Context? = nil) throws -> (returnValue: DoubleS, p3: FloatS, p4: DoubleS) {
        return try _impl._invoke(operation: "opFloatDoubleS",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_p1)
                                     ostr.write(iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: FloatS = try istr.read()
                                     let iceP_p4: DoubleS = try istr.read()
                                     let iceP_returnValue: DoubleS = try istr.read()
                                     return (iceP_returnValue, iceP_p3, iceP_p4)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `FloatS`
    ///
    /// - parameter p2: `DoubleS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: DoubleS, p3: FloatS, p4: DoubleS)>` - The result of the operation
    func opFloatDoubleSAsync(p1 iceP_p1: FloatS, p2 iceP_p2: DoubleS, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: DoubleS, p3: FloatS, p4: DoubleS)> {
        return _impl._invokeAsync(operation: "opFloatDoubleS",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_p1)
                                      ostr.write(iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: FloatS = try istr.read()
                                      let iceP_p4: DoubleS = try istr.read()
                                      let iceP_returnValue: DoubleS = try istr.read()
                                      return (iceP_returnValue, iceP_p3, iceP_p4)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `StringS`
    ///
    /// - parameter p2: `StringS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: StringS, p3: StringS)`:
    ///
    ///   - returnValue: `StringS`
    ///
    ///   - p3: `StringS`
    func opStringS(p1 iceP_p1: StringS, p2 iceP_p2: StringS, context: Ice.Context? = nil) throws -> (returnValue: StringS, p3: StringS) {
        return try _impl._invoke(operation: "opStringS",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_p1)
                                     ostr.write(iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: StringS = try istr.read()
                                     let iceP_returnValue: StringS = try istr.read()
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `StringS`
    ///
    /// - parameter p2: `StringS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: StringS, p3: StringS)>` - The result of the operation
    func opStringSAsync(p1 iceP_p1: StringS, p2 iceP_p2: StringS, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: StringS, p3: StringS)> {
        return _impl._invokeAsync(operation: "opStringS",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_p1)
                                      ostr.write(iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: StringS = try istr.read()
                                      let iceP_returnValue: StringS = try istr.read()
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `ByteSS`
    ///
    /// - parameter p2: `ByteSS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: ByteSS, p3: ByteSS)`:
    ///
    ///   - returnValue: `ByteSS`
    ///
    ///   - p3: `ByteSS`
    func opByteSS(p1 iceP_p1: ByteSS, p2 iceP_p2: ByteSS, context: Ice.Context? = nil) throws -> (returnValue: ByteSS, p3: ByteSS) {
        return try _impl._invoke(operation: "opByteSS",
                                 mode: .Normal,
                                 write: { ostr in
                                     ByteSSHelper.write(to: ostr, value: iceP_p1)
                                     ByteSSHelper.write(to: ostr, value: iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: ByteSS = try ByteSSHelper.read(from: istr)
                                     let iceP_returnValue: ByteSS = try ByteSSHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `ByteSS`
    ///
    /// - parameter p2: `ByteSS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: ByteSS, p3: ByteSS)>` - The result of the operation
    func opByteSSAsync(p1 iceP_p1: ByteSS, p2 iceP_p2: ByteSS, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: ByteSS, p3: ByteSS)> {
        return _impl._invokeAsync(operation: "opByteSS",
                                  mode: .Normal,
                                  write: { ostr in
                                      ByteSSHelper.write(to: ostr, value: iceP_p1)
                                      ByteSSHelper.write(to: ostr, value: iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: ByteSS = try ByteSSHelper.read(from: istr)
                                      let iceP_returnValue: ByteSS = try ByteSSHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `BoolSS`
    ///
    /// - parameter p2: `BoolSS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: BoolSS, p3: BoolSS)`:
    ///
    ///   - returnValue: `BoolSS`
    ///
    ///   - p3: `BoolSS`
    func opBoolSS(p1 iceP_p1: BoolSS, p2 iceP_p2: BoolSS, context: Ice.Context? = nil) throws -> (returnValue: BoolSS, p3: BoolSS) {
        return try _impl._invoke(operation: "opBoolSS",
                                 mode: .Normal,
                                 write: { ostr in
                                     BoolSSHelper.write(to: ostr, value: iceP_p1)
                                     BoolSSHelper.write(to: ostr, value: iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: BoolSS = try BoolSSHelper.read(from: istr)
                                     let iceP_returnValue: BoolSS = try BoolSSHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `BoolSS`
    ///
    /// - parameter p2: `BoolSS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: BoolSS, p3: BoolSS)>` - The result of the operation
    func opBoolSSAsync(p1 iceP_p1: BoolSS, p2 iceP_p2: BoolSS, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: BoolSS, p3: BoolSS)> {
        return _impl._invokeAsync(operation: "opBoolSS",
                                  mode: .Normal,
                                  write: { ostr in
                                      BoolSSHelper.write(to: ostr, value: iceP_p1)
                                      BoolSSHelper.write(to: ostr, value: iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: BoolSS = try BoolSSHelper.read(from: istr)
                                      let iceP_returnValue: BoolSS = try BoolSSHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `ShortSS`
    ///
    /// - parameter p2: `IntSS`
    ///
    /// - parameter p3: `LongSS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: LongSS, p4: ShortSS, p5: IntSS, p6: LongSS)`:
    ///
    ///   - returnValue: `LongSS`
    ///
    ///   - p4: `ShortSS`
    ///
    ///   - p5: `IntSS`
    ///
    ///   - p6: `LongSS`
    func opShortIntLongSS(p1 iceP_p1: ShortSS, p2 iceP_p2: IntSS, p3 iceP_p3: LongSS, context: Ice.Context? = nil) throws -> (returnValue: LongSS, p4: ShortSS, p5: IntSS, p6: LongSS) {
        return try _impl._invoke(operation: "opShortIntLongSS",
                                 mode: .Normal,
                                 write: { ostr in
                                     ShortSSHelper.write(to: ostr, value: iceP_p1)
                                     IntSSHelper.write(to: ostr, value: iceP_p2)
                                     LongSSHelper.write(to: ostr, value: iceP_p3)
                                 },
                                 read: { istr in
                                     let iceP_p4: ShortSS = try ShortSSHelper.read(from: istr)
                                     let iceP_p5: IntSS = try IntSSHelper.read(from: istr)
                                     let iceP_p6: LongSS = try LongSSHelper.read(from: istr)
                                     let iceP_returnValue: LongSS = try LongSSHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p4, iceP_p5, iceP_p6)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `ShortSS`
    ///
    /// - parameter p2: `IntSS`
    ///
    /// - parameter p3: `LongSS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: LongSS, p4: ShortSS, p5: IntSS, p6: LongSS)>` - The result of the operation
    func opShortIntLongSSAsync(p1 iceP_p1: ShortSS, p2 iceP_p2: IntSS, p3 iceP_p3: LongSS, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: LongSS, p4: ShortSS, p5: IntSS, p6: LongSS)> {
        return _impl._invokeAsync(operation: "opShortIntLongSS",
                                  mode: .Normal,
                                  write: { ostr in
                                      ShortSSHelper.write(to: ostr, value: iceP_p1)
                                      IntSSHelper.write(to: ostr, value: iceP_p2)
                                      LongSSHelper.write(to: ostr, value: iceP_p3)
                                  },
                                  read: { istr in
                                      let iceP_p4: ShortSS = try ShortSSHelper.read(from: istr)
                                      let iceP_p5: IntSS = try IntSSHelper.read(from: istr)
                                      let iceP_p6: LongSS = try LongSSHelper.read(from: istr)
                                      let iceP_returnValue: LongSS = try LongSSHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p4, iceP_p5, iceP_p6)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `FloatSS`
    ///
    /// - parameter p2: `DoubleSS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: DoubleSS, p3: FloatSS, p4: DoubleSS)`:
    ///
    ///   - returnValue: `DoubleSS`
    ///
    ///   - p3: `FloatSS`
    ///
    ///   - p4: `DoubleSS`
    func opFloatDoubleSS(p1 iceP_p1: FloatSS, p2 iceP_p2: DoubleSS, context: Ice.Context? = nil) throws -> (returnValue: DoubleSS, p3: FloatSS, p4: DoubleSS) {
        return try _impl._invoke(operation: "opFloatDoubleSS",
                                 mode: .Normal,
                                 write: { ostr in
                                     FloatSSHelper.write(to: ostr, value: iceP_p1)
                                     DoubleSSHelper.write(to: ostr, value: iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: FloatSS = try FloatSSHelper.read(from: istr)
                                     let iceP_p4: DoubleSS = try DoubleSSHelper.read(from: istr)
                                     let iceP_returnValue: DoubleSS = try DoubleSSHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p3, iceP_p4)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `FloatSS`
    ///
    /// - parameter p2: `DoubleSS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: DoubleSS, p3: FloatSS, p4: DoubleSS)>` - The result of the operation
    func opFloatDoubleSSAsync(p1 iceP_p1: FloatSS, p2 iceP_p2: DoubleSS, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: DoubleSS, p3: FloatSS, p4: DoubleSS)> {
        return _impl._invokeAsync(operation: "opFloatDoubleSS",
                                  mode: .Normal,
                                  write: { ostr in
                                      FloatSSHelper.write(to: ostr, value: iceP_p1)
                                      DoubleSSHelper.write(to: ostr, value: iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: FloatSS = try FloatSSHelper.read(from: istr)
                                      let iceP_p4: DoubleSS = try DoubleSSHelper.read(from: istr)
                                      let iceP_returnValue: DoubleSS = try DoubleSSHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p3, iceP_p4)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `StringSS`
    ///
    /// - parameter p2: `StringSS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: StringSS, p3: StringSS)`:
    ///
    ///   - returnValue: `StringSS`
    ///
    ///   - p3: `StringSS`
    func opStringSS(p1 iceP_p1: StringSS, p2 iceP_p2: StringSS, context: Ice.Context? = nil) throws -> (returnValue: StringSS, p3: StringSS) {
        return try _impl._invoke(operation: "opStringSS",
                                 mode: .Normal,
                                 write: { ostr in
                                     StringSSHelper.write(to: ostr, value: iceP_p1)
                                     StringSSHelper.write(to: ostr, value: iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: StringSS = try StringSSHelper.read(from: istr)
                                     let iceP_returnValue: StringSS = try StringSSHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `StringSS`
    ///
    /// - parameter p2: `StringSS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: StringSS, p3: StringSS)>` - The result of the operation
    func opStringSSAsync(p1 iceP_p1: StringSS, p2 iceP_p2: StringSS, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: StringSS, p3: StringSS)> {
        return _impl._invokeAsync(operation: "opStringSS",
                                  mode: .Normal,
                                  write: { ostr in
                                      StringSSHelper.write(to: ostr, value: iceP_p1)
                                      StringSSHelper.write(to: ostr, value: iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: StringSS = try StringSSHelper.read(from: istr)
                                      let iceP_returnValue: StringSS = try StringSSHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `StringSSS`
    ///
    /// - parameter p2: `StringSSS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: StringSSS, p3: StringSSS)`:
    ///
    ///   - returnValue: `StringSSS`
    ///
    ///   - p3: `StringSSS`
    func opStringSSS(p1 iceP_p1: StringSSS, p2 iceP_p2: StringSSS, context: Ice.Context? = nil) throws -> (returnValue: StringSSS, p3: StringSSS) {
        return try _impl._invoke(operation: "opStringSSS",
                                 mode: .Normal,
                                 write: { ostr in
                                     StringSSSHelper.write(to: ostr, value: iceP_p1)
                                     StringSSSHelper.write(to: ostr, value: iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: StringSSS = try StringSSSHelper.read(from: istr)
                                     let iceP_returnValue: StringSSS = try StringSSSHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `StringSSS`
    ///
    /// - parameter p2: `StringSSS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: StringSSS, p3: StringSSS)>` - The result of the operation
    func opStringSSSAsync(p1 iceP_p1: StringSSS, p2 iceP_p2: StringSSS, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: StringSSS, p3: StringSSS)> {
        return _impl._invokeAsync(operation: "opStringSSS",
                                  mode: .Normal,
                                  write: { ostr in
                                      StringSSSHelper.write(to: ostr, value: iceP_p1)
                                      StringSSSHelper.write(to: ostr, value: iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: StringSSS = try StringSSSHelper.read(from: istr)
                                      let iceP_returnValue: StringSSS = try StringSSSHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `ByteBoolD`
    ///
    /// - parameter p2: `ByteBoolD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: ByteBoolD, p3: ByteBoolD)`:
    ///
    ///   - returnValue: `ByteBoolD`
    ///
    ///   - p3: `ByteBoolD`
    func opByteBoolD(p1 iceP_p1: ByteBoolD, p2 iceP_p2: ByteBoolD, context: Ice.Context? = nil) throws -> (returnValue: ByteBoolD, p3: ByteBoolD) {
        return try _impl._invoke(operation: "opByteBoolD",
                                 mode: .Normal,
                                 write: { ostr in
                                     ByteBoolDHelper.write(to: ostr, value: iceP_p1)
                                     ByteBoolDHelper.write(to: ostr, value: iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: ByteBoolD = try ByteBoolDHelper.read(from: istr)
                                     let iceP_returnValue: ByteBoolD = try ByteBoolDHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `ByteBoolD`
    ///
    /// - parameter p2: `ByteBoolD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: ByteBoolD, p3: ByteBoolD)>` - The result of the operation
    func opByteBoolDAsync(p1 iceP_p1: ByteBoolD, p2 iceP_p2: ByteBoolD, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: ByteBoolD, p3: ByteBoolD)> {
        return _impl._invokeAsync(operation: "opByteBoolD",
                                  mode: .Normal,
                                  write: { ostr in
                                      ByteBoolDHelper.write(to: ostr, value: iceP_p1)
                                      ByteBoolDHelper.write(to: ostr, value: iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: ByteBoolD = try ByteBoolDHelper.read(from: istr)
                                      let iceP_returnValue: ByteBoolD = try ByteBoolDHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `ShortIntD`
    ///
    /// - parameter p2: `ShortIntD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: ShortIntD, p3: ShortIntD)`:
    ///
    ///   - returnValue: `ShortIntD`
    ///
    ///   - p3: `ShortIntD`
    func opShortIntD(p1 iceP_p1: ShortIntD, p2 iceP_p2: ShortIntD, context: Ice.Context? = nil) throws -> (returnValue: ShortIntD, p3: ShortIntD) {
        return try _impl._invoke(operation: "opShortIntD",
                                 mode: .Normal,
                                 write: { ostr in
                                     ShortIntDHelper.write(to: ostr, value: iceP_p1)
                                     ShortIntDHelper.write(to: ostr, value: iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: ShortIntD = try ShortIntDHelper.read(from: istr)
                                     let iceP_returnValue: ShortIntD = try ShortIntDHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `ShortIntD`
    ///
    /// - parameter p2: `ShortIntD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: ShortIntD, p3: ShortIntD)>` - The result of the operation
    func opShortIntDAsync(p1 iceP_p1: ShortIntD, p2 iceP_p2: ShortIntD, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: ShortIntD, p3: ShortIntD)> {
        return _impl._invokeAsync(operation: "opShortIntD",
                                  mode: .Normal,
                                  write: { ostr in
                                      ShortIntDHelper.write(to: ostr, value: iceP_p1)
                                      ShortIntDHelper.write(to: ostr, value: iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: ShortIntD = try ShortIntDHelper.read(from: istr)
                                      let iceP_returnValue: ShortIntD = try ShortIntDHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `LongFloatD`
    ///
    /// - parameter p2: `LongFloatD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: LongFloatD, p3: LongFloatD)`:
    ///
    ///   - returnValue: `LongFloatD`
    ///
    ///   - p3: `LongFloatD`
    func opLongFloatD(p1 iceP_p1: LongFloatD, p2 iceP_p2: LongFloatD, context: Ice.Context? = nil) throws -> (returnValue: LongFloatD, p3: LongFloatD) {
        return try _impl._invoke(operation: "opLongFloatD",
                                 mode: .Normal,
                                 write: { ostr in
                                     LongFloatDHelper.write(to: ostr, value: iceP_p1)
                                     LongFloatDHelper.write(to: ostr, value: iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: LongFloatD = try LongFloatDHelper.read(from: istr)
                                     let iceP_returnValue: LongFloatD = try LongFloatDHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `LongFloatD`
    ///
    /// - parameter p2: `LongFloatD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: LongFloatD, p3: LongFloatD)>` - The result of the operation
    func opLongFloatDAsync(p1 iceP_p1: LongFloatD, p2 iceP_p2: LongFloatD, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: LongFloatD, p3: LongFloatD)> {
        return _impl._invokeAsync(operation: "opLongFloatD",
                                  mode: .Normal,
                                  write: { ostr in
                                      LongFloatDHelper.write(to: ostr, value: iceP_p1)
                                      LongFloatDHelper.write(to: ostr, value: iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: LongFloatD = try LongFloatDHelper.read(from: istr)
                                      let iceP_returnValue: LongFloatD = try LongFloatDHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `StringStringD`
    ///
    /// - parameter p2: `StringStringD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: StringStringD, p3: StringStringD)`:
    ///
    ///   - returnValue: `StringStringD`
    ///
    ///   - p3: `StringStringD`
    func opStringStringD(p1 iceP_p1: StringStringD, p2 iceP_p2: StringStringD, context: Ice.Context? = nil) throws -> (returnValue: StringStringD, p3: StringStringD) {
        return try _impl._invoke(operation: "opStringStringD",
                                 mode: .Normal,
                                 write: { ostr in
                                     StringStringDHelper.write(to: ostr, value: iceP_p1)
                                     StringStringDHelper.write(to: ostr, value: iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: StringStringD = try StringStringDHelper.read(from: istr)
                                     let iceP_returnValue: StringStringD = try StringStringDHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `StringStringD`
    ///
    /// - parameter p2: `StringStringD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: StringStringD, p3: StringStringD)>` - The result of the operation
    func opStringStringDAsync(p1 iceP_p1: StringStringD, p2 iceP_p2: StringStringD, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: StringStringD, p3: StringStringD)> {
        return _impl._invokeAsync(operation: "opStringStringD",
                                  mode: .Normal,
                                  write: { ostr in
                                      StringStringDHelper.write(to: ostr, value: iceP_p1)
                                      StringStringDHelper.write(to: ostr, value: iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: StringStringD = try StringStringDHelper.read(from: istr)
                                      let iceP_returnValue: StringStringD = try StringStringDHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `StringMyEnumD`
    ///
    /// - parameter p2: `StringMyEnumD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: StringMyEnumD, p3: StringMyEnumD)`:
    ///
    ///   - returnValue: `StringMyEnumD`
    ///
    ///   - p3: `StringMyEnumD`
    func opStringMyEnumD(p1 iceP_p1: StringMyEnumD, p2 iceP_p2: StringMyEnumD, context: Ice.Context? = nil) throws -> (returnValue: StringMyEnumD, p3: StringMyEnumD) {
        return try _impl._invoke(operation: "opStringMyEnumD",
                                 mode: .Normal,
                                 write: { ostr in
                                     StringMyEnumDHelper.write(to: ostr, value: iceP_p1)
                                     StringMyEnumDHelper.write(to: ostr, value: iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: StringMyEnumD = try StringMyEnumDHelper.read(from: istr)
                                     let iceP_returnValue: StringMyEnumD = try StringMyEnumDHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `StringMyEnumD`
    ///
    /// - parameter p2: `StringMyEnumD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: StringMyEnumD, p3: StringMyEnumD)>` - The result of the operation
    func opStringMyEnumDAsync(p1 iceP_p1: StringMyEnumD, p2 iceP_p2: StringMyEnumD, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: StringMyEnumD, p3: StringMyEnumD)> {
        return _impl._invokeAsync(operation: "opStringMyEnumD",
                                  mode: .Normal,
                                  write: { ostr in
                                      StringMyEnumDHelper.write(to: ostr, value: iceP_p1)
                                      StringMyEnumDHelper.write(to: ostr, value: iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: StringMyEnumD = try StringMyEnumDHelper.read(from: istr)
                                      let iceP_returnValue: StringMyEnumD = try StringMyEnumDHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `MyEnumStringD`
    ///
    /// - parameter p2: `MyEnumStringD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: MyEnumStringD, p3: MyEnumStringD)`:
    ///
    ///   - returnValue: `MyEnumStringD`
    ///
    ///   - p3: `MyEnumStringD`
    func opMyEnumStringD(p1 iceP_p1: MyEnumStringD, p2 iceP_p2: MyEnumStringD, context: Ice.Context? = nil) throws -> (returnValue: MyEnumStringD, p3: MyEnumStringD) {
        return try _impl._invoke(operation: "opMyEnumStringD",
                                 mode: .Normal,
                                 write: { ostr in
                                     MyEnumStringDHelper.write(to: ostr, value: iceP_p1)
                                     MyEnumStringDHelper.write(to: ostr, value: iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: MyEnumStringD = try MyEnumStringDHelper.read(from: istr)
                                     let iceP_returnValue: MyEnumStringD = try MyEnumStringDHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `MyEnumStringD`
    ///
    /// - parameter p2: `MyEnumStringD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: MyEnumStringD, p3: MyEnumStringD)>` - The result of the operation
    func opMyEnumStringDAsync(p1 iceP_p1: MyEnumStringD, p2 iceP_p2: MyEnumStringD, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: MyEnumStringD, p3: MyEnumStringD)> {
        return _impl._invokeAsync(operation: "opMyEnumStringD",
                                  mode: .Normal,
                                  write: { ostr in
                                      MyEnumStringDHelper.write(to: ostr, value: iceP_p1)
                                      MyEnumStringDHelper.write(to: ostr, value: iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: MyEnumStringD = try MyEnumStringDHelper.read(from: istr)
                                      let iceP_returnValue: MyEnumStringD = try MyEnumStringDHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `MyStructMyEnumD`
    ///
    /// - parameter p2: `MyStructMyEnumD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: MyStructMyEnumD, p3: MyStructMyEnumD)`:
    ///
    ///   - returnValue: `MyStructMyEnumD`
    ///
    ///   - p3: `MyStructMyEnumD`
    func opMyStructMyEnumD(p1 iceP_p1: MyStructMyEnumD, p2 iceP_p2: MyStructMyEnumD, context: Ice.Context? = nil) throws -> (returnValue: MyStructMyEnumD, p3: MyStructMyEnumD) {
        return try _impl._invoke(operation: "opMyStructMyEnumD",
                                 mode: .Normal,
                                 write: { ostr in
                                     MyStructMyEnumDHelper.write(to: ostr, value: iceP_p1)
                                     MyStructMyEnumDHelper.write(to: ostr, value: iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: MyStructMyEnumD = try MyStructMyEnumDHelper.read(from: istr)
                                     let iceP_returnValue: MyStructMyEnumD = try MyStructMyEnumDHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `MyStructMyEnumD`
    ///
    /// - parameter p2: `MyStructMyEnumD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: MyStructMyEnumD, p3: MyStructMyEnumD)>` - The result of the operation
    func opMyStructMyEnumDAsync(p1 iceP_p1: MyStructMyEnumD, p2 iceP_p2: MyStructMyEnumD, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: MyStructMyEnumD, p3: MyStructMyEnumD)> {
        return _impl._invokeAsync(operation: "opMyStructMyEnumD",
                                  mode: .Normal,
                                  write: { ostr in
                                      MyStructMyEnumDHelper.write(to: ostr, value: iceP_p1)
                                      MyStructMyEnumDHelper.write(to: ostr, value: iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: MyStructMyEnumD = try MyStructMyEnumDHelper.read(from: istr)
                                      let iceP_returnValue: MyStructMyEnumD = try MyStructMyEnumDHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `ByteBoolDS`
    ///
    /// - parameter p2: `ByteBoolDS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: ByteBoolDS, p3: ByteBoolDS)`:
    ///
    ///   - returnValue: `ByteBoolDS`
    ///
    ///   - p3: `ByteBoolDS`
    func opByteBoolDS(p1 iceP_p1: ByteBoolDS, p2 iceP_p2: ByteBoolDS, context: Ice.Context? = nil) throws -> (returnValue: ByteBoolDS, p3: ByteBoolDS) {
        return try _impl._invoke(operation: "opByteBoolDS",
                                 mode: .Normal,
                                 write: { ostr in
                                     ByteBoolDSHelper.write(to: ostr, value: iceP_p1)
                                     ByteBoolDSHelper.write(to: ostr, value: iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: ByteBoolDS = try ByteBoolDSHelper.read(from: istr)
                                     let iceP_returnValue: ByteBoolDS = try ByteBoolDSHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `ByteBoolDS`
    ///
    /// - parameter p2: `ByteBoolDS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: ByteBoolDS, p3: ByteBoolDS)>` - The result of the operation
    func opByteBoolDSAsync(p1 iceP_p1: ByteBoolDS, p2 iceP_p2: ByteBoolDS, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: ByteBoolDS, p3: ByteBoolDS)> {
        return _impl._invokeAsync(operation: "opByteBoolDS",
                                  mode: .Normal,
                                  write: { ostr in
                                      ByteBoolDSHelper.write(to: ostr, value: iceP_p1)
                                      ByteBoolDSHelper.write(to: ostr, value: iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: ByteBoolDS = try ByteBoolDSHelper.read(from: istr)
                                      let iceP_returnValue: ByteBoolDS = try ByteBoolDSHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `ShortIntDS`
    ///
    /// - parameter p2: `ShortIntDS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: ShortIntDS, p3: ShortIntDS)`:
    ///
    ///   - returnValue: `ShortIntDS`
    ///
    ///   - p3: `ShortIntDS`
    func opShortIntDS(p1 iceP_p1: ShortIntDS, p2 iceP_p2: ShortIntDS, context: Ice.Context? = nil) throws -> (returnValue: ShortIntDS, p3: ShortIntDS) {
        return try _impl._invoke(operation: "opShortIntDS",
                                 mode: .Normal,
                                 write: { ostr in
                                     ShortIntDSHelper.write(to: ostr, value: iceP_p1)
                                     ShortIntDSHelper.write(to: ostr, value: iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: ShortIntDS = try ShortIntDSHelper.read(from: istr)
                                     let iceP_returnValue: ShortIntDS = try ShortIntDSHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `ShortIntDS`
    ///
    /// - parameter p2: `ShortIntDS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: ShortIntDS, p3: ShortIntDS)>` - The result of the operation
    func opShortIntDSAsync(p1 iceP_p1: ShortIntDS, p2 iceP_p2: ShortIntDS, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: ShortIntDS, p3: ShortIntDS)> {
        return _impl._invokeAsync(operation: "opShortIntDS",
                                  mode: .Normal,
                                  write: { ostr in
                                      ShortIntDSHelper.write(to: ostr, value: iceP_p1)
                                      ShortIntDSHelper.write(to: ostr, value: iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: ShortIntDS = try ShortIntDSHelper.read(from: istr)
                                      let iceP_returnValue: ShortIntDS = try ShortIntDSHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `LongFloatDS`
    ///
    /// - parameter p2: `LongFloatDS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: LongFloatDS, p3: LongFloatDS)`:
    ///
    ///   - returnValue: `LongFloatDS`
    ///
    ///   - p3: `LongFloatDS`
    func opLongFloatDS(p1 iceP_p1: LongFloatDS, p2 iceP_p2: LongFloatDS, context: Ice.Context? = nil) throws -> (returnValue: LongFloatDS, p3: LongFloatDS) {
        return try _impl._invoke(operation: "opLongFloatDS",
                                 mode: .Normal,
                                 write: { ostr in
                                     LongFloatDSHelper.write(to: ostr, value: iceP_p1)
                                     LongFloatDSHelper.write(to: ostr, value: iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: LongFloatDS = try LongFloatDSHelper.read(from: istr)
                                     let iceP_returnValue: LongFloatDS = try LongFloatDSHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `LongFloatDS`
    ///
    /// - parameter p2: `LongFloatDS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: LongFloatDS, p3: LongFloatDS)>` - The result of the operation
    func opLongFloatDSAsync(p1 iceP_p1: LongFloatDS, p2 iceP_p2: LongFloatDS, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: LongFloatDS, p3: LongFloatDS)> {
        return _impl._invokeAsync(operation: "opLongFloatDS",
                                  mode: .Normal,
                                  write: { ostr in
                                      LongFloatDSHelper.write(to: ostr, value: iceP_p1)
                                      LongFloatDSHelper.write(to: ostr, value: iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: LongFloatDS = try LongFloatDSHelper.read(from: istr)
                                      let iceP_returnValue: LongFloatDS = try LongFloatDSHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `StringStringDS`
    ///
    /// - parameter p2: `StringStringDS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: StringStringDS, p3: StringStringDS)`:
    ///
    ///   - returnValue: `StringStringDS`
    ///
    ///   - p3: `StringStringDS`
    func opStringStringDS(p1 iceP_p1: StringStringDS, p2 iceP_p2: StringStringDS, context: Ice.Context? = nil) throws -> (returnValue: StringStringDS, p3: StringStringDS) {
        return try _impl._invoke(operation: "opStringStringDS",
                                 mode: .Normal,
                                 write: { ostr in
                                     StringStringDSHelper.write(to: ostr, value: iceP_p1)
                                     StringStringDSHelper.write(to: ostr, value: iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: StringStringDS = try StringStringDSHelper.read(from: istr)
                                     let iceP_returnValue: StringStringDS = try StringStringDSHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `StringStringDS`
    ///
    /// - parameter p2: `StringStringDS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: StringStringDS, p3: StringStringDS)>` - The result of the operation
    func opStringStringDSAsync(p1 iceP_p1: StringStringDS, p2 iceP_p2: StringStringDS, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: StringStringDS, p3: StringStringDS)> {
        return _impl._invokeAsync(operation: "opStringStringDS",
                                  mode: .Normal,
                                  write: { ostr in
                                      StringStringDSHelper.write(to: ostr, value: iceP_p1)
                                      StringStringDSHelper.write(to: ostr, value: iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: StringStringDS = try StringStringDSHelper.read(from: istr)
                                      let iceP_returnValue: StringStringDS = try StringStringDSHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `StringMyEnumDS`
    ///
    /// - parameter p2: `StringMyEnumDS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: StringMyEnumDS, p3: StringMyEnumDS)`:
    ///
    ///   - returnValue: `StringMyEnumDS`
    ///
    ///   - p3: `StringMyEnumDS`
    func opStringMyEnumDS(p1 iceP_p1: StringMyEnumDS, p2 iceP_p2: StringMyEnumDS, context: Ice.Context? = nil) throws -> (returnValue: StringMyEnumDS, p3: StringMyEnumDS) {
        return try _impl._invoke(operation: "opStringMyEnumDS",
                                 mode: .Normal,
                                 write: { ostr in
                                     StringMyEnumDSHelper.write(to: ostr, value: iceP_p1)
                                     StringMyEnumDSHelper.write(to: ostr, value: iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: StringMyEnumDS = try StringMyEnumDSHelper.read(from: istr)
                                     let iceP_returnValue: StringMyEnumDS = try StringMyEnumDSHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `StringMyEnumDS`
    ///
    /// - parameter p2: `StringMyEnumDS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: StringMyEnumDS, p3: StringMyEnumDS)>` - The result of the operation
    func opStringMyEnumDSAsync(p1 iceP_p1: StringMyEnumDS, p2 iceP_p2: StringMyEnumDS, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: StringMyEnumDS, p3: StringMyEnumDS)> {
        return _impl._invokeAsync(operation: "opStringMyEnumDS",
                                  mode: .Normal,
                                  write: { ostr in
                                      StringMyEnumDSHelper.write(to: ostr, value: iceP_p1)
                                      StringMyEnumDSHelper.write(to: ostr, value: iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: StringMyEnumDS = try StringMyEnumDSHelper.read(from: istr)
                                      let iceP_returnValue: StringMyEnumDS = try StringMyEnumDSHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `MyEnumStringDS`
    ///
    /// - parameter p2: `MyEnumStringDS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: MyEnumStringDS, p3: MyEnumStringDS)`:
    ///
    ///   - returnValue: `MyEnumStringDS`
    ///
    ///   - p3: `MyEnumStringDS`
    func opMyEnumStringDS(p1 iceP_p1: MyEnumStringDS, p2 iceP_p2: MyEnumStringDS, context: Ice.Context? = nil) throws -> (returnValue: MyEnumStringDS, p3: MyEnumStringDS) {
        return try _impl._invoke(operation: "opMyEnumStringDS",
                                 mode: .Normal,
                                 write: { ostr in
                                     MyEnumStringDSHelper.write(to: ostr, value: iceP_p1)
                                     MyEnumStringDSHelper.write(to: ostr, value: iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: MyEnumStringDS = try MyEnumStringDSHelper.read(from: istr)
                                     let iceP_returnValue: MyEnumStringDS = try MyEnumStringDSHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `MyEnumStringDS`
    ///
    /// - parameter p2: `MyEnumStringDS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: MyEnumStringDS, p3: MyEnumStringDS)>` - The result of the operation
    func opMyEnumStringDSAsync(p1 iceP_p1: MyEnumStringDS, p2 iceP_p2: MyEnumStringDS, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: MyEnumStringDS, p3: MyEnumStringDS)> {
        return _impl._invokeAsync(operation: "opMyEnumStringDS",
                                  mode: .Normal,
                                  write: { ostr in
                                      MyEnumStringDSHelper.write(to: ostr, value: iceP_p1)
                                      MyEnumStringDSHelper.write(to: ostr, value: iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: MyEnumStringDS = try MyEnumStringDSHelper.read(from: istr)
                                      let iceP_returnValue: MyEnumStringDS = try MyEnumStringDSHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `MyStructMyEnumDS`
    ///
    /// - parameter p2: `MyStructMyEnumDS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: MyStructMyEnumDS, p3: MyStructMyEnumDS)`:
    ///
    ///   - returnValue: `MyStructMyEnumDS`
    ///
    ///   - p3: `MyStructMyEnumDS`
    func opMyStructMyEnumDS(p1 iceP_p1: MyStructMyEnumDS, p2 iceP_p2: MyStructMyEnumDS, context: Ice.Context? = nil) throws -> (returnValue: MyStructMyEnumDS, p3: MyStructMyEnumDS) {
        return try _impl._invoke(operation: "opMyStructMyEnumDS",
                                 mode: .Normal,
                                 write: { ostr in
                                     MyStructMyEnumDSHelper.write(to: ostr, value: iceP_p1)
                                     MyStructMyEnumDSHelper.write(to: ostr, value: iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: MyStructMyEnumDS = try MyStructMyEnumDSHelper.read(from: istr)
                                     let iceP_returnValue: MyStructMyEnumDS = try MyStructMyEnumDSHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `MyStructMyEnumDS`
    ///
    /// - parameter p2: `MyStructMyEnumDS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: MyStructMyEnumDS, p3: MyStructMyEnumDS)>` - The result of the operation
    func opMyStructMyEnumDSAsync(p1 iceP_p1: MyStructMyEnumDS, p2 iceP_p2: MyStructMyEnumDS, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: MyStructMyEnumDS, p3: MyStructMyEnumDS)> {
        return _impl._invokeAsync(operation: "opMyStructMyEnumDS",
                                  mode: .Normal,
                                  write: { ostr in
                                      MyStructMyEnumDSHelper.write(to: ostr, value: iceP_p1)
                                      MyStructMyEnumDSHelper.write(to: ostr, value: iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: MyStructMyEnumDS = try MyStructMyEnumDSHelper.read(from: istr)
                                      let iceP_returnValue: MyStructMyEnumDS = try MyStructMyEnumDSHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `ByteByteSD`
    ///
    /// - parameter p2: `ByteByteSD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: ByteByteSD, p3: ByteByteSD)`:
    ///
    ///   - returnValue: `ByteByteSD`
    ///
    ///   - p3: `ByteByteSD`
    func opByteByteSD(p1 iceP_p1: ByteByteSD, p2 iceP_p2: ByteByteSD, context: Ice.Context? = nil) throws -> (returnValue: ByteByteSD, p3: ByteByteSD) {
        return try _impl._invoke(operation: "opByteByteSD",
                                 mode: .Normal,
                                 write: { ostr in
                                     ByteByteSDHelper.write(to: ostr, value: iceP_p1)
                                     ByteByteSDHelper.write(to: ostr, value: iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: ByteByteSD = try ByteByteSDHelper.read(from: istr)
                                     let iceP_returnValue: ByteByteSD = try ByteByteSDHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `ByteByteSD`
    ///
    /// - parameter p2: `ByteByteSD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: ByteByteSD, p3: ByteByteSD)>` - The result of the operation
    func opByteByteSDAsync(p1 iceP_p1: ByteByteSD, p2 iceP_p2: ByteByteSD, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: ByteByteSD, p3: ByteByteSD)> {
        return _impl._invokeAsync(operation: "opByteByteSD",
                                  mode: .Normal,
                                  write: { ostr in
                                      ByteByteSDHelper.write(to: ostr, value: iceP_p1)
                                      ByteByteSDHelper.write(to: ostr, value: iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: ByteByteSD = try ByteByteSDHelper.read(from: istr)
                                      let iceP_returnValue: ByteByteSD = try ByteByteSDHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `BoolBoolSD`
    ///
    /// - parameter p2: `BoolBoolSD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: BoolBoolSD, p3: BoolBoolSD)`:
    ///
    ///   - returnValue: `BoolBoolSD`
    ///
    ///   - p3: `BoolBoolSD`
    func opBoolBoolSD(p1 iceP_p1: BoolBoolSD, p2 iceP_p2: BoolBoolSD, context: Ice.Context? = nil) throws -> (returnValue: BoolBoolSD, p3: BoolBoolSD) {
        return try _impl._invoke(operation: "opBoolBoolSD",
                                 mode: .Normal,
                                 write: { ostr in
                                     BoolBoolSDHelper.write(to: ostr, value: iceP_p1)
                                     BoolBoolSDHelper.write(to: ostr, value: iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: BoolBoolSD = try BoolBoolSDHelper.read(from: istr)
                                     let iceP_returnValue: BoolBoolSD = try BoolBoolSDHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `BoolBoolSD`
    ///
    /// - parameter p2: `BoolBoolSD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: BoolBoolSD, p3: BoolBoolSD)>` - The result of the operation
    func opBoolBoolSDAsync(p1 iceP_p1: BoolBoolSD, p2 iceP_p2: BoolBoolSD, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: BoolBoolSD, p3: BoolBoolSD)> {
        return _impl._invokeAsync(operation: "opBoolBoolSD",
                                  mode: .Normal,
                                  write: { ostr in
                                      BoolBoolSDHelper.write(to: ostr, value: iceP_p1)
                                      BoolBoolSDHelper.write(to: ostr, value: iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: BoolBoolSD = try BoolBoolSDHelper.read(from: istr)
                                      let iceP_returnValue: BoolBoolSD = try BoolBoolSDHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `ShortShortSD`
    ///
    /// - parameter p2: `ShortShortSD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: ShortShortSD, p3: ShortShortSD)`:
    ///
    ///   - returnValue: `ShortShortSD`
    ///
    ///   - p3: `ShortShortSD`
    func opShortShortSD(p1 iceP_p1: ShortShortSD, p2 iceP_p2: ShortShortSD, context: Ice.Context? = nil) throws -> (returnValue: ShortShortSD, p3: ShortShortSD) {
        return try _impl._invoke(operation: "opShortShortSD",
                                 mode: .Normal,
                                 write: { ostr in
                                     ShortShortSDHelper.write(to: ostr, value: iceP_p1)
                                     ShortShortSDHelper.write(to: ostr, value: iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: ShortShortSD = try ShortShortSDHelper.read(from: istr)
                                     let iceP_returnValue: ShortShortSD = try ShortShortSDHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `ShortShortSD`
    ///
    /// - parameter p2: `ShortShortSD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: ShortShortSD, p3: ShortShortSD)>` - The result of the operation
    func opShortShortSDAsync(p1 iceP_p1: ShortShortSD, p2 iceP_p2: ShortShortSD, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: ShortShortSD, p3: ShortShortSD)> {
        return _impl._invokeAsync(operation: "opShortShortSD",
                                  mode: .Normal,
                                  write: { ostr in
                                      ShortShortSDHelper.write(to: ostr, value: iceP_p1)
                                      ShortShortSDHelper.write(to: ostr, value: iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: ShortShortSD = try ShortShortSDHelper.read(from: istr)
                                      let iceP_returnValue: ShortShortSD = try ShortShortSDHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `IntIntSD`
    ///
    /// - parameter p2: `IntIntSD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: IntIntSD, p3: IntIntSD)`:
    ///
    ///   - returnValue: `IntIntSD`
    ///
    ///   - p3: `IntIntSD`
    func opIntIntSD(p1 iceP_p1: IntIntSD, p2 iceP_p2: IntIntSD, context: Ice.Context? = nil) throws -> (returnValue: IntIntSD, p3: IntIntSD) {
        return try _impl._invoke(operation: "opIntIntSD",
                                 mode: .Normal,
                                 write: { ostr in
                                     IntIntSDHelper.write(to: ostr, value: iceP_p1)
                                     IntIntSDHelper.write(to: ostr, value: iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: IntIntSD = try IntIntSDHelper.read(from: istr)
                                     let iceP_returnValue: IntIntSD = try IntIntSDHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `IntIntSD`
    ///
    /// - parameter p2: `IntIntSD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: IntIntSD, p3: IntIntSD)>` - The result of the operation
    func opIntIntSDAsync(p1 iceP_p1: IntIntSD, p2 iceP_p2: IntIntSD, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: IntIntSD, p3: IntIntSD)> {
        return _impl._invokeAsync(operation: "opIntIntSD",
                                  mode: .Normal,
                                  write: { ostr in
                                      IntIntSDHelper.write(to: ostr, value: iceP_p1)
                                      IntIntSDHelper.write(to: ostr, value: iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: IntIntSD = try IntIntSDHelper.read(from: istr)
                                      let iceP_returnValue: IntIntSD = try IntIntSDHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `LongLongSD`
    ///
    /// - parameter p2: `LongLongSD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: LongLongSD, p3: LongLongSD)`:
    ///
    ///   - returnValue: `LongLongSD`
    ///
    ///   - p3: `LongLongSD`
    func opLongLongSD(p1 iceP_p1: LongLongSD, p2 iceP_p2: LongLongSD, context: Ice.Context? = nil) throws -> (returnValue: LongLongSD, p3: LongLongSD) {
        return try _impl._invoke(operation: "opLongLongSD",
                                 mode: .Normal,
                                 write: { ostr in
                                     LongLongSDHelper.write(to: ostr, value: iceP_p1)
                                     LongLongSDHelper.write(to: ostr, value: iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: LongLongSD = try LongLongSDHelper.read(from: istr)
                                     let iceP_returnValue: LongLongSD = try LongLongSDHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `LongLongSD`
    ///
    /// - parameter p2: `LongLongSD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: LongLongSD, p3: LongLongSD)>` - The result of the operation
    func opLongLongSDAsync(p1 iceP_p1: LongLongSD, p2 iceP_p2: LongLongSD, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: LongLongSD, p3: LongLongSD)> {
        return _impl._invokeAsync(operation: "opLongLongSD",
                                  mode: .Normal,
                                  write: { ostr in
                                      LongLongSDHelper.write(to: ostr, value: iceP_p1)
                                      LongLongSDHelper.write(to: ostr, value: iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: LongLongSD = try LongLongSDHelper.read(from: istr)
                                      let iceP_returnValue: LongLongSD = try LongLongSDHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `StringFloatSD`
    ///
    /// - parameter p2: `StringFloatSD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: StringFloatSD, p3: StringFloatSD)`:
    ///
    ///   - returnValue: `StringFloatSD`
    ///
    ///   - p3: `StringFloatSD`
    func opStringFloatSD(p1 iceP_p1: StringFloatSD, p2 iceP_p2: StringFloatSD, context: Ice.Context? = nil) throws -> (returnValue: StringFloatSD, p3: StringFloatSD) {
        return try _impl._invoke(operation: "opStringFloatSD",
                                 mode: .Normal,
                                 write: { ostr in
                                     StringFloatSDHelper.write(to: ostr, value: iceP_p1)
                                     StringFloatSDHelper.write(to: ostr, value: iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: StringFloatSD = try StringFloatSDHelper.read(from: istr)
                                     let iceP_returnValue: StringFloatSD = try StringFloatSDHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `StringFloatSD`
    ///
    /// - parameter p2: `StringFloatSD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: StringFloatSD, p3: StringFloatSD)>` - The result of the operation
    func opStringFloatSDAsync(p1 iceP_p1: StringFloatSD, p2 iceP_p2: StringFloatSD, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: StringFloatSD, p3: StringFloatSD)> {
        return _impl._invokeAsync(operation: "opStringFloatSD",
                                  mode: .Normal,
                                  write: { ostr in
                                      StringFloatSDHelper.write(to: ostr, value: iceP_p1)
                                      StringFloatSDHelper.write(to: ostr, value: iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: StringFloatSD = try StringFloatSDHelper.read(from: istr)
                                      let iceP_returnValue: StringFloatSD = try StringFloatSDHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `StringDoubleSD`
    ///
    /// - parameter p2: `StringDoubleSD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: StringDoubleSD, p3: StringDoubleSD)`:
    ///
    ///   - returnValue: `StringDoubleSD`
    ///
    ///   - p3: `StringDoubleSD`
    func opStringDoubleSD(p1 iceP_p1: StringDoubleSD, p2 iceP_p2: StringDoubleSD, context: Ice.Context? = nil) throws -> (returnValue: StringDoubleSD, p3: StringDoubleSD) {
        return try _impl._invoke(operation: "opStringDoubleSD",
                                 mode: .Normal,
                                 write: { ostr in
                                     StringDoubleSDHelper.write(to: ostr, value: iceP_p1)
                                     StringDoubleSDHelper.write(to: ostr, value: iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: StringDoubleSD = try StringDoubleSDHelper.read(from: istr)
                                     let iceP_returnValue: StringDoubleSD = try StringDoubleSDHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `StringDoubleSD`
    ///
    /// - parameter p2: `StringDoubleSD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: StringDoubleSD, p3: StringDoubleSD)>` - The result of the operation
    func opStringDoubleSDAsync(p1 iceP_p1: StringDoubleSD, p2 iceP_p2: StringDoubleSD, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: StringDoubleSD, p3: StringDoubleSD)> {
        return _impl._invokeAsync(operation: "opStringDoubleSD",
                                  mode: .Normal,
                                  write: { ostr in
                                      StringDoubleSDHelper.write(to: ostr, value: iceP_p1)
                                      StringDoubleSDHelper.write(to: ostr, value: iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: StringDoubleSD = try StringDoubleSDHelper.read(from: istr)
                                      let iceP_returnValue: StringDoubleSD = try StringDoubleSDHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `StringStringSD`
    ///
    /// - parameter p2: `StringStringSD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: StringStringSD, p3: StringStringSD)`:
    ///
    ///   - returnValue: `StringStringSD`
    ///
    ///   - p3: `StringStringSD`
    func opStringStringSD(p1 iceP_p1: StringStringSD, p2 iceP_p2: StringStringSD, context: Ice.Context? = nil) throws -> (returnValue: StringStringSD, p3: StringStringSD) {
        return try _impl._invoke(operation: "opStringStringSD",
                                 mode: .Normal,
                                 write: { ostr in
                                     StringStringSDHelper.write(to: ostr, value: iceP_p1)
                                     StringStringSDHelper.write(to: ostr, value: iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: StringStringSD = try StringStringSDHelper.read(from: istr)
                                     let iceP_returnValue: StringStringSD = try StringStringSDHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `StringStringSD`
    ///
    /// - parameter p2: `StringStringSD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: StringStringSD, p3: StringStringSD)>` - The result of the operation
    func opStringStringSDAsync(p1 iceP_p1: StringStringSD, p2 iceP_p2: StringStringSD, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: StringStringSD, p3: StringStringSD)> {
        return _impl._invokeAsync(operation: "opStringStringSD",
                                  mode: .Normal,
                                  write: { ostr in
                                      StringStringSDHelper.write(to: ostr, value: iceP_p1)
                                      StringStringSDHelper.write(to: ostr, value: iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: StringStringSD = try StringStringSDHelper.read(from: istr)
                                      let iceP_returnValue: StringStringSD = try StringStringSDHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `MyEnumMyEnumSD`
    ///
    /// - parameter p2: `MyEnumMyEnumSD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: MyEnumMyEnumSD, p3: MyEnumMyEnumSD)`:
    ///
    ///   - returnValue: `MyEnumMyEnumSD`
    ///
    ///   - p3: `MyEnumMyEnumSD`
    func opMyEnumMyEnumSD(p1 iceP_p1: MyEnumMyEnumSD, p2 iceP_p2: MyEnumMyEnumSD, context: Ice.Context? = nil) throws -> (returnValue: MyEnumMyEnumSD, p3: MyEnumMyEnumSD) {
        return try _impl._invoke(operation: "opMyEnumMyEnumSD",
                                 mode: .Normal,
                                 write: { ostr in
                                     MyEnumMyEnumSDHelper.write(to: ostr, value: iceP_p1)
                                     MyEnumMyEnumSDHelper.write(to: ostr, value: iceP_p2)
                                 },
                                 read: { istr in
                                     let iceP_p3: MyEnumMyEnumSD = try MyEnumMyEnumSDHelper.read(from: istr)
                                     let iceP_returnValue: MyEnumMyEnumSD = try MyEnumMyEnumSDHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p3)
                                 },
                                 context: context)
    }

    ///
    /// - parameter p1: `MyEnumMyEnumSD`
    ///
    /// - parameter p2: `MyEnumMyEnumSD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: MyEnumMyEnumSD, p3: MyEnumMyEnumSD)>` - The result of the operation
    func opMyEnumMyEnumSDAsync(p1 iceP_p1: MyEnumMyEnumSD, p2 iceP_p2: MyEnumMyEnumSD, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: MyEnumMyEnumSD, p3: MyEnumMyEnumSD)> {
        return _impl._invokeAsync(operation: "opMyEnumMyEnumSD",
                                  mode: .Normal,
                                  write: { ostr in
                                      MyEnumMyEnumSDHelper.write(to: ostr, value: iceP_p1)
                                      MyEnumMyEnumSDHelper.write(to: ostr, value: iceP_p2)
                                  },
                                  read: { istr in
                                      let iceP_p3: MyEnumMyEnumSD = try MyEnumMyEnumSDHelper.read(from: istr)
                                      let iceP_returnValue: MyEnumMyEnumSD = try MyEnumMyEnumSDHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p3)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `IntS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `IntS`
    func opIntS(_ iceP_s: IntS, context: Ice.Context? = nil) throws -> IntS {
        return try _impl._invoke(operation: "opIntS",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_s)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: IntS = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `IntS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<IntS>` - The result of the operation
    func opIntSAsync(_ iceP_s: IntS, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<IntS> {
        return _impl._invokeAsync(operation: "opIntS",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_s)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: IntS = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `ByteS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func opByteSOneway(_ iceP_s: ByteS, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "opByteSOneway",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_s)
                          },
                          context: context)
    }

    ///
    /// - parameter _: `ByteS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func opByteSOnewayAsync(_ iceP_s: ByteS, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "opByteSOneway",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_s)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Int32`
    func opByteSOnewayCallCount(context: Ice.Context? = nil) throws -> Swift.Int32 {
        return try _impl._invoke(operation: "opByteSOnewayCallCount",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: Swift.Int32 = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Int32>` - The result of the operation
    func opByteSOnewayCallCountAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Int32> {
        return _impl._invokeAsync(operation: "opByteSOnewayCallCount",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_returnValue: Swift.Int32 = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Ice.Context`
    func opContext(context: Ice.Context? = nil) throws -> Ice.Context {
        return try _impl._invoke(operation: "opContext",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: Ice.Context = try Ice.ContextHelper.read(from: istr)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Ice.Context>` - The result of the operation
    func opContextAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Ice.Context> {
        return _impl._invokeAsync(operation: "opContext",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_returnValue: Ice.Context = try Ice.ContextHelper.read(from: istr)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter p1: `Swift.Double`
    ///
    /// - parameter p2: `DoubleS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func opDoubleMarshaling(p1 iceP_p1: Swift.Double, p2 iceP_p2: DoubleS, context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "opDoubleMarshaling",
                          mode: .Normal,
                          write: { ostr in
                              ostr.write(iceP_p1)
                              ostr.write(iceP_p2)
                          },
                          context: context)
    }

    ///
    /// - parameter p1: `Swift.Double`
    ///
    /// - parameter p2: `DoubleS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func opDoubleMarshalingAsync(p1 iceP_p1: Swift.Double, p2 iceP_p2: DoubleS, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "opDoubleMarshaling",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_p1)
                                      ostr.write(iceP_p2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func opIdempotent(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "opIdempotent",
                          mode: .Idempotent,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func opIdempotentAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "opIdempotent",
                                  mode: .Idempotent,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func opNonmutating(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "opNonmutating",
                          mode: .Nonmutating,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func opNonmutatingAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "opNonmutating",
                                  mode: .Nonmutating,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `Swift.UInt8`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.UInt8`
    func opByte1(_ iceP_opByte1: Swift.UInt8, context: Ice.Context? = nil) throws -> Swift.UInt8 {
        return try _impl._invoke(operation: "opByte1",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_opByte1)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: Swift.UInt8 = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `Swift.UInt8`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.UInt8>` - The result of the operation
    func opByte1Async(_ iceP_opByte1: Swift.UInt8, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.UInt8> {
        return _impl._invokeAsync(operation: "opByte1",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_opByte1)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: Swift.UInt8 = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `Swift.Int16`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Int16`
    func opShort1(_ iceP_opShort1: Swift.Int16, context: Ice.Context? = nil) throws -> Swift.Int16 {
        return try _impl._invoke(operation: "opShort1",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_opShort1)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: Swift.Int16 = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `Swift.Int16`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Int16>` - The result of the operation
    func opShort1Async(_ iceP_opShort1: Swift.Int16, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Int16> {
        return _impl._invokeAsync(operation: "opShort1",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_opShort1)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: Swift.Int16 = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Int32`
    func opInt1(_ iceP_opInt1: Swift.Int32, context: Ice.Context? = nil) throws -> Swift.Int32 {
        return try _impl._invoke(operation: "opInt1",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_opInt1)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: Swift.Int32 = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Int32>` - The result of the operation
    func opInt1Async(_ iceP_opInt1: Swift.Int32, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Int32> {
        return _impl._invokeAsync(operation: "opInt1",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_opInt1)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: Swift.Int32 = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `Swift.Int64`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Int64`
    func opLong1(_ iceP_opLong1: Swift.Int64, context: Ice.Context? = nil) throws -> Swift.Int64 {
        return try _impl._invoke(operation: "opLong1",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_opLong1)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: Swift.Int64 = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `Swift.Int64`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Int64>` - The result of the operation
    func opLong1Async(_ iceP_opLong1: Swift.Int64, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Int64> {
        return _impl._invokeAsync(operation: "opLong1",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_opLong1)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: Swift.Int64 = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `Swift.Float`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Float`
    func opFloat1(_ iceP_opFloat1: Swift.Float, context: Ice.Context? = nil) throws -> Swift.Float {
        return try _impl._invoke(operation: "opFloat1",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_opFloat1)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: Swift.Float = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `Swift.Float`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Float>` - The result of the operation
    func opFloat1Async(_ iceP_opFloat1: Swift.Float, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Float> {
        return _impl._invokeAsync(operation: "opFloat1",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_opFloat1)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: Swift.Float = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `Swift.Double`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Double`
    func opDouble1(_ iceP_opDouble1: Swift.Double, context: Ice.Context? = nil) throws -> Swift.Double {
        return try _impl._invoke(operation: "opDouble1",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_opDouble1)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: Swift.Double = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `Swift.Double`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Double>` - The result of the operation
    func opDouble1Async(_ iceP_opDouble1: Swift.Double, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Double> {
        return _impl._invokeAsync(operation: "opDouble1",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_opDouble1)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: Swift.Double = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `Swift.String`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String`
    func opString1(_ iceP_opString1: Swift.String, context: Ice.Context? = nil) throws -> Swift.String {
        return try _impl._invoke(operation: "opString1",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_opString1)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: Swift.String = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `Swift.String`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.String>` - The result of the operation
    func opString1Async(_ iceP_opString1: Swift.String, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.String> {
        return _impl._invokeAsync(operation: "opString1",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_opString1)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: Swift.String = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `StringS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `StringS`
    func opStringS1(_ iceP_opStringS1: StringS, context: Ice.Context? = nil) throws -> StringS {
        return try _impl._invoke(operation: "opStringS1",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_opStringS1)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: StringS = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `StringS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<StringS>` - The result of the operation
    func opStringS1Async(_ iceP_opStringS1: StringS, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<StringS> {
        return _impl._invokeAsync(operation: "opStringS1",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_opStringS1)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: StringS = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `ByteBoolD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `ByteBoolD`
    func opByteBoolD1(_ iceP_opByteBoolD1: ByteBoolD, context: Ice.Context? = nil) throws -> ByteBoolD {
        return try _impl._invoke(operation: "opByteBoolD1",
                                 mode: .Normal,
                                 write: { ostr in
                                     ByteBoolDHelper.write(to: ostr, value: iceP_opByteBoolD1)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: ByteBoolD = try ByteBoolDHelper.read(from: istr)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `ByteBoolD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<ByteBoolD>` - The result of the operation
    func opByteBoolD1Async(_ iceP_opByteBoolD1: ByteBoolD, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<ByteBoolD> {
        return _impl._invokeAsync(operation: "opByteBoolD1",
                                  mode: .Normal,
                                  write: { ostr in
                                      ByteBoolDHelper.write(to: ostr, value: iceP_opByteBoolD1)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: ByteBoolD = try ByteBoolDHelper.read(from: istr)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `StringS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `StringS`
    func opStringS2(_ iceP_stringS: StringS, context: Ice.Context? = nil) throws -> StringS {
        return try _impl._invoke(operation: "opStringS2",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_stringS)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: StringS = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `StringS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<StringS>` - The result of the operation
    func opStringS2Async(_ iceP_stringS: StringS, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<StringS> {
        return _impl._invokeAsync(operation: "opStringS2",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_stringS)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: StringS = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `ByteBoolD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `ByteBoolD`
    func opByteBoolD2(_ iceP_byteBoolD: ByteBoolD, context: Ice.Context? = nil) throws -> ByteBoolD {
        return try _impl._invoke(operation: "opByteBoolD2",
                                 mode: .Normal,
                                 write: { ostr in
                                     ByteBoolDHelper.write(to: ostr, value: iceP_byteBoolD)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: ByteBoolD = try ByteBoolDHelper.read(from: istr)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `ByteBoolD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<ByteBoolD>` - The result of the operation
    func opByteBoolD2Async(_ iceP_byteBoolD: ByteBoolD, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<ByteBoolD> {
        return _impl._invokeAsync(operation: "opByteBoolD2",
                                  mode: .Normal,
                                  write: { ostr in
                                      ByteBoolDHelper.write(to: ostr, value: iceP_byteBoolD)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: ByteBoolD = try ByteBoolDHelper.read(from: istr)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `StringS`
    func opStringLiterals(context: Ice.Context? = nil) throws -> StringS {
        return try _impl._invoke(operation: "opStringLiterals",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: StringS = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<StringS>` - The result of the operation
    func opStringLiteralsAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<StringS> {
        return _impl._invokeAsync(operation: "opStringLiterals",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_returnValue: StringS = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `StringS`
    func opWStringLiterals(context: Ice.Context? = nil) throws -> StringS {
        return try _impl._invoke(operation: "opWStringLiterals",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: StringS = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<StringS>` - The result of the operation
    func opWStringLiteralsAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<StringS> {
        return _impl._invokeAsync(operation: "opWStringLiterals",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_returnValue: StringS = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Structure`
    func opMStruct1(context: Ice.Context? = nil) throws -> Structure {
        return try _impl._invoke(operation: "opMStruct1",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: Structure = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Structure>` - The result of the operation
    func opMStruct1Async(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Structure> {
        return _impl._invokeAsync(operation: "opMStruct1",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_returnValue: Structure = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `Structure`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: Structure, p2: Structure)`:
    ///
    ///   - returnValue: `Structure`
    ///
    ///   - p2: `Structure`
    func opMStruct2(_ iceP_p1: Structure, context: Ice.Context? = nil) throws -> (returnValue: Structure, p2: Structure) {
        return try _impl._invoke(operation: "opMStruct2",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_p1)
                                 },
                                 read: { istr in
                                     let iceP_p2: Structure = try istr.read()
                                     let iceP_returnValue: Structure = try istr.read()
                                     return (iceP_returnValue, iceP_p2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `Structure`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: Structure, p2: Structure)>` - The result of the operation
    func opMStruct2Async(_ iceP_p1: Structure, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: Structure, p2: Structure)> {
        return _impl._invokeAsync(operation: "opMStruct2",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_p1)
                                  },
                                  read: { istr in
                                      let iceP_p2: Structure = try istr.read()
                                      let iceP_returnValue: Structure = try istr.read()
                                      return (iceP_returnValue, iceP_p2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `StringS`
    func opMSeq1(context: Ice.Context? = nil) throws -> StringS {
        return try _impl._invoke(operation: "opMSeq1",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: StringS = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<StringS>` - The result of the operation
    func opMSeq1Async(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<StringS> {
        return _impl._invokeAsync(operation: "opMSeq1",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_returnValue: StringS = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `StringS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: StringS, p2: StringS)`:
    ///
    ///   - returnValue: `StringS`
    ///
    ///   - p2: `StringS`
    func opMSeq2(_ iceP_p1: StringS, context: Ice.Context? = nil) throws -> (returnValue: StringS, p2: StringS) {
        return try _impl._invoke(operation: "opMSeq2",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_p1)
                                 },
                                 read: { istr in
                                     let iceP_p2: StringS = try istr.read()
                                     let iceP_returnValue: StringS = try istr.read()
                                     return (iceP_returnValue, iceP_p2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `StringS`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: StringS, p2: StringS)>` - The result of the operation
    func opMSeq2Async(_ iceP_p1: StringS, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: StringS, p2: StringS)> {
        return _impl._invokeAsync(operation: "opMSeq2",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_p1)
                                  },
                                  read: { istr in
                                      let iceP_p2: StringS = try istr.read()
                                      let iceP_returnValue: StringS = try istr.read()
                                      return (iceP_returnValue, iceP_p2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `StringStringD`
    func opMDict1(context: Ice.Context? = nil) throws -> StringStringD {
        return try _impl._invoke(operation: "opMDict1",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: StringStringD = try StringStringDHelper.read(from: istr)
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<StringStringD>` - The result of the operation
    func opMDict1Async(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<StringStringD> {
        return _impl._invokeAsync(operation: "opMDict1",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_returnValue: StringStringD = try StringStringDHelper.read(from: istr)
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `StringStringD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `(returnValue: StringStringD, p2: StringStringD)`:
    ///
    ///   - returnValue: `StringStringD`
    ///
    ///   - p2: `StringStringD`
    func opMDict2(_ iceP_p1: StringStringD, context: Ice.Context? = nil) throws -> (returnValue: StringStringD, p2: StringStringD) {
        return try _impl._invoke(operation: "opMDict2",
                                 mode: .Normal,
                                 write: { ostr in
                                     StringStringDHelper.write(to: ostr, value: iceP_p1)
                                 },
                                 read: { istr in
                                     let iceP_p2: StringStringD = try StringStringDHelper.read(from: istr)
                                     let iceP_returnValue: StringStringD = try StringStringDHelper.read(from: istr)
                                     return (iceP_returnValue, iceP_p2)
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `StringStringD`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<(returnValue: StringStringD, p2: StringStringD)>` - The result of the operation
    func opMDict2Async(_ iceP_p1: StringStringD, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<(returnValue: StringStringD, p2: StringStringD)> {
        return _impl._invokeAsync(operation: "opMDict2",
                                  mode: .Normal,
                                  write: { ostr in
                                      StringStringDHelper.write(to: ostr, value: iceP_p1)
                                  },
                                  read: { istr in
                                      let iceP_p2: StringStringD = try StringStringDHelper.read(from: istr)
                                      let iceP_returnValue: StringStringD = try StringStringDHelper.read(from: istr)
                                      return (iceP_returnValue, iceP_p2)
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// MyDerivedClassPrx overview.
///
/// MyDerivedClassPrx Methods:
///
///  - opDerived: 
///
///  - opDerivedAsync: 
///
///  - opMyClass1: 
///
///  - opMyClass1Async: 
///
///  - opMyStruct1: 
///
///  - opMyStruct1Async: 
public protocol MyDerivedClassPrx: MyClassPrx {}

private final class MyDerivedClassPrxI: Ice.ObjectPrxI, MyDerivedClassPrx {
    public override class func ice_staticId() -> Swift.String {
        return MyDerivedClassTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `MyDerivedClassPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `MyDerivedClassPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: MyDerivedClassPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> MyDerivedClassPrx? {
    return try MyDerivedClassPrxI.checkedCast(prx: prx, facet: facet, context: context) as MyDerivedClassPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `MyDerivedClassPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `MyDerivedClassPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: MyDerivedClassPrx.Protocol, facet: Swift.String? = nil) -> MyDerivedClassPrx {
    return MyDerivedClassPrxI.uncheckedCast(prx: prx, facet: facet) as MyDerivedClassPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `MyDerivedClassPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: MyDerivedClassPrx.Protocol) -> Swift.String {
    return MyDerivedClassTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `MyDerivedClassPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `MyDerivedClassPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `MyDerivedClassPrx?` - The extracted proxy
    func read(_ type: MyDerivedClassPrx.Protocol) throws -> MyDerivedClassPrx? {
        return try read() as MyDerivedClassPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `MyDerivedClassPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `MyDerivedClassPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: MyDerivedClassPrx.Protocol) throws -> MyDerivedClassPrx? {
        return try read(tag: tag) as MyDerivedClassPrxI?
    }
}

/// MyDerivedClassPrx overview.
///
/// MyDerivedClassPrx Methods:
///
///  - opDerived: 
///
///  - opDerivedAsync: 
///
///  - opMyClass1: 
///
///  - opMyClass1Async: 
///
///  - opMyStruct1: 
///
///  - opMyStruct1Async: 
public extension MyDerivedClassPrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func opDerived(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "opDerived",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func opDerivedAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "opDerived",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `MyClass1?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `MyClass1?`
    func opMyClass1(_ iceP_opMyClass1: MyClass1?, context: Ice.Context? = nil) throws -> MyClass1? {
        return try _impl._invoke(operation: "opMyClass1",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_opMyClass1)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     var iceP_returnValue: MyClass1?
                                     try istr.read(MyClass1.self) { iceP_returnValue = $0 }
                                     try istr.readPendingValues()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `MyClass1?`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<MyClass1?>` - The result of the operation
    func opMyClass1Async(_ iceP_opMyClass1: MyClass1?, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<MyClass1?> {
        return _impl._invokeAsync(operation: "opMyClass1",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_opMyClass1)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      var iceP_returnValue: MyClass1?
                                      try istr.read(MyClass1.self) { iceP_returnValue = $0 }
                                      try istr.readPendingValues()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter _: `MyStruct1`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `MyStruct1`
    func opMyStruct1(_ iceP_opMyStruct1: MyStruct1, context: Ice.Context? = nil) throws -> MyStruct1 {
        return try _impl._invoke(operation: "opMyStruct1",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_opMyStruct1)
                                 },
                                 read: { istr in
                                     let iceP_returnValue: MyStruct1 = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `MyStruct1`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<MyStruct1>` - The result of the operation
    func opMyStruct1Async(_ iceP_opMyStruct1: MyStruct1, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<MyStruct1> {
        return _impl._invokeAsync(operation: "opMyStruct1",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_opMyStruct1)
                                  },
                                  read: { istr in
                                      let iceP_returnValue: MyStruct1 = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// :nodoc:
public class MyClass1_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return MyClass1.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_MyClass1() -> Ice.ValueTypeResolver {
        return MyClass1_TypeResolver()
    }
}

open class MyClass1: Ice.Value {
    public var tesT: Swift.String = ""
    public var myClass: MyClassPrx? = nil
    public var myClass1: Swift.String = ""

    public required init() {}

    public init(tesT: Swift.String, myClass: MyClassPrx?, myClass1: Swift.String) {
        self.tesT = tesT
        self.myClass = myClass
        self.myClass1 = myClass1
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return MyClass1Traits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return MyClass1Traits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.tesT = try istr.read()
        self.myClass = try istr.read(MyClassPrx.self)
        self.myClass1 = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: MyClass1Traits.staticId, compactId: -1, last: true)
        ostr.write(self.tesT)
        ostr.write(self.myClass)
        ostr.write(self.myClass1)
        ostr.endSlice()
    }
}


/// Dispatcher for `MyClass` servants.
public struct MyClassDisp: Ice.Disp {
    public let servant: MyClass
    private static let defaultObject = Ice.ObjectI<MyClassTraits>()

    public init(_ servant: MyClass) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "ice_id":
            return try (servant as? Object ?? MyClassDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? MyClassDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? MyClassDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? MyClassDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "opBool":
            return try servant._iceD_opBool(incoming: request, current: current)
        case "opBoolBoolSD":
            return try servant._iceD_opBoolBoolSD(incoming: request, current: current)
        case "opBoolS":
            return try servant._iceD_opBoolS(incoming: request, current: current)
        case "opBoolSS":
            return try servant._iceD_opBoolSS(incoming: request, current: current)
        case "opByte":
            return try servant._iceD_opByte(incoming: request, current: current)
        case "opByte1":
            return try servant._iceD_opByte1(incoming: request, current: current)
        case "opByteBoolD":
            return try servant._iceD_opByteBoolD(incoming: request, current: current)
        case "opByteBoolD1":
            return try servant._iceD_opByteBoolD1(incoming: request, current: current)
        case "opByteBoolD2":
            return try servant._iceD_opByteBoolD2(incoming: request, current: current)
        case "opByteBoolDS":
            return try servant._iceD_opByteBoolDS(incoming: request, current: current)
        case "opByteByteSD":
            return try servant._iceD_opByteByteSD(incoming: request, current: current)
        case "opByteS":
            return try servant._iceD_opByteS(incoming: request, current: current)
        case "opByteSOneway":
            return try servant._iceD_opByteSOneway(incoming: request, current: current)
        case "opByteSOnewayCallCount":
            return try servant._iceD_opByteSOnewayCallCount(incoming: request, current: current)
        case "opByteSS":
            return try servant._iceD_opByteSS(incoming: request, current: current)
        case "opContext":
            return try servant._iceD_opContext(incoming: request, current: current)
        case "opDouble1":
            return try servant._iceD_opDouble1(incoming: request, current: current)
        case "opDoubleMarshaling":
            return try servant._iceD_opDoubleMarshaling(incoming: request, current: current)
        case "opFloat1":
            return try servant._iceD_opFloat1(incoming: request, current: current)
        case "opFloatDouble":
            return try servant._iceD_opFloatDouble(incoming: request, current: current)
        case "opFloatDoubleS":
            return try servant._iceD_opFloatDoubleS(incoming: request, current: current)
        case "opFloatDoubleSS":
            return try servant._iceD_opFloatDoubleSS(incoming: request, current: current)
        case "opIdempotent":
            return try servant._iceD_opIdempotent(incoming: request, current: current)
        case "opInt1":
            return try servant._iceD_opInt1(incoming: request, current: current)
        case "opIntIntSD":
            return try servant._iceD_opIntIntSD(incoming: request, current: current)
        case "opIntS":
            return try servant._iceD_opIntS(incoming: request, current: current)
        case "opLong1":
            return try servant._iceD_opLong1(incoming: request, current: current)
        case "opLongFloatD":
            return try servant._iceD_opLongFloatD(incoming: request, current: current)
        case "opLongFloatDS":
            return try servant._iceD_opLongFloatDS(incoming: request, current: current)
        case "opLongLongSD":
            return try servant._iceD_opLongLongSD(incoming: request, current: current)
        case "opMDict1":
            return try servant._iceD_opMDict1(incoming: request, current: current)
        case "opMDict2":
            return try servant._iceD_opMDict2(incoming: request, current: current)
        case "opMSeq1":
            return try servant._iceD_opMSeq1(incoming: request, current: current)
        case "opMSeq2":
            return try servant._iceD_opMSeq2(incoming: request, current: current)
        case "opMStruct1":
            return try servant._iceD_opMStruct1(incoming: request, current: current)
        case "opMStruct2":
            return try servant._iceD_opMStruct2(incoming: request, current: current)
        case "opMyClass":
            return try servant._iceD_opMyClass(incoming: request, current: current)
        case "opMyEnum":
            return try servant._iceD_opMyEnum(incoming: request, current: current)
        case "opMyEnumMyEnumSD":
            return try servant._iceD_opMyEnumMyEnumSD(incoming: request, current: current)
        case "opMyEnumStringD":
            return try servant._iceD_opMyEnumStringD(incoming: request, current: current)
        case "opMyEnumStringDS":
            return try servant._iceD_opMyEnumStringDS(incoming: request, current: current)
        case "opMyStructMyEnumD":
            return try servant._iceD_opMyStructMyEnumD(incoming: request, current: current)
        case "opMyStructMyEnumDS":
            return try servant._iceD_opMyStructMyEnumDS(incoming: request, current: current)
        case "opNonmutating":
            return try servant._iceD_opNonmutating(incoming: request, current: current)
        case "opShort1":
            return try servant._iceD_opShort1(incoming: request, current: current)
        case "opShortIntD":
            return try servant._iceD_opShortIntD(incoming: request, current: current)
        case "opShortIntDS":
            return try servant._iceD_opShortIntDS(incoming: request, current: current)
        case "opShortIntLong":
            return try servant._iceD_opShortIntLong(incoming: request, current: current)
        case "opShortIntLongS":
            return try servant._iceD_opShortIntLongS(incoming: request, current: current)
        case "opShortIntLongSS":
            return try servant._iceD_opShortIntLongSS(incoming: request, current: current)
        case "opShortShortSD":
            return try servant._iceD_opShortShortSD(incoming: request, current: current)
        case "opString":
            return try servant._iceD_opString(incoming: request, current: current)
        case "opString1":
            return try servant._iceD_opString1(incoming: request, current: current)
        case "opStringDoubleSD":
            return try servant._iceD_opStringDoubleSD(incoming: request, current: current)
        case "opStringFloatSD":
            return try servant._iceD_opStringFloatSD(incoming: request, current: current)
        case "opStringLiterals":
            return try servant._iceD_opStringLiterals(incoming: request, current: current)
        case "opStringMyEnumD":
            return try servant._iceD_opStringMyEnumD(incoming: request, current: current)
        case "opStringMyEnumDS":
            return try servant._iceD_opStringMyEnumDS(incoming: request, current: current)
        case "opStringS":
            return try servant._iceD_opStringS(incoming: request, current: current)
        case "opStringS1":
            return try servant._iceD_opStringS1(incoming: request, current: current)
        case "opStringS2":
            return try servant._iceD_opStringS2(incoming: request, current: current)
        case "opStringSS":
            return try servant._iceD_opStringSS(incoming: request, current: current)
        case "opStringSSS":
            return try servant._iceD_opStringSSS(incoming: request, current: current)
        case "opStringStringD":
            return try servant._iceD_opStringStringD(incoming: request, current: current)
        case "opStringStringDS":
            return try servant._iceD_opStringStringDS(incoming: request, current: current)
        case "opStringStringSD":
            return try servant._iceD_opStringStringSD(incoming: request, current: current)
        case "opStruct":
            return try servant._iceD_opStruct(incoming: request, current: current)
        case "opVoid":
            return try servant._iceD_opVoid(incoming: request, current: current)
        case "opWStringLiterals":
            return try servant._iceD_opWStringLiterals(incoming: request, current: current)
        case "shutdown":
            return try servant._iceD_shutdown(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol MyClass {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func shutdown(current: Ice.Current) throws

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func opVoid(current: Ice.Current) throws

    ///
    /// - parameter p1: `Swift.UInt8`
    ///
    /// - parameter p2: `Swift.UInt8`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: Swift.UInt8, p3: Swift.UInt8)`:
    ///
    ///   - returnValue: `Swift.UInt8`
    ///
    ///   - p3: `Swift.UInt8`
    func opByte(p1: Swift.UInt8, p2: Swift.UInt8, current: Ice.Current) throws -> (returnValue: Swift.UInt8, p3: Swift.UInt8)

    ///
    /// - parameter p1: `Swift.Bool`
    ///
    /// - parameter p2: `Swift.Bool`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: Swift.Bool, p3: Swift.Bool)`:
    ///
    ///   - returnValue: `Swift.Bool`
    ///
    ///   - p3: `Swift.Bool`
    func opBool(p1: Swift.Bool, p2: Swift.Bool, current: Ice.Current) throws -> (returnValue: Swift.Bool, p3: Swift.Bool)

    ///
    /// - parameter p1: `Swift.Int16`
    ///
    /// - parameter p2: `Swift.Int32`
    ///
    /// - parameter p3: `Swift.Int64`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: Swift.Int64, p4: Swift.Int16, p5: Swift.Int32, p6: Swift.Int64)`:
    ///
    ///   - returnValue: `Swift.Int64`
    ///
    ///   - p4: `Swift.Int16`
    ///
    ///   - p5: `Swift.Int32`
    ///
    ///   - p6: `Swift.Int64`
    func opShortIntLong(p1: Swift.Int16, p2: Swift.Int32, p3: Swift.Int64, current: Ice.Current) throws -> (returnValue: Swift.Int64, p4: Swift.Int16, p5: Swift.Int32, p6: Swift.Int64)

    ///
    /// - parameter p1: `Swift.Float`
    ///
    /// - parameter p2: `Swift.Double`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: Swift.Double, p3: Swift.Float, p4: Swift.Double)`:
    ///
    ///   - returnValue: `Swift.Double`
    ///
    ///   - p3: `Swift.Float`
    ///
    ///   - p4: `Swift.Double`
    func opFloatDouble(p1: Swift.Float, p2: Swift.Double, current: Ice.Current) throws -> (returnValue: Swift.Double, p3: Swift.Float, p4: Swift.Double)

    ///
    /// - parameter p1: `Swift.String`
    ///
    /// - parameter p2: `Swift.String`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: Swift.String, p3: Swift.String)`:
    ///
    ///   - returnValue: `Swift.String`
    ///
    ///   - p3: `Swift.String`
    func opString(p1: Swift.String, p2: Swift.String, current: Ice.Current) throws -> (returnValue: Swift.String, p3: Swift.String)

    ///
    /// - parameter p1: `MyEnum`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: MyEnum, p2: MyEnum)`:
    ///
    ///   - returnValue: `MyEnum`
    ///
    ///   - p2: `MyEnum`
    func opMyEnum(p1: MyEnum, current: Ice.Current) throws -> (returnValue: MyEnum, p2: MyEnum)

    ///
    /// - parameter p1: `MyClassPrx?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: MyClassPrx?, p2: MyClassPrx?, p3: MyClassPrx?)`:
    ///
    ///   - returnValue: `MyClassPrx?`
    ///
    ///   - p2: `MyClassPrx?`
    ///
    ///   - p3: `MyClassPrx?`
    func opMyClass(p1: MyClassPrx?, current: Ice.Current) throws -> (returnValue: MyClassPrx?, p2: MyClassPrx?, p3: MyClassPrx?)

    ///
    /// - parameter p1: `Structure`
    ///
    /// - parameter p2: `Structure`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: Structure, p3: Structure)`:
    ///
    ///   - returnValue: `Structure`
    ///
    ///   - p3: `Structure`
    func opStruct(p1: Structure, p2: Structure, current: Ice.Current) throws -> (returnValue: Structure, p3: Structure)

    ///
    /// - parameter p1: `ByteS`
    ///
    /// - parameter p2: `ByteS`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: ByteS, p3: ByteS)`:
    ///
    ///   - returnValue: `ByteS`
    ///
    ///   - p3: `ByteS`
    func opByteS(p1: ByteS, p2: ByteS, current: Ice.Current) throws -> (returnValue: ByteS, p3: ByteS)

    ///
    /// - parameter p1: `BoolS`
    ///
    /// - parameter p2: `BoolS`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: BoolS, p3: BoolS)`:
    ///
    ///   - returnValue: `BoolS`
    ///
    ///   - p3: `BoolS`
    func opBoolS(p1: BoolS, p2: BoolS, current: Ice.Current) throws -> (returnValue: BoolS, p3: BoolS)

    ///
    /// - parameter p1: `ShortS`
    ///
    /// - parameter p2: `IntS`
    ///
    /// - parameter p3: `LongS`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: LongS, p4: ShortS, p5: IntS, p6: LongS)`:
    ///
    ///   - returnValue: `LongS`
    ///
    ///   - p4: `ShortS`
    ///
    ///   - p5: `IntS`
    ///
    ///   - p6: `LongS`
    func opShortIntLongS(p1: ShortS, p2: IntS, p3: LongS, current: Ice.Current) throws -> (returnValue: LongS, p4: ShortS, p5: IntS, p6: LongS)

    ///
    /// - parameter p1: `FloatS`
    ///
    /// - parameter p2: `DoubleS`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: DoubleS, p3: FloatS, p4: DoubleS)`:
    ///
    ///   - returnValue: `DoubleS`
    ///
    ///   - p3: `FloatS`
    ///
    ///   - p4: `DoubleS`
    func opFloatDoubleS(p1: FloatS, p2: DoubleS, current: Ice.Current) throws -> (returnValue: DoubleS, p3: FloatS, p4: DoubleS)

    ///
    /// - parameter p1: `StringS`
    ///
    /// - parameter p2: `StringS`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: StringS, p3: StringS)`:
    ///
    ///   - returnValue: `StringS`
    ///
    ///   - p3: `StringS`
    func opStringS(p1: StringS, p2: StringS, current: Ice.Current) throws -> (returnValue: StringS, p3: StringS)

    ///
    /// - parameter p1: `ByteSS`
    ///
    /// - parameter p2: `ByteSS`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: ByteSS, p3: ByteSS)`:
    ///
    ///   - returnValue: `ByteSS`
    ///
    ///   - p3: `ByteSS`
    func opByteSS(p1: ByteSS, p2: ByteSS, current: Ice.Current) throws -> (returnValue: ByteSS, p3: ByteSS)

    ///
    /// - parameter p1: `BoolSS`
    ///
    /// - parameter p2: `BoolSS`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: BoolSS, p3: BoolSS)`:
    ///
    ///   - returnValue: `BoolSS`
    ///
    ///   - p3: `BoolSS`
    func opBoolSS(p1: BoolSS, p2: BoolSS, current: Ice.Current) throws -> (returnValue: BoolSS, p3: BoolSS)

    ///
    /// - parameter p1: `ShortSS`
    ///
    /// - parameter p2: `IntSS`
    ///
    /// - parameter p3: `LongSS`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: LongSS, p4: ShortSS, p5: IntSS, p6: LongSS)`:
    ///
    ///   - returnValue: `LongSS`
    ///
    ///   - p4: `ShortSS`
    ///
    ///   - p5: `IntSS`
    ///
    ///   - p6: `LongSS`
    func opShortIntLongSS(p1: ShortSS, p2: IntSS, p3: LongSS, current: Ice.Current) throws -> (returnValue: LongSS, p4: ShortSS, p5: IntSS, p6: LongSS)

    ///
    /// - parameter p1: `FloatSS`
    ///
    /// - parameter p2: `DoubleSS`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: DoubleSS, p3: FloatSS, p4: DoubleSS)`:
    ///
    ///   - returnValue: `DoubleSS`
    ///
    ///   - p3: `FloatSS`
    ///
    ///   - p4: `DoubleSS`
    func opFloatDoubleSS(p1: FloatSS, p2: DoubleSS, current: Ice.Current) throws -> (returnValue: DoubleSS, p3: FloatSS, p4: DoubleSS)

    ///
    /// - parameter p1: `StringSS`
    ///
    /// - parameter p2: `StringSS`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: StringSS, p3: StringSS)`:
    ///
    ///   - returnValue: `StringSS`
    ///
    ///   - p3: `StringSS`
    func opStringSS(p1: StringSS, p2: StringSS, current: Ice.Current) throws -> (returnValue: StringSS, p3: StringSS)

    ///
    /// - parameter p1: `StringSSS`
    ///
    /// - parameter p2: `StringSSS`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: StringSSS, p3: StringSSS)`:
    ///
    ///   - returnValue: `StringSSS`
    ///
    ///   - p3: `StringSSS`
    func opStringSSS(p1: StringSSS, p2: StringSSS, current: Ice.Current) throws -> (returnValue: StringSSS, p3: StringSSS)

    ///
    /// - parameter p1: `ByteBoolD`
    ///
    /// - parameter p2: `ByteBoolD`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: ByteBoolD, p3: ByteBoolD)`:
    ///
    ///   - returnValue: `ByteBoolD`
    ///
    ///   - p3: `ByteBoolD`
    func opByteBoolD(p1: ByteBoolD, p2: ByteBoolD, current: Ice.Current) throws -> (returnValue: ByteBoolD, p3: ByteBoolD)

    ///
    /// - parameter p1: `ShortIntD`
    ///
    /// - parameter p2: `ShortIntD`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: ShortIntD, p3: ShortIntD)`:
    ///
    ///   - returnValue: `ShortIntD`
    ///
    ///   - p3: `ShortIntD`
    func opShortIntD(p1: ShortIntD, p2: ShortIntD, current: Ice.Current) throws -> (returnValue: ShortIntD, p3: ShortIntD)

    ///
    /// - parameter p1: `LongFloatD`
    ///
    /// - parameter p2: `LongFloatD`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: LongFloatD, p3: LongFloatD)`:
    ///
    ///   - returnValue: `LongFloatD`
    ///
    ///   - p3: `LongFloatD`
    func opLongFloatD(p1: LongFloatD, p2: LongFloatD, current: Ice.Current) throws -> (returnValue: LongFloatD, p3: LongFloatD)

    ///
    /// - parameter p1: `StringStringD`
    ///
    /// - parameter p2: `StringStringD`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: StringStringD, p3: StringStringD)`:
    ///
    ///   - returnValue: `StringStringD`
    ///
    ///   - p3: `StringStringD`
    func opStringStringD(p1: StringStringD, p2: StringStringD, current: Ice.Current) throws -> (returnValue: StringStringD, p3: StringStringD)

    ///
    /// - parameter p1: `StringMyEnumD`
    ///
    /// - parameter p2: `StringMyEnumD`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: StringMyEnumD, p3: StringMyEnumD)`:
    ///
    ///   - returnValue: `StringMyEnumD`
    ///
    ///   - p3: `StringMyEnumD`
    func opStringMyEnumD(p1: StringMyEnumD, p2: StringMyEnumD, current: Ice.Current) throws -> (returnValue: StringMyEnumD, p3: StringMyEnumD)

    ///
    /// - parameter p1: `MyEnumStringD`
    ///
    /// - parameter p2: `MyEnumStringD`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: MyEnumStringD, p3: MyEnumStringD)`:
    ///
    ///   - returnValue: `MyEnumStringD`
    ///
    ///   - p3: `MyEnumStringD`
    func opMyEnumStringD(p1: MyEnumStringD, p2: MyEnumStringD, current: Ice.Current) throws -> (returnValue: MyEnumStringD, p3: MyEnumStringD)

    ///
    /// - parameter p1: `MyStructMyEnumD`
    ///
    /// - parameter p2: `MyStructMyEnumD`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: MyStructMyEnumD, p3: MyStructMyEnumD)`:
    ///
    ///   - returnValue: `MyStructMyEnumD`
    ///
    ///   - p3: `MyStructMyEnumD`
    func opMyStructMyEnumD(p1: MyStructMyEnumD, p2: MyStructMyEnumD, current: Ice.Current) throws -> (returnValue: MyStructMyEnumD, p3: MyStructMyEnumD)

    ///
    /// - parameter p1: `ByteBoolDS`
    ///
    /// - parameter p2: `ByteBoolDS`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: ByteBoolDS, p3: ByteBoolDS)`:
    ///
    ///   - returnValue: `ByteBoolDS`
    ///
    ///   - p3: `ByteBoolDS`
    func opByteBoolDS(p1: ByteBoolDS, p2: ByteBoolDS, current: Ice.Current) throws -> (returnValue: ByteBoolDS, p3: ByteBoolDS)

    ///
    /// - parameter p1: `ShortIntDS`
    ///
    /// - parameter p2: `ShortIntDS`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: ShortIntDS, p3: ShortIntDS)`:
    ///
    ///   - returnValue: `ShortIntDS`
    ///
    ///   - p3: `ShortIntDS`
    func opShortIntDS(p1: ShortIntDS, p2: ShortIntDS, current: Ice.Current) throws -> (returnValue: ShortIntDS, p3: ShortIntDS)

    ///
    /// - parameter p1: `LongFloatDS`
    ///
    /// - parameter p2: `LongFloatDS`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: LongFloatDS, p3: LongFloatDS)`:
    ///
    ///   - returnValue: `LongFloatDS`
    ///
    ///   - p3: `LongFloatDS`
    func opLongFloatDS(p1: LongFloatDS, p2: LongFloatDS, current: Ice.Current) throws -> (returnValue: LongFloatDS, p3: LongFloatDS)

    ///
    /// - parameter p1: `StringStringDS`
    ///
    /// - parameter p2: `StringStringDS`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: StringStringDS, p3: StringStringDS)`:
    ///
    ///   - returnValue: `StringStringDS`
    ///
    ///   - p3: `StringStringDS`
    func opStringStringDS(p1: StringStringDS, p2: StringStringDS, current: Ice.Current) throws -> (returnValue: StringStringDS, p3: StringStringDS)

    ///
    /// - parameter p1: `StringMyEnumDS`
    ///
    /// - parameter p2: `StringMyEnumDS`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: StringMyEnumDS, p3: StringMyEnumDS)`:
    ///
    ///   - returnValue: `StringMyEnumDS`
    ///
    ///   - p3: `StringMyEnumDS`
    func opStringMyEnumDS(p1: StringMyEnumDS, p2: StringMyEnumDS, current: Ice.Current) throws -> (returnValue: StringMyEnumDS, p3: StringMyEnumDS)

    ///
    /// - parameter p1: `MyEnumStringDS`
    ///
    /// - parameter p2: `MyEnumStringDS`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: MyEnumStringDS, p3: MyEnumStringDS)`:
    ///
    ///   - returnValue: `MyEnumStringDS`
    ///
    ///   - p3: `MyEnumStringDS`
    func opMyEnumStringDS(p1: MyEnumStringDS, p2: MyEnumStringDS, current: Ice.Current) throws -> (returnValue: MyEnumStringDS, p3: MyEnumStringDS)

    ///
    /// - parameter p1: `MyStructMyEnumDS`
    ///
    /// - parameter p2: `MyStructMyEnumDS`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: MyStructMyEnumDS, p3: MyStructMyEnumDS)`:
    ///
    ///   - returnValue: `MyStructMyEnumDS`
    ///
    ///   - p3: `MyStructMyEnumDS`
    func opMyStructMyEnumDS(p1: MyStructMyEnumDS, p2: MyStructMyEnumDS, current: Ice.Current) throws -> (returnValue: MyStructMyEnumDS, p3: MyStructMyEnumDS)

    ///
    /// - parameter p1: `ByteByteSD`
    ///
    /// - parameter p2: `ByteByteSD`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: ByteByteSD, p3: ByteByteSD)`:
    ///
    ///   - returnValue: `ByteByteSD`
    ///
    ///   - p3: `ByteByteSD`
    func opByteByteSD(p1: ByteByteSD, p2: ByteByteSD, current: Ice.Current) throws -> (returnValue: ByteByteSD, p3: ByteByteSD)

    ///
    /// - parameter p1: `BoolBoolSD`
    ///
    /// - parameter p2: `BoolBoolSD`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: BoolBoolSD, p3: BoolBoolSD)`:
    ///
    ///   - returnValue: `BoolBoolSD`
    ///
    ///   - p3: `BoolBoolSD`
    func opBoolBoolSD(p1: BoolBoolSD, p2: BoolBoolSD, current: Ice.Current) throws -> (returnValue: BoolBoolSD, p3: BoolBoolSD)

    ///
    /// - parameter p1: `ShortShortSD`
    ///
    /// - parameter p2: `ShortShortSD`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: ShortShortSD, p3: ShortShortSD)`:
    ///
    ///   - returnValue: `ShortShortSD`
    ///
    ///   - p3: `ShortShortSD`
    func opShortShortSD(p1: ShortShortSD, p2: ShortShortSD, current: Ice.Current) throws -> (returnValue: ShortShortSD, p3: ShortShortSD)

    ///
    /// - parameter p1: `IntIntSD`
    ///
    /// - parameter p2: `IntIntSD`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: IntIntSD, p3: IntIntSD)`:
    ///
    ///   - returnValue: `IntIntSD`
    ///
    ///   - p3: `IntIntSD`
    func opIntIntSD(p1: IntIntSD, p2: IntIntSD, current: Ice.Current) throws -> (returnValue: IntIntSD, p3: IntIntSD)

    ///
    /// - parameter p1: `LongLongSD`
    ///
    /// - parameter p2: `LongLongSD`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: LongLongSD, p3: LongLongSD)`:
    ///
    ///   - returnValue: `LongLongSD`
    ///
    ///   - p3: `LongLongSD`
    func opLongLongSD(p1: LongLongSD, p2: LongLongSD, current: Ice.Current) throws -> (returnValue: LongLongSD, p3: LongLongSD)

    ///
    /// - parameter p1: `StringFloatSD`
    ///
    /// - parameter p2: `StringFloatSD`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: StringFloatSD, p3: StringFloatSD)`:
    ///
    ///   - returnValue: `StringFloatSD`
    ///
    ///   - p3: `StringFloatSD`
    func opStringFloatSD(p1: StringFloatSD, p2: StringFloatSD, current: Ice.Current) throws -> (returnValue: StringFloatSD, p3: StringFloatSD)

    ///
    /// - parameter p1: `StringDoubleSD`
    ///
    /// - parameter p2: `StringDoubleSD`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: StringDoubleSD, p3: StringDoubleSD)`:
    ///
    ///   - returnValue: `StringDoubleSD`
    ///
    ///   - p3: `StringDoubleSD`
    func opStringDoubleSD(p1: StringDoubleSD, p2: StringDoubleSD, current: Ice.Current) throws -> (returnValue: StringDoubleSD, p3: StringDoubleSD)

    ///
    /// - parameter p1: `StringStringSD`
    ///
    /// - parameter p2: `StringStringSD`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: StringStringSD, p3: StringStringSD)`:
    ///
    ///   - returnValue: `StringStringSD`
    ///
    ///   - p3: `StringStringSD`
    func opStringStringSD(p1: StringStringSD, p2: StringStringSD, current: Ice.Current) throws -> (returnValue: StringStringSD, p3: StringStringSD)

    ///
    /// - parameter p1: `MyEnumMyEnumSD`
    ///
    /// - parameter p2: `MyEnumMyEnumSD`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: MyEnumMyEnumSD, p3: MyEnumMyEnumSD)`:
    ///
    ///   - returnValue: `MyEnumMyEnumSD`
    ///
    ///   - p3: `MyEnumMyEnumSD`
    func opMyEnumMyEnumSD(p1: MyEnumMyEnumSD, p2: MyEnumMyEnumSD, current: Ice.Current) throws -> (returnValue: MyEnumMyEnumSD, p3: MyEnumMyEnumSD)

    ///
    /// - parameter s: `IntS`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `IntS`
    func opIntS(s: IntS, current: Ice.Current) throws -> IntS

    ///
    /// - parameter s: `ByteS`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func opByteSOneway(s: ByteS, current: Ice.Current) throws

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Int32`
    func opByteSOnewayCallCount(current: Ice.Current) throws -> Swift.Int32

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Ice.Context`
    func opContext(current: Ice.Current) throws -> Ice.Context

    ///
    /// - parameter p1: `Swift.Double`
    ///
    /// - parameter p2: `DoubleS`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func opDoubleMarshaling(p1: Swift.Double, p2: DoubleS, current: Ice.Current) throws

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func opIdempotent(current: Ice.Current) throws

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func opNonmutating(current: Ice.Current) throws

    ///
    /// - parameter opByte1: `Swift.UInt8`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.UInt8`
    func opByte1(opByte1: Swift.UInt8, current: Ice.Current) throws -> Swift.UInt8

    ///
    /// - parameter opShort1: `Swift.Int16`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Int16`
    func opShort1(opShort1: Swift.Int16, current: Ice.Current) throws -> Swift.Int16

    ///
    /// - parameter opInt1: `Swift.Int32`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Int32`
    func opInt1(opInt1: Swift.Int32, current: Ice.Current) throws -> Swift.Int32

    ///
    /// - parameter opLong1: `Swift.Int64`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Int64`
    func opLong1(opLong1: Swift.Int64, current: Ice.Current) throws -> Swift.Int64

    ///
    /// - parameter opFloat1: `Swift.Float`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Float`
    func opFloat1(opFloat1: Swift.Float, current: Ice.Current) throws -> Swift.Float

    ///
    /// - parameter opDouble1: `Swift.Double`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.Double`
    func opDouble1(opDouble1: Swift.Double, current: Ice.Current) throws -> Swift.Double

    ///
    /// - parameter opString1: `Swift.String`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String`
    func opString1(opString1: Swift.String, current: Ice.Current) throws -> Swift.String

    ///
    /// - parameter opStringS1: `StringS`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `StringS`
    func opStringS1(opStringS1: StringS, current: Ice.Current) throws -> StringS

    ///
    /// - parameter opByteBoolD1: `ByteBoolD`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `ByteBoolD`
    func opByteBoolD1(opByteBoolD1: ByteBoolD, current: Ice.Current) throws -> ByteBoolD

    ///
    /// - parameter stringS: `StringS`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `StringS`
    func opStringS2(stringS: StringS, current: Ice.Current) throws -> StringS

    ///
    /// - parameter byteBoolD: `ByteBoolD`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `ByteBoolD`
    func opByteBoolD2(byteBoolD: ByteBoolD, current: Ice.Current) throws -> ByteBoolD

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `StringS`
    func opStringLiterals(current: Ice.Current) throws -> StringS

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `StringS`
    func opWStringLiterals(current: Ice.Current) throws -> StringS

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Structure`
    func opMStruct1(current: Ice.Current) throws -> Structure

    ///
    /// - parameter p1: `Structure`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: Structure, p2: Structure)`:
    ///
    ///   - returnValue: `Structure`
    ///
    ///   - p2: `Structure`
    func opMStruct2(p1: Structure, current: Ice.Current) throws -> (returnValue: Structure, p2: Structure)

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `StringS`
    func opMSeq1(current: Ice.Current) throws -> StringS

    ///
    /// - parameter p1: `StringS`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: StringS, p2: StringS)`:
    ///
    ///   - returnValue: `StringS`
    ///
    ///   - p2: `StringS`
    func opMSeq2(p1: StringS, current: Ice.Current) throws -> (returnValue: StringS, p2: StringS)

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `StringStringD`
    func opMDict1(current: Ice.Current) throws -> StringStringD

    ///
    /// - parameter p1: `StringStringD`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `(returnValue: StringStringD, p2: StringStringD)`:
    ///
    ///   - returnValue: `StringStringD`
    ///
    ///   - p2: `StringStringD`
    func opMDict2(p1: StringStringD, current: Ice.Current) throws -> (returnValue: StringStringD, p2: StringStringD)
}


/// Dispatcher for `MyDerivedClass` servants.
public struct MyDerivedClassDisp: Ice.Disp {
    public let servant: MyDerivedClass
    private static let defaultObject = Ice.ObjectI<MyDerivedClassTraits>()

    public init(_ servant: MyDerivedClass) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "ice_id":
            return try (servant as? Object ?? MyDerivedClassDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? MyDerivedClassDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? MyDerivedClassDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? MyDerivedClassDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "opBool":
            return try servant._iceD_opBool(incoming: request, current: current)
        case "opBoolBoolSD":
            return try servant._iceD_opBoolBoolSD(incoming: request, current: current)
        case "opBoolS":
            return try servant._iceD_opBoolS(incoming: request, current: current)
        case "opBoolSS":
            return try servant._iceD_opBoolSS(incoming: request, current: current)
        case "opByte":
            return try servant._iceD_opByte(incoming: request, current: current)
        case "opByte1":
            return try servant._iceD_opByte1(incoming: request, current: current)
        case "opByteBoolD":
            return try servant._iceD_opByteBoolD(incoming: request, current: current)
        case "opByteBoolD1":
            return try servant._iceD_opByteBoolD1(incoming: request, current: current)
        case "opByteBoolD2":
            return try servant._iceD_opByteBoolD2(incoming: request, current: current)
        case "opByteBoolDS":
            return try servant._iceD_opByteBoolDS(incoming: request, current: current)
        case "opByteByteSD":
            return try servant._iceD_opByteByteSD(incoming: request, current: current)
        case "opByteS":
            return try servant._iceD_opByteS(incoming: request, current: current)
        case "opByteSOneway":
            return try servant._iceD_opByteSOneway(incoming: request, current: current)
        case "opByteSOnewayCallCount":
            return try servant._iceD_opByteSOnewayCallCount(incoming: request, current: current)
        case "opByteSS":
            return try servant._iceD_opByteSS(incoming: request, current: current)
        case "opContext":
            return try servant._iceD_opContext(incoming: request, current: current)
        case "opDerived":
            return try servant._iceD_opDerived(incoming: request, current: current)
        case "opDouble1":
            return try servant._iceD_opDouble1(incoming: request, current: current)
        case "opDoubleMarshaling":
            return try servant._iceD_opDoubleMarshaling(incoming: request, current: current)
        case "opFloat1":
            return try servant._iceD_opFloat1(incoming: request, current: current)
        case "opFloatDouble":
            return try servant._iceD_opFloatDouble(incoming: request, current: current)
        case "opFloatDoubleS":
            return try servant._iceD_opFloatDoubleS(incoming: request, current: current)
        case "opFloatDoubleSS":
            return try servant._iceD_opFloatDoubleSS(incoming: request, current: current)
        case "opIdempotent":
            return try servant._iceD_opIdempotent(incoming: request, current: current)
        case "opInt1":
            return try servant._iceD_opInt1(incoming: request, current: current)
        case "opIntIntSD":
            return try servant._iceD_opIntIntSD(incoming: request, current: current)
        case "opIntS":
            return try servant._iceD_opIntS(incoming: request, current: current)
        case "opLong1":
            return try servant._iceD_opLong1(incoming: request, current: current)
        case "opLongFloatD":
            return try servant._iceD_opLongFloatD(incoming: request, current: current)
        case "opLongFloatDS":
            return try servant._iceD_opLongFloatDS(incoming: request, current: current)
        case "opLongLongSD":
            return try servant._iceD_opLongLongSD(incoming: request, current: current)
        case "opMDict1":
            return try servant._iceD_opMDict1(incoming: request, current: current)
        case "opMDict2":
            return try servant._iceD_opMDict2(incoming: request, current: current)
        case "opMSeq1":
            return try servant._iceD_opMSeq1(incoming: request, current: current)
        case "opMSeq2":
            return try servant._iceD_opMSeq2(incoming: request, current: current)
        case "opMStruct1":
            return try servant._iceD_opMStruct1(incoming: request, current: current)
        case "opMStruct2":
            return try servant._iceD_opMStruct2(incoming: request, current: current)
        case "opMyClass":
            return try servant._iceD_opMyClass(incoming: request, current: current)
        case "opMyClass1":
            return try servant._iceD_opMyClass1(incoming: request, current: current)
        case "opMyEnum":
            return try servant._iceD_opMyEnum(incoming: request, current: current)
        case "opMyEnumMyEnumSD":
            return try servant._iceD_opMyEnumMyEnumSD(incoming: request, current: current)
        case "opMyEnumStringD":
            return try servant._iceD_opMyEnumStringD(incoming: request, current: current)
        case "opMyEnumStringDS":
            return try servant._iceD_opMyEnumStringDS(incoming: request, current: current)
        case "opMyStruct1":
            return try servant._iceD_opMyStruct1(incoming: request, current: current)
        case "opMyStructMyEnumD":
            return try servant._iceD_opMyStructMyEnumD(incoming: request, current: current)
        case "opMyStructMyEnumDS":
            return try servant._iceD_opMyStructMyEnumDS(incoming: request, current: current)
        case "opNonmutating":
            return try servant._iceD_opNonmutating(incoming: request, current: current)
        case "opShort1":
            return try servant._iceD_opShort1(incoming: request, current: current)
        case "opShortIntD":
            return try servant._iceD_opShortIntD(incoming: request, current: current)
        case "opShortIntDS":
            return try servant._iceD_opShortIntDS(incoming: request, current: current)
        case "opShortIntLong":
            return try servant._iceD_opShortIntLong(incoming: request, current: current)
        case "opShortIntLongS":
            return try servant._iceD_opShortIntLongS(incoming: request, current: current)
        case "opShortIntLongSS":
            return try servant._iceD_opShortIntLongSS(incoming: request, current: current)
        case "opShortShortSD":
            return try servant._iceD_opShortShortSD(incoming: request, current: current)
        case "opString":
            return try servant._iceD_opString(incoming: request, current: current)
        case "opString1":
            return try servant._iceD_opString1(incoming: request, current: current)
        case "opStringDoubleSD":
            return try servant._iceD_opStringDoubleSD(incoming: request, current: current)
        case "opStringFloatSD":
            return try servant._iceD_opStringFloatSD(incoming: request, current: current)
        case "opStringLiterals":
            return try servant._iceD_opStringLiterals(incoming: request, current: current)
        case "opStringMyEnumD":
            return try servant._iceD_opStringMyEnumD(incoming: request, current: current)
        case "opStringMyEnumDS":
            return try servant._iceD_opStringMyEnumDS(incoming: request, current: current)
        case "opStringS":
            return try servant._iceD_opStringS(incoming: request, current: current)
        case "opStringS1":
            return try servant._iceD_opStringS1(incoming: request, current: current)
        case "opStringS2":
            return try servant._iceD_opStringS2(incoming: request, current: current)
        case "opStringSS":
            return try servant._iceD_opStringSS(incoming: request, current: current)
        case "opStringSSS":
            return try servant._iceD_opStringSSS(incoming: request, current: current)
        case "opStringStringD":
            return try servant._iceD_opStringStringD(incoming: request, current: current)
        case "opStringStringDS":
            return try servant._iceD_opStringStringDS(incoming: request, current: current)
        case "opStringStringSD":
            return try servant._iceD_opStringStringSD(incoming: request, current: current)
        case "opStruct":
            return try servant._iceD_opStruct(incoming: request, current: current)
        case "opVoid":
            return try servant._iceD_opVoid(incoming: request, current: current)
        case "opWStringLiterals":
            return try servant._iceD_opWStringLiterals(incoming: request, current: current)
        case "shutdown":
            return try servant._iceD_shutdown(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol MyDerivedClass: MyClass {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func opDerived(current: Ice.Current) throws

    ///
    /// - parameter opMyClass1: `MyClass1?`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `MyClass1?`
    func opMyClass1(opMyClass1: MyClass1?, current: Ice.Current) throws -> MyClass1?

    ///
    /// - parameter opMyStruct1: `MyStruct1`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `MyStruct1`
    func opMyStruct1(opMyStruct1: MyStruct1, current: Ice.Current) throws -> MyStruct1
}

/// MyClass overview.
///
/// MyClass Methods:
///
///  - shutdown: 
///
///  - opVoid: 
///
///  - opByte: 
///
///  - opBool: 
///
///  - opShortIntLong: 
///
///  - opFloatDouble: 
///
///  - opString: 
///
///  - opMyEnum: 
///
///  - opMyClass: 
///
///  - opStruct: 
///
///  - opByteS: 
///
///  - opBoolS: 
///
///  - opShortIntLongS: 
///
///  - opFloatDoubleS: 
///
///  - opStringS: 
///
///  - opByteSS: 
///
///  - opBoolSS: 
///
///  - opShortIntLongSS: 
///
///  - opFloatDoubleSS: 
///
///  - opStringSS: 
///
///  - opStringSSS: 
///
///  - opByteBoolD: 
///
///  - opShortIntD: 
///
///  - opLongFloatD: 
///
///  - opStringStringD: 
///
///  - opStringMyEnumD: 
///
///  - opMyEnumStringD: 
///
///  - opMyStructMyEnumD: 
///
///  - opByteBoolDS: 
///
///  - opShortIntDS: 
///
///  - opLongFloatDS: 
///
///  - opStringStringDS: 
///
///  - opStringMyEnumDS: 
///
///  - opMyEnumStringDS: 
///
///  - opMyStructMyEnumDS: 
///
///  - opByteByteSD: 
///
///  - opBoolBoolSD: 
///
///  - opShortShortSD: 
///
///  - opIntIntSD: 
///
///  - opLongLongSD: 
///
///  - opStringFloatSD: 
///
///  - opStringDoubleSD: 
///
///  - opStringStringSD: 
///
///  - opMyEnumMyEnumSD: 
///
///  - opIntS: 
///
///  - opByteSOneway: 
///
///  - opByteSOnewayCallCount: 
///
///  - opContext: 
///
///  - opDoubleMarshaling: 
///
///  - opIdempotent: 
///
///  - opNonmutating: 
///
///  - opByte1: 
///
///  - opShort1: 
///
///  - opInt1: 
///
///  - opLong1: 
///
///  - opFloat1: 
///
///  - opDouble1: 
///
///  - opString1: 
///
///  - opStringS1: 
///
///  - opByteBoolD1: 
///
///  - opStringS2: 
///
///  - opByteBoolD2: 
///
///  - opStringLiterals: 
///
///  - opWStringLiterals: 
///
///  - opMStruct1: 
///
///  - opMStruct2: 
///
///  - opMSeq1: 
///
///  - opMSeq2: 
///
///  - opMDict1: 
///
///  - opMDict2: 
public extension MyClass {
    func _iceD_shutdown(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.shutdown(current: current)

        return inS.setResult()
    }

    func _iceD_opVoid(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.opVoid(current: current)

        return inS.setResult()
    }

    func _iceD_opByte(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (Swift.UInt8, Swift.UInt8) = try inS.read { istr in
            let iceP_p1: Swift.UInt8 = try istr.read()
            let iceP_p2: Swift.UInt8 = try istr.read()
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opByte(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_p3)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opBool(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (Swift.Bool, Swift.Bool) = try inS.read { istr in
            let iceP_p1: Swift.Bool = try istr.read()
            let iceP_p2: Swift.Bool = try istr.read()
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opBool(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_p3)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opShortIntLong(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2, iceP_p3): (Swift.Int16, Swift.Int32, Swift.Int64) = try inS.read { istr in
            let iceP_p1: Swift.Int16 = try istr.read()
            let iceP_p2: Swift.Int32 = try istr.read()
            let iceP_p3: Swift.Int64 = try istr.read()
            return (iceP_p1, iceP_p2, iceP_p3)
        }

        let (iceP_returnValue, iceP_p4, iceP_p5, iceP_p6) = try self.opShortIntLong(p1: iceP_p1, p2: iceP_p2, p3: iceP_p3, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_p4)
            ostr.write(iceP_p5)
            ostr.write(iceP_p6)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opFloatDouble(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (Swift.Float, Swift.Double) = try inS.read { istr in
            let iceP_p1: Swift.Float = try istr.read()
            let iceP_p2: Swift.Double = try istr.read()
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3, iceP_p4) = try self.opFloatDouble(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_p3)
            ostr.write(iceP_p4)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opString(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (Swift.String, Swift.String) = try inS.read { istr in
            let iceP_p1: Swift.String = try istr.read()
            let iceP_p2: Swift.String = try istr.read()
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opString(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_p3)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opMyEnum(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_p1: MyEnum = try inS.read { istr in
            let iceP_p1: MyEnum = try istr.read()
            return iceP_p1
        }

        let (iceP_returnValue, iceP_p2) = try self.opMyEnum(p1: iceP_p1, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_p2)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opMyClass(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_p1: MyClassPrx? = try inS.read { istr in
            let iceP_p1: MyClassPrx? = try istr.read(MyClassPrx.self)
            return iceP_p1
        }

        let (iceP_returnValue, iceP_p2, iceP_p3) = try self.opMyClass(p1: iceP_p1, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_p2)
            ostr.write(iceP_p3)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opStruct(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (Structure, Structure) = try inS.read { istr in
            let iceP_p1: Structure = try istr.read()
            let iceP_p2: Structure = try istr.read()
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opStruct(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_p3)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opByteS(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (ByteS, ByteS) = try inS.read { istr in
            let iceP_p1: ByteS = try istr.read()
            let iceP_p2: ByteS = try istr.read()
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opByteS(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_p3)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opBoolS(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (BoolS, BoolS) = try inS.read { istr in
            let iceP_p1: BoolS = try istr.read()
            let iceP_p2: BoolS = try istr.read()
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opBoolS(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_p3)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opShortIntLongS(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2, iceP_p3): (ShortS, IntS, LongS) = try inS.read { istr in
            let iceP_p1: ShortS = try istr.read()
            let iceP_p2: IntS = try istr.read()
            let iceP_p3: LongS = try istr.read()
            return (iceP_p1, iceP_p2, iceP_p3)
        }

        let (iceP_returnValue, iceP_p4, iceP_p5, iceP_p6) = try self.opShortIntLongS(p1: iceP_p1, p2: iceP_p2, p3: iceP_p3, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_p4)
            ostr.write(iceP_p5)
            ostr.write(iceP_p6)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opFloatDoubleS(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (FloatS, DoubleS) = try inS.read { istr in
            let iceP_p1: FloatS = try istr.read()
            let iceP_p2: DoubleS = try istr.read()
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3, iceP_p4) = try self.opFloatDoubleS(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_p3)
            ostr.write(iceP_p4)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opStringS(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (StringS, StringS) = try inS.read { istr in
            let iceP_p1: StringS = try istr.read()
            let iceP_p2: StringS = try istr.read()
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opStringS(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_p3)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opByteSS(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (ByteSS, ByteSS) = try inS.read { istr in
            let iceP_p1: ByteSS = try ByteSSHelper.read(from: istr)
            let iceP_p2: ByteSS = try ByteSSHelper.read(from: istr)
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opByteSS(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            ByteSSHelper.write(to: ostr, value: iceP_p3)
            ByteSSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opBoolSS(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (BoolSS, BoolSS) = try inS.read { istr in
            let iceP_p1: BoolSS = try BoolSSHelper.read(from: istr)
            let iceP_p2: BoolSS = try BoolSSHelper.read(from: istr)
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opBoolSS(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            BoolSSHelper.write(to: ostr, value: iceP_p3)
            BoolSSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opShortIntLongSS(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2, iceP_p3): (ShortSS, IntSS, LongSS) = try inS.read { istr in
            let iceP_p1: ShortSS = try ShortSSHelper.read(from: istr)
            let iceP_p2: IntSS = try IntSSHelper.read(from: istr)
            let iceP_p3: LongSS = try LongSSHelper.read(from: istr)
            return (iceP_p1, iceP_p2, iceP_p3)
        }

        let (iceP_returnValue, iceP_p4, iceP_p5, iceP_p6) = try self.opShortIntLongSS(p1: iceP_p1, p2: iceP_p2, p3: iceP_p3, current: current)

        return inS.setResult{ ostr in
            ShortSSHelper.write(to: ostr, value: iceP_p4)
            IntSSHelper.write(to: ostr, value: iceP_p5)
            LongSSHelper.write(to: ostr, value: iceP_p6)
            LongSSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opFloatDoubleSS(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (FloatSS, DoubleSS) = try inS.read { istr in
            let iceP_p1: FloatSS = try FloatSSHelper.read(from: istr)
            let iceP_p2: DoubleSS = try DoubleSSHelper.read(from: istr)
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3, iceP_p4) = try self.opFloatDoubleSS(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            FloatSSHelper.write(to: ostr, value: iceP_p3)
            DoubleSSHelper.write(to: ostr, value: iceP_p4)
            DoubleSSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opStringSS(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (StringSS, StringSS) = try inS.read { istr in
            let iceP_p1: StringSS = try StringSSHelper.read(from: istr)
            let iceP_p2: StringSS = try StringSSHelper.read(from: istr)
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opStringSS(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            StringSSHelper.write(to: ostr, value: iceP_p3)
            StringSSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opStringSSS(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (StringSSS, StringSSS) = try inS.read { istr in
            let iceP_p1: StringSSS = try StringSSSHelper.read(from: istr)
            let iceP_p2: StringSSS = try StringSSSHelper.read(from: istr)
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opStringSSS(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            StringSSSHelper.write(to: ostr, value: iceP_p3)
            StringSSSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opByteBoolD(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (ByteBoolD, ByteBoolD) = try inS.read { istr in
            let iceP_p1: ByteBoolD = try ByteBoolDHelper.read(from: istr)
            let iceP_p2: ByteBoolD = try ByteBoolDHelper.read(from: istr)
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opByteBoolD(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            ByteBoolDHelper.write(to: ostr, value: iceP_p3)
            ByteBoolDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opShortIntD(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (ShortIntD, ShortIntD) = try inS.read { istr in
            let iceP_p1: ShortIntD = try ShortIntDHelper.read(from: istr)
            let iceP_p2: ShortIntD = try ShortIntDHelper.read(from: istr)
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opShortIntD(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            ShortIntDHelper.write(to: ostr, value: iceP_p3)
            ShortIntDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opLongFloatD(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (LongFloatD, LongFloatD) = try inS.read { istr in
            let iceP_p1: LongFloatD = try LongFloatDHelper.read(from: istr)
            let iceP_p2: LongFloatD = try LongFloatDHelper.read(from: istr)
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opLongFloatD(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            LongFloatDHelper.write(to: ostr, value: iceP_p3)
            LongFloatDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opStringStringD(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (StringStringD, StringStringD) = try inS.read { istr in
            let iceP_p1: StringStringD = try StringStringDHelper.read(from: istr)
            let iceP_p2: StringStringD = try StringStringDHelper.read(from: istr)
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opStringStringD(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            StringStringDHelper.write(to: ostr, value: iceP_p3)
            StringStringDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opStringMyEnumD(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (StringMyEnumD, StringMyEnumD) = try inS.read { istr in
            let iceP_p1: StringMyEnumD = try StringMyEnumDHelper.read(from: istr)
            let iceP_p2: StringMyEnumD = try StringMyEnumDHelper.read(from: istr)
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opStringMyEnumD(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            StringMyEnumDHelper.write(to: ostr, value: iceP_p3)
            StringMyEnumDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opMyEnumStringD(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (MyEnumStringD, MyEnumStringD) = try inS.read { istr in
            let iceP_p1: MyEnumStringD = try MyEnumStringDHelper.read(from: istr)
            let iceP_p2: MyEnumStringD = try MyEnumStringDHelper.read(from: istr)
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opMyEnumStringD(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            MyEnumStringDHelper.write(to: ostr, value: iceP_p3)
            MyEnumStringDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opMyStructMyEnumD(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (MyStructMyEnumD, MyStructMyEnumD) = try inS.read { istr in
            let iceP_p1: MyStructMyEnumD = try MyStructMyEnumDHelper.read(from: istr)
            let iceP_p2: MyStructMyEnumD = try MyStructMyEnumDHelper.read(from: istr)
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opMyStructMyEnumD(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            MyStructMyEnumDHelper.write(to: ostr, value: iceP_p3)
            MyStructMyEnumDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opByteBoolDS(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (ByteBoolDS, ByteBoolDS) = try inS.read { istr in
            let iceP_p1: ByteBoolDS = try ByteBoolDSHelper.read(from: istr)
            let iceP_p2: ByteBoolDS = try ByteBoolDSHelper.read(from: istr)
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opByteBoolDS(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            ByteBoolDSHelper.write(to: ostr, value: iceP_p3)
            ByteBoolDSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opShortIntDS(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (ShortIntDS, ShortIntDS) = try inS.read { istr in
            let iceP_p1: ShortIntDS = try ShortIntDSHelper.read(from: istr)
            let iceP_p2: ShortIntDS = try ShortIntDSHelper.read(from: istr)
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opShortIntDS(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            ShortIntDSHelper.write(to: ostr, value: iceP_p3)
            ShortIntDSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opLongFloatDS(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (LongFloatDS, LongFloatDS) = try inS.read { istr in
            let iceP_p1: LongFloatDS = try LongFloatDSHelper.read(from: istr)
            let iceP_p2: LongFloatDS = try LongFloatDSHelper.read(from: istr)
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opLongFloatDS(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            LongFloatDSHelper.write(to: ostr, value: iceP_p3)
            LongFloatDSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opStringStringDS(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (StringStringDS, StringStringDS) = try inS.read { istr in
            let iceP_p1: StringStringDS = try StringStringDSHelper.read(from: istr)
            let iceP_p2: StringStringDS = try StringStringDSHelper.read(from: istr)
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opStringStringDS(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            StringStringDSHelper.write(to: ostr, value: iceP_p3)
            StringStringDSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opStringMyEnumDS(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (StringMyEnumDS, StringMyEnumDS) = try inS.read { istr in
            let iceP_p1: StringMyEnumDS = try StringMyEnumDSHelper.read(from: istr)
            let iceP_p2: StringMyEnumDS = try StringMyEnumDSHelper.read(from: istr)
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opStringMyEnumDS(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            StringMyEnumDSHelper.write(to: ostr, value: iceP_p3)
            StringMyEnumDSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opMyEnumStringDS(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (MyEnumStringDS, MyEnumStringDS) = try inS.read { istr in
            let iceP_p1: MyEnumStringDS = try MyEnumStringDSHelper.read(from: istr)
            let iceP_p2: MyEnumStringDS = try MyEnumStringDSHelper.read(from: istr)
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opMyEnumStringDS(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            MyEnumStringDSHelper.write(to: ostr, value: iceP_p3)
            MyEnumStringDSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opMyStructMyEnumDS(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (MyStructMyEnumDS, MyStructMyEnumDS) = try inS.read { istr in
            let iceP_p1: MyStructMyEnumDS = try MyStructMyEnumDSHelper.read(from: istr)
            let iceP_p2: MyStructMyEnumDS = try MyStructMyEnumDSHelper.read(from: istr)
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opMyStructMyEnumDS(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            MyStructMyEnumDSHelper.write(to: ostr, value: iceP_p3)
            MyStructMyEnumDSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opByteByteSD(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (ByteByteSD, ByteByteSD) = try inS.read { istr in
            let iceP_p1: ByteByteSD = try ByteByteSDHelper.read(from: istr)
            let iceP_p2: ByteByteSD = try ByteByteSDHelper.read(from: istr)
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opByteByteSD(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            ByteByteSDHelper.write(to: ostr, value: iceP_p3)
            ByteByteSDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opBoolBoolSD(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (BoolBoolSD, BoolBoolSD) = try inS.read { istr in
            let iceP_p1: BoolBoolSD = try BoolBoolSDHelper.read(from: istr)
            let iceP_p2: BoolBoolSD = try BoolBoolSDHelper.read(from: istr)
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opBoolBoolSD(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            BoolBoolSDHelper.write(to: ostr, value: iceP_p3)
            BoolBoolSDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opShortShortSD(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (ShortShortSD, ShortShortSD) = try inS.read { istr in
            let iceP_p1: ShortShortSD = try ShortShortSDHelper.read(from: istr)
            let iceP_p2: ShortShortSD = try ShortShortSDHelper.read(from: istr)
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opShortShortSD(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            ShortShortSDHelper.write(to: ostr, value: iceP_p3)
            ShortShortSDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opIntIntSD(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (IntIntSD, IntIntSD) = try inS.read { istr in
            let iceP_p1: IntIntSD = try IntIntSDHelper.read(from: istr)
            let iceP_p2: IntIntSD = try IntIntSDHelper.read(from: istr)
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opIntIntSD(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            IntIntSDHelper.write(to: ostr, value: iceP_p3)
            IntIntSDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opLongLongSD(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (LongLongSD, LongLongSD) = try inS.read { istr in
            let iceP_p1: LongLongSD = try LongLongSDHelper.read(from: istr)
            let iceP_p2: LongLongSD = try LongLongSDHelper.read(from: istr)
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opLongLongSD(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            LongLongSDHelper.write(to: ostr, value: iceP_p3)
            LongLongSDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opStringFloatSD(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (StringFloatSD, StringFloatSD) = try inS.read { istr in
            let iceP_p1: StringFloatSD = try StringFloatSDHelper.read(from: istr)
            let iceP_p2: StringFloatSD = try StringFloatSDHelper.read(from: istr)
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opStringFloatSD(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            StringFloatSDHelper.write(to: ostr, value: iceP_p3)
            StringFloatSDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opStringDoubleSD(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (StringDoubleSD, StringDoubleSD) = try inS.read { istr in
            let iceP_p1: StringDoubleSD = try StringDoubleSDHelper.read(from: istr)
            let iceP_p2: StringDoubleSD = try StringDoubleSDHelper.read(from: istr)
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opStringDoubleSD(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            StringDoubleSDHelper.write(to: ostr, value: iceP_p3)
            StringDoubleSDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opStringStringSD(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (StringStringSD, StringStringSD) = try inS.read { istr in
            let iceP_p1: StringStringSD = try StringStringSDHelper.read(from: istr)
            let iceP_p2: StringStringSD = try StringStringSDHelper.read(from: istr)
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opStringStringSD(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            StringStringSDHelper.write(to: ostr, value: iceP_p3)
            StringStringSDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opMyEnumMyEnumSD(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (MyEnumMyEnumSD, MyEnumMyEnumSD) = try inS.read { istr in
            let iceP_p1: MyEnumMyEnumSD = try MyEnumMyEnumSDHelper.read(from: istr)
            let iceP_p2: MyEnumMyEnumSD = try MyEnumMyEnumSDHelper.read(from: istr)
            return (iceP_p1, iceP_p2)
        }

        let (iceP_returnValue, iceP_p3) = try self.opMyEnumMyEnumSD(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult{ ostr in
            MyEnumMyEnumSDHelper.write(to: ostr, value: iceP_p3)
            MyEnumMyEnumSDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opIntS(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_s: IntS = try inS.read { istr in
            let iceP_s: IntS = try istr.read()
            return iceP_s
        }

        let iceP_returnValue = try self.opIntS(s: iceP_s, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opByteSOneway(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_s: ByteS = try inS.read { istr in
            let iceP_s: ByteS = try istr.read()
            return iceP_s
        }

        try self.opByteSOneway(s: iceP_s, current: current)

        return inS.setResult()
    }

    func _iceD_opByteSOnewayCallCount(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.opByteSOnewayCallCount(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opContext(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.opContext(current: current)

        return inS.setResult{ ostr in
            Ice.ContextHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opDoubleMarshaling(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let (iceP_p1, iceP_p2): (Swift.Double, DoubleS) = try inS.read { istr in
            let iceP_p1: Swift.Double = try istr.read()
            let iceP_p2: DoubleS = try istr.read()
            return (iceP_p1, iceP_p2)
        }

        try self.opDoubleMarshaling(p1: iceP_p1, p2: iceP_p2, current: current)

        return inS.setResult()
    }

    func _iceD_opIdempotent(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.opIdempotent(current: current)

        return inS.setResult()
    }

    func _iceD_opNonmutating(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.opNonmutating(current: current)

        return inS.setResult()
    }

    func _iceD_opByte1(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_opByte1: Swift.UInt8 = try inS.read { istr in
            let iceP_opByte1: Swift.UInt8 = try istr.read()
            return iceP_opByte1
        }

        let iceP_returnValue = try self.opByte1(opByte1: iceP_opByte1, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opShort1(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_opShort1: Swift.Int16 = try inS.read { istr in
            let iceP_opShort1: Swift.Int16 = try istr.read()
            return iceP_opShort1
        }

        let iceP_returnValue = try self.opShort1(opShort1: iceP_opShort1, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opInt1(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_opInt1: Swift.Int32 = try inS.read { istr in
            let iceP_opInt1: Swift.Int32 = try istr.read()
            return iceP_opInt1
        }

        let iceP_returnValue = try self.opInt1(opInt1: iceP_opInt1, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opLong1(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_opLong1: Swift.Int64 = try inS.read { istr in
            let iceP_opLong1: Swift.Int64 = try istr.read()
            return iceP_opLong1
        }

        let iceP_returnValue = try self.opLong1(opLong1: iceP_opLong1, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opFloat1(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_opFloat1: Swift.Float = try inS.read { istr in
            let iceP_opFloat1: Swift.Float = try istr.read()
            return iceP_opFloat1
        }

        let iceP_returnValue = try self.opFloat1(opFloat1: iceP_opFloat1, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opDouble1(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_opDouble1: Swift.Double = try inS.read { istr in
            let iceP_opDouble1: Swift.Double = try istr.read()
            return iceP_opDouble1
        }

        let iceP_returnValue = try self.opDouble1(opDouble1: iceP_opDouble1, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opString1(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_opString1: Swift.String = try inS.read { istr in
            let iceP_opString1: Swift.String = try istr.read()
            return iceP_opString1
        }

        let iceP_returnValue = try self.opString1(opString1: iceP_opString1, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opStringS1(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_opStringS1: StringS = try inS.read { istr in
            let iceP_opStringS1: StringS = try istr.read()
            return iceP_opStringS1
        }

        let iceP_returnValue = try self.opStringS1(opStringS1: iceP_opStringS1, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opByteBoolD1(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_opByteBoolD1: ByteBoolD = try inS.read { istr in
            let iceP_opByteBoolD1: ByteBoolD = try ByteBoolDHelper.read(from: istr)
            return iceP_opByteBoolD1
        }

        let iceP_returnValue = try self.opByteBoolD1(opByteBoolD1: iceP_opByteBoolD1, current: current)

        return inS.setResult{ ostr in
            ByteBoolDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opStringS2(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_stringS: StringS = try inS.read { istr in
            let iceP_stringS: StringS = try istr.read()
            return iceP_stringS
        }

        let iceP_returnValue = try self.opStringS2(stringS: iceP_stringS, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opByteBoolD2(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_byteBoolD: ByteBoolD = try inS.read { istr in
            let iceP_byteBoolD: ByteBoolD = try ByteBoolDHelper.read(from: istr)
            return iceP_byteBoolD
        }

        let iceP_returnValue = try self.opByteBoolD2(byteBoolD: iceP_byteBoolD, current: current)

        return inS.setResult{ ostr in
            ByteBoolDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opStringLiterals(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.opStringLiterals(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opWStringLiterals(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.opWStringLiterals(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opMStruct1(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.opMStruct1(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opMStruct2(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_p1: Structure = try inS.read { istr in
            let iceP_p1: Structure = try istr.read()
            return iceP_p1
        }

        let (iceP_returnValue, iceP_p2) = try self.opMStruct2(p1: iceP_p1, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_p2)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opMSeq1(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.opMSeq1(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opMSeq2(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_p1: StringS = try inS.read { istr in
            let iceP_p1: StringS = try istr.read()
            return iceP_p1
        }

        let (iceP_returnValue, iceP_p2) = try self.opMSeq2(p1: iceP_p1, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_p2)
            ostr.write(iceP_returnValue)
        }
    }

    func _iceD_opMDict1(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.opMDict1(current: current)

        return inS.setResult{ ostr in
            StringStringDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    func _iceD_opMDict2(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_p1: StringStringD = try inS.read { istr in
            let iceP_p1: StringStringD = try StringStringDHelper.read(from: istr)
            return iceP_p1
        }

        let (iceP_returnValue, iceP_p2) = try self.opMDict2(p1: iceP_p1, current: current)

        return inS.setResult{ ostr in
            StringStringDHelper.write(to: ostr, value: iceP_p2)
            StringStringDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }
}

/// MyDerivedClass overview.
///
/// MyDerivedClass Methods:
///
///  - opDerived: 
///
///  - opMyClass1: 
///
///  - opMyStruct1: 
public extension MyDerivedClass {
    func _iceD_opDerived(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.opDerived(current: current)

        return inS.setResult()
    }

    func _iceD_opMyClass1(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_opMyClass1: MyClass1? = try inS.read { istr in
            var iceP_opMyClass1: MyClass1?
            try istr.read(MyClass1.self) { iceP_opMyClass1 = $0 }
            try istr.readPendingValues()
            return iceP_opMyClass1
        }

        let iceP_returnValue = try self.opMyClass1(opMyClass1: iceP_opMyClass1, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    func _iceD_opMyStruct1(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        let iceP_opMyStruct1: MyStruct1 = try inS.read { istr in
            let iceP_opMyStruct1: MyStruct1 = try istr.read()
            return iceP_opMyStruct1
        }

        let iceP_returnValue = try self.opMyStruct1(opMyStruct1: iceP_opMyStruct1, current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }
}
