//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `TestAMD.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice

public typealias AByteS = Foundation.Data

public typealias LByteS = Foundation.Data

public typealias KByteS = Foundation.Data

public typealias QByteS = Foundation.Data

public typealias SByteS = Foundation.Data

public typealias ABoolS = [Swift.Bool]

public typealias LBoolS = [Swift.Bool]

public typealias KBoolS = [Swift.Bool]

public typealias QBoolS = [Swift.Bool]

public typealias SBoolS = [Swift.Bool]

public typealias AShortS = [Swift.Int16]

public typealias LShortS = [Swift.Int16]

public typealias KShortS = [Swift.Int16]

public typealias QShortS = [Swift.Int16]

public typealias SShortS = [Swift.Int16]

public typealias AIntS = [Swift.Int32]

public typealias LIntS = [Swift.Int32]

public typealias KIntS = [Swift.Int32]

public typealias QIntS = [Swift.Int32]

public typealias SIntS = [Swift.Int32]

public typealias ALongS = [Swift.Int64]

public typealias LLongS = [Swift.Int64]

public typealias KLongS = [Swift.Int64]

public typealias QLongS = [Swift.Int64]

public typealias SLongS = [Swift.Int64]

public typealias AFloatS = [Swift.Float]

public typealias LFloatS = [Swift.Float]

public typealias KFloatS = [Swift.Float]

public typealias QFloatS = [Swift.Float]

public typealias SFloatS = [Swift.Float]

public typealias ADoubleS = [Swift.Double]

public typealias LDoubleS = [Swift.Double]

public typealias KDoubleS = [Swift.Double]

public typealias QDoubleS = [Swift.Double]

public typealias SDoubleS = [Swift.Double]

public typealias AStringS = [Swift.String]

public typealias LStringS = [Swift.String]

public typealias KStringS = [Swift.String]

public typealias QStringS = [Swift.String]

public typealias SStringS = [Swift.String]

public typealias AObjectS = [Ice.Value?]

/// Helper class to read and write `AObjectS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct AObjectSHelper {
    /// Read a `AObjectS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> AObjectS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = AObjectS(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read() { p.pointee = $0 }
            }
        }
        return v
    }

    /// Read an optional `AObjectS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> AObjectS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `AObjectS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: AObjectS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `AObjectS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: AObjectS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias LObjectS = [Ice.Value?]

/// Helper class to read and write `LObjectS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LObjectSHelper {
    /// Read a `LObjectS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LObjectS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = LObjectS(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read() { p.pointee = $0 }
            }
        }
        return v
    }

    /// Read an optional `LObjectS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LObjectS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `LObjectS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LObjectS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `LObjectS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: LObjectS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias AObjectPrxS = [Ice.ObjectPrx?]

/// Helper class to read and write `AObjectPrxS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct AObjectPrxSHelper {
    /// Read a `AObjectPrxS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> AObjectPrxS {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = AObjectPrxS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
            v.append(j)
        }
        return v
    }

    /// Read an optional `AObjectPrxS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> AObjectPrxS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `AObjectPrxS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: AObjectPrxS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `AObjectPrxS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: AObjectPrxS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias LObjectPrxS = [Ice.ObjectPrx?]

/// Helper class to read and write `LObjectPrxS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LObjectPrxSHelper {
    /// Read a `LObjectPrxS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LObjectPrxS {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = LObjectPrxS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
            v.append(j)
        }
        return v
    }

    /// Read an optional `LObjectPrxS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LObjectPrxS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `LObjectPrxS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LObjectPrxS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `LObjectPrxS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: LObjectPrxS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias KObjectPrxS = [Ice.ObjectPrx?]

/// Helper class to read and write `KObjectPrxS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct KObjectPrxSHelper {
    /// Read a `KObjectPrxS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> KObjectPrxS {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = KObjectPrxS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
            v.append(j)
        }
        return v
    }

    /// Read an optional `KObjectPrxS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> KObjectPrxS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `KObjectPrxS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: KObjectPrxS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `KObjectPrxS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: KObjectPrxS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias QObjectPrxS = [Ice.ObjectPrx?]

/// Helper class to read and write `QObjectPrxS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct QObjectPrxSHelper {
    /// Read a `QObjectPrxS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> QObjectPrxS {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = QObjectPrxS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
            v.append(j)
        }
        return v
    }

    /// Read an optional `QObjectPrxS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> QObjectPrxS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `QObjectPrxS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: QObjectPrxS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `QObjectPrxS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: QObjectPrxS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias SObjectPrxS = [Ice.ObjectPrx?]

/// Helper class to read and write `SObjectPrxS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct SObjectPrxSHelper {
    /// Read a `SObjectPrxS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> SObjectPrxS {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = SObjectPrxS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: Ice.ObjectPrx? = try istr.read(Ice.ObjectPrx.self)
            v.append(j)
        }
        return v
    }

    /// Read an optional `SObjectPrxS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> SObjectPrxS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `SObjectPrxS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: SObjectPrxS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `SObjectPrxS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: SObjectPrxS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public struct S: Swift.Hashable {
    public var i: Swift.Int32 = 0

    public init() {}

    public init(i: Swift.Int32) {
        self.i = i
    }
}

/// An `Ice.InputStream` extension to read `S` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `S` structured value from the stream.
    ///
    /// - Returns: The structured value read from the stream.
    func read() throws -> S {
        var v = S()
        v.i = try self.read()
        return v
    }

    /// Read an optional `S?` structured value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> S? {
        guard try readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try skipSize()
        return try read() as S
    }
}

/// An `Ice.OutputStream` extension to write `S` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `S` structured value to the stream.
    ///
    /// - Parameter v: The value to write to the stream.
    func write(_ v: S) {
        self.write(v.i)
    }

    /// Write an optional `S?` structured value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The value to write to the stream.
    func write(tag: Swift.Int32, value: S?) {
        if let v = value {
            if writeOptional(tag: tag, format: .VSize) {
                write(size: 4)
                write(v)
            }
        }
    }
}

public typealias AStructS = [S]

/// Helper class to read and write `AStructS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct AStructSHelper {
    /// Read a `AStructS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> AStructS {
        let sz = try istr.readAndCheckSeqSize(minSize: 4)
        var v = AStructS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: S = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `AStructS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> AStructS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Write a `AStructS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: AStructS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `AStructS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: AStructS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 4) {
            write(to: ostr, value: val)
        }
    }
}

public typealias LStructS = [S]

/// Helper class to read and write `LStructS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LStructSHelper {
    /// Read a `LStructS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LStructS {
        let sz = try istr.readAndCheckSeqSize(minSize: 4)
        var v = LStructS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: S = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `LStructS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LStructS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Write a `LStructS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LStructS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `LStructS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: LStructS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 4) {
            write(to: ostr, value: val)
        }
    }
}

public typealias KStructS = [S]

/// Helper class to read and write `KStructS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct KStructSHelper {
    /// Read a `KStructS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> KStructS {
        let sz = try istr.readAndCheckSeqSize(minSize: 4)
        var v = KStructS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: S = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `KStructS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> KStructS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Write a `KStructS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: KStructS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `KStructS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: KStructS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 4) {
            write(to: ostr, value: val)
        }
    }
}

public typealias QStructS = [S]

/// Helper class to read and write `QStructS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct QStructSHelper {
    /// Read a `QStructS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> QStructS {
        let sz = try istr.readAndCheckSeqSize(minSize: 4)
        var v = QStructS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: S = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `QStructS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> QStructS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Write a `QStructS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: QStructS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `QStructS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: QStructS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 4) {
            write(to: ostr, value: val)
        }
    }
}

public typealias SStructS = [S]

/// Helper class to read and write `SStructS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct SStructSHelper {
    /// Read a `SStructS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> SStructS {
        let sz = try istr.readAndCheckSeqSize(minSize: 4)
        var v = SStructS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: S = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `SStructS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> SStructS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Write a `SStructS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: SStructS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `SStructS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: SStructS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 4) {
            write(to: ostr, value: val)
        }
    }
}

public struct SD: Swift.Hashable {
    public var i: Swift.Int32 = 1

    public init() {}

    public init(i: Swift.Int32) {
        self.i = i
    }
}

/// An `Ice.InputStream` extension to read `SD` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `SD` structured value from the stream.
    ///
    /// - Returns: The structured value read from the stream.
    func read() throws -> SD {
        var v = SD()
        v.i = try self.read()
        return v
    }

    /// Read an optional `SD?` structured value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> SD? {
        guard try readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try skipSize()
        return try read() as SD
    }
}

/// An `Ice.OutputStream` extension to write `SD` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `SD` structured value to the stream.
    ///
    /// - Parameter v: The value to write to the stream.
    func write(_ v: SD) {
        self.write(v.i)
    }

    /// Write an optional `SD?` structured value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The value to write to the stream.
    func write(tag: Swift.Int32, value: SD?) {
        if let v = value {
            if writeOptional(tag: tag, format: .VSize) {
                write(size: 4)
                write(v)
            }
        }
    }
}

public typealias AStructSD = [SD]

/// Helper class to read and write `AStructSD` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct AStructSDHelper {
    /// Read a `AStructSD` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> AStructSD {
        let sz = try istr.readAndCheckSeqSize(minSize: 4)
        var v = AStructSD()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: SD = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `AStructSD?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> AStructSD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Write a `AStructSD` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: AStructSD) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `AStructSD?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: AStructSD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 4) {
            write(to: ostr, value: val)
        }
    }
}

public typealias LStructSD = [SD]

/// Helper class to read and write `LStructSD` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LStructSDHelper {
    /// Read a `LStructSD` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LStructSD {
        let sz = try istr.readAndCheckSeqSize(minSize: 4)
        var v = LStructSD()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: SD = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `LStructSD?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LStructSD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Write a `LStructSD` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LStructSD) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `LStructSD?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: LStructSD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 4) {
            write(to: ostr, value: val)
        }
    }
}

public typealias KStructSD = [SD]

/// Helper class to read and write `KStructSD` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct KStructSDHelper {
    /// Read a `KStructSD` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> KStructSD {
        let sz = try istr.readAndCheckSeqSize(minSize: 4)
        var v = KStructSD()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: SD = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `KStructSD?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> KStructSD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Write a `KStructSD` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: KStructSD) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `KStructSD?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: KStructSD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 4) {
            write(to: ostr, value: val)
        }
    }
}

public typealias QStructSD = [SD]

/// Helper class to read and write `QStructSD` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct QStructSDHelper {
    /// Read a `QStructSD` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> QStructSD {
        let sz = try istr.readAndCheckSeqSize(minSize: 4)
        var v = QStructSD()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: SD = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `QStructSD?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> QStructSD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Write a `QStructSD` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: QStructSD) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `QStructSD?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: QStructSD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 4) {
            write(to: ostr, value: val)
        }
    }
}

public typealias SStructSD = [SD]

/// Helper class to read and write `SStructSD` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct SStructSDHelper {
    /// Read a `SStructSD` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> SStructSD {
        let sz = try istr.readAndCheckSeqSize(minSize: 4)
        var v = SStructSD()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: SD = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `SStructSD?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> SStructSD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Write a `SStructSD` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: SStructSD) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `SStructSD?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: SStructSD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 4) {
            write(to: ostr, value: val)
        }
    }
}

public typealias ACVS = [CV?]

/// Helper class to read and write `ACVS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ACVSHelper {
    /// Read a `ACVS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ACVS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = ACVS(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(CV.self) { p.pointee = $0 }
            }
        }
        return v
    }

    /// Read an optional `ACVS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ACVS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `ACVS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ACVS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `ACVS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ACVS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias LCVS = [CV?]

/// Helper class to read and write `LCVS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LCVSHelper {
    /// Read a `LCVS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LCVS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = LCVS(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(CV.self) { p.pointee = $0 }
            }
        }
        return v
    }

    /// Read an optional `LCVS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LCVS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `LCVS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LCVS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `LCVS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: LCVS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice interface `I`.
public struct ITraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::I"]
    public static let staticId = "::Test::I"
}

public typealias AIPrxS = [IPrx?]

/// Helper class to read and write `AIPrxS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct AIPrxSHelper {
    /// Read a `AIPrxS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> AIPrxS {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = AIPrxS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: IPrx? = try istr.read(IPrx.self)
            v.append(j)
        }
        return v
    }

    /// Read an optional `AIPrxS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> AIPrxS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `AIPrxS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: AIPrxS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `AIPrxS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: AIPrxS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias LIPrxS = [IPrx?]

/// Helper class to read and write `LIPrxS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LIPrxSHelper {
    /// Read a `LIPrxS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LIPrxS {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = LIPrxS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: IPrx? = try istr.read(IPrx.self)
            v.append(j)
        }
        return v
    }

    /// Read an optional `LIPrxS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LIPrxS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `LIPrxS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LIPrxS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `LIPrxS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: LIPrxS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias KIPrxS = [IPrx?]

/// Helper class to read and write `KIPrxS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct KIPrxSHelper {
    /// Read a `KIPrxS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> KIPrxS {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = KIPrxS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: IPrx? = try istr.read(IPrx.self)
            v.append(j)
        }
        return v
    }

    /// Read an optional `KIPrxS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> KIPrxS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `KIPrxS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: KIPrxS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `KIPrxS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: KIPrxS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias QIPrxS = [IPrx?]

/// Helper class to read and write `QIPrxS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct QIPrxSHelper {
    /// Read a `QIPrxS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> QIPrxS {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = QIPrxS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: IPrx? = try istr.read(IPrx.self)
            v.append(j)
        }
        return v
    }

    /// Read an optional `QIPrxS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> QIPrxS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `QIPrxS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: QIPrxS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `QIPrxS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: QIPrxS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias SIPrxS = [IPrx?]

/// Helper class to read and write `SIPrxS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct SIPrxSHelper {
    /// Read a `SIPrxS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> SIPrxS {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = SIPrxS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: IPrx? = try istr.read(IPrx.self)
            v.append(j)
        }
        return v
    }

    /// Read an optional `SIPrxS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> SIPrxS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `SIPrxS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: SIPrxS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `SIPrxS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: SIPrxS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ACRS = [CR?]

/// Helper class to read and write `ACRS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ACRSHelper {
    /// Read a `ACRS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ACRS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = ACRS(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(CR.self) { p.pointee = $0 }
            }
        }
        return v
    }

    /// Read an optional `ACRS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ACRS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `ACRS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ACRS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `ACRS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ACRS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias LCRS = [CR?]

/// Helper class to read and write `LCRS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LCRSHelper {
    /// Read a `LCRS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LCRS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = LCRS(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(CR.self) { p.pointee = $0 }
            }
        }
        return v
    }

    /// Read an optional `LCRS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LCRS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `LCRS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LCRS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `LCRS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: LCRS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public enum En: Swift.UInt8 {
    case A = 0
    case B = 1
    case C = 2
    public init() {
        self = .A
    }
}

/// An `Ice.InputStream` extension to read `En` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - Returns:  The enumerated value.
    func read() throws -> En {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 2)
        guard let val = En(rawValue: rawValue) else {
            throw Ice.MarshalException("invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The enumerated value.
    func read(tag: Swift.Int32) throws -> En? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as En
    }
}

/// An `Ice.OutputStream` extension to write `En` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// - Parameter v: The enumerator to write.
    func write(_ v: En) {
        write(enum: v.rawValue, maxValue: 2)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The enumerator to write.
    func write(tag: Swift.Int32, value: En?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 2)
    }
}

public typealias AEnS = [En]

/// Helper class to read and write `AEnS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct AEnSHelper {
    /// Read a `AEnS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> AEnS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = AEnS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: En = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `AEnS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> AEnS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `AEnS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: AEnS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `AEnS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: AEnS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias LEnS = [En]

/// Helper class to read and write `LEnS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LEnSHelper {
    /// Read a `LEnS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LEnS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = LEnS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: En = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `LEnS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LEnS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `LEnS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LEnS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `LEnS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: LEnS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias KEnS = [En]

/// Helper class to read and write `KEnS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct KEnSHelper {
    /// Read a `KEnS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> KEnS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = KEnS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: En = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `KEnS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> KEnS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `KEnS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: KEnS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `KEnS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: KEnS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias QEnS = [En]

/// Helper class to read and write `QEnS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct QEnSHelper {
    /// Read a `QEnS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> QEnS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = QEnS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: En = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `QEnS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> QEnS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `QEnS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: QEnS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `QEnS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: QEnS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias SEnS = [En]

/// Helper class to read and write `SEnS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct SEnSHelper {
    /// Read a `SEnS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> SEnS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = SEnS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: En = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `SEnS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> SEnS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `SEnS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: SEnS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `SEnS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: SEnS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias CustomIntS = [Swift.Int32]

public typealias CustomCVS = [CV?]

/// Helper class to read and write `CustomCVS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct CustomCVSHelper {
    /// Read a `CustomCVS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> CustomCVS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = CustomCVS(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(CV.self) { p.pointee = $0 }
            }
        }
        return v
    }

    /// Read an optional `CustomCVS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> CustomCVS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `CustomCVS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: CustomCVS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `CustomCVS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: CustomCVS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias CustomIntSS = [CustomIntS]

/// Helper class to read and write `CustomIntSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct CustomIntSSHelper {
    /// Read a `CustomIntSS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> CustomIntSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = CustomIntSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: CustomIntS = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `CustomIntSS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> CustomIntSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `CustomIntSS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: CustomIntSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `CustomIntSS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: CustomIntSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias CustomCVSS = [CustomCVS]

/// Helper class to read and write `CustomCVSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct CustomCVSSHelper {
    /// Read a `CustomCVSS` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> CustomCVSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = CustomCVSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: CustomCVS = try CustomCVSHelper.read(from: istr)
            v.append(j)
        }
        return v
    }

    /// Read an optional `CustomCVSS?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> CustomCVSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `CustomCVSS` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: CustomCVSS) {
        ostr.write(size: v.count)
        for item in v {
            CustomCVSHelper.write(to: ostr, value: item)
        }
    }

    /// Write an optional `CustomCVSS?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: CustomCVSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice interface `MyClass`.
public struct MyClassTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::MyClass"]
    public static let staticId = "::Test::MyClass"
}

public protocol IPrx: Ice.ObjectPrx {}

private final class IPrxI: Ice.ObjectPrxI, IPrx {
    public override class func ice_staticId() -> Swift.String {
        return ITraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: IPrx.Protocol) throws -> IPrx {
    try communicator.makeProxyImpl(proxyString) as IPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: IPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> IPrx? {
    return try await IPrxI.checkedCast(prx: prx, facet: facet, context: context) as IPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: IPrx.Protocol, facet: Swift.String? = nil) -> IPrx {
    return IPrxI.uncheckedCast(prx: prx, facet: facet) as IPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: IPrx.Protocol) -> Swift.String {
    return ITraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `IPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: IPrx.Protocol) throws -> IPrx? {
        return try read() as IPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: IPrx.Protocol) throws -> IPrx? {
        return try read(tag: tag) as IPrxI?
    }
}

public extension IPrx {}

public protocol MyClassPrx: Ice.ObjectPrx {}

private final class MyClassPrxI: Ice.ObjectPrxI, MyClassPrx {
    public override class func ice_staticId() -> Swift.String {
        return MyClassTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: MyClassPrx.Protocol) throws -> MyClassPrx {
    try communicator.makeProxyImpl(proxyString) as MyClassPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: MyClassPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> MyClassPrx? {
    return try await MyClassPrxI.checkedCast(prx: prx, facet: facet, context: context) as MyClassPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: MyClassPrx.Protocol, facet: Swift.String? = nil) -> MyClassPrx {
    return MyClassPrxI.uncheckedCast(prx: prx, facet: facet) as MyClassPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: MyClassPrx.Protocol) -> Swift.String {
    return MyClassTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `MyClassPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: MyClassPrx.Protocol) throws -> MyClassPrx? {
        return try read() as MyClassPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: MyClassPrx.Protocol) throws -> MyClassPrx? {
        return try read(tag: tag) as MyClassPrxI?
    }
}

public extension MyClassPrx {
    func shutdown(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "shutdown",
                                       mode: .Normal,
                                       context: context)
    }

    func opAByteS(_ iceP_i: AByteS, context: Ice.Context? = nil) async throws -> (returnValue: AByteS, o: AByteS) {
        return try await _impl._invoke(operation: "opAByteS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: AByteS = try istr.read()
                                           let iceP_returnValue: AByteS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opLByteS(_ iceP_i: LByteS, context: Ice.Context? = nil) async throws -> (returnValue: LByteS, o: LByteS) {
        return try await _impl._invoke(operation: "opLByteS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: LByteS = try istr.read()
                                           let iceP_returnValue: LByteS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opKByteS(_ iceP_i: KByteS, context: Ice.Context? = nil) async throws -> (returnValue: KByteS, o: KByteS) {
        return try await _impl._invoke(operation: "opKByteS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: KByteS = try istr.read()
                                           let iceP_returnValue: KByteS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opQByteS(_ iceP_i: QByteS, context: Ice.Context? = nil) async throws -> (returnValue: QByteS, o: QByteS) {
        return try await _impl._invoke(operation: "opQByteS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: QByteS = try istr.read()
                                           let iceP_returnValue: QByteS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opSByteS(_ iceP_i: SByteS, context: Ice.Context? = nil) async throws -> (returnValue: SByteS, o: SByteS) {
        return try await _impl._invoke(operation: "opSByteS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: SByteS = try istr.read()
                                           let iceP_returnValue: SByteS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opABoolS(_ iceP_i: ABoolS, context: Ice.Context? = nil) async throws -> (returnValue: ABoolS, o: ABoolS) {
        return try await _impl._invoke(operation: "opABoolS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: ABoolS = try istr.read()
                                           let iceP_returnValue: ABoolS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opLBoolS(_ iceP_i: LBoolS, context: Ice.Context? = nil) async throws -> (returnValue: LBoolS, o: LBoolS) {
        return try await _impl._invoke(operation: "opLBoolS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: LBoolS = try istr.read()
                                           let iceP_returnValue: LBoolS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opKBoolS(_ iceP_i: KBoolS, context: Ice.Context? = nil) async throws -> (returnValue: KBoolS, o: KBoolS) {
        return try await _impl._invoke(operation: "opKBoolS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: KBoolS = try istr.read()
                                           let iceP_returnValue: KBoolS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opQBoolS(_ iceP_i: QBoolS, context: Ice.Context? = nil) async throws -> (returnValue: QBoolS, o: QBoolS) {
        return try await _impl._invoke(operation: "opQBoolS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: QBoolS = try istr.read()
                                           let iceP_returnValue: QBoolS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opSBoolS(_ iceP_i: SBoolS, context: Ice.Context? = nil) async throws -> (returnValue: SBoolS, o: SBoolS) {
        return try await _impl._invoke(operation: "opSBoolS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: SBoolS = try istr.read()
                                           let iceP_returnValue: SBoolS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opAShortS(_ iceP_i: AShortS, context: Ice.Context? = nil) async throws -> (returnValue: AShortS, o: AShortS) {
        return try await _impl._invoke(operation: "opAShortS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: AShortS = try istr.read()
                                           let iceP_returnValue: AShortS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opLShortS(_ iceP_i: LShortS, context: Ice.Context? = nil) async throws -> (returnValue: LShortS, o: LShortS) {
        return try await _impl._invoke(operation: "opLShortS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: LShortS = try istr.read()
                                           let iceP_returnValue: LShortS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opKShortS(_ iceP_i: KShortS, context: Ice.Context? = nil) async throws -> (returnValue: KShortS, o: KShortS) {
        return try await _impl._invoke(operation: "opKShortS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: KShortS = try istr.read()
                                           let iceP_returnValue: KShortS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opQShortS(_ iceP_i: QShortS, context: Ice.Context? = nil) async throws -> (returnValue: QShortS, o: QShortS) {
        return try await _impl._invoke(operation: "opQShortS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: QShortS = try istr.read()
                                           let iceP_returnValue: QShortS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opSShortS(_ iceP_i: SShortS, context: Ice.Context? = nil) async throws -> (returnValue: SShortS, o: SShortS) {
        return try await _impl._invoke(operation: "opSShortS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: SShortS = try istr.read()
                                           let iceP_returnValue: SShortS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opAIntS(_ iceP_i: AIntS, context: Ice.Context? = nil) async throws -> (returnValue: AIntS, o: AIntS) {
        return try await _impl._invoke(operation: "opAIntS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: AIntS = try istr.read()
                                           let iceP_returnValue: AIntS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opLIntS(_ iceP_i: LIntS, context: Ice.Context? = nil) async throws -> (returnValue: LIntS, o: LIntS) {
        return try await _impl._invoke(operation: "opLIntS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: LIntS = try istr.read()
                                           let iceP_returnValue: LIntS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opKIntS(_ iceP_i: KIntS, context: Ice.Context? = nil) async throws -> (returnValue: KIntS, o: KIntS) {
        return try await _impl._invoke(operation: "opKIntS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: KIntS = try istr.read()
                                           let iceP_returnValue: KIntS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opQIntS(_ iceP_i: QIntS, context: Ice.Context? = nil) async throws -> (returnValue: QIntS, o: QIntS) {
        return try await _impl._invoke(operation: "opQIntS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: QIntS = try istr.read()
                                           let iceP_returnValue: QIntS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opSIntS(_ iceP_i: SIntS, context: Ice.Context? = nil) async throws -> (returnValue: SIntS, o: SIntS) {
        return try await _impl._invoke(operation: "opSIntS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: SIntS = try istr.read()
                                           let iceP_returnValue: SIntS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opALongS(_ iceP_i: ALongS, context: Ice.Context? = nil) async throws -> (returnValue: ALongS, o: ALongS) {
        return try await _impl._invoke(operation: "opALongS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: ALongS = try istr.read()
                                           let iceP_returnValue: ALongS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opLLongS(_ iceP_i: LLongS, context: Ice.Context? = nil) async throws -> (returnValue: LLongS, o: LLongS) {
        return try await _impl._invoke(operation: "opLLongS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: LLongS = try istr.read()
                                           let iceP_returnValue: LLongS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opKLongS(_ iceP_i: KLongS, context: Ice.Context? = nil) async throws -> (returnValue: KLongS, o: KLongS) {
        return try await _impl._invoke(operation: "opKLongS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: KLongS = try istr.read()
                                           let iceP_returnValue: KLongS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opQLongS(_ iceP_i: QLongS, context: Ice.Context? = nil) async throws -> (returnValue: QLongS, o: QLongS) {
        return try await _impl._invoke(operation: "opQLongS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: QLongS = try istr.read()
                                           let iceP_returnValue: QLongS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opSLongS(_ iceP_i: SLongS, context: Ice.Context? = nil) async throws -> (returnValue: SLongS, o: SLongS) {
        return try await _impl._invoke(operation: "opSLongS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: SLongS = try istr.read()
                                           let iceP_returnValue: SLongS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opAFloatS(_ iceP_i: AFloatS, context: Ice.Context? = nil) async throws -> (returnValue: AFloatS, o: AFloatS) {
        return try await _impl._invoke(operation: "opAFloatS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: AFloatS = try istr.read()
                                           let iceP_returnValue: AFloatS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opLFloatS(_ iceP_i: LFloatS, context: Ice.Context? = nil) async throws -> (returnValue: LFloatS, o: LFloatS) {
        return try await _impl._invoke(operation: "opLFloatS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: LFloatS = try istr.read()
                                           let iceP_returnValue: LFloatS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opKFloatS(_ iceP_i: KFloatS, context: Ice.Context? = nil) async throws -> (returnValue: KFloatS, o: KFloatS) {
        return try await _impl._invoke(operation: "opKFloatS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: KFloatS = try istr.read()
                                           let iceP_returnValue: KFloatS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opQFloatS(_ iceP_i: QFloatS, context: Ice.Context? = nil) async throws -> (returnValue: QFloatS, o: QFloatS) {
        return try await _impl._invoke(operation: "opQFloatS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: QFloatS = try istr.read()
                                           let iceP_returnValue: QFloatS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opSFloatS(_ iceP_i: SFloatS, context: Ice.Context? = nil) async throws -> (returnValue: SFloatS, o: SFloatS) {
        return try await _impl._invoke(operation: "opSFloatS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: SFloatS = try istr.read()
                                           let iceP_returnValue: SFloatS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opADoubleS(_ iceP_i: ADoubleS, context: Ice.Context? = nil) async throws -> (returnValue: ADoubleS, o: ADoubleS) {
        return try await _impl._invoke(operation: "opADoubleS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: ADoubleS = try istr.read()
                                           let iceP_returnValue: ADoubleS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opLDoubleS(_ iceP_i: LDoubleS, context: Ice.Context? = nil) async throws -> (returnValue: LDoubleS, o: LDoubleS) {
        return try await _impl._invoke(operation: "opLDoubleS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: LDoubleS = try istr.read()
                                           let iceP_returnValue: LDoubleS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opKDoubleS(_ iceP_i: KDoubleS, context: Ice.Context? = nil) async throws -> (returnValue: KDoubleS, o: KDoubleS) {
        return try await _impl._invoke(operation: "opKDoubleS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: KDoubleS = try istr.read()
                                           let iceP_returnValue: KDoubleS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opQDoubleS(_ iceP_i: QDoubleS, context: Ice.Context? = nil) async throws -> (returnValue: QDoubleS, o: QDoubleS) {
        return try await _impl._invoke(operation: "opQDoubleS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: QDoubleS = try istr.read()
                                           let iceP_returnValue: QDoubleS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opSDoubleS(_ iceP_i: SDoubleS, context: Ice.Context? = nil) async throws -> (returnValue: SDoubleS, o: SDoubleS) {
        return try await _impl._invoke(operation: "opSDoubleS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: SDoubleS = try istr.read()
                                           let iceP_returnValue: SDoubleS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opAStringS(_ iceP_i: AStringS, context: Ice.Context? = nil) async throws -> (returnValue: AStringS, o: AStringS) {
        return try await _impl._invoke(operation: "opAStringS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: AStringS = try istr.read()
                                           let iceP_returnValue: AStringS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opLStringS(_ iceP_i: LStringS, context: Ice.Context? = nil) async throws -> (returnValue: LStringS, o: LStringS) {
        return try await _impl._invoke(operation: "opLStringS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: LStringS = try istr.read()
                                           let iceP_returnValue: LStringS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opKStringS(_ iceP_i: KStringS, context: Ice.Context? = nil) async throws -> (returnValue: KStringS, o: KStringS) {
        return try await _impl._invoke(operation: "opKStringS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: KStringS = try istr.read()
                                           let iceP_returnValue: KStringS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opQStringS(_ iceP_i: QStringS, context: Ice.Context? = nil) async throws -> (returnValue: QStringS, o: QStringS) {
        return try await _impl._invoke(operation: "opQStringS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: QStringS = try istr.read()
                                           let iceP_returnValue: QStringS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opSStringS(_ iceP_i: SStringS, context: Ice.Context? = nil) async throws -> (returnValue: SStringS, o: SStringS) {
        return try await _impl._invoke(operation: "opSStringS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: SStringS = try istr.read()
                                           let iceP_returnValue: SStringS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opAObjectS(_ iceP_i: AObjectS, context: Ice.Context? = nil) async throws -> (returnValue: AObjectS, o: AObjectS) {
        return try await _impl._invoke(operation: "opAObjectS",
                                       mode: .Normal,
                                       write: { ostr in
                                           AObjectSHelper.write(to: ostr, value: iceP_i)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           let iceP_o: AObjectS = try AObjectSHelper.read(from: istr)
                                           let iceP_returnValue: AObjectS = try AObjectSHelper.read(from: istr)
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opLObjectS(_ iceP_i: LObjectS, context: Ice.Context? = nil) async throws -> (returnValue: LObjectS, o: LObjectS) {
        return try await _impl._invoke(operation: "opLObjectS",
                                       mode: .Normal,
                                       write: { ostr in
                                           LObjectSHelper.write(to: ostr, value: iceP_i)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           let iceP_o: LObjectS = try LObjectSHelper.read(from: istr)
                                           let iceP_returnValue: LObjectS = try LObjectSHelper.read(from: istr)
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opAObjectPrxS(_ iceP_i: AObjectPrxS, context: Ice.Context? = nil) async throws -> (returnValue: AObjectPrxS, o: AObjectPrxS) {
        return try await _impl._invoke(operation: "opAObjectPrxS",
                                       mode: .Normal,
                                       write: { ostr in
                                           AObjectPrxSHelper.write(to: ostr, value: iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: AObjectPrxS = try AObjectPrxSHelper.read(from: istr)
                                           let iceP_returnValue: AObjectPrxS = try AObjectPrxSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opLObjectPrxS(_ iceP_i: LObjectPrxS, context: Ice.Context? = nil) async throws -> (returnValue: LObjectPrxS, o: LObjectPrxS) {
        return try await _impl._invoke(operation: "opLObjectPrxS",
                                       mode: .Normal,
                                       write: { ostr in
                                           LObjectPrxSHelper.write(to: ostr, value: iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: LObjectPrxS = try LObjectPrxSHelper.read(from: istr)
                                           let iceP_returnValue: LObjectPrxS = try LObjectPrxSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opKObjectPrxS(_ iceP_i: KObjectPrxS, context: Ice.Context? = nil) async throws -> (returnValue: KObjectPrxS, o: KObjectPrxS) {
        return try await _impl._invoke(operation: "opKObjectPrxS",
                                       mode: .Normal,
                                       write: { ostr in
                                           KObjectPrxSHelper.write(to: ostr, value: iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: KObjectPrxS = try KObjectPrxSHelper.read(from: istr)
                                           let iceP_returnValue: KObjectPrxS = try KObjectPrxSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opQObjectPrxS(_ iceP_i: QObjectPrxS, context: Ice.Context? = nil) async throws -> (returnValue: QObjectPrxS, o: QObjectPrxS) {
        return try await _impl._invoke(operation: "opQObjectPrxS",
                                       mode: .Normal,
                                       write: { ostr in
                                           QObjectPrxSHelper.write(to: ostr, value: iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: QObjectPrxS = try QObjectPrxSHelper.read(from: istr)
                                           let iceP_returnValue: QObjectPrxS = try QObjectPrxSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opSObjectPrxS(_ iceP_i: SObjectPrxS, context: Ice.Context? = nil) async throws -> (returnValue: SObjectPrxS, o: SObjectPrxS) {
        return try await _impl._invoke(operation: "opSObjectPrxS",
                                       mode: .Normal,
                                       write: { ostr in
                                           SObjectPrxSHelper.write(to: ostr, value: iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: SObjectPrxS = try SObjectPrxSHelper.read(from: istr)
                                           let iceP_returnValue: SObjectPrxS = try SObjectPrxSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opAStructS(_ iceP_i: AStructS, context: Ice.Context? = nil) async throws -> (returnValue: AStructS, o: AStructS) {
        return try await _impl._invoke(operation: "opAStructS",
                                       mode: .Normal,
                                       write: { ostr in
                                           AStructSHelper.write(to: ostr, value: iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: AStructS = try AStructSHelper.read(from: istr)
                                           let iceP_returnValue: AStructS = try AStructSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opLStructS(_ iceP_i: LStructS, context: Ice.Context? = nil) async throws -> (returnValue: LStructS, o: LStructS) {
        return try await _impl._invoke(operation: "opLStructS",
                                       mode: .Normal,
                                       write: { ostr in
                                           LStructSHelper.write(to: ostr, value: iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: LStructS = try LStructSHelper.read(from: istr)
                                           let iceP_returnValue: LStructS = try LStructSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opKStructS(_ iceP_i: KStructS, context: Ice.Context? = nil) async throws -> (returnValue: KStructS, o: KStructS) {
        return try await _impl._invoke(operation: "opKStructS",
                                       mode: .Normal,
                                       write: { ostr in
                                           KStructSHelper.write(to: ostr, value: iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: KStructS = try KStructSHelper.read(from: istr)
                                           let iceP_returnValue: KStructS = try KStructSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opQStructS(_ iceP_i: QStructS, context: Ice.Context? = nil) async throws -> (returnValue: QStructS, o: QStructS) {
        return try await _impl._invoke(operation: "opQStructS",
                                       mode: .Normal,
                                       write: { ostr in
                                           QStructSHelper.write(to: ostr, value: iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: QStructS = try QStructSHelper.read(from: istr)
                                           let iceP_returnValue: QStructS = try QStructSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opSStructS(_ iceP_i: SStructS, context: Ice.Context? = nil) async throws -> (returnValue: SStructS, o: SStructS) {
        return try await _impl._invoke(operation: "opSStructS",
                                       mode: .Normal,
                                       write: { ostr in
                                           SStructSHelper.write(to: ostr, value: iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: SStructS = try SStructSHelper.read(from: istr)
                                           let iceP_returnValue: SStructS = try SStructSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opAStructSD(_ iceP_i: AStructSD, context: Ice.Context? = nil) async throws -> (returnValue: AStructSD, o: AStructSD) {
        return try await _impl._invoke(operation: "opAStructSD",
                                       mode: .Normal,
                                       write: { ostr in
                                           AStructSDHelper.write(to: ostr, value: iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: AStructSD = try AStructSDHelper.read(from: istr)
                                           let iceP_returnValue: AStructSD = try AStructSDHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opLStructSD(_ iceP_i: LStructSD, context: Ice.Context? = nil) async throws -> (returnValue: LStructSD, o: LStructSD) {
        return try await _impl._invoke(operation: "opLStructSD",
                                       mode: .Normal,
                                       write: { ostr in
                                           LStructSDHelper.write(to: ostr, value: iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: LStructSD = try LStructSDHelper.read(from: istr)
                                           let iceP_returnValue: LStructSD = try LStructSDHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opKStructSD(_ iceP_i: KStructSD, context: Ice.Context? = nil) async throws -> (returnValue: KStructSD, o: KStructSD) {
        return try await _impl._invoke(operation: "opKStructSD",
                                       mode: .Normal,
                                       write: { ostr in
                                           KStructSDHelper.write(to: ostr, value: iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: KStructSD = try KStructSDHelper.read(from: istr)
                                           let iceP_returnValue: KStructSD = try KStructSDHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opQStructSD(_ iceP_i: QStructSD, context: Ice.Context? = nil) async throws -> (returnValue: QStructSD, o: QStructSD) {
        return try await _impl._invoke(operation: "opQStructSD",
                                       mode: .Normal,
                                       write: { ostr in
                                           QStructSDHelper.write(to: ostr, value: iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: QStructSD = try QStructSDHelper.read(from: istr)
                                           let iceP_returnValue: QStructSD = try QStructSDHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opSStructSD(_ iceP_i: SStructSD, context: Ice.Context? = nil) async throws -> (returnValue: SStructSD, o: SStructSD) {
        return try await _impl._invoke(operation: "opSStructSD",
                                       mode: .Normal,
                                       write: { ostr in
                                           SStructSDHelper.write(to: ostr, value: iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: SStructSD = try SStructSDHelper.read(from: istr)
                                           let iceP_returnValue: SStructSD = try SStructSDHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opACVS(_ iceP_i: ACVS, context: Ice.Context? = nil) async throws -> (returnValue: ACVS, o: ACVS) {
        return try await _impl._invoke(operation: "opACVS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ACVSHelper.write(to: ostr, value: iceP_i)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           let iceP_o: ACVS = try ACVSHelper.read(from: istr)
                                           let iceP_returnValue: ACVS = try ACVSHelper.read(from: istr)
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opLCVS(_ iceP_i: LCVS, context: Ice.Context? = nil) async throws -> (returnValue: LCVS, o: LCVS) {
        return try await _impl._invoke(operation: "opLCVS",
                                       mode: .Normal,
                                       write: { ostr in
                                           LCVSHelper.write(to: ostr, value: iceP_i)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           let iceP_o: LCVS = try LCVSHelper.read(from: istr)
                                           let iceP_returnValue: LCVS = try LCVSHelper.read(from: istr)
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opACRS(_ iceP_i: ACRS, context: Ice.Context? = nil) async throws -> (returnValue: ACRS, o: ACRS) {
        return try await _impl._invoke(operation: "opACRS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ACRSHelper.write(to: ostr, value: iceP_i)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           let iceP_o: ACRS = try ACRSHelper.read(from: istr)
                                           let iceP_returnValue: ACRS = try ACRSHelper.read(from: istr)
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opLCRS(_ iceP_i: LCRS, context: Ice.Context? = nil) async throws -> (returnValue: LCRS, o: LCRS) {
        return try await _impl._invoke(operation: "opLCRS",
                                       mode: .Normal,
                                       write: { ostr in
                                           LCRSHelper.write(to: ostr, value: iceP_i)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           let iceP_o: LCRS = try LCRSHelper.read(from: istr)
                                           let iceP_returnValue: LCRS = try LCRSHelper.read(from: istr)
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opAEnS(_ iceP_i: AEnS, context: Ice.Context? = nil) async throws -> (returnValue: AEnS, o: AEnS) {
        return try await _impl._invoke(operation: "opAEnS",
                                       mode: .Normal,
                                       write: { ostr in
                                           AEnSHelper.write(to: ostr, value: iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: AEnS = try AEnSHelper.read(from: istr)
                                           let iceP_returnValue: AEnS = try AEnSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opLEnS(_ iceP_i: LEnS, context: Ice.Context? = nil) async throws -> (returnValue: LEnS, o: LEnS) {
        return try await _impl._invoke(operation: "opLEnS",
                                       mode: .Normal,
                                       write: { ostr in
                                           LEnSHelper.write(to: ostr, value: iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: LEnS = try LEnSHelper.read(from: istr)
                                           let iceP_returnValue: LEnS = try LEnSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opKEnS(_ iceP_i: KEnS, context: Ice.Context? = nil) async throws -> (returnValue: KEnS, o: KEnS) {
        return try await _impl._invoke(operation: "opKEnS",
                                       mode: .Normal,
                                       write: { ostr in
                                           KEnSHelper.write(to: ostr, value: iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: KEnS = try KEnSHelper.read(from: istr)
                                           let iceP_returnValue: KEnS = try KEnSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opQEnS(_ iceP_i: QEnS, context: Ice.Context? = nil) async throws -> (returnValue: QEnS, o: QEnS) {
        return try await _impl._invoke(operation: "opQEnS",
                                       mode: .Normal,
                                       write: { ostr in
                                           QEnSHelper.write(to: ostr, value: iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: QEnS = try QEnSHelper.read(from: istr)
                                           let iceP_returnValue: QEnS = try QEnSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opSEnS(_ iceP_i: SEnS, context: Ice.Context? = nil) async throws -> (returnValue: SEnS, o: SEnS) {
        return try await _impl._invoke(operation: "opSEnS",
                                       mode: .Normal,
                                       write: { ostr in
                                           SEnSHelper.write(to: ostr, value: iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: SEnS = try SEnSHelper.read(from: istr)
                                           let iceP_returnValue: SEnS = try SEnSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opAIPrxS(_ iceP_i: AIPrxS, context: Ice.Context? = nil) async throws -> (returnValue: AIPrxS, o: AIPrxS) {
        return try await _impl._invoke(operation: "opAIPrxS",
                                       mode: .Normal,
                                       write: { ostr in
                                           AIPrxSHelper.write(to: ostr, value: iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: AIPrxS = try AIPrxSHelper.read(from: istr)
                                           let iceP_returnValue: AIPrxS = try AIPrxSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opLIPrxS(_ iceP_i: LIPrxS, context: Ice.Context? = nil) async throws -> (returnValue: LIPrxS, o: LIPrxS) {
        return try await _impl._invoke(operation: "opLIPrxS",
                                       mode: .Normal,
                                       write: { ostr in
                                           LIPrxSHelper.write(to: ostr, value: iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: LIPrxS = try LIPrxSHelper.read(from: istr)
                                           let iceP_returnValue: LIPrxS = try LIPrxSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opKIPrxS(_ iceP_i: KIPrxS, context: Ice.Context? = nil) async throws -> (returnValue: KIPrxS, o: KIPrxS) {
        return try await _impl._invoke(operation: "opKIPrxS",
                                       mode: .Normal,
                                       write: { ostr in
                                           KIPrxSHelper.write(to: ostr, value: iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: KIPrxS = try KIPrxSHelper.read(from: istr)
                                           let iceP_returnValue: KIPrxS = try KIPrxSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opQIPrxS(_ iceP_i: QIPrxS, context: Ice.Context? = nil) async throws -> (returnValue: QIPrxS, o: QIPrxS) {
        return try await _impl._invoke(operation: "opQIPrxS",
                                       mode: .Normal,
                                       write: { ostr in
                                           QIPrxSHelper.write(to: ostr, value: iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: QIPrxS = try QIPrxSHelper.read(from: istr)
                                           let iceP_returnValue: QIPrxS = try QIPrxSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opSIPrxS(_ iceP_i: SIPrxS, context: Ice.Context? = nil) async throws -> (returnValue: SIPrxS, o: SIPrxS) {
        return try await _impl._invoke(operation: "opSIPrxS",
                                       mode: .Normal,
                                       write: { ostr in
                                           SIPrxSHelper.write(to: ostr, value: iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: SIPrxS = try SIPrxSHelper.read(from: istr)
                                           let iceP_returnValue: SIPrxS = try SIPrxSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opCustomIntS(_ iceP_i: CustomIntS, context: Ice.Context? = nil) async throws -> (returnValue: CustomIntS, o: CustomIntS) {
        return try await _impl._invoke(operation: "opCustomIntS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: CustomIntS = try istr.read()
                                           let iceP_returnValue: CustomIntS = try istr.read()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opCustomCVS(_ iceP_i: CustomCVS, context: Ice.Context? = nil) async throws -> (returnValue: CustomCVS, o: CustomCVS) {
        return try await _impl._invoke(operation: "opCustomCVS",
                                       mode: .Normal,
                                       write: { ostr in
                                           CustomCVSHelper.write(to: ostr, value: iceP_i)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           let iceP_o: CustomCVS = try CustomCVSHelper.read(from: istr)
                                           let iceP_returnValue: CustomCVS = try CustomCVSHelper.read(from: istr)
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opCustomIntSS(_ iceP_i: CustomIntSS, context: Ice.Context? = nil) async throws -> (returnValue: CustomIntSS, o: CustomIntSS) {
        return try await _impl._invoke(operation: "opCustomIntSS",
                                       mode: .Normal,
                                       write: { ostr in
                                           CustomIntSSHelper.write(to: ostr, value: iceP_i)
                                       },
                                       read: { istr in
                                           let iceP_o: CustomIntSS = try CustomIntSSHelper.read(from: istr)
                                           let iceP_returnValue: CustomIntSS = try CustomIntSSHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }

    func opCustomCVSS(_ iceP_i: CustomCVSS, context: Ice.Context? = nil) async throws -> (returnValue: CustomCVSS, o: CustomCVSS) {
        return try await _impl._invoke(operation: "opCustomCVSS",
                                       mode: .Normal,
                                       write: { ostr in
                                           CustomCVSSHelper.write(to: ostr, value: iceP_i)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           let iceP_o: CustomCVSS = try CustomCVSSHelper.read(from: istr)
                                           let iceP_returnValue: CustomCVSS = try CustomCVSSHelper.read(from: istr)
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_o)
                                       },
                                       context: context)
    }
}

@_documentation(visibility: internal)
public class CV_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return CV.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_CV() -> Ice.ValueTypeResolver {
        return CV_TypeResolver()
    }
}

open class CV: Ice.Value {
    public var i: Swift.Int32 = 0

    public required init() {}

    public init(i: Swift.Int32) {
        self.i = i
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::CV" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.i = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CV.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.i)
        ostr.endSlice()
    }
}

@_documentation(visibility: internal)
public class CR_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return CR.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_CR() -> Ice.ValueTypeResolver {
        return CR_TypeResolver()
    }
}

open class CR: Ice.Value {
    public var v: CV? = nil

    public required init() {}

    public init(v: CV?) {
        self.v = v
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::CR" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(CV.self) { self.v = $0 }
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CR.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.v)
        ostr.endSlice()
    }
}


/// Dispatcher for `I` servants.
public struct IDisp: Ice.Dispatcher {
    public let servant: I
    private static let defaultObject = Ice.ObjectI<ITraits>()

    public init(_ servant: I) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "ice_id":
            try await (servant as? Ice.Object ?? IDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? IDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? IDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? IDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol I {}


/// Dispatcher for `MyClass` servants.
public struct MyClassDisp: Ice.Dispatcher {
    public let servant: MyClass
    private static let defaultObject = Ice.ObjectI<MyClassTraits>()

    public init(_ servant: MyClass) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "ice_id":
            try await (servant as? Ice.Object ?? MyClassDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? MyClassDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? MyClassDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? MyClassDisp.defaultObject)._iceD_ice_ping(request)
        case "opABoolS":
            try await servant._iceD_opABoolS(request)
        case "opAByteS":
            try await servant._iceD_opAByteS(request)
        case "opACRS":
            try await servant._iceD_opACRS(request)
        case "opACVS":
            try await servant._iceD_opACVS(request)
        case "opADoubleS":
            try await servant._iceD_opADoubleS(request)
        case "opAEnS":
            try await servant._iceD_opAEnS(request)
        case "opAFloatS":
            try await servant._iceD_opAFloatS(request)
        case "opAIPrxS":
            try await servant._iceD_opAIPrxS(request)
        case "opAIntS":
            try await servant._iceD_opAIntS(request)
        case "opALongS":
            try await servant._iceD_opALongS(request)
        case "opAObjectPrxS":
            try await servant._iceD_opAObjectPrxS(request)
        case "opAObjectS":
            try await servant._iceD_opAObjectS(request)
        case "opAShortS":
            try await servant._iceD_opAShortS(request)
        case "opAStringS":
            try await servant._iceD_opAStringS(request)
        case "opAStructS":
            try await servant._iceD_opAStructS(request)
        case "opAStructSD":
            try await servant._iceD_opAStructSD(request)
        case "opCustomCVS":
            try await servant._iceD_opCustomCVS(request)
        case "opCustomCVSS":
            try await servant._iceD_opCustomCVSS(request)
        case "opCustomIntS":
            try await servant._iceD_opCustomIntS(request)
        case "opCustomIntSS":
            try await servant._iceD_opCustomIntSS(request)
        case "opKBoolS":
            try await servant._iceD_opKBoolS(request)
        case "opKByteS":
            try await servant._iceD_opKByteS(request)
        case "opKDoubleS":
            try await servant._iceD_opKDoubleS(request)
        case "opKEnS":
            try await servant._iceD_opKEnS(request)
        case "opKFloatS":
            try await servant._iceD_opKFloatS(request)
        case "opKIPrxS":
            try await servant._iceD_opKIPrxS(request)
        case "opKIntS":
            try await servant._iceD_opKIntS(request)
        case "opKLongS":
            try await servant._iceD_opKLongS(request)
        case "opKObjectPrxS":
            try await servant._iceD_opKObjectPrxS(request)
        case "opKShortS":
            try await servant._iceD_opKShortS(request)
        case "opKStringS":
            try await servant._iceD_opKStringS(request)
        case "opKStructS":
            try await servant._iceD_opKStructS(request)
        case "opKStructSD":
            try await servant._iceD_opKStructSD(request)
        case "opLBoolS":
            try await servant._iceD_opLBoolS(request)
        case "opLByteS":
            try await servant._iceD_opLByteS(request)
        case "opLCRS":
            try await servant._iceD_opLCRS(request)
        case "opLCVS":
            try await servant._iceD_opLCVS(request)
        case "opLDoubleS":
            try await servant._iceD_opLDoubleS(request)
        case "opLEnS":
            try await servant._iceD_opLEnS(request)
        case "opLFloatS":
            try await servant._iceD_opLFloatS(request)
        case "opLIPrxS":
            try await servant._iceD_opLIPrxS(request)
        case "opLIntS":
            try await servant._iceD_opLIntS(request)
        case "opLLongS":
            try await servant._iceD_opLLongS(request)
        case "opLObjectPrxS":
            try await servant._iceD_opLObjectPrxS(request)
        case "opLObjectS":
            try await servant._iceD_opLObjectS(request)
        case "opLShortS":
            try await servant._iceD_opLShortS(request)
        case "opLStringS":
            try await servant._iceD_opLStringS(request)
        case "opLStructS":
            try await servant._iceD_opLStructS(request)
        case "opLStructSD":
            try await servant._iceD_opLStructSD(request)
        case "opQBoolS":
            try await servant._iceD_opQBoolS(request)
        case "opQByteS":
            try await servant._iceD_opQByteS(request)
        case "opQDoubleS":
            try await servant._iceD_opQDoubleS(request)
        case "opQEnS":
            try await servant._iceD_opQEnS(request)
        case "opQFloatS":
            try await servant._iceD_opQFloatS(request)
        case "opQIPrxS":
            try await servant._iceD_opQIPrxS(request)
        case "opQIntS":
            try await servant._iceD_opQIntS(request)
        case "opQLongS":
            try await servant._iceD_opQLongS(request)
        case "opQObjectPrxS":
            try await servant._iceD_opQObjectPrxS(request)
        case "opQShortS":
            try await servant._iceD_opQShortS(request)
        case "opQStringS":
            try await servant._iceD_opQStringS(request)
        case "opQStructS":
            try await servant._iceD_opQStructS(request)
        case "opQStructSD":
            try await servant._iceD_opQStructSD(request)
        case "opSBoolS":
            try await servant._iceD_opSBoolS(request)
        case "opSByteS":
            try await servant._iceD_opSByteS(request)
        case "opSDoubleS":
            try await servant._iceD_opSDoubleS(request)
        case "opSEnS":
            try await servant._iceD_opSEnS(request)
        case "opSFloatS":
            try await servant._iceD_opSFloatS(request)
        case "opSIPrxS":
            try await servant._iceD_opSIPrxS(request)
        case "opSIntS":
            try await servant._iceD_opSIntS(request)
        case "opSLongS":
            try await servant._iceD_opSLongS(request)
        case "opSObjectPrxS":
            try await servant._iceD_opSObjectPrxS(request)
        case "opSShortS":
            try await servant._iceD_opSShortS(request)
        case "opSStringS":
            try await servant._iceD_opSStringS(request)
        case "opSStructS":
            try await servant._iceD_opSStructS(request)
        case "opSStructSD":
            try await servant._iceD_opSStructSD(request)
        case "shutdown":
            try await servant._iceD_shutdown(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol MyClass {
    func shutdown(current: Ice.Current) async throws

    func opAByteS(i: AByteS, current: Ice.Current) async throws -> (returnValue: AByteS, o: AByteS)

    func opLByteS(i: LByteS, current: Ice.Current) async throws -> (returnValue: LByteS, o: LByteS)

    func opKByteS(i: KByteS, current: Ice.Current) async throws -> (returnValue: KByteS, o: KByteS)

    func opQByteS(i: QByteS, current: Ice.Current) async throws -> (returnValue: QByteS, o: QByteS)

    func opSByteS(i: SByteS, current: Ice.Current) async throws -> (returnValue: SByteS, o: SByteS)

    func opABoolS(i: ABoolS, current: Ice.Current) async throws -> (returnValue: ABoolS, o: ABoolS)

    func opLBoolS(i: LBoolS, current: Ice.Current) async throws -> (returnValue: LBoolS, o: LBoolS)

    func opKBoolS(i: KBoolS, current: Ice.Current) async throws -> (returnValue: KBoolS, o: KBoolS)

    func opQBoolS(i: QBoolS, current: Ice.Current) async throws -> (returnValue: QBoolS, o: QBoolS)

    func opSBoolS(i: SBoolS, current: Ice.Current) async throws -> (returnValue: SBoolS, o: SBoolS)

    func opAShortS(i: AShortS, current: Ice.Current) async throws -> (returnValue: AShortS, o: AShortS)

    func opLShortS(i: LShortS, current: Ice.Current) async throws -> (returnValue: LShortS, o: LShortS)

    func opKShortS(i: KShortS, current: Ice.Current) async throws -> (returnValue: KShortS, o: KShortS)

    func opQShortS(i: QShortS, current: Ice.Current) async throws -> (returnValue: QShortS, o: QShortS)

    func opSShortS(i: SShortS, current: Ice.Current) async throws -> (returnValue: SShortS, o: SShortS)

    func opAIntS(i: AIntS, current: Ice.Current) async throws -> (returnValue: AIntS, o: AIntS)

    func opLIntS(i: LIntS, current: Ice.Current) async throws -> (returnValue: LIntS, o: LIntS)

    func opKIntS(i: KIntS, current: Ice.Current) async throws -> (returnValue: KIntS, o: KIntS)

    func opQIntS(i: QIntS, current: Ice.Current) async throws -> (returnValue: QIntS, o: QIntS)

    func opSIntS(i: SIntS, current: Ice.Current) async throws -> (returnValue: SIntS, o: SIntS)

    func opALongS(i: ALongS, current: Ice.Current) async throws -> (returnValue: ALongS, o: ALongS)

    func opLLongS(i: LLongS, current: Ice.Current) async throws -> (returnValue: LLongS, o: LLongS)

    func opKLongS(i: KLongS, current: Ice.Current) async throws -> (returnValue: KLongS, o: KLongS)

    func opQLongS(i: QLongS, current: Ice.Current) async throws -> (returnValue: QLongS, o: QLongS)

    func opSLongS(i: SLongS, current: Ice.Current) async throws -> (returnValue: SLongS, o: SLongS)

    func opAFloatS(i: AFloatS, current: Ice.Current) async throws -> (returnValue: AFloatS, o: AFloatS)

    func opLFloatS(i: LFloatS, current: Ice.Current) async throws -> (returnValue: LFloatS, o: LFloatS)

    func opKFloatS(i: KFloatS, current: Ice.Current) async throws -> (returnValue: KFloatS, o: KFloatS)

    func opQFloatS(i: QFloatS, current: Ice.Current) async throws -> (returnValue: QFloatS, o: QFloatS)

    func opSFloatS(i: SFloatS, current: Ice.Current) async throws -> (returnValue: SFloatS, o: SFloatS)

    func opADoubleS(i: ADoubleS, current: Ice.Current) async throws -> (returnValue: ADoubleS, o: ADoubleS)

    func opLDoubleS(i: LDoubleS, current: Ice.Current) async throws -> (returnValue: LDoubleS, o: LDoubleS)

    func opKDoubleS(i: KDoubleS, current: Ice.Current) async throws -> (returnValue: KDoubleS, o: KDoubleS)

    func opQDoubleS(i: QDoubleS, current: Ice.Current) async throws -> (returnValue: QDoubleS, o: QDoubleS)

    func opSDoubleS(i: SDoubleS, current: Ice.Current) async throws -> (returnValue: SDoubleS, o: SDoubleS)

    func opAStringS(i: AStringS, current: Ice.Current) async throws -> (returnValue: AStringS, o: AStringS)

    func opLStringS(i: LStringS, current: Ice.Current) async throws -> (returnValue: LStringS, o: LStringS)

    func opKStringS(i: KStringS, current: Ice.Current) async throws -> (returnValue: KStringS, o: KStringS)

    func opQStringS(i: QStringS, current: Ice.Current) async throws -> (returnValue: QStringS, o: QStringS)

    func opSStringS(i: SStringS, current: Ice.Current) async throws -> (returnValue: SStringS, o: SStringS)

    func opAObjectS(i: AObjectS, current: Ice.Current) async throws -> (returnValue: AObjectS, o: AObjectS)

    func opLObjectS(i: LObjectS, current: Ice.Current) async throws -> (returnValue: LObjectS, o: LObjectS)

    func opAObjectPrxS(i: AObjectPrxS, current: Ice.Current) async throws -> (returnValue: AObjectPrxS, o: AObjectPrxS)

    func opLObjectPrxS(i: LObjectPrxS, current: Ice.Current) async throws -> (returnValue: LObjectPrxS, o: LObjectPrxS)

    func opKObjectPrxS(i: KObjectPrxS, current: Ice.Current) async throws -> (returnValue: KObjectPrxS, o: KObjectPrxS)

    func opQObjectPrxS(i: QObjectPrxS, current: Ice.Current) async throws -> (returnValue: QObjectPrxS, o: QObjectPrxS)

    func opSObjectPrxS(i: SObjectPrxS, current: Ice.Current) async throws -> (returnValue: SObjectPrxS, o: SObjectPrxS)

    func opAStructS(i: AStructS, current: Ice.Current) async throws -> (returnValue: AStructS, o: AStructS)

    func opLStructS(i: LStructS, current: Ice.Current) async throws -> (returnValue: LStructS, o: LStructS)

    func opKStructS(i: KStructS, current: Ice.Current) async throws -> (returnValue: KStructS, o: KStructS)

    func opQStructS(i: QStructS, current: Ice.Current) async throws -> (returnValue: QStructS, o: QStructS)

    func opSStructS(i: SStructS, current: Ice.Current) async throws -> (returnValue: SStructS, o: SStructS)

    func opAStructSD(i: AStructSD, current: Ice.Current) async throws -> (returnValue: AStructSD, o: AStructSD)

    func opLStructSD(i: LStructSD, current: Ice.Current) async throws -> (returnValue: LStructSD, o: LStructSD)

    func opKStructSD(i: KStructSD, current: Ice.Current) async throws -> (returnValue: KStructSD, o: KStructSD)

    func opQStructSD(i: QStructSD, current: Ice.Current) async throws -> (returnValue: QStructSD, o: QStructSD)

    func opSStructSD(i: SStructSD, current: Ice.Current) async throws -> (returnValue: SStructSD, o: SStructSD)

    func opACVS(i: ACVS, current: Ice.Current) async throws -> (returnValue: ACVS, o: ACVS)

    func opLCVS(i: LCVS, current: Ice.Current) async throws -> (returnValue: LCVS, o: LCVS)

    func opACRS(i: ACRS, current: Ice.Current) async throws -> (returnValue: ACRS, o: ACRS)

    func opLCRS(i: LCRS, current: Ice.Current) async throws -> (returnValue: LCRS, o: LCRS)

    func opAEnS(i: AEnS, current: Ice.Current) async throws -> (returnValue: AEnS, o: AEnS)

    func opLEnS(i: LEnS, current: Ice.Current) async throws -> (returnValue: LEnS, o: LEnS)

    func opKEnS(i: KEnS, current: Ice.Current) async throws -> (returnValue: KEnS, o: KEnS)

    func opQEnS(i: QEnS, current: Ice.Current) async throws -> (returnValue: QEnS, o: QEnS)

    func opSEnS(i: SEnS, current: Ice.Current) async throws -> (returnValue: SEnS, o: SEnS)

    func opAIPrxS(i: AIPrxS, current: Ice.Current) async throws -> (returnValue: AIPrxS, o: AIPrxS)

    func opLIPrxS(i: LIPrxS, current: Ice.Current) async throws -> (returnValue: LIPrxS, o: LIPrxS)

    func opKIPrxS(i: KIPrxS, current: Ice.Current) async throws -> (returnValue: KIPrxS, o: KIPrxS)

    func opQIPrxS(i: QIPrxS, current: Ice.Current) async throws -> (returnValue: QIPrxS, o: QIPrxS)

    func opSIPrxS(i: SIPrxS, current: Ice.Current) async throws -> (returnValue: SIPrxS, o: SIPrxS)

    func opCustomIntS(i: CustomIntS, current: Ice.Current) async throws -> (returnValue: CustomIntS, o: CustomIntS)

    func opCustomCVS(i: CustomCVS, current: Ice.Current) async throws -> (returnValue: CustomCVS, o: CustomCVS)

    func opCustomIntSS(i: CustomIntSS, current: Ice.Current) async throws -> (returnValue: CustomIntSS, o: CustomIntSS)

    func opCustomCVSS(i: CustomCVSS, current: Ice.Current) async throws -> (returnValue: CustomCVSS, o: CustomCVSS)
}

extension I {}

extension MyClass {
    public func _iceD_shutdown(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.shutdown(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_opAByteS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: AByteS = try istr.read()
        let result = try await self.opAByteS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opLByteS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: LByteS = try istr.read()
        let result = try await self.opLByteS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opKByteS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: KByteS = try istr.read()
        let result = try await self.opKByteS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opQByteS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: QByteS = try istr.read()
        let result = try await self.opQByteS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opSByteS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: SByteS = try istr.read()
        let result = try await self.opSByteS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opABoolS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: ABoolS = try istr.read()
        let result = try await self.opABoolS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opLBoolS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: LBoolS = try istr.read()
        let result = try await self.opLBoolS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opKBoolS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: KBoolS = try istr.read()
        let result = try await self.opKBoolS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opQBoolS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: QBoolS = try istr.read()
        let result = try await self.opQBoolS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opSBoolS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: SBoolS = try istr.read()
        let result = try await self.opSBoolS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opAShortS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: AShortS = try istr.read()
        let result = try await self.opAShortS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opLShortS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: LShortS = try istr.read()
        let result = try await self.opLShortS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opKShortS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: KShortS = try istr.read()
        let result = try await self.opKShortS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opQShortS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: QShortS = try istr.read()
        let result = try await self.opQShortS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opSShortS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: SShortS = try istr.read()
        let result = try await self.opSShortS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opAIntS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: AIntS = try istr.read()
        let result = try await self.opAIntS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opLIntS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: LIntS = try istr.read()
        let result = try await self.opLIntS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opKIntS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: KIntS = try istr.read()
        let result = try await self.opKIntS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opQIntS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: QIntS = try istr.read()
        let result = try await self.opQIntS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opSIntS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: SIntS = try istr.read()
        let result = try await self.opSIntS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opALongS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: ALongS = try istr.read()
        let result = try await self.opALongS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opLLongS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: LLongS = try istr.read()
        let result = try await self.opLLongS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opKLongS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: KLongS = try istr.read()
        let result = try await self.opKLongS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opQLongS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: QLongS = try istr.read()
        let result = try await self.opQLongS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opSLongS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: SLongS = try istr.read()
        let result = try await self.opSLongS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opAFloatS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: AFloatS = try istr.read()
        let result = try await self.opAFloatS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opLFloatS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: LFloatS = try istr.read()
        let result = try await self.opLFloatS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opKFloatS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: KFloatS = try istr.read()
        let result = try await self.opKFloatS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opQFloatS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: QFloatS = try istr.read()
        let result = try await self.opQFloatS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opSFloatS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: SFloatS = try istr.read()
        let result = try await self.opSFloatS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opADoubleS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: ADoubleS = try istr.read()
        let result = try await self.opADoubleS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opLDoubleS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: LDoubleS = try istr.read()
        let result = try await self.opLDoubleS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opKDoubleS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: KDoubleS = try istr.read()
        let result = try await self.opKDoubleS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opQDoubleS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: QDoubleS = try istr.read()
        let result = try await self.opQDoubleS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opSDoubleS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: SDoubleS = try istr.read()
        let result = try await self.opSDoubleS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opAStringS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: AStringS = try istr.read()
        let result = try await self.opAStringS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opLStringS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: LStringS = try istr.read()
        let result = try await self.opLStringS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opKStringS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: KStringS = try istr.read()
        let result = try await self.opKStringS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opQStringS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: QStringS = try istr.read()
        let result = try await self.opQStringS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opSStringS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: SStringS = try istr.read()
        let result = try await self.opSStringS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opAObjectS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: AObjectS = try AObjectSHelper.read(from: istr)
        try istr.readPendingValues()
        let result = try await self.opAObjectS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            AObjectSHelper.write(to: ostr, value: iceP_o)
            AObjectSHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_opLObjectS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: LObjectS = try LObjectSHelper.read(from: istr)
        try istr.readPendingValues()
        let result = try await self.opLObjectS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            LObjectSHelper.write(to: ostr, value: iceP_o)
            LObjectSHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_opAObjectPrxS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: AObjectPrxS = try AObjectPrxSHelper.read(from: istr)
        let result = try await self.opAObjectPrxS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            AObjectPrxSHelper.write(to: ostr, value: iceP_o)
            AObjectPrxSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opLObjectPrxS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: LObjectPrxS = try LObjectPrxSHelper.read(from: istr)
        let result = try await self.opLObjectPrxS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            LObjectPrxSHelper.write(to: ostr, value: iceP_o)
            LObjectPrxSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opKObjectPrxS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: KObjectPrxS = try KObjectPrxSHelper.read(from: istr)
        let result = try await self.opKObjectPrxS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            KObjectPrxSHelper.write(to: ostr, value: iceP_o)
            KObjectPrxSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opQObjectPrxS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: QObjectPrxS = try QObjectPrxSHelper.read(from: istr)
        let result = try await self.opQObjectPrxS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            QObjectPrxSHelper.write(to: ostr, value: iceP_o)
            QObjectPrxSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opSObjectPrxS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: SObjectPrxS = try SObjectPrxSHelper.read(from: istr)
        let result = try await self.opSObjectPrxS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            SObjectPrxSHelper.write(to: ostr, value: iceP_o)
            SObjectPrxSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opAStructS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: AStructS = try AStructSHelper.read(from: istr)
        let result = try await self.opAStructS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            AStructSHelper.write(to: ostr, value: iceP_o)
            AStructSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opLStructS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: LStructS = try LStructSHelper.read(from: istr)
        let result = try await self.opLStructS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            LStructSHelper.write(to: ostr, value: iceP_o)
            LStructSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opKStructS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: KStructS = try KStructSHelper.read(from: istr)
        let result = try await self.opKStructS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            KStructSHelper.write(to: ostr, value: iceP_o)
            KStructSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opQStructS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: QStructS = try QStructSHelper.read(from: istr)
        let result = try await self.opQStructS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            QStructSHelper.write(to: ostr, value: iceP_o)
            QStructSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opSStructS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: SStructS = try SStructSHelper.read(from: istr)
        let result = try await self.opSStructS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            SStructSHelper.write(to: ostr, value: iceP_o)
            SStructSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opAStructSD(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: AStructSD = try AStructSDHelper.read(from: istr)
        let result = try await self.opAStructSD(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            AStructSDHelper.write(to: ostr, value: iceP_o)
            AStructSDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opLStructSD(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: LStructSD = try LStructSDHelper.read(from: istr)
        let result = try await self.opLStructSD(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            LStructSDHelper.write(to: ostr, value: iceP_o)
            LStructSDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opKStructSD(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: KStructSD = try KStructSDHelper.read(from: istr)
        let result = try await self.opKStructSD(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            KStructSDHelper.write(to: ostr, value: iceP_o)
            KStructSDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opQStructSD(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: QStructSD = try QStructSDHelper.read(from: istr)
        let result = try await self.opQStructSD(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            QStructSDHelper.write(to: ostr, value: iceP_o)
            QStructSDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opSStructSD(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: SStructSD = try SStructSDHelper.read(from: istr)
        let result = try await self.opSStructSD(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            SStructSDHelper.write(to: ostr, value: iceP_o)
            SStructSDHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opACVS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: ACVS = try ACVSHelper.read(from: istr)
        try istr.readPendingValues()
        let result = try await self.opACVS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ACVSHelper.write(to: ostr, value: iceP_o)
            ACVSHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_opLCVS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: LCVS = try LCVSHelper.read(from: istr)
        try istr.readPendingValues()
        let result = try await self.opLCVS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            LCVSHelper.write(to: ostr, value: iceP_o)
            LCVSHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_opACRS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: ACRS = try ACRSHelper.read(from: istr)
        try istr.readPendingValues()
        let result = try await self.opACRS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ACRSHelper.write(to: ostr, value: iceP_o)
            ACRSHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_opLCRS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: LCRS = try LCRSHelper.read(from: istr)
        try istr.readPendingValues()
        let result = try await self.opLCRS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            LCRSHelper.write(to: ostr, value: iceP_o)
            LCRSHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_opAEnS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: AEnS = try AEnSHelper.read(from: istr)
        let result = try await self.opAEnS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            AEnSHelper.write(to: ostr, value: iceP_o)
            AEnSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opLEnS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: LEnS = try LEnSHelper.read(from: istr)
        let result = try await self.opLEnS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            LEnSHelper.write(to: ostr, value: iceP_o)
            LEnSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opKEnS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: KEnS = try KEnSHelper.read(from: istr)
        let result = try await self.opKEnS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            KEnSHelper.write(to: ostr, value: iceP_o)
            KEnSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opQEnS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: QEnS = try QEnSHelper.read(from: istr)
        let result = try await self.opQEnS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            QEnSHelper.write(to: ostr, value: iceP_o)
            QEnSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opSEnS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: SEnS = try SEnSHelper.read(from: istr)
        let result = try await self.opSEnS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            SEnSHelper.write(to: ostr, value: iceP_o)
            SEnSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opAIPrxS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: AIPrxS = try AIPrxSHelper.read(from: istr)
        let result = try await self.opAIPrxS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            AIPrxSHelper.write(to: ostr, value: iceP_o)
            AIPrxSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opLIPrxS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: LIPrxS = try LIPrxSHelper.read(from: istr)
        let result = try await self.opLIPrxS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            LIPrxSHelper.write(to: ostr, value: iceP_o)
            LIPrxSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opKIPrxS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: KIPrxS = try KIPrxSHelper.read(from: istr)
        let result = try await self.opKIPrxS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            KIPrxSHelper.write(to: ostr, value: iceP_o)
            KIPrxSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opQIPrxS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: QIPrxS = try QIPrxSHelper.read(from: istr)
        let result = try await self.opQIPrxS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            QIPrxSHelper.write(to: ostr, value: iceP_o)
            QIPrxSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opSIPrxS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: SIPrxS = try SIPrxSHelper.read(from: istr)
        let result = try await self.opSIPrxS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            SIPrxSHelper.write(to: ostr, value: iceP_o)
            SIPrxSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opCustomIntS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: CustomIntS = try istr.read()
        let result = try await self.opCustomIntS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            ostr.write(iceP_o)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opCustomCVS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: CustomCVS = try CustomCVSHelper.read(from: istr)
        try istr.readPendingValues()
        let result = try await self.opCustomCVS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            CustomCVSHelper.write(to: ostr, value: iceP_o)
            CustomCVSHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_opCustomIntSS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: CustomIntSS = try CustomIntSSHelper.read(from: istr)
        let result = try await self.opCustomIntSS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            CustomIntSSHelper.write(to: ostr, value: iceP_o)
            CustomIntSSHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opCustomCVSS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_i: CustomCVSS = try CustomCVSSHelper.read(from: istr)
        try istr.readPendingValues()
        let result = try await self.opCustomCVSS(i: iceP_i, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_o) = value
            CustomCVSSHelper.write(to: ostr, value: iceP_o)
            CustomCVSSHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }
}
