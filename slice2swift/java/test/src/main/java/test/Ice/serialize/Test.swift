//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice

public enum MyEnum: Swift.UInt8 {
    /// enum1
    case enum1 = 0
    /// enum2
    case enum2 = 1
    /// enum3
    case enum3 = 2
    public init() {
        self = .enum1
    }
}

/// An `Ice.InputStream` extension to read `MyEnum` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - returns: `MyEnum` - The enumarated value.
    func read() throws -> MyEnum {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 2)
        guard let val = MyEnum(rawValue: rawValue) else {
            throw Ice.MarshalException("invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyEnum` - The enumerated value.
    func read(tag: Swift.Int32) throws -> MyEnum? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as MyEnum
    }
}

/// An `Ice.OutputStream` extension to write `MyEnum` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// parameter _: `MyEnum` - The enumerator to write.
    func write(_ v: MyEnum) {
        write(enum: v.rawValue, maxValue: 2)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// parameter _: `MyEnum` - The enumerator to write.
    func write(tag: Swift.Int32, value: MyEnum?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 2)
    }
}

public struct Struct1 {
    public var bo: Swift.Bool = false
    public var by: Swift.UInt8 = 0
    public var sh: Swift.Int16 = 0
    public var i: Swift.Int32 = 0
    public var l: Swift.Int64 = 0
    public var f: Swift.Float = 0.0
    public var d: Swift.Double = 0.0
    public var str: Swift.String = ""
    public var e: MyEnum = .enum1
    public var p: InitialPrx? = nil

    public init() {}

    public init(bo: Swift.Bool, by: Swift.UInt8, sh: Swift.Int16, i: Swift.Int32, l: Swift.Int64, f: Swift.Float, d: Swift.Double, str: Swift.String, e: MyEnum, p: InitialPrx?) {
        self.bo = bo
        self.by = by
        self.sh = sh
        self.i = i
        self.l = l
        self.f = f
        self.d = d
        self.str = str
        self.e = e
        self.p = p
    }
}

/// An `Ice.InputStream` extension to read `Struct1` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `Struct1` structured value from the stream.
    ///
    /// - returns: `Struct1` - The structured value read from the stream.
    func read() throws -> Struct1 {
        var v = Struct1()
        v.bo = try self.read()
        v.by = try self.read()
        v.sh = try self.read()
        v.i = try self.read()
        v.l = try self.read()
        v.f = try self.read()
        v.d = try self.read()
        v.str = try self.read()
        v.e = try self.read()
        v.p = try self.read(InitialPrx.self)
        return v
    }

    /// Read an optional `Struct1?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `Struct1?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> Struct1? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as Struct1
    }
}

/// An `Ice.OutputStream` extension to write `Struct1` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `Struct1` structured value to the stream.
    ///
    /// - parameter _: `Struct1` - The value to write to the stream.
    func write(_ v: Struct1) {
        self.write(v.bo)
        self.write(v.by)
        self.write(v.sh)
        self.write(v.i)
        self.write(v.l)
        self.write(v.f)
        self.write(v.d)
        self.write(v.str)
        self.write(v.e)
        self.write(v.p)
    }

    /// Write an optional `Struct1?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `Struct1?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: Struct1?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public typealias ByteS = Foundation.Data

public typealias IntS = [Swift.Int32]

public typealias MyEnumS = [MyEnum]

/// Helper class to read and write `MyEnumS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyEnumSHelper {
    /// Read a `MyEnumS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `MyEnumS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyEnumS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = MyEnumS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: MyEnum = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `MyEnumS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyEnumS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyEnumS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `MyEnumS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `MyEnumS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyEnumS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `MyEnumS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `MyEnumS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: MyEnumS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias BaseS = [Base?]

/// Helper class to read and write `BaseS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct BaseSHelper {
    /// Read a `BaseS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `BaseS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> BaseS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = BaseS(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(Base.self) { p.pointee = $0 }
            }
        }
        return v
    }
    /// Read an optional `BaseS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `BaseS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> BaseS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `BaseS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `BaseS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: BaseS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `BaseS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `BaseS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: BaseS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ByteBoolD = [Swift.UInt8: Swift.Bool]

/// Helper class to read and write `ByteBoolD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ByteBoolDHelper {
    /// Read a `ByteBoolD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ByteBoolD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ByteBoolD {
        let sz = try Swift.Int(istr.readSize())
        var v = ByteBoolD()
        for _ in 0 ..< sz {
            let key: Swift.UInt8 = try istr.read()
            let value: Swift.Bool = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `ByteBoolD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ByteBoolD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ByteBoolD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Wite a `ByteBoolD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ByteBoolD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ByteBoolD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `ByteBoolD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ByteBoolD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: ByteBoolD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 2) {
            write(to: ostr, value: val)
        }
    }
}

public typealias ShortIntD = [Swift.Int16: Swift.Int32]

/// Helper class to read and write `ShortIntD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ShortIntDHelper {
    /// Read a `ShortIntD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ShortIntD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ShortIntD {
        let sz = try Swift.Int(istr.readSize())
        var v = ShortIntD()
        for _ in 0 ..< sz {
            let key: Swift.Int16 = try istr.read()
            let value: Swift.Int32 = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `ShortIntD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ShortIntD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ShortIntD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Wite a `ShortIntD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ShortIntD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ShortIntD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `ShortIntD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ShortIntD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: ShortIntD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 6) {
            write(to: ostr, value: val)
        }
    }
}

public typealias StringMyEnumD = [Swift.String: MyEnum]

/// Helper class to read and write `StringMyEnumD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringMyEnumDHelper {
    /// Read a `StringMyEnumD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringMyEnumD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringMyEnumD {
        let sz = try Swift.Int(istr.readSize())
        var v = StringMyEnumD()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: MyEnum = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `StringMyEnumD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringMyEnumD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringMyEnumD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringMyEnumD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringMyEnumD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringMyEnumD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `StringMyEnumD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringMyEnumD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: StringMyEnumD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringBaseD = [Swift.String: Base?]

/// Helper class to read and write `StringBaseD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringBaseDHelper {
    /// Read a `StringBaseD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringBaseD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringBaseD {
        let sz = try Swift.Int(istr.readSize())
        var v = StringBaseD()
        let e = Ice.DictEntryArray<Swift.String, Base?>(size: sz)
        for i in 0 ..< sz {
            let key: Swift.String = try istr.read()
            v[key] = nil as Base?
            Swift.withUnsafeMutablePointer(to: &v[key, default:nil]) {
                e.values[i] = Ice.DictEntry<Swift.String, Base?>(key: key, value: $0)
            }
            try istr.read(Base.self) { e.values[i].value.pointee = $0 }
        }
        for i in 0..<sz {
            Swift.withUnsafeMutablePointer(to: &v[e.values[i].key, default:nil]) {
                e.values[i].value = $0
            }
        }
        return v
    }
    /// Read an optional `StringBaseD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringBaseD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringBaseD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringBaseD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringBaseD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringBaseD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `StringBaseD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringBaseD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: StringBaseD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// :nodoc:
public class Ex_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return Ex.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Ex() -> Ice.UserExceptionTypeResolver {
        return Ex_TypeResolver()
    }
}

open class Ex: Ice.UserException {
    public var s: Struct1 = Struct1()
    public var b: Base? = nil

    public required init() {}

    public init(s: Struct1, b: Base?) {
        self.s = s
        self.b = b
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Test::Ex" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Ex.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.s)
        ostr.write(self.b)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.s = try istr.read()
        try istr.read(Base.self) { self.b = $0 }
        try istr.endSlice()
    }

    open override func _usesClasses() -> Swift.Bool {
        return true
    }
}

/// Traits for Slice interface`Initial`.
public struct InitialTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Initial"]
    public static let staticId = "::Test::Initial"
}

/// InitialPrx overview.
///
/// InitialPrx Methods:
///
///  - getStruct1: 
///
///  - getStruct1Async: 
///
///  - getBase: 
///
///  - getBaseAsync: 
///
///  - getEx: 
///
///  - getExAsync: 
///
///  - shutdown: 
///
///  - shutdownAsync: 
public protocol InitialPrx: Ice.ObjectPrx {}

private final class InitialPrxI: Ice.ObjectPrxI, InitialPrx {
    public override class func ice_staticId() -> Swift.String {
        return InitialTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: InitialPrx.Protocol) throws -> InitialPrx {
    try communicator.makeProxyImpl(proxyString) as InitialPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `InitialPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `InitialPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: InitialPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> InitialPrx? {
    return try InitialPrxI.checkedCast(prx: prx, facet: facet, context: context) as InitialPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `InitialPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `InitialPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: InitialPrx.Protocol, facet: Swift.String? = nil) -> InitialPrx {
    return InitialPrxI.uncheckedCast(prx: prx, facet: facet) as InitialPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `InitialPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: InitialPrx.Protocol) -> Swift.String {
    return InitialTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `InitialPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `InitialPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `InitialPrx?` - The extracted proxy
    func read(_ type: InitialPrx.Protocol) throws -> InitialPrx? {
        return try read() as InitialPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `InitialPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `InitialPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: InitialPrx.Protocol) throws -> InitialPrx? {
        return try read(tag: tag) as InitialPrxI?
    }
}

/// InitialPrx overview.
///
/// InitialPrx Methods:
///
///  - getStruct1: 
///
///  - getStruct1Async: 
///
///  - getBase: 
///
///  - getBaseAsync: 
///
///  - getEx: 
///
///  - getExAsync: 
///
///  - shutdown: 
///
///  - shutdownAsync: 
public extension InitialPrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `ByteS`
    func getStruct1(context: Ice.Context? = nil) throws -> ByteS {
        return try _impl._invoke(operation: "getStruct1",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: ByteS = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `ByteS` - The result of the operation
    func getStruct1Async(context: Ice.Context? = nil) async throws -> ByteS {
        return try await _impl._invokeAsync(operation: "getStruct1",
                                            mode: .Normal,
                                            read: { istr in
                                                let iceP_returnValue: ByteS = try istr.read()
                                                return iceP_returnValue
                                            },
                                            context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `ByteS`
    func getBase(context: Ice.Context? = nil) throws -> ByteS {
        return try _impl._invoke(operation: "getBase",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: ByteS = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `ByteS` - The result of the operation
    func getBaseAsync(context: Ice.Context? = nil) async throws -> ByteS {
        return try await _impl._invokeAsync(operation: "getBase",
                                            mode: .Normal,
                                            read: { istr in
                                                let iceP_returnValue: ByteS = try istr.read()
                                                return iceP_returnValue
                                            },
                                            context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `ByteS`
    func getEx(context: Ice.Context? = nil) throws -> ByteS {
        return try _impl._invoke(operation: "getEx",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: ByteS = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `ByteS` - The result of the operation
    func getExAsync(context: Ice.Context? = nil) async throws -> ByteS {
        return try await _impl._invokeAsync(operation: "getEx",
                                            mode: .Normal,
                                            read: { istr in
                                                let iceP_returnValue: ByteS = try istr.read()
                                                return iceP_returnValue
                                            },
                                            context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func shutdown(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "shutdown",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `` - The result of the operation
    func shutdownAsync(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invokeAsync(operation: "shutdown",
                                            mode: .Normal,
                                            context: context)
    }
}

/// :nodoc:
public class Base_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Base.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Base() -> Ice.ValueTypeResolver {
        return Base_TypeResolver()
    }
}

open class Base: Ice.Value {
    public var b: Base? = nil
    public var o: Ice.Value? = nil
    public var s: Struct1 = Struct1()
    public var seq1: ByteS = ByteS()
    public var seq2: IntS = IntS()
    public var seq3: MyEnumS = MyEnumS()
    public var seq4: BaseS = BaseS()
    public var d1: ByteBoolD = ByteBoolD()
    public var d2: ShortIntD = ShortIntD()
    public var d3: StringMyEnumD = StringMyEnumD()
    public var d4: StringBaseD = StringBaseD()

    public required init() {}

    public init(b: Base?, o: Ice.Value?, s: Struct1, seq1: ByteS, seq2: IntS, seq3: MyEnumS, seq4: BaseS, d1: ByteBoolD, d2: ShortIntD, d3: StringMyEnumD, d4: StringBaseD) {
        self.b = b
        self.o = o
        self.s = s
        self.seq1 = seq1
        self.seq2 = seq2
        self.seq3 = seq3
        self.seq4 = seq4
        self.d1 = d1
        self.d2 = d2
        self.d3 = d3
        self.d4 = d4
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::Base" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(Base.self) { self.b = $0 }
        try istr.read() { self.o = $0 }
        self.s = try istr.read()
        self.seq1 = try istr.read()
        self.seq2 = try istr.read()
        self.seq3 = try MyEnumSHelper.read(from: istr)
        self.seq4 = try BaseSHelper.read(from: istr)
        self.d1 = try ByteBoolDHelper.read(from: istr)
        self.d2 = try ShortIntDHelper.read(from: istr)
        self.d3 = try StringMyEnumDHelper.read(from: istr)
        self.d4 = try StringBaseDHelper.read(from: istr)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Base.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.b)
        ostr.write(self.o)
        ostr.write(self.s)
        ostr.write(self.seq1)
        ostr.write(self.seq2)
        MyEnumSHelper.write(to: ostr, value: self.seq3)
        BaseSHelper.write(to: ostr, value: self.seq4)
        ByteBoolDHelper.write(to: ostr, value: self.d1)
        ShortIntDHelper.write(to: ostr, value: self.d2)
        StringMyEnumDHelper.write(to: ostr, value: self.d3)
        StringBaseDHelper.write(to: ostr, value: self.d4)
        ostr.endSlice()
    }
}

/// :nodoc:
public class Derived_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Derived.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Derived() -> Ice.ValueTypeResolver {
        return Derived_TypeResolver()
    }
}

open class Derived: Base {
    public var p: Ice.ObjectPrx? = nil

    public required init() {
        super.init()
    }

    public init(b: Base?, o: Ice.Value?, s: Struct1, seq1: ByteS, seq2: IntS, seq3: MyEnumS, seq4: BaseS, d1: ByteBoolD, d2: ShortIntD, d3: StringMyEnumD, d4: StringBaseD, p: Ice.ObjectPrx?) {
        self.p = p
        super.init(b: b, o: o, s: s, seq1: seq1, seq2: seq2, seq3: seq3, seq4: seq4, d1: d1, d2: d2, d3: d3, d4: d4)
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::Derived" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.p = try istr.read(Ice.ObjectPrx.self)
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Derived.ice_staticId(), compactId: -1, last: false)
        ostr.write(self.p)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}


/// Dispatcher for `Initial` servants.
public struct InitialDisp: Ice.Dispatcher {
    public let servant: Initial
    private static let defaultObject = Ice.ObjectI<InitialTraits>()

    public init(_ servant: Initial) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "getBase":
            try await servant._iceD_getBase(request)
        case "getEx":
            try await servant._iceD_getEx(request)
        case "getStruct1":
            try await servant._iceD_getStruct1(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? InitialDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? InitialDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? InitialDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? InitialDisp.defaultObject)._iceD_ice_ping(request)
        case "shutdown":
            try await servant._iceD_shutdown(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol Initial {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `ByteS` - The result of the operation
    func getStruct1(current: Ice.Current) async throws -> ByteS

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `ByteS` - The result of the operation
    func getBase(current: Ice.Current) async throws -> ByteS

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `ByteS` - The result of the operation
    func getEx(current: Ice.Current) async throws -> ByteS

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `` - The result of the operation
    func shutdown(current: Ice.Current) async throws
}

/// Initial overview.
///
/// Initial Methods:
///
///  - getStruct1: 
///
///  - getBase: 
///
///  - getEx: 
///
///  - shutdown: 
extension Initial {
    public func _iceD_getStruct1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getStruct1(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_getBase(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getBase(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_getEx(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getEx(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_shutdown(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.shutdown(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}
