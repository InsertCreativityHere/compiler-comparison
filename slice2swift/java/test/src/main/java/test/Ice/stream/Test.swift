//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice
import PromiseKit

public enum MyEnum: Swift.UInt8 {
    /// enum1
    case enum1 = 0
    /// enum2
    case enum2 = 1
    /// enum3
    case enum3 = 2
    public init() {
        self = .enum1
    }
}

/// An `Ice.InputStream` extension to read `MyEnum` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - returns: `MyEnum` - The enumarated value.
    func read() throws -> MyEnum {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 2)
        guard let val = MyEnum(rawValue: rawValue) else {
            throw Ice.MarshalException("invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyEnum` - The enumerated value.
    func read(tag: Swift.Int32) throws -> MyEnum? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as MyEnum
    }
}

/// An `Ice.OutputStream` extension to write `MyEnum` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// parameter _: `MyEnum` - The enumerator to write.
    func write(_ v: MyEnum) {
        write(enum: v.rawValue, maxValue: 2)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// parameter _: `MyEnum` - The enumerator to write.
    func write(tag: Swift.Int32, value: MyEnum?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 2)
    }
}

public typealias SerialSmall = Foundation.Data

public struct LargeStruct {
    public var bo: Swift.Bool = false
    public var by: Swift.UInt8 = 0
    public var sh: Swift.Int16 = 0
    public var i: Swift.Int32 = 0
    public var l: Swift.Int64 = 0
    public var f: Swift.Float = 0.0
    public var d: Swift.Double = 0.0
    public var str: Swift.String = ""
    public var e: MyEnum = .enum1
    public var p: MyInterfacePrx? = nil
    public var ss: SerialSmall = SerialSmall()

    public init() {}

    public init(bo: Swift.Bool, by: Swift.UInt8, sh: Swift.Int16, i: Swift.Int32, l: Swift.Int64, f: Swift.Float, d: Swift.Double, str: Swift.String, e: MyEnum, p: MyInterfacePrx?, ss: SerialSmall) {
        self.bo = bo
        self.by = by
        self.sh = sh
        self.i = i
        self.l = l
        self.f = f
        self.d = d
        self.str = str
        self.e = e
        self.p = p
        self.ss = ss
    }
}

/// An `Ice.InputStream` extension to read `LargeStruct` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `LargeStruct` structured value from the stream.
    ///
    /// - returns: `LargeStruct` - The structured value read from the stream.
    func read() throws -> LargeStruct {
        var v = LargeStruct()
        v.bo = try self.read()
        v.by = try self.read()
        v.sh = try self.read()
        v.i = try self.read()
        v.l = try self.read()
        v.f = try self.read()
        v.d = try self.read()
        v.str = try self.read()
        v.e = try self.read()
        v.p = try self.read(MyInterfacePrx.self)
        v.ss = try self.read()
        return v
    }

    /// Read an optional `LargeStruct?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LargeStruct?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> LargeStruct? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as LargeStruct
    }
}

/// An `Ice.OutputStream` extension to write `LargeStruct` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `LargeStruct` structured value to the stream.
    ///
    /// - parameter _: `LargeStruct` - The value to write to the stream.
    func write(_ v: LargeStruct) {
        self.write(v.bo)
        self.write(v.by)
        self.write(v.sh)
        self.write(v.i)
        self.write(v.l)
        self.write(v.f)
        self.write(v.d)
        self.write(v.str)
        self.write(v.e)
        self.write(v.p)
        self.write(v.ss)
    }

    /// Write an optional `LargeStruct?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LargeStruct?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: LargeStruct?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public struct Point: Swift.Hashable {
    public var x: Swift.Int32 = 0
    public var y: Swift.Int32 = 0

    public init() {}

    public init(x: Swift.Int32, y: Swift.Int32) {
        self.x = x
        self.y = y
    }
}

/// An `Ice.InputStream` extension to read `Point` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `Point` structured value from the stream.
    ///
    /// - returns: `Point` - The structured value read from the stream.
    func read() throws -> Point {
        var v = Point()
        v.x = try self.read()
        v.y = try self.read()
        return v
    }

    /// Read an optional `Point?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `Point?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> Point? {
        guard try readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try skipSize()
        return try read() as Point
    }
}

/// An `Ice.OutputStream` extension to write `Point` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `Point` structured value to the stream.
    ///
    /// - parameter _: `Point` - The value to write to the stream.
    func write(_ v: Point) {
        self.write(v.x)
        self.write(v.y)
    }

    /// Write an optional `Point?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `Point?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: Point?) {
        if let v = value {
            if writeOptional(tag: tag, format: .VSize) {
                write(size: 8)
                write(v)
            }
        }
    }
}

public typealias MyEnumS = [MyEnum]

/// Helper class to read and write `MyEnumS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyEnumSHelper {
    /// Read a `MyEnumS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `MyEnumS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyEnumS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = MyEnumS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: MyEnum = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `MyEnumS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyEnumS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyEnumS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `MyEnumS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `MyEnumS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyEnumS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `MyEnumS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `MyEnumS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: MyEnumS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias MyClassS = [MyClass?]

/// Helper class to read and write `MyClassS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyClassSHelper {
    /// Read a `MyClassS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `MyClassS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyClassS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = MyClassS(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(MyClass.self) { p.pointee = $0 }
            }
        }
        return v
    }
    /// Read an optional `MyClassS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyClassS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyClassS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `MyClassS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `MyClassS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyClassS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `MyClassS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `MyClassS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: MyClassS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ByteBoolD = [Swift.UInt8: Swift.Bool]

/// Helper class to read and write `ByteBoolD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ByteBoolDHelper {
    /// Read a `ByteBoolD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ByteBoolD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ByteBoolD {
        let sz = try Swift.Int(istr.readSize())
        var v = ByteBoolD()
        for _ in 0 ..< sz {
            let key: Swift.UInt8 = try istr.read()
            let value: Swift.Bool = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `ByteBoolD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ByteBoolD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ByteBoolD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Wite a `ByteBoolD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ByteBoolD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ByteBoolD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `ByteBoolD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ByteBoolD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: ByteBoolD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 2) {
            write(to: ostr, value: val)
        }
    }
}

public typealias ShortIntD = [Swift.Int16: Swift.Int32]

/// Helper class to read and write `ShortIntD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ShortIntDHelper {
    /// Read a `ShortIntD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ShortIntD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ShortIntD {
        let sz = try Swift.Int(istr.readSize())
        var v = ShortIntD()
        for _ in 0 ..< sz {
            let key: Swift.Int16 = try istr.read()
            let value: Swift.Int32 = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `ShortIntD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ShortIntD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ShortIntD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Wite a `ShortIntD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ShortIntD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ShortIntD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `ShortIntD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ShortIntD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: ShortIntD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 6) {
            write(to: ostr, value: val)
        }
    }
}

public typealias StringMyClassD = [Swift.String: MyClass?]

/// Helper class to read and write `StringMyClassD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringMyClassDHelper {
    /// Read a `StringMyClassD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringMyClassD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringMyClassD {
        let sz = try Swift.Int(istr.readSize())
        var v = StringMyClassD()
        let e = Ice.DictEntryArray<Swift.String, MyClass?>(size: sz)
        for i in 0 ..< sz {
            let key: Swift.String = try istr.read()
            v[key] = nil as MyClass?
            Swift.withUnsafeMutablePointer(to: &v[key, default:nil]) {
                e.values[i] = Ice.DictEntry<Swift.String, MyClass?>(key: key, value: $0)
            }
            try istr.read(MyClass.self) { e.values[i].value.pointee = $0 }
        }
        for i in 0..<sz {
            Swift.withUnsafeMutablePointer(to: &v[e.values[i].key, default:nil]) {
                e.values[i].value = $0
            }
        }
        return v
    }
    /// Read an optional `StringMyClassD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringMyClassD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringMyClassD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringMyClassD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringMyClassD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringMyClassD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `StringMyClassD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringMyClassD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: StringMyClassD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias BoolSS = [Ice.BoolSeq]

/// Helper class to read and write `BoolSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct BoolSSHelper {
    /// Read a `BoolSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `BoolSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> BoolSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = BoolSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: Ice.BoolSeq = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `BoolSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `BoolSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> BoolSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `BoolSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `BoolSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: BoolSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `BoolSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `BoolSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: BoolSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ByteSS = [Ice.ByteSeq]

/// Helper class to read and write `ByteSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ByteSSHelper {
    /// Read a `ByteSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ByteSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ByteSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = ByteSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: Ice.ByteSeq = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `ByteSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ByteSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ByteSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ByteSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ByteSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ByteSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `ByteSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ByteSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ByteSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ShortSS = [Ice.ShortSeq]

/// Helper class to read and write `ShortSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ShortSSHelper {
    /// Read a `ShortSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ShortSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ShortSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = ShortSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: Ice.ShortSeq = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `ShortSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ShortSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ShortSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ShortSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ShortSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ShortSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `ShortSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ShortSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ShortSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias IntSS = [Ice.IntSeq]

/// Helper class to read and write `IntSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct IntSSHelper {
    /// Read a `IntSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `IntSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> IntSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = IntSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: Ice.IntSeq = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `IntSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `IntSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> IntSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `IntSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `IntSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: IntSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `IntSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `IntSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: IntSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias LongSS = [Ice.LongSeq]

/// Helper class to read and write `LongSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LongSSHelper {
    /// Read a `LongSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `LongSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LongSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = LongSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: Ice.LongSeq = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `LongSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LongSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LongSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `LongSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `LongSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LongSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `LongSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LongSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: LongSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias FloatSS = [Ice.FloatSeq]

/// Helper class to read and write `FloatSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct FloatSSHelper {
    /// Read a `FloatSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `FloatSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> FloatSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = FloatSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: Ice.FloatSeq = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `FloatSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `FloatSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> FloatSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `FloatSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `FloatSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: FloatSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `FloatSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `FloatSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: FloatSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias DoubleSS = [Ice.DoubleSeq]

/// Helper class to read and write `DoubleSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct DoubleSSHelper {
    /// Read a `DoubleSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `DoubleSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> DoubleSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = DoubleSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: Ice.DoubleSeq = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `DoubleSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `DoubleSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> DoubleSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `DoubleSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `DoubleSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: DoubleSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `DoubleSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `DoubleSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: DoubleSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias StringSS = [Ice.StringSeq]

/// Helper class to read and write `StringSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringSSHelper {
    /// Read a `StringSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = StringSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: Ice.StringSeq = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional `StringSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringSS) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `StringSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: StringSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias MyEnumSS = [MyEnumS]

/// Helper class to read and write `MyEnumSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyEnumSSHelper {
    /// Read a `MyEnumSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `MyEnumSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyEnumSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = MyEnumSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: MyEnumS = try MyEnumSHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `MyEnumSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyEnumSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyEnumSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `MyEnumSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `MyEnumSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyEnumSS) {
        ostr.write(size: v.count)
        for item in v {
            MyEnumSHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `MyEnumSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `MyEnumSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: MyEnumSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias MyClassSS = [MyClassS]

/// Helper class to read and write `MyClassSS` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct MyClassSSHelper {
    /// Read a `MyClassSS` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `MyClassSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> MyClassSS {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = MyClassSS()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: MyClassS = try MyClassSHelper.read(from: istr)
            v.append(j)
        }
        return v
    }
    /// Read an optional `MyClassSS?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `MyClassSS` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> MyClassSS? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `MyClassSS` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `MyClassSS` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: MyClassSS) {
        ostr.write(size: v.count)
        for item in v {
            MyClassSHelper.write(to: ostr, value: item)
        }
    }

    /// Wite an optional `MyClassSS?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `MyClassSS` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: MyClassSS?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias LongFloatD = [Swift.Int64: Swift.Float]

/// Helper class to read and write `LongFloatD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LongFloatDHelper {
    /// Read a `LongFloatD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `LongFloatD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LongFloatD {
        let sz = try Swift.Int(istr.readSize())
        var v = LongFloatD()
        for _ in 0 ..< sz {
            let key: Swift.Int64 = try istr.read()
            let value: Swift.Float = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `LongFloatD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LongFloatD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LongFloatD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Wite a `LongFloatD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `LongFloatD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LongFloatD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `LongFloatD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LongFloatD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: LongFloatD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 12) {
            write(to: ostr, value: val)
        }
    }
}

public typealias StringStringD = [Swift.String: Swift.String]

/// Helper class to read and write `StringStringD` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct StringStringDHelper {
    /// Read a `StringStringD` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `StringStringD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> StringStringD {
        let sz = try Swift.Int(istr.readSize())
        var v = StringStringD()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: Swift.String = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `StringStringD?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StringStringD` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> StringStringD? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `StringStringD` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `StringStringD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: StringStringD) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `StringStringD?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StringStringD` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: StringStringD?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// :nodoc:
public class MyException_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return MyException.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_MyException() -> Ice.UserExceptionTypeResolver {
        return MyException_TypeResolver()
    }
}

open class MyException: Ice.UserException {
    public var c: MyClass? = nil

    public required init() {}

    public init(c: MyClass?) {
        self.c = c
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Test::MyException" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: MyException.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.c)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(MyClass.self) { self.c = $0 }
        try istr.endSlice()
    }

    open override func _usesClasses() -> Swift.Bool {
        return true
    }
}

/// Traits for Slice interface`MyInterface`.
public struct MyInterfaceTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::MyInterface"]
    public static let staticId = "::Test::MyInterface"
}

/// MyInterfacePrx overview.
public protocol MyInterfacePrx: Ice.ObjectPrx {}

private final class MyInterfacePrxI: Ice.ObjectPrxI, MyInterfacePrx {
    public override class func ice_staticId() -> Swift.String {
        return MyInterfaceTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: MyInterfacePrx.Protocol) throws -> MyInterfacePrx {
    try communicator.makeProxyImpl(proxyString) as MyInterfacePrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `MyInterfacePrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `MyInterfacePrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: MyInterfacePrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> MyInterfacePrx? {
    return try MyInterfacePrxI.checkedCast(prx: prx, facet: facet, context: context) as MyInterfacePrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `MyInterfacePrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `MyInterfacePrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: MyInterfacePrx.Protocol, facet: Swift.String? = nil) -> MyInterfacePrx {
    return MyInterfacePrxI.uncheckedCast(prx: prx, facet: facet) as MyInterfacePrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `MyInterfacePrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: MyInterfacePrx.Protocol) -> Swift.String {
    return MyInterfaceTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `MyInterfacePrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `MyInterfacePrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `MyInterfacePrx?` - The extracted proxy
    func read(_ type: MyInterfacePrx.Protocol) throws -> MyInterfacePrx? {
        return try read() as MyInterfacePrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `MyInterfacePrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `MyInterfacePrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: MyInterfacePrx.Protocol) throws -> MyInterfacePrx? {
        return try read(tag: tag) as MyInterfacePrxI?
    }
}

/// MyInterfacePrx overview.
public extension MyInterfacePrx {}

/// :nodoc:
public class OptionalClass_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return OptionalClass.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_OptionalClass() -> Ice.ValueTypeResolver {
        return OptionalClass_TypeResolver()
    }
}

open class OptionalClass: Ice.Value {
    public var bo: Swift.Bool = false
    public var by: Swift.UInt8 = 0
    public var sh: Swift.Int16? = nil
    public var i: Swift.Int32? = nil
    public var s: LargeStruct? = nil
    public var enumS4: MyEnumS? = nil
    public var byteBoolD6: ByteBoolD? = nil
    public var shortIntD7: ShortIntD? = nil
    public var enum8: MyEnum? = nil
    public var intSeq12: Ice.IntSeq? = nil
    public var byteSeq13: Ice.ByteSeq? = nil
    public var stringSeq14: Ice.StringSeq? = nil
    public var p15: Point? = nil

    public required init() {}

    public init(bo: Swift.Bool, by: Swift.UInt8, sh: Swift.Int16?, i: Swift.Int32?, s: LargeStruct?, enumS4: MyEnumS?, byteBoolD6: ByteBoolD?, shortIntD7: ShortIntD?, enum8: MyEnum?, intSeq12: Ice.IntSeq?, byteSeq13: Ice.ByteSeq?, stringSeq14: Ice.StringSeq?, p15: Point?) {
        self.bo = bo
        self.by = by
        self.sh = sh
        self.i = i
        self.s = s
        self.enumS4 = enumS4
        self.byteBoolD6 = byteBoolD6
        self.shortIntD7 = shortIntD7
        self.enum8 = enum8
        self.intSeq12 = intSeq12
        self.byteSeq13 = byteSeq13
        self.stringSeq14 = stringSeq14
        self.p15 = p15
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::OptionalClass" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.bo = try istr.read()
        self.by = try istr.read()
        self.sh = try istr.read(tag: 1)
        self.i = try istr.read(tag: 2)
        self.s = try istr.read(tag: 3)
        self.enumS4 = try MyEnumSHelper.read(from: istr, tag: 4)
        self.byteBoolD6 = try ByteBoolDHelper.read(from: istr, tag: 6)
        self.shortIntD7 = try ShortIntDHelper.read(from: istr, tag: 7)
        self.enum8 = try istr.read(tag: 8)
        self.intSeq12 = try istr.read(tag: 12)
        self.byteSeq13 = try istr.read(tag: 13)
        self.stringSeq14 = try istr.read(tag: 14)
        self.p15 = try istr.read(tag: 15)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: OptionalClass.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.bo)
        ostr.write(self.by)
        ostr.write(tag: 1, value: self.sh)
        ostr.write(tag: 2, value: self.i)
        ostr.write(tag: 3, value: self.s)
        MyEnumSHelper.write(to: ostr, tag: 4, value: self.enumS4)
        ByteBoolDHelper.write(to: ostr, tag: 6, value: self.byteBoolD6)
        ShortIntDHelper.write(to: ostr, tag: 7, value: self.shortIntD7)
        ostr.write(tag: 8, value: self.enum8)
        ostr.write(tag: 12, value: self.intSeq12)
        ostr.write(tag: 13, value: self.byteSeq13)
        ostr.write(tag: 14, value: self.stringSeq14)
        ostr.write(tag: 15, value: self.p15)
        ostr.endSlice()
    }
}

/// :nodoc:
public class MyClass_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return MyClass.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_MyClass() -> Ice.ValueTypeResolver {
        return MyClass_TypeResolver()
    }
}

open class MyClass: Ice.Value {
    public var c: MyClass? = nil
    public var prx: MyInterfacePrx? = nil
    public var o: Ice.Value? = nil
    public var s: LargeStruct = LargeStruct()
    public var seq1: Ice.BoolSeq = Ice.BoolSeq()
    public var seq2: Ice.ByteSeq = Ice.ByteSeq()
    public var seq3: Ice.ShortSeq = Ice.ShortSeq()
    public var seq4: Ice.IntSeq = Ice.IntSeq()
    public var seq5: Ice.LongSeq = Ice.LongSeq()
    public var seq6: Ice.FloatSeq = Ice.FloatSeq()
    public var seq7: Ice.DoubleSeq = Ice.DoubleSeq()
    public var seq8: Ice.StringSeq = Ice.StringSeq()
    public var seq9: MyEnumS = MyEnumS()
    public var seq10: MyClassS = MyClassS()
    public var d: StringMyClassD = StringMyClassD()

    public required init() {}

    public init(c: MyClass?, prx: MyInterfacePrx?, o: Ice.Value?, s: LargeStruct, seq1: Ice.BoolSeq, seq2: Ice.ByteSeq, seq3: Ice.ShortSeq, seq4: Ice.IntSeq, seq5: Ice.LongSeq, seq6: Ice.FloatSeq, seq7: Ice.DoubleSeq, seq8: Ice.StringSeq, seq9: MyEnumS, seq10: MyClassS, d: StringMyClassD) {
        self.c = c
        self.prx = prx
        self.o = o
        self.s = s
        self.seq1 = seq1
        self.seq2 = seq2
        self.seq3 = seq3
        self.seq4 = seq4
        self.seq5 = seq5
        self.seq6 = seq6
        self.seq7 = seq7
        self.seq8 = seq8
        self.seq9 = seq9
        self.seq10 = seq10
        self.d = d
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::MyClass" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(MyClass.self) { self.c = $0 }
        self.prx = try istr.read(MyInterfacePrx.self)
        try istr.read() { self.o = $0 }
        self.s = try istr.read()
        self.seq1 = try istr.read()
        self.seq2 = try istr.read()
        self.seq3 = try istr.read()
        self.seq4 = try istr.read()
        self.seq5 = try istr.read()
        self.seq6 = try istr.read()
        self.seq7 = try istr.read()
        self.seq8 = try istr.read()
        self.seq9 = try MyEnumSHelper.read(from: istr)
        self.seq10 = try MyClassSHelper.read(from: istr)
        self.d = try StringMyClassDHelper.read(from: istr)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: MyClass.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.c)
        ostr.write(self.prx)
        ostr.write(self.o)
        ostr.write(self.s)
        ostr.write(self.seq1)
        ostr.write(self.seq2)
        ostr.write(self.seq3)
        ostr.write(self.seq4)
        ostr.write(self.seq5)
        ostr.write(self.seq6)
        ostr.write(self.seq7)
        ostr.write(self.seq8)
        MyEnumSHelper.write(to: ostr, value: self.seq9)
        MyClassSHelper.write(to: ostr, value: self.seq10)
        StringMyClassDHelper.write(to: ostr, value: self.d)
        ostr.endSlice()
    }
}


/// Dispatcher for `MyInterface` servants.
public struct MyInterfaceDisp: Ice.Dispatcher {
    public let servant: MyInterface
    private static let defaultObject = Ice.ObjectI<MyInterfaceTraits>()

    public init(_ servant: MyInterface) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        switch request.current.operation {
        case "ice_id":
            (servant as? Ice.Object ?? MyInterfaceDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            (servant as? Ice.Object ?? MyInterfaceDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            (servant as? Ice.Object ?? MyInterfaceDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            (servant as? Ice.Object ?? MyInterfaceDisp.defaultObject)._iceD_ice_ping(request)
        default:
            PromiseKit.Promise(error: Ice.OperationNotExistException())
        }
    }
}

public protocol MyInterface {}

/// MyInterface overview.
extension MyInterface {}
