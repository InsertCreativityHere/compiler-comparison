//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Key.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice
import PromiseKit

public enum assert: Swift.UInt8 {
    /// boolean
    case boolean = 0
    public init() {
        self = .boolean
    }
}

/// An `Ice.InputStream` extension to read `assert` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - returns: `assert` - The enumarated value.
    func read() throws -> assert {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 0)
        guard let val = assert(rawValue: rawValue) else {
            throw Ice.MarshalException(reason: "invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `assert` - The enumerated value.
    func read(tag: Swift.Int32) throws -> assert? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as assert
    }
}

/// An `Ice.OutputStream` extension to write `assert` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// parameter _: `assert` - The enumerator to write.
    func write(_ v: assert) {
        write(enum: v.rawValue, maxValue: 0)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// parameter _: `assert` - The enumerator to write.
    func write(tag: Swift.Int32, value: assert?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 0)
    }
}

public struct `break`: Swift.Hashable {
    public var `case`: Swift.Int32 = 0

    public init() {}

    public init(`case`: Swift.Int32) {
        self.`case` = `case`
    }
}

/// An `Ice.InputStream` extension to read ``break`` structured values from the stream.
public extension Ice.InputStream {
    /// Read a ``break`` structured value from the stream.
    ///
    /// - returns: ``break`` - The structured value read from the stream.
    func read() throws -> `break` {
        var v = `break`()
        v.`case` = try self.read()
        return v
    }

    /// Read an optional ``break`?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: ``break`?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> `break`? {
        guard try readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try skipSize()
        return try read() as `break`
    }
}

/// An `Ice.OutputStream` extension to write ``break`` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a ``break`` structured value to the stream.
    ///
    /// - parameter _: ``break`` - The value to write to the stream.
    func write(_ v: `break`) {
        self.write(v.`case`)
    }

    /// Write an optional ``break`?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: ``break`?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: `break`?) {
        if let v = value {
            if writeOptional(tag: tag, format: .VSize) {
                write(size: 4)
                write(v)
            }
        }
    }
}

/// Traits for Slice interface``catch``.
public struct catchTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::abstract::catch"]
    public static let staticId = "::abstract::catch"
}

/// Traits for Slice interface``default``.
public struct defaultTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::abstract::default"]
    public static let staticId = "::abstract::default"
}

/// Traits for Slice class``else``.
public struct elseTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::abstract::else"]
    public static let staticId = "::abstract::else"
}

/// Traits for Slice interface`finalize`.
public struct finalizeTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::abstract::catch", "::abstract::default", "::abstract::finalize"]
    public static let staticId = "::abstract::finalize"
}

public typealias `for` = [assert]

/// Helper class to read and write ``for`` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct forHelper {
    /// Read a ``for`` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: ``for`` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> `for` {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = `for`()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: assert = try istr.read()
            v.append(j)
        }
        return v
    }
    /// Read an optional ``for`?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: ``for`` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> `for`? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a ``for`` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: ``for`` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: `for`) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional ``for`?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: ``for`` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: `for`?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias goto = [Swift.String: assert]

/// Helper class to read and write `goto` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct gotoHelper {
    /// Read a `goto` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `goto` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> goto {
        let sz = try Swift.Int(istr.readSize())
        var v = goto()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: assert = try istr.read()
            v[key] = value
        }
        return v
    }
    /// Read an optional `goto?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `goto` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> goto? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `goto` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `goto` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: goto) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `goto?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `goto` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: goto?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// :nodoc:
public class hashCode_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return hashCode.self
    }
}

public extension Ice.ClassResolver {
    @objc static func abstract_hashCode() -> Ice.UserExceptionTypeResolver {
        return hashCode_TypeResolver()
    }
}

open class hashCode: Ice.UserException {
    public var `if`: Swift.Int32 = 0

    public required init() {}

    public init(`if`: Swift.Int32) {
        self.`if` = `if`
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::abstract::hashCode"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: hashCode.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.`if`)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.`if` = try istr.read()
        try istr.endSlice()
    }
}

/// :nodoc:
public class import_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return `import`.self
    }
}

public extension Ice.ClassResolver {
    @objc static func abstract_import() -> Ice.UserExceptionTypeResolver {
        return import_TypeResolver()
    }
}

open class `import`: hashCode {
    public var instanceof: Swift.Int32 = 0
    public var native: Swift.Int32 = 0

    public required init() {
        super.init()
    }

    public init(`if`: Swift.Int32, instanceof: Swift.Int32, native: Swift.Int32) {
        self.instanceof = instanceof
        self.native = native
        super.init(`if`: `if`)
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String {
        return "::abstract::import"
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: `import`.ice_staticId(), compactId: -1, last: false)
        ostr.write(self.instanceof)
        ostr.write(self.native)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.instanceof = try istr.read()
        self.native = try istr.read()
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }
}

/// Traits for Slice interface`new`.
public struct newTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::abstract::new"]
    public static let staticId = "::abstract::new"
}
public let `switch`: Swift.Int32 = 0

public let synchronized: Swift.Int32 = 0

public let this: Swift.Int32 = 0

public let `throw`: Swift.Int32 = 0

public let toString: Swift.Int32 = 0

public let `try`: Swift.Int32 = 0

public let uncheckedCast: Swift.Int32 = 0

public let volatile: Swift.Int32 = 0

public let wait: Swift.Int32 = 0

public let `while`: Swift.Int32 = 0

public let finally: Swift.Int32 = 0

public let getClass: Swift.Int32 = 0


/// catchPrx overview.
///
/// catchPrx Methods:
///
///  - checkedCast: 
///
///  - checkedCastAsync: 
public protocol catchPrx: Ice.ObjectPrx {}

private final class catchPrxI: Ice.ObjectPrxI, catchPrx {
    public override class func ice_staticId() -> Swift.String {
        return catchTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ProxyParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: catchPrx.Protocol) throws -> catchPrx {
    try communicator.makeProxyImpl(proxyString) as catchPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `catchPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `catchPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: catchPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> catchPrx? {
    return try catchPrxI.checkedCast(prx: prx, facet: facet, context: context) as catchPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `catchPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `catchPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: catchPrx.Protocol, facet: Swift.String? = nil) -> catchPrx {
    return catchPrxI.uncheckedCast(prx: prx, facet: facet) as catchPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `catchPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: catchPrx.Protocol) -> Swift.String {
    return catchTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `catchPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `catchPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `catchPrx?` - The extracted proxy
    func read(_ type: catchPrx.Protocol) throws -> catchPrx? {
        return try read() as catchPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `catchPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `catchPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: catchPrx.Protocol) throws -> catchPrx? {
        return try read(tag: tag) as catchPrxI?
    }
}

/// catchPrx overview.
///
/// catchPrx Methods:
///
///  - checkedCast: 
///
///  - checkedCastAsync: 
public extension catchPrx {
    ///
    /// - parameter _: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.Int32`
    func checkedCast(_ iceP_clone: Swift.Int32, context: Ice.Context? = nil) throws -> Swift.Int32 {
        return try _impl._invoke(operation: "checkedCast",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_clone)
                                 },
                                 read: { istr in
                                     let iceP_continue: Swift.Int32 = try istr.read()
                                     return iceP_continue
                                 },
                                 context: context)
    }

    ///
    /// - parameter _: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Int32>` - The result of the operation
    func checkedCastAsync(_ iceP_clone: Swift.Int32, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Int32> {
        return _impl._invokeAsync(operation: "checkedCast",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_clone)
                                  },
                                  read: { istr in
                                      let iceP_continue: Swift.Int32 = try istr.read()
                                      return iceP_continue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// defaultPrx overview.
///
/// defaultPrx Methods:
///
///  - `do`: 
///
///  - doAsync: 
public protocol defaultPrx: Ice.ObjectPrx {}

private final class defaultPrxI: Ice.ObjectPrxI, defaultPrx {
    public override class func ice_staticId() -> Swift.String {
        return defaultTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ProxyParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: defaultPrx.Protocol) throws -> defaultPrx {
    try communicator.makeProxyImpl(proxyString) as defaultPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `defaultPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `defaultPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: defaultPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> defaultPrx? {
    return try defaultPrxI.checkedCast(prx: prx, facet: facet, context: context) as defaultPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `defaultPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `defaultPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: defaultPrx.Protocol, facet: Swift.String? = nil) -> defaultPrx {
    return defaultPrxI.uncheckedCast(prx: prx, facet: facet) as defaultPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `defaultPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: defaultPrx.Protocol) -> Swift.String {
    return defaultTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `defaultPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `defaultPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `defaultPrx?` - The extracted proxy
    func read(_ type: defaultPrx.Protocol) throws -> defaultPrx? {
        return try read() as defaultPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `defaultPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `defaultPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: defaultPrx.Protocol) throws -> defaultPrx? {
        return try read(tag: tag) as defaultPrxI?
    }
}

/// defaultPrx overview.
///
/// defaultPrx Methods:
///
///  - `do`: 
///
///  - doAsync: 
public extension defaultPrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func `do`(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "do",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func doAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "do",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// finalizePrx overview.
public protocol finalizePrx: defaultPrx, catchPrx {}

private final class finalizePrxI: Ice.ObjectPrxI, finalizePrx {
    public override class func ice_staticId() -> Swift.String {
        return finalizeTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ProxyParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: finalizePrx.Protocol) throws -> finalizePrx {
    try communicator.makeProxyImpl(proxyString) as finalizePrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `finalizePrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `finalizePrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: finalizePrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> finalizePrx? {
    return try finalizePrxI.checkedCast(prx: prx, facet: facet, context: context) as finalizePrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `finalizePrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `finalizePrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: finalizePrx.Protocol, facet: Swift.String? = nil) -> finalizePrx {
    return finalizePrxI.uncheckedCast(prx: prx, facet: facet) as finalizePrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `finalizePrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: finalizePrx.Protocol) -> Swift.String {
    return finalizeTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `finalizePrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `finalizePrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `finalizePrx?` - The extracted proxy
    func read(_ type: finalizePrx.Protocol) throws -> finalizePrx? {
        return try read() as finalizePrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `finalizePrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `finalizePrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: finalizePrx.Protocol) throws -> finalizePrx? {
        return try read(tag: tag) as finalizePrxI?
    }
}

/// finalizePrx overview.
public extension finalizePrx {}

/// newPrx overview.
///
/// newPrx Methods:
///
///  - notify: 
///
///  - notifyAsync: 
public protocol newPrx: Ice.ObjectPrx {}

private final class newPrxI: Ice.ObjectPrxI, newPrx {
    public override class func ice_staticId() -> Swift.String {
        return newTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ProxyParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: newPrx.Protocol) throws -> newPrx {
    try communicator.makeProxyImpl(proxyString) as newPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `newPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `newPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: newPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> newPrx? {
    return try newPrxI.checkedCast(prx: prx, facet: facet, context: context) as newPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `newPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `newPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: newPrx.Protocol, facet: Swift.String? = nil) -> newPrx {
    return newPrxI.uncheckedCast(prx: prx, facet: facet) as newPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `newPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: newPrx.Protocol) -> Swift.String {
    return newTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `newPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `newPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `newPrx?` - The extracted proxy
    func read(_ type: newPrx.Protocol) throws -> newPrx? {
        return try read() as newPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `newPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `newPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: newPrx.Protocol) throws -> newPrx? {
        return try read(tag: tag) as newPrxI?
    }
}

/// newPrx overview.
///
/// newPrx Methods:
///
///  - notify: 
///
///  - notifyAsync: 
public extension newPrx {
    ///
    /// - parameter notifyAll: ``break``
    ///
    /// - parameter null: ``else`?`
    ///
    /// - parameter package: `finalizePrx?`
    ///
    /// - parameter public: `catchPrx?`
    ///
    /// - parameter return: `defaultPrx?`
    ///
    /// - parameter static: `Swift.Int32`
    ///
    /// - parameter strictfp: `Swift.Int32`
    ///
    /// - parameter super: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `assert`
    func notify(notifyAll iceP_notifyAll: `break`, null iceP_null: `else`?, package iceP_package: finalizePrx?, public iceP_public: catchPrx?, return iceP_return: defaultPrx?, static iceP_static: Swift.Int32, strictfp iceP_strictfp: Swift.Int32, super iceP_super: Swift.Int32, context: Ice.Context? = nil) throws -> assert {
        return try _impl._invoke(operation: "notify",
                                 mode: .Normal,
                                 write: { ostr in
                                     ostr.write(iceP_notifyAll)
                                     ostr.write(iceP_null)
                                     ostr.write(iceP_package)
                                     ostr.write(iceP_public)
                                     ostr.write(iceP_return)
                                     ostr.write(iceP_static)
                                     ostr.write(iceP_strictfp)
                                     ostr.write(iceP_super)
                                     ostr.writePendingValues()
                                 },
                                 read: { istr in
                                     let iceP_returnValue: assert = try istr.read()
                                     return iceP_returnValue
                                 },
                                 userException:{ ex in
                                     do  {
                                         throw ex
                                     } catch let error as hashCode {
                                         throw error
                                     } catch let error as import {
                                         throw error
                                     } catch is Ice.UserException {}
                                 },
                                 context: context)
    }

    ///
    /// - parameter notifyAll: ``break``
    ///
    /// - parameter null: ``else`?`
    ///
    /// - parameter package: `finalizePrx?`
    ///
    /// - parameter public: `catchPrx?`
    ///
    /// - parameter return: `defaultPrx?`
    ///
    /// - parameter static: `Swift.Int32`
    ///
    /// - parameter strictfp: `Swift.Int32`
    ///
    /// - parameter super: `Swift.Int32`
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<assert>` - The result of the operation
    func notifyAsync(notifyAll iceP_notifyAll: `break`, null iceP_null: `else`?, package iceP_package: finalizePrx?, public iceP_public: catchPrx?, return iceP_return: defaultPrx?, static iceP_static: Swift.Int32, strictfp iceP_strictfp: Swift.Int32, super iceP_super: Swift.Int32, context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<assert> {
        return _impl._invokeAsync(operation: "notify",
                                  mode: .Normal,
                                  write: { ostr in
                                      ostr.write(iceP_notifyAll)
                                      ostr.write(iceP_null)
                                      ostr.write(iceP_package)
                                      ostr.write(iceP_public)
                                      ostr.write(iceP_return)
                                      ostr.write(iceP_static)
                                      ostr.write(iceP_strictfp)
                                      ostr.write(iceP_super)
                                      ostr.writePendingValues()
                                  },
                                  read: { istr in
                                      let iceP_returnValue: assert = try istr.read()
                                      return iceP_returnValue
                                  },
                                  userException:{ ex in
                                      do  {
                                          throw ex
                                      } catch let error as hashCode {
                                          throw error
                                      } catch let error as import {
                                          throw error
                                      } catch is Ice.UserException {}
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// :nodoc:
public class else_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return `else`.self
    }
}

public extension Ice.ClassResolver {
    @objc static func abstract_else() -> Ice.ValueTypeResolver {
        return else_TypeResolver()
    }
}

open class `else`: Ice.Value {
    public var `if`: Swift.Int32 = 0
    public var equals: defaultPrx? = nil
    public var `final`: Swift.Int32 = 0

    public required init() {}

    public init(`if`: Swift.Int32, equals: defaultPrx?, `final`: Swift.Int32) {
        self.`if` = `if`
        self.equals = equals
        self.`final` = `final`
    }

    /// Returns the Slice type ID of the most-derived interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the most-derived interface supported by this object
    open override func ice_id() -> Swift.String {
        return elseTraits.staticId
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String {
        return elseTraits.staticId
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.`if` = try istr.read()
        self.equals = try istr.read(defaultPrx.self)
        self.`final` = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: elseTraits.staticId, compactId: -1, last: true)
        ostr.write(self.`if`)
        ostr.write(self.equals)
        ostr.write(self.`final`)
        ostr.endSlice()
    }
}


/// Dispatcher for ``catch`` servants.
public struct catchDisp: Ice.Dispatcher {
    public let servant: `catch`
    private static let defaultObject = Ice.ObjectI<catchTraits>()

    public init(_ servant: `catch`) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        switch request.current.operation {
        case "checkedCast":
            servant._iceD_checkedCast(request)
        case "ice_id":
            (servant as? Ice.Object ?? catchDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            (servant as? Ice.Object ?? catchDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            (servant as? Ice.Object ?? catchDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            (servant as? Ice.Object ?? catchDisp.defaultObject)._iceD_ice_ping(request)
        default:
            PromiseKit.Promise(error: Ice.OperationNotExistException())
        }
    }
}

public protocol `catch` {
    ///
    /// - parameter clone: `Swift.Int32`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `PromiseKit.Promise<Swift.Int32>` - The result of the operation
    func checkedCastAsync(clone: Swift.Int32, current: Ice.Current) -> PromiseKit.Promise<Swift.Int32>
}


/// Dispatcher for ``default`` servants.
public struct defaultDisp: Ice.Dispatcher {
    public let servant: `default`
    private static let defaultObject = Ice.ObjectI<defaultTraits>()

    public init(_ servant: `default`) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        switch request.current.operation {
        case "do":
            servant._iceD_do(request)
        case "ice_id":
            (servant as? Ice.Object ?? defaultDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            (servant as? Ice.Object ?? defaultDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            (servant as? Ice.Object ?? defaultDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            (servant as? Ice.Object ?? defaultDisp.defaultObject)._iceD_ice_ping(request)
        default:
            PromiseKit.Promise(error: Ice.OperationNotExistException())
        }
    }
}

public protocol `default` {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func `do`(current: Ice.Current) throws
}


/// Dispatcher for `finalize` servants.
public struct finalizeDisp: Ice.Dispatcher {
    public let servant: finalize
    private static let defaultObject = Ice.ObjectI<finalizeTraits>()

    public init(_ servant: finalize) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        switch request.current.operation {
        case "checkedCast":
            servant._iceD_checkedCast(request)
        case "do":
            servant._iceD_do(request)
        case "ice_id":
            (servant as? Ice.Object ?? finalizeDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            (servant as? Ice.Object ?? finalizeDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            (servant as? Ice.Object ?? finalizeDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            (servant as? Ice.Object ?? finalizeDisp.defaultObject)._iceD_ice_ping(request)
        default:
            PromiseKit.Promise(error: Ice.OperationNotExistException())
        }
    }
}

public protocol finalize: `default`, `catch` {}


/// Dispatcher for `new` servants.
public struct newDisp: Ice.Dispatcher {
    public let servant: new
    private static let defaultObject = Ice.ObjectI<newTraits>()

    public init(_ servant: new) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        switch request.current.operation {
        case "ice_id":
            (servant as? Ice.Object ?? newDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            (servant as? Ice.Object ?? newDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            (servant as? Ice.Object ?? newDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            (servant as? Ice.Object ?? newDisp.defaultObject)._iceD_ice_ping(request)
        case "notify":
            servant._iceD_notify(request)
        default:
            PromiseKit.Promise(error: Ice.OperationNotExistException())
        }
    }
}

public protocol new {
    ///
    /// - parameter notifyAll: ``break``
    ///
    /// - parameter null: ``else`?`
    ///
    /// - parameter package: `finalizePrx?`
    ///
    /// - parameter public: `catchPrx?`
    ///
    /// - parameter return: `defaultPrx?`
    ///
    /// - parameter static: `Swift.Int32`
    ///
    /// - parameter strictfp: `Swift.Int32`
    ///
    /// - parameter super: `Swift.Int32`
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `assert`
    func notify(notifyAll: `break`, null: `else`?, package: finalizePrx?, public: catchPrx?, return: defaultPrx?, static: Swift.Int32, strictfp: Swift.Int32, super: Swift.Int32, current: Ice.Current) throws -> assert
}

/// catch overview.
///
/// catch Methods:
///
///  - checkedCast: 
extension `catch` {
    public func _iceD_checkedCast(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_clone: Swift.Int32 = try istr.read()
            return self.checkedCastAsync(
                clone: iceP_clone, current: request.current
            ).map(on: nil) { result in 
                request.current.makeOutgoingResponse(result, formatType:.DefaultFormat) { ostr, value in 
                    let iceP_continue = value
                    ostr.write(iceP_continue)
                }
            }
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }
}

/// default overview.
///
/// default Methods:
///
///  - `do`: 
extension `default` {
    public func _iceD_do(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            _ = try request.inputStream.skipEmptyEncapsulation()

            try self.`do`(current: request.current)
            return PromiseKit.Promise.value(request.current.makeEmptyOutgoingResponse())
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }
}

/// finalize overview.
extension finalize {}

/// new overview.
///
/// new Methods:
///
///  - notify: 
extension new {
    public func _iceD_notify(_ request: Ice.IncomingRequest) -> PromiseKit.Promise<Ice.OutgoingResponse> {
        do {
            let istr = request.inputStream
            _ = try istr.startEncapsulation()
            let iceP_notifyAll: `break` = try istr.read()
            var iceP_null: `else`?
            try istr.read(else.self) { iceP_null = $0 }
            let iceP_package: finalizePrx? = try istr.read(finalizePrx.self)
            let iceP_public: catchPrx? = try istr.read(catchPrx.self)
            let iceP_return: defaultPrx? = try istr.read(defaultPrx.self)
            let iceP_static: Swift.Int32 = try istr.read()
            let iceP_strictfp: Swift.Int32 = try istr.read()
            let iceP_super: Swift.Int32 = try istr.read()
            try istr.readPendingValues()

            let iceP_returnValue = try self.notify(notifyAll: iceP_notifyAll, null: iceP_null, package: iceP_package, public: iceP_public, return: iceP_return, static: iceP_static, strictfp: iceP_strictfp, super: iceP_super, current: request.current)
            let ostr = request.current.startReplyStream()
            ostr.startEncapsulation(encoding: request.current.encoding, format: .DefaultFormat)
            ostr.write(iceP_returnValue)
            ostr.endEncapsulation()
            return PromiseKit.Promise.value(Ice.OutgoingResponse(ostr))
        } catch {
            return PromiseKit.Promise(error: error)
        }
    }
}
