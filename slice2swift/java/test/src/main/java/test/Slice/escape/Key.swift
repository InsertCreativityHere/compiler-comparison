//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Key.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice

public enum assert: Swift.UInt8 {
    case boolean = 0
    public init() {
        self = .boolean
    }
}

/// An `Ice.InputStream` extension to read `assert` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - Returns:  The enumerated value.
    func read() throws -> assert {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 0)
        guard let val = assert(rawValue: rawValue) else {
            throw Ice.MarshalException("invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The enumerated value.
    func read(tag: Swift.Int32) throws -> assert? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as assert
    }
}

/// An `Ice.OutputStream` extension to write `assert` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// - Parameter v: The enumerator to write.
    func write(_ v: assert) {
        write(enum: v.rawValue, maxValue: 0)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The enumerator to write.
    func write(tag: Swift.Int32, value: assert?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 0)
    }
}

public struct `break`: Swift.Hashable {
    public var `case`: Swift.Int32 = 0

    public init() {}

    public init(`case`: Swift.Int32) {
        self.`case` = `case`
    }
}

/// An `Ice.InputStream` extension to read ``break`` structured values from the stream.
public extension Ice.InputStream {
    /// Read a ``break`` structured value from the stream.
    ///
    /// - Returns: The structured value read from the stream.
    func read() throws -> `break` {
        var v = `break`()
        v.`case` = try self.read()
        return v
    }

    /// Read an optional ``break`?` structured value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> `break`? {
        guard try readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try skipSize()
        return try read() as `break`
    }
}

/// An `Ice.OutputStream` extension to write ``break`` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a ``break`` structured value to the stream.
    ///
    /// - Parameter v: The value to write to the stream.
    func write(_ v: `break`) {
        self.write(v.`case`)
    }

    /// Write an optional ``break`?` structured value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The value to write to the stream.
    func write(tag: Swift.Int32, value: `break`?) {
        if let v = value {
            if writeOptional(tag: tag, format: .VSize) {
                write(size: 4)
                write(v)
            }
        }
    }
}

/// Traits for Slice interface ``catch``.
public struct catchTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::abstract::catch"]
    public static let staticId = "::abstract::catch"
}

/// Traits for Slice interface ``default``.
public struct defaultTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::abstract::default"]
    public static let staticId = "::abstract::default"
}

/// Traits for Slice interface `finalize`.
public struct finalizeTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::abstract::catch", "::abstract::default", "::abstract::finalize"]
    public static let staticId = "::abstract::finalize"
}

public typealias `for` = [assert]

/// Helper class to read and write ``for`` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct forHelper {
    /// Read a ``for`` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> `for` {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = `for`()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: assert = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional ``for`?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> `for`? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a ``for`` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: `for`) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional ``for`?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: `for`?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias goto = [Swift.String: assert]

/// Helper class to read and write `goto` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct gotoHelper {
    /// Read a `goto` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> goto {
        let sz = try Swift.Int(istr.readSize())
        var v = goto()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: assert = try istr.read()
            v[key] = value
        }
        return v
    }

    /// Read an optional `goto?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> goto? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `goto` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: goto) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `goto?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: goto?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

@_documentation(visibility: internal)
public class hashCode_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return hashCode.self
    }
}

public extension Ice.ClassResolver {
    @objc static func abstract_hashCode() -> Ice.UserExceptionTypeResolver {
        return hashCode_TypeResolver()
    }
}

open class hashCode: Ice.UserException, @unchecked Sendable {
    public var `if`: Swift.Int32 = 0

    public required init() {}

    public init(`if`: Swift.Int32) {
        self.`if` = `if`
    }

    /// - Returns: The Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::abstract::hashCode" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: hashCode.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.`if`)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.`if` = try istr.read()
        try istr.endSlice()
    }
}

@_documentation(visibility: internal)
public class import_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return `import`.self
    }
}

public extension Ice.ClassResolver {
    @objc static func abstract_import() -> Ice.UserExceptionTypeResolver {
        return import_TypeResolver()
    }
}

open class `import`: hashCode, @unchecked Sendable {
    public var instanceof: Swift.Int32 = 0
    public var native: Swift.Int32 = 0

    public required init() {
        super.init()
    }

    public init(`if`: Swift.Int32, instanceof: Swift.Int32, native: Swift.Int32) {
        self.instanceof = instanceof
        self.native = native
        super.init(`if`: `if`)
    }

    /// - Returns: The Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::abstract::import" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: `import`.ice_staticId(), compactId: -1, last: false)
        ostr.write(self.instanceof)
        ostr.write(self.native)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.instanceof = try istr.read()
        self.native = try istr.read()
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }
}

/// Traits for Slice interface `new`.
public struct newTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::abstract::new"]
    public static let staticId = "::abstract::new"
}
public let `switch`: Swift.Int32 = 0

public let synchronized: Swift.Int32 = 0

public let this: Swift.Int32 = 0

public let `throw`: Swift.Int32 = 0

public let toString: Swift.Int32 = 0

public let `try`: Swift.Int32 = 0

public let uncheckedCast: Swift.Int32 = 0

public let volatile: Swift.Int32 = 0

public let wait: Swift.Int32 = 0

public let `while`: Swift.Int32 = 0

public let finally: Swift.Int32 = 0

public let getClass: Swift.Int32 = 0


public protocol catchPrx: Ice.ObjectPrx {}

private final class catchPrxI: Ice.ObjectPrxI, catchPrx {
    public override class func ice_staticId() -> Swift.String {
        return catchTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: catchPrx.Protocol) throws -> catchPrx {
    try communicator.makeProxyImpl(proxyString) as catchPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: catchPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> catchPrx? {
    return try await catchPrxI.checkedCast(prx: prx, facet: facet, context: context) as catchPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: catchPrx.Protocol, facet: Swift.String? = nil) -> catchPrx {
    return catchPrxI.uncheckedCast(prx: prx, facet: facet) as catchPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: catchPrx.Protocol) -> Swift.String {
    return catchTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `catchPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: catchPrx.Protocol) throws -> catchPrx? {
        return try read() as catchPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: catchPrx.Protocol) throws -> catchPrx? {
        return try read(tag: tag) as catchPrxI?
    }
}

public extension catchPrx {
    func checkedCast(_ iceP_clone: Swift.Int32, context: Ice.Context? = nil) async throws -> Swift.Int32 {
        return try await _impl._invoke(operation: "checkedCast",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_clone)
                                       },
                                       read: { istr in
                                           let iceP_continue: Swift.Int32 = try istr.read()
                                           return iceP_continue
                                       },
                                       context: context)
    }
}

public protocol defaultPrx: Ice.ObjectPrx {}

private final class defaultPrxI: Ice.ObjectPrxI, defaultPrx {
    public override class func ice_staticId() -> Swift.String {
        return defaultTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: defaultPrx.Protocol) throws -> defaultPrx {
    try communicator.makeProxyImpl(proxyString) as defaultPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: defaultPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> defaultPrx? {
    return try await defaultPrxI.checkedCast(prx: prx, facet: facet, context: context) as defaultPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: defaultPrx.Protocol, facet: Swift.String? = nil) -> defaultPrx {
    return defaultPrxI.uncheckedCast(prx: prx, facet: facet) as defaultPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: defaultPrx.Protocol) -> Swift.String {
    return defaultTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `defaultPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: defaultPrx.Protocol) throws -> defaultPrx? {
        return try read() as defaultPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: defaultPrx.Protocol) throws -> defaultPrx? {
        return try read(tag: tag) as defaultPrxI?
    }
}

public extension defaultPrx {
    func `do`(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "do",
                                       mode: .Normal,
                                       context: context)
    }
}

public protocol finalizePrx: defaultPrx, catchPrx {}

private final class finalizePrxI: Ice.ObjectPrxI, finalizePrx {
    public override class func ice_staticId() -> Swift.String {
        return finalizeTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: finalizePrx.Protocol) throws -> finalizePrx {
    try communicator.makeProxyImpl(proxyString) as finalizePrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: finalizePrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> finalizePrx? {
    return try await finalizePrxI.checkedCast(prx: prx, facet: facet, context: context) as finalizePrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: finalizePrx.Protocol, facet: Swift.String? = nil) -> finalizePrx {
    return finalizePrxI.uncheckedCast(prx: prx, facet: facet) as finalizePrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: finalizePrx.Protocol) -> Swift.String {
    return finalizeTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `finalizePrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: finalizePrx.Protocol) throws -> finalizePrx? {
        return try read() as finalizePrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: finalizePrx.Protocol) throws -> finalizePrx? {
        return try read(tag: tag) as finalizePrxI?
    }
}

public extension finalizePrx {}

public protocol newPrx: Ice.ObjectPrx {}

private final class newPrxI: Ice.ObjectPrxI, newPrx {
    public override class func ice_staticId() -> Swift.String {
        return newTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: newPrx.Protocol) throws -> newPrx {
    try communicator.makeProxyImpl(proxyString) as newPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: newPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> newPrx? {
    return try await newPrxI.checkedCast(prx: prx, facet: facet, context: context) as newPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: newPrx.Protocol, facet: Swift.String? = nil) -> newPrx {
    return newPrxI.uncheckedCast(prx: prx, facet: facet) as newPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: newPrx.Protocol) -> Swift.String {
    return newTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `newPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: newPrx.Protocol) throws -> newPrx? {
        return try read() as newPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: newPrx.Protocol) throws -> newPrx? {
        return try read(tag: tag) as newPrxI?
    }
}

public extension newPrx {
    func notify(notifyAll iceP_notifyAll: `break`, null iceP_null: `else`?, package iceP_package: finalizePrx?, public iceP_public: catchPrx?, return iceP_return: defaultPrx?, static iceP_static: Swift.Int32, strictfp iceP_strictfp: Swift.Int32, super iceP_super: Swift.Int32, context: Ice.Context? = nil) async throws -> assert {
        return try await _impl._invoke(operation: "notify",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_notifyAll)
                                           ostr.write(iceP_null)
                                           ostr.write(iceP_package)
                                           ostr.write(iceP_public)
                                           ostr.write(iceP_return)
                                           ostr.write(iceP_static)
                                           ostr.write(iceP_strictfp)
                                           ostr.write(iceP_super)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           let iceP_returnValue: assert = try istr.read()
                                           return iceP_returnValue
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as hashCode {
                                               throw error
                                           } catch let error as `import` {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }
}

@_documentation(visibility: internal)
public class else_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return `else`.self
    }
}

public extension Ice.ClassResolver {
    @objc static func abstract_else() -> Ice.ValueTypeResolver {
        return else_TypeResolver()
    }
}

open class `else`: Ice.Value {
    public var `if`: Swift.Int32 = 0
    public var equals: defaultPrx? = nil
    public var `final`: Swift.Int32 = 0

    public required init() {}

    public init(`if`: Swift.Int32, equals: defaultPrx?, `final`: Swift.Int32) {
        self.`if` = `if`
        self.equals = equals
        self.`final` = `final`
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::abstract::else" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.`if` = try istr.read()
        self.equals = try istr.read(defaultPrx.self)
        self.`final` = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: `else`.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.`if`)
        ostr.write(self.equals)
        ostr.write(self.`final`)
        ostr.endSlice()
    }
}


/// Dispatcher for ``catch`` servants.
public struct catchDisp: Ice.Dispatcher {
    public let servant: `catch`
    private static let defaultObject = Ice.ObjectI<catchTraits>()

    public init(_ servant: `catch`) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "checkedCast":
            try await servant._iceD_checkedCast(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? catchDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? catchDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? catchDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? catchDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol `catch` {
    func checkedCast(clone: Swift.Int32, current: Ice.Current) async throws -> Swift.Int32
}


/// Dispatcher for ``default`` servants.
public struct defaultDisp: Ice.Dispatcher {
    public let servant: `default`
    private static let defaultObject = Ice.ObjectI<defaultTraits>()

    public init(_ servant: `default`) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "do":
            try await servant._iceD_do(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? defaultDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? defaultDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? defaultDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? defaultDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol `default` {
    func `do`(current: Ice.Current) async throws
}


/// Dispatcher for `finalize` servants.
public struct finalizeDisp: Ice.Dispatcher {
    public let servant: finalize
    private static let defaultObject = Ice.ObjectI<finalizeTraits>()

    public init(_ servant: finalize) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "checkedCast":
            try await servant._iceD_checkedCast(request)
        case "do":
            try await servant._iceD_do(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? finalizeDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? finalizeDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? finalizeDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? finalizeDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol finalize: `default`, `catch` {}


/// Dispatcher for `new` servants.
public struct newDisp: Ice.Dispatcher {
    public let servant: new
    private static let defaultObject = Ice.ObjectI<newTraits>()

    public init(_ servant: new) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "ice_id":
            try await (servant as? Ice.Object ?? newDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? newDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? newDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? newDisp.defaultObject)._iceD_ice_ping(request)
        case "notify":
            try await servant._iceD_notify(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol new {
    func notify(notifyAll: `break`, null: `else`?, package: finalizePrx?, public: catchPrx?, return: defaultPrx?, static: Swift.Int32, strictfp: Swift.Int32, super: Swift.Int32, current: Ice.Current) async throws -> assert
}

extension `catch` {
    public func _iceD_checkedCast(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_clone: Swift.Int32 = try istr.read()
        let result = try await self.checkedCast(clone: iceP_clone, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_continue = value
            ostr.write(iceP_continue)
        }
    }
}

extension `default` {
    public func _iceD_do(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.`do`(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}

extension finalize {}

extension new {
    public func _iceD_notify(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_notifyAll: `break` = try istr.read()
        var iceP_null: `else`?
        try istr.read(`else`.self) { iceP_null = $0 }
        let iceP_package: finalizePrx? = try istr.read(finalizePrx.self)
        let iceP_public: catchPrx? = try istr.read(catchPrx.self)
        let iceP_return: defaultPrx? = try istr.read(defaultPrx.self)
        let iceP_static: Swift.Int32 = try istr.read()
        let iceP_strictfp: Swift.Int32 = try istr.read()
        let iceP_super: Swift.Int32 = try istr.read()
        try istr.readPendingValues()
        let result = try await self.notify(notifyAll: iceP_notifyAll, null: iceP_null, package: iceP_package, public: iceP_public, return: iceP_return, static: iceP_static, strictfp: iceP_strictfp, super: iceP_super, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }
}
