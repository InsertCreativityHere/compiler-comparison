//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Controller.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice

public typealias CommonBoolSeq = [Swift.Bool]

public typealias CommonStringSeq = [Swift.String]

@_documentation(visibility: internal)
public class CommonTestCaseNotExistException_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return CommonTestCaseNotExistException.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Common_TestCaseNotExistException() -> Ice.UserExceptionTypeResolver {
        return CommonTestCaseNotExistException_TypeResolver()
    }
}

open class CommonTestCaseNotExistException: Ice.UserException, @unchecked Sendable {
    public var reason: Swift.String = ""

    public required init() {}

    public init(reason: Swift.String) {
        self.reason = reason
    }

    /// - Returns: The Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Test::Common::TestCaseNotExistException" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CommonTestCaseNotExistException.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.reason)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.reason = try istr.read()
        try istr.endSlice()
    }
}

@_documentation(visibility: internal)
public class CommonTestCaseFailedException_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return CommonTestCaseFailedException.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Common_TestCaseFailedException() -> Ice.UserExceptionTypeResolver {
        return CommonTestCaseFailedException_TypeResolver()
    }
}

open class CommonTestCaseFailedException: Ice.UserException, @unchecked Sendable {
    public var output: Swift.String = ""

    public required init() {}

    public init(output: Swift.String) {
        self.output = output
    }

    /// - Returns: The Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Test::Common::TestCaseFailedException" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CommonTestCaseFailedException.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.output)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.output = try istr.read()
        try istr.endSlice()
    }
}

/// Traits for Slice interface `CommonTestCase`.
public struct CommonTestCaseTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Common::TestCase"]
    public static let staticId = "::Test::Common::TestCase"
}

/// Traits for Slice interface `CommonController`.
public struct CommonControllerTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Common::Controller"]
    public static let staticId = "::Test::Common::Controller"
}

@_documentation(visibility: internal)
public class CommonProcessFailedException_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return CommonProcessFailedException.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Common_ProcessFailedException() -> Ice.UserExceptionTypeResolver {
        return CommonProcessFailedException_TypeResolver()
    }
}

open class CommonProcessFailedException: Ice.UserException, @unchecked Sendable {
    public var reason: Swift.String = ""

    public required init() {}

    public init(reason: Swift.String) {
        self.reason = reason
    }

    /// - Returns: The Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Test::Common::ProcessFailedException" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CommonProcessFailedException.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.reason)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.reason = try istr.read()
        try istr.endSlice()
    }
}

/// Traits for Slice interface `CommonProcess`.
public struct CommonProcessTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Common::Process"]
    public static let staticId = "::Test::Common::Process"
}

/// Traits for Slice interface `CommonProcessController`.
public struct CommonProcessControllerTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Common::ProcessController"]
    public static let staticId = "::Test::Common::ProcessController"
}

/// Traits for Slice interface `CommonBrowserProcessController`.
public struct CommonBrowserProcessControllerTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Common::BrowserProcessController", "::Test::Common::ProcessController"]
    public static let staticId = "::Test::Common::BrowserProcessController"
}

/// Traits for Slice interface `CommonProcessControllerRegistry`.
public struct CommonProcessControllerRegistryTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Common::ProcessControllerRegistry"]
    public static let staticId = "::Test::Common::ProcessControllerRegistry"
}

public protocol CommonTestCasePrx: Ice.ObjectPrx {}

private final class CommonTestCasePrxI: Ice.ObjectPrxI, CommonTestCasePrx {
    public override class func ice_staticId() -> Swift.String {
        return CommonTestCaseTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: CommonTestCasePrx.Protocol) throws -> CommonTestCasePrx {
    try communicator.makeProxyImpl(proxyString) as CommonTestCasePrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: CommonTestCasePrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> CommonTestCasePrx? {
    return try await CommonTestCasePrxI.checkedCast(prx: prx, facet: facet, context: context) as CommonTestCasePrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: CommonTestCasePrx.Protocol, facet: Swift.String? = nil) -> CommonTestCasePrx {
    return CommonTestCasePrxI.uncheckedCast(prx: prx, facet: facet) as CommonTestCasePrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: CommonTestCasePrx.Protocol) -> Swift.String {
    return CommonTestCaseTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `CommonTestCasePrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: CommonTestCasePrx.Protocol) throws -> CommonTestCasePrx? {
        return try read() as CommonTestCasePrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: CommonTestCasePrx.Protocol) throws -> CommonTestCasePrx? {
        return try read(tag: tag) as CommonTestCasePrxI?
    }
}

public extension CommonTestCasePrx {
    func startServerSide(_ iceP_config: CommonConfig?, context: Ice.Context? = nil) async throws -> Swift.String {
        return try await _impl._invoke(operation: "startServerSide",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_config)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Swift.String = try istr.read()
                                           return iceP_returnValue
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as CommonTestCaseFailedException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    func stopServerSide(_ iceP_success: Swift.Bool, context: Ice.Context? = nil) async throws -> Swift.String {
        return try await _impl._invoke(operation: "stopServerSide",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_success)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Swift.String = try istr.read()
                                           return iceP_returnValue
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as CommonTestCaseFailedException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    func runClientSide(host iceP_host: Swift.String, config iceP_config: CommonConfig?, context: Ice.Context? = nil) async throws -> Swift.String {
        return try await _impl._invoke(operation: "runClientSide",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_host)
                                           ostr.write(iceP_config)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Swift.String = try istr.read()
                                           return iceP_returnValue
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as CommonTestCaseFailedException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    func destroy(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "destroy",
                                       mode: .Normal,
                                       context: context)
    }
}

public protocol CommonControllerPrx: Ice.ObjectPrx {}

private final class CommonControllerPrxI: Ice.ObjectPrxI, CommonControllerPrx {
    public override class func ice_staticId() -> Swift.String {
        return CommonControllerTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: CommonControllerPrx.Protocol) throws -> CommonControllerPrx {
    try communicator.makeProxyImpl(proxyString) as CommonControllerPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: CommonControllerPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> CommonControllerPrx? {
    return try await CommonControllerPrxI.checkedCast(prx: prx, facet: facet, context: context) as CommonControllerPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: CommonControllerPrx.Protocol, facet: Swift.String? = nil) -> CommonControllerPrx {
    return CommonControllerPrxI.uncheckedCast(prx: prx, facet: facet) as CommonControllerPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: CommonControllerPrx.Protocol) -> Swift.String {
    return CommonControllerTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `CommonControllerPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: CommonControllerPrx.Protocol) throws -> CommonControllerPrx? {
        return try read() as CommonControllerPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: CommonControllerPrx.Protocol) throws -> CommonControllerPrx? {
        return try read(tag: tag) as CommonControllerPrxI?
    }
}

public extension CommonControllerPrx {
    func runTestCase(mapping iceP_mapping: Swift.String, testsuite iceP_testsuite: Swift.String, testcase iceP_testcase: Swift.String, cross iceP_cross: Swift.String, context: Ice.Context? = nil) async throws -> CommonTestCasePrx? {
        return try await _impl._invoke(operation: "runTestCase",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_mapping)
                                           ostr.write(iceP_testsuite)
                                           ostr.write(iceP_testcase)
                                           ostr.write(iceP_cross)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: CommonTestCasePrx? = try istr.read(CommonTestCasePrx.self)
                                           return iceP_returnValue
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as CommonTestCaseNotExistException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    func getOptionOverrides(context: Ice.Context? = nil) async throws -> CommonOptionOverrides? {
        return try await _impl._invoke(operation: "getOptionOverrides",
                                       mode: .Normal,
                                       read: { istr in
                                           var iceP_returnValue: CommonOptionOverrides?
                                           try istr.read(CommonOptionOverrides.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func getTestSuites(_ iceP_mapping: Swift.String, context: Ice.Context? = nil) async throws -> CommonStringSeq {
        return try await _impl._invoke(operation: "getTestSuites",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_mapping)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: CommonStringSeq = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func getHost(protocol iceP_protocol: Swift.String, ipv6 iceP_ipv6: Swift.Bool, context: Ice.Context? = nil) async throws -> Swift.String {
        return try await _impl._invoke(operation: "getHost",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_protocol)
                                           ostr.write(iceP_ipv6)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Swift.String = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}

public protocol CommonProcessPrx: Ice.ObjectPrx {}

private final class CommonProcessPrxI: Ice.ObjectPrxI, CommonProcessPrx {
    public override class func ice_staticId() -> Swift.String {
        return CommonProcessTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: CommonProcessPrx.Protocol) throws -> CommonProcessPrx {
    try communicator.makeProxyImpl(proxyString) as CommonProcessPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: CommonProcessPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> CommonProcessPrx? {
    return try await CommonProcessPrxI.checkedCast(prx: prx, facet: facet, context: context) as CommonProcessPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: CommonProcessPrx.Protocol, facet: Swift.String? = nil) -> CommonProcessPrx {
    return CommonProcessPrxI.uncheckedCast(prx: prx, facet: facet) as CommonProcessPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: CommonProcessPrx.Protocol) -> Swift.String {
    return CommonProcessTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `CommonProcessPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: CommonProcessPrx.Protocol) throws -> CommonProcessPrx? {
        return try read() as CommonProcessPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: CommonProcessPrx.Protocol) throws -> CommonProcessPrx? {
        return try read(tag: tag) as CommonProcessPrxI?
    }
}

public extension CommonProcessPrx {
    func waitReady(_ iceP_timeout: Swift.Int32, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "waitReady",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_timeout)
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as CommonProcessFailedException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    func waitSuccess(_ iceP_timeout: Swift.Int32, context: Ice.Context? = nil) async throws -> Swift.Int32 {
        return try await _impl._invoke(operation: "waitSuccess",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_timeout)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Swift.Int32 = try istr.read()
                                           return iceP_returnValue
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as CommonProcessFailedException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    func terminate(context: Ice.Context? = nil) async throws -> Swift.String {
        return try await _impl._invoke(operation: "terminate",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: Swift.String = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}

public protocol CommonProcessControllerPrx: Ice.ObjectPrx {}

private final class CommonProcessControllerPrxI: Ice.ObjectPrxI, CommonProcessControllerPrx {
    public override class func ice_staticId() -> Swift.String {
        return CommonProcessControllerTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: CommonProcessControllerPrx.Protocol) throws -> CommonProcessControllerPrx {
    try communicator.makeProxyImpl(proxyString) as CommonProcessControllerPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: CommonProcessControllerPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> CommonProcessControllerPrx? {
    return try await CommonProcessControllerPrxI.checkedCast(prx: prx, facet: facet, context: context) as CommonProcessControllerPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: CommonProcessControllerPrx.Protocol, facet: Swift.String? = nil) -> CommonProcessControllerPrx {
    return CommonProcessControllerPrxI.uncheckedCast(prx: prx, facet: facet) as CommonProcessControllerPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: CommonProcessControllerPrx.Protocol) -> Swift.String {
    return CommonProcessControllerTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `CommonProcessControllerPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: CommonProcessControllerPrx.Protocol) throws -> CommonProcessControllerPrx? {
        return try read() as CommonProcessControllerPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: CommonProcessControllerPrx.Protocol) throws -> CommonProcessControllerPrx? {
        return try read(tag: tag) as CommonProcessControllerPrxI?
    }
}

public extension CommonProcessControllerPrx {
    func start(testsuite iceP_testsuite: Swift.String, exe iceP_exe: Swift.String, args iceP_args: CommonStringSeq, context: Ice.Context? = nil) async throws -> CommonProcessPrx? {
        return try await _impl._invoke(operation: "start",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_testsuite)
                                           ostr.write(iceP_exe)
                                           ostr.write(iceP_args)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: CommonProcessPrx? = try istr.read(CommonProcessPrx.self)
                                           return iceP_returnValue
                                       },
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as CommonProcessFailedException {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    func getHost(protocol iceP_protocol: Swift.String, ipv6 iceP_ipv6: Swift.Bool, context: Ice.Context? = nil) async throws -> Swift.String {
        return try await _impl._invoke(operation: "getHost",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_protocol)
                                           ostr.write(iceP_ipv6)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: Swift.String = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}

public protocol CommonBrowserProcessControllerPrx: CommonProcessControllerPrx {}

private final class CommonBrowserProcessControllerPrxI: Ice.ObjectPrxI, CommonBrowserProcessControllerPrx {
    public override class func ice_staticId() -> Swift.String {
        return CommonBrowserProcessControllerTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: CommonBrowserProcessControllerPrx.Protocol) throws -> CommonBrowserProcessControllerPrx {
    try communicator.makeProxyImpl(proxyString) as CommonBrowserProcessControllerPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: CommonBrowserProcessControllerPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> CommonBrowserProcessControllerPrx? {
    return try await CommonBrowserProcessControllerPrxI.checkedCast(prx: prx, facet: facet, context: context) as CommonBrowserProcessControllerPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: CommonBrowserProcessControllerPrx.Protocol, facet: Swift.String? = nil) -> CommonBrowserProcessControllerPrx {
    return CommonBrowserProcessControllerPrxI.uncheckedCast(prx: prx, facet: facet) as CommonBrowserProcessControllerPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: CommonBrowserProcessControllerPrx.Protocol) -> Swift.String {
    return CommonBrowserProcessControllerTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `CommonBrowserProcessControllerPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: CommonBrowserProcessControllerPrx.Protocol) throws -> CommonBrowserProcessControllerPrx? {
        return try read() as CommonBrowserProcessControllerPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: CommonBrowserProcessControllerPrx.Protocol) throws -> CommonBrowserProcessControllerPrx? {
        return try read(tag: tag) as CommonBrowserProcessControllerPrxI?
    }
}

public extension CommonBrowserProcessControllerPrx {
    func redirect(_ iceP_url: Swift.String, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "redirect",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_url)
                                       },
                                       context: context)
    }
}

public protocol CommonProcessControllerRegistryPrx: Ice.ObjectPrx {}

private final class CommonProcessControllerRegistryPrxI: Ice.ObjectPrxI, CommonProcessControllerRegistryPrx {
    public override class func ice_staticId() -> Swift.String {
        return CommonProcessControllerRegistryTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: CommonProcessControllerRegistryPrx.Protocol) throws -> CommonProcessControllerRegistryPrx {
    try communicator.makeProxyImpl(proxyString) as CommonProcessControllerRegistryPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: CommonProcessControllerRegistryPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> CommonProcessControllerRegistryPrx? {
    return try await CommonProcessControllerRegistryPrxI.checkedCast(prx: prx, facet: facet, context: context) as CommonProcessControllerRegistryPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: CommonProcessControllerRegistryPrx.Protocol, facet: Swift.String? = nil) -> CommonProcessControllerRegistryPrx {
    return CommonProcessControllerRegistryPrxI.uncheckedCast(prx: prx, facet: facet) as CommonProcessControllerRegistryPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: CommonProcessControllerRegistryPrx.Protocol) -> Swift.String {
    return CommonProcessControllerRegistryTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `CommonProcessControllerRegistryPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: CommonProcessControllerRegistryPrx.Protocol) throws -> CommonProcessControllerRegistryPrx? {
        return try read() as CommonProcessControllerRegistryPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: CommonProcessControllerRegistryPrx.Protocol) throws -> CommonProcessControllerRegistryPrx? {
        return try read(tag: tag) as CommonProcessControllerRegistryPrxI?
    }
}

public extension CommonProcessControllerRegistryPrx {
    func setProcessController(_ iceP_controller: CommonProcessControllerPrx?, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "setProcessController",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_controller)
                                       },
                                       context: context)
    }
}

@_documentation(visibility: internal)
public class CommonConfig_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return CommonConfig.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Common_Config() -> Ice.ValueTypeResolver {
        return CommonConfig_TypeResolver()
    }
}

open class CommonConfig: Ice.Value {
    public var `protocol`: Swift.String? = nil
    public var mx: Swift.Bool? = nil
    public var serialize: Swift.Bool? = nil
    public var compress: Swift.Bool? = nil
    public var ipv6: Swift.Bool? = nil
    public var cprops: CommonStringSeq? = nil
    public var sprops: CommonStringSeq? = nil

    public required init() {}

    public init(`protocol`: Swift.String?, mx: Swift.Bool?, serialize: Swift.Bool?, compress: Swift.Bool?, ipv6: Swift.Bool?, cprops: CommonStringSeq?, sprops: CommonStringSeq?) {
        self.`protocol` = `protocol`
        self.mx = mx
        self.serialize = serialize
        self.compress = compress
        self.ipv6 = ipv6
        self.cprops = cprops
        self.sprops = sprops
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::Common::Config" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.`protocol` = try istr.read(tag: 1)
        self.mx = try istr.read(tag: 2)
        self.serialize = try istr.read(tag: 3)
        self.compress = try istr.read(tag: 4)
        self.ipv6 = try istr.read(tag: 5)
        self.cprops = try istr.read(tag: 6)
        self.sprops = try istr.read(tag: 7)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CommonConfig.ice_staticId(), compactId: -1, last: true)
        ostr.write(tag: 1, value: self.`protocol`)
        ostr.write(tag: 2, value: self.mx)
        ostr.write(tag: 3, value: self.serialize)
        ostr.write(tag: 4, value: self.compress)
        ostr.write(tag: 5, value: self.ipv6)
        ostr.write(tag: 6, value: self.cprops)
        ostr.write(tag: 7, value: self.sprops)
        ostr.endSlice()
    }
}

@_documentation(visibility: internal)
public class CommonOptionOverrides_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return CommonOptionOverrides.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Common_OptionOverrides() -> Ice.ValueTypeResolver {
        return CommonOptionOverrides_TypeResolver()
    }
}

open class CommonOptionOverrides: Ice.Value {
    public var `protocol`: CommonStringSeq? = nil
    public var mx: CommonBoolSeq? = nil
    public var serialize: CommonBoolSeq? = nil
    public var compress: CommonBoolSeq? = nil
    public var ipv6: CommonBoolSeq? = nil

    public required init() {}

    public init(`protocol`: CommonStringSeq?, mx: CommonBoolSeq?, serialize: CommonBoolSeq?, compress: CommonBoolSeq?, ipv6: CommonBoolSeq?) {
        self.`protocol` = `protocol`
        self.mx = mx
        self.serialize = serialize
        self.compress = compress
        self.ipv6 = ipv6
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::Common::OptionOverrides" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.`protocol` = try istr.read(tag: 1)
        self.mx = try istr.read(tag: 2)
        self.serialize = try istr.read(tag: 3)
        self.compress = try istr.read(tag: 4)
        self.ipv6 = try istr.read(tag: 5)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CommonOptionOverrides.ice_staticId(), compactId: -1, last: true)
        ostr.write(tag: 1, value: self.`protocol`)
        ostr.write(tag: 2, value: self.mx)
        ostr.write(tag: 3, value: self.serialize)
        ostr.write(tag: 4, value: self.compress)
        ostr.write(tag: 5, value: self.ipv6)
        ostr.endSlice()
    }
}


/// Dispatcher for `CommonTestCase` servants.
public struct CommonTestCaseDisp: Ice.Dispatcher {
    public let servant: CommonTestCase
    private static let defaultObject = Ice.ObjectI<CommonTestCaseTraits>()

    public init(_ servant: CommonTestCase) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "destroy":
            try await servant._iceD_destroy(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? CommonTestCaseDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? CommonTestCaseDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? CommonTestCaseDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? CommonTestCaseDisp.defaultObject)._iceD_ice_ping(request)
        case "runClientSide":
            try await servant._iceD_runClientSide(request)
        case "startServerSide":
            try await servant._iceD_startServerSide(request)
        case "stopServerSide":
            try await servant._iceD_stopServerSide(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol CommonTestCase {
    func startServerSide(config: CommonConfig?, current: Ice.Current) async throws -> Swift.String

    func stopServerSide(success: Swift.Bool, current: Ice.Current) async throws -> Swift.String

    func runClientSide(host: Swift.String, config: CommonConfig?, current: Ice.Current) async throws -> Swift.String

    func destroy(current: Ice.Current) async throws
}


/// Dispatcher for `CommonController` servants.
public struct CommonControllerDisp: Ice.Dispatcher {
    public let servant: CommonController
    private static let defaultObject = Ice.ObjectI<CommonControllerTraits>()

    public init(_ servant: CommonController) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "getHost":
            try await servant._iceD_getHost(request)
        case "getOptionOverrides":
            try await servant._iceD_getOptionOverrides(request)
        case "getTestSuites":
            try await servant._iceD_getTestSuites(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? CommonControllerDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? CommonControllerDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? CommonControllerDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? CommonControllerDisp.defaultObject)._iceD_ice_ping(request)
        case "runTestCase":
            try await servant._iceD_runTestCase(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol CommonController {
    func runTestCase(mapping: Swift.String, testsuite: Swift.String, testcase: Swift.String, cross: Swift.String, current: Ice.Current) async throws -> CommonTestCasePrx?

    func getOptionOverrides(current: Ice.Current) async throws -> CommonOptionOverrides?

    func getTestSuites(mapping: Swift.String, current: Ice.Current) async throws -> CommonStringSeq

    func getHost(protocol: Swift.String, ipv6: Swift.Bool, current: Ice.Current) async throws -> Swift.String
}


/// Dispatcher for `CommonProcess` servants.
public struct CommonProcessDisp: Ice.Dispatcher {
    public let servant: CommonProcess
    private static let defaultObject = Ice.ObjectI<CommonProcessTraits>()

    public init(_ servant: CommonProcess) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "ice_id":
            try await (servant as? Ice.Object ?? CommonProcessDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? CommonProcessDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? CommonProcessDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? CommonProcessDisp.defaultObject)._iceD_ice_ping(request)
        case "terminate":
            try await servant._iceD_terminate(request)
        case "waitReady":
            try await servant._iceD_waitReady(request)
        case "waitSuccess":
            try await servant._iceD_waitSuccess(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol CommonProcess {
    func waitReady(timeout: Swift.Int32, current: Ice.Current) async throws

    func waitSuccess(timeout: Swift.Int32, current: Ice.Current) async throws -> Swift.Int32

    func terminate(current: Ice.Current) async throws -> Swift.String
}


/// Dispatcher for `CommonProcessController` servants.
public struct CommonProcessControllerDisp: Ice.Dispatcher {
    public let servant: CommonProcessController
    private static let defaultObject = Ice.ObjectI<CommonProcessControllerTraits>()

    public init(_ servant: CommonProcessController) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "getHost":
            try await servant._iceD_getHost(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? CommonProcessControllerDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? CommonProcessControllerDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? CommonProcessControllerDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? CommonProcessControllerDisp.defaultObject)._iceD_ice_ping(request)
        case "start":
            try await servant._iceD_start(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol CommonProcessController {
    func start(testsuite: Swift.String, exe: Swift.String, args: CommonStringSeq, current: Ice.Current) async throws -> CommonProcessPrx?

    func getHost(protocol: Swift.String, ipv6: Swift.Bool, current: Ice.Current) async throws -> Swift.String
}


/// Dispatcher for `CommonBrowserProcessController` servants.
public struct CommonBrowserProcessControllerDisp: Ice.Dispatcher {
    public let servant: CommonBrowserProcessController
    private static let defaultObject = Ice.ObjectI<CommonBrowserProcessControllerTraits>()

    public init(_ servant: CommonBrowserProcessController) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "getHost":
            try await servant._iceD_getHost(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? CommonBrowserProcessControllerDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? CommonBrowserProcessControllerDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? CommonBrowserProcessControllerDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? CommonBrowserProcessControllerDisp.defaultObject)._iceD_ice_ping(request)
        case "redirect":
            try await servant._iceD_redirect(request)
        case "start":
            try await servant._iceD_start(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol CommonBrowserProcessController: CommonProcessController {
    func redirect(url: Swift.String, current: Ice.Current) async throws
}


/// Dispatcher for `CommonProcessControllerRegistry` servants.
public struct CommonProcessControllerRegistryDisp: Ice.Dispatcher {
    public let servant: CommonProcessControllerRegistry
    private static let defaultObject = Ice.ObjectI<CommonProcessControllerRegistryTraits>()

    public init(_ servant: CommonProcessControllerRegistry) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "ice_id":
            try await (servant as? Ice.Object ?? CommonProcessControllerRegistryDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? CommonProcessControllerRegistryDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? CommonProcessControllerRegistryDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? CommonProcessControllerRegistryDisp.defaultObject)._iceD_ice_ping(request)
        case "setProcessController":
            try await servant._iceD_setProcessController(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol CommonProcessControllerRegistry {
    func setProcessController(controller: CommonProcessControllerPrx?, current: Ice.Current) async throws
}

extension CommonTestCase {
    public func _iceD_startServerSide(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_config: CommonConfig?
        try istr.read(CommonConfig.self) { iceP_config = $0 }
        try istr.readPendingValues()
        let result = try await self.startServerSide(config: iceP_config, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_stopServerSide(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_success: Swift.Bool = try istr.read()
        let result = try await self.stopServerSide(success: iceP_success, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_runClientSide(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_host: Swift.String = try istr.read()
        var iceP_config: CommonConfig?
        try istr.read(CommonConfig.self) { iceP_config = $0 }
        try istr.readPendingValues()
        let result = try await self.runClientSide(host: iceP_host, config: iceP_config, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_destroy(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.destroy(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}

extension CommonController {
    public func _iceD_runTestCase(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_mapping: Swift.String = try istr.read()
        let iceP_testsuite: Swift.String = try istr.read()
        let iceP_testcase: Swift.String = try istr.read()
        let iceP_cross: Swift.String = try istr.read()
        let result = try await self.runTestCase(mapping: iceP_mapping, testsuite: iceP_testsuite, testcase: iceP_testcase, cross: iceP_cross, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_getOptionOverrides(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getOptionOverrides(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_getTestSuites(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_mapping: Swift.String = try istr.read()
        let result = try await self.getTestSuites(mapping: iceP_mapping, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_getHost(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_protocol: Swift.String = try istr.read()
        let iceP_ipv6: Swift.Bool = try istr.read()
        let result = try await self.getHost(protocol: iceP_protocol, ipv6: iceP_ipv6, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }
}

extension CommonProcess {
    public func _iceD_waitReady(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_timeout: Swift.Int32 = try istr.read()
        try await self.waitReady(timeout: iceP_timeout, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_waitSuccess(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_timeout: Swift.Int32 = try istr.read()
        let result = try await self.waitSuccess(timeout: iceP_timeout, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_terminate(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.terminate(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }
}

extension CommonProcessController {
    public func _iceD_start(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_testsuite: Swift.String = try istr.read()
        let iceP_exe: Swift.String = try istr.read()
        let iceP_args: CommonStringSeq = try istr.read()
        let result = try await self.start(testsuite: iceP_testsuite, exe: iceP_exe, args: iceP_args, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_getHost(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_protocol: Swift.String = try istr.read()
        let iceP_ipv6: Swift.Bool = try istr.read()
        let result = try await self.getHost(protocol: iceP_protocol, ipv6: iceP_ipv6, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }
}

extension CommonBrowserProcessController {
    public func _iceD_redirect(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_url: Swift.String = try istr.read()
        try await self.redirect(url: iceP_url, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}

extension CommonProcessControllerRegistry {
    public func _iceD_setProcessController(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_controller: CommonProcessControllerPrx? = try istr.read(CommonProcessControllerPrx.self)
        try await self.setProcessController(controller: iceP_controller, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}
