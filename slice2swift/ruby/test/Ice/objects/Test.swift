//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice

public struct S: Swift.Hashable {
    public var str: Swift.String = ""

    public init() {}

    public init(str: Swift.String) {
        self.str = str
    }
}

/// An `Ice.InputStream` extension to read `S` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `S` structured value from the stream.
    ///
    /// - returns: `S` - The structured value read from the stream.
    func read() throws -> S {
        var v = S()
        v.str = try self.read()
        return v
    }

    /// Read an optional `S?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `S?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> S? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as S
    }
}

/// An `Ice.OutputStream` extension to write `S` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `S` structured value to the stream.
    ///
    /// - parameter _: `S` - The value to write to the stream.
    func write(_ v: S) {
        self.write(v.str)
    }

    /// Write an optional `S?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `S?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: S?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public typealias BaseSeq = [Base?]

/// Helper class to read and write `BaseSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct BaseSeqHelper {
    /// Read a `BaseSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `BaseSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> BaseSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = BaseSeq(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(Base.self) { p.pointee = $0 }
            }
        }
        return v
    }
    /// Read an optional `BaseSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `BaseSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> BaseSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `BaseSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `BaseSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: BaseSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `BaseSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `BaseSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: BaseSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}
public let CompactExtId: Swift.Int32 = 789


/// :nodoc:
public class EBase_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return EBase.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_EBase() -> Ice.UserExceptionTypeResolver {
        return EBase_TypeResolver()
    }
}

open class EBase: Ice.UserException, @unchecked Sendable {
    public var a1: A1? = nil
    public var a2: A1? = nil

    public required init() {}

    public init(a1: A1?, a2: A1?) {
        self.a1 = a1
        self.a2 = a2
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Test::EBase" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: EBase.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.a1)
        ostr.write(self.a2)
        ostr.endSlice()
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(A1.self) { self.a1 = $0 }
        try istr.read(A1.self) { self.a2 = $0 }
        try istr.endSlice()
    }

    open override func _usesClasses() -> Swift.Bool {
        return true
    }
}

/// :nodoc:
public class EDerived_TypeResolver: Ice.UserExceptionTypeResolver {
    public override func type() -> Ice.UserException.Type {
        return EDerived.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_EDerived() -> Ice.UserExceptionTypeResolver {
        return EDerived_TypeResolver()
    }
}

open class EDerived: EBase, @unchecked Sendable {
    public var a3: A1? = nil
    public var a4: A1? = nil

    public required init() {
        super.init()
    }

    public init(a1: A1?, a2: A1?, a3: A1?, a4: A1?) {
        self.a3 = a3
        self.a4 = a4
        super.init(a1: a1, a2: a2)
    }

    /// Returns the Slice type ID of this exception.
    ///
    /// - returns: `Swift.String` - the Slice type ID of this exception.
    open override class func ice_staticId() -> Swift.String { "::Test::EDerived" }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: EDerived.ice_staticId(), compactId: -1, last: false)
        ostr.write(self.a3)
        ostr.write(self.a4)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(A1.self) { self.a3 = $0 }
        try istr.read(A1.self) { self.a4 = $0 }
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }
}

public typealias ValueSeq = [Ice.Value?]

/// Helper class to read and write `ValueSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ValueSeqHelper {
    /// Read a `ValueSeq` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ValueSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ValueSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = ValueSeq(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read() { p.pointee = $0 }
            }
        }
        return v
    }
    /// Read an optional `ValueSeq?` sequence from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ValueSeq` - The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ValueSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ValueSeq` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ValueSeq` - The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ValueSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Wite an optional `ValueSeq?` sequence to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ValueSeq` The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ValueSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ValueMap = [Swift.String: Ice.Value?]

/// Helper class to read and write `ValueMap` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ValueMapHelper {
    /// Read a `ValueMap` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `ValueMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ValueMap {
        let sz = try Swift.Int(istr.readSize())
        var v = ValueMap()
        let e = Ice.DictEntryArray<Swift.String, Ice.Value?>(size: sz)
        for i in 0 ..< sz {
            let key: Swift.String = try istr.read()
            v[key] = nil as Ice.Value?
            Swift.withUnsafeMutablePointer(to: &v[key, default:nil]) {
                e.values[i] = Ice.DictEntry<Swift.String, Ice.Value?>(key: key, value: $0)
            }
            try istr.read() { e.values[i].value.pointee = $0 }
        }
        for i in 0..<sz {
            Swift.withUnsafeMutablePointer(to: &v[e.values[i].key, default:nil]) {
                e.values[i].value = $0
            }
        }
        return v
    }
    /// Read an optional `ValueMap?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `ValueMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ValueMap? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `ValueMap` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `ValueMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ValueMap) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `ValueMap?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `ValueMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: ValueMap?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public struct StructKey: Swift.Hashable {
    public var i: Swift.Int32 = 0
    public var s: Swift.String = ""

    public init() {}

    public init(i: Swift.Int32, s: Swift.String) {
        self.i = i
        self.s = s
    }
}

/// An `Ice.InputStream` extension to read `StructKey` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `StructKey` structured value from the stream.
    ///
    /// - returns: `StructKey` - The structured value read from the stream.
    func read() throws -> StructKey {
        var v = StructKey()
        v.i = try self.read()
        v.s = try self.read()
        return v
    }

    /// Read an optional `StructKey?` structured value from the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `StructKey?` - The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> StructKey? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as StructKey
    }
}

/// An `Ice.OutputStream` extension to write `StructKey` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `StructKey` structured value to the stream.
    ///
    /// - parameter _: `StructKey` - The value to write to the stream.
    func write(_ v: StructKey) {
        self.write(v.i)
        self.write(v.s)
    }

    /// Write an optional `StructKey?` structured value to the stream.
    ///
    /// - parameter tag: `Swift.Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `StructKey?` - The value to write to the stream.
    func write(tag: Swift.Int32, value: StructKey?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public typealias LMap = [StructKey: L?]

/// Helper class to read and write `LMap` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct LMapHelper {
    /// Read a `LMap` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - returns: `LMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> LMap {
        let sz = try Swift.Int(istr.readSize())
        var v = LMap()
        let e = Ice.DictEntryArray<StructKey, L?>(size: sz)
        for i in 0 ..< sz {
            let key: StructKey = try istr.read()
            v[key] = nil as L?
            Swift.withUnsafeMutablePointer(to: &v[key, default:nil]) {
                e.values[i] = Ice.DictEntry<StructKey, L?>(key: key, value: $0)
            }
            try istr.read(L.self) { e.values[i].value.pointee = $0 }
        }
        for i in 0..<sz {
            Swift.withUnsafeMutablePointer(to: &v[e.values[i].key, default:nil]) {
                e.values[i].value = $0
            }
        }
        return v
    }
    /// Read an optional `LMap?` dictionary from the stream.
    ///
    /// - parameter istr: `Ice.InputStream` - The stream to read from.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - returns: `LMap` - The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> LMap? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Wite a `LMap` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter value: `LMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: LMap) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Wite an optional `LMap?` dictionary to the stream.
    ///
    /// - parameter ostr: `Ice.OuputStream` - The stream to write to.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter value: `LMap` - The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: LMap?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice interface`Initial`.
public struct InitialTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Initial"]
    public static let staticId = "::Test::Initial"
}

public protocol InitialPrx: Ice.ObjectPrx {}

private final class InitialPrxI: Ice.ObjectPrxI, InitialPrx {
    public override class func ice_staticId() -> Swift.String {
        return InitialTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: InitialPrx.Protocol) throws -> InitialPrx {
    try communicator.makeProxyImpl(proxyString) as InitialPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `InitialPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `InitialPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: InitialPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> InitialPrx? {
    return try await InitialPrxI.checkedCast(prx: prx, facet: facet, context: context) as InitialPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `InitialPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `InitialPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: InitialPrx.Protocol, facet: Swift.String? = nil) -> InitialPrx {
    return InitialPrxI.uncheckedCast(prx: prx, facet: facet) as InitialPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// parameter type: `InitialPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: InitialPrx.Protocol) -> Swift.String {
    return InitialTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `InitialPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `InitialPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `InitialPrx?` - The extracted proxy
    func read(_ type: InitialPrx.Protocol) throws -> InitialPrx? {
        return try read() as InitialPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `InitialPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `InitialPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: InitialPrx.Protocol) throws -> InitialPrx? {
        return try read(tag: tag) as InitialPrxI?
    }
}

public extension InitialPrx {
    func shutdown(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "shutdown",
                                       mode: .Normal,
                                       context: context)
    }

    func getB1(context: Ice.Context? = nil) async throws -> B? {
        return try await _impl._invoke(operation: "getB1",
                                       mode: .Normal,
                                       read: { istr in
                                           var iceP_returnValue: B?
                                           try istr.read(B.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func getB2(context: Ice.Context? = nil) async throws -> B? {
        return try await _impl._invoke(operation: "getB2",
                                       mode: .Normal,
                                       read: { istr in
                                           var iceP_returnValue: B?
                                           try istr.read(B.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func getC(context: Ice.Context? = nil) async throws -> C? {
        return try await _impl._invoke(operation: "getC",
                                       mode: .Normal,
                                       read: { istr in
                                           var iceP_returnValue: C?
                                           try istr.read(C.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func getD(context: Ice.Context? = nil) async throws -> D? {
        return try await _impl._invoke(operation: "getD",
                                       mode: .Normal,
                                       read: { istr in
                                           var iceP_returnValue: D?
                                           try istr.read(D.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func getE(context: Ice.Context? = nil) async throws -> E? {
        return try await _impl._invoke(operation: "getE",
                                       mode: .Normal,
                                       read: { istr in
                                           var iceP_returnValue: E?
                                           try istr.read(E.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func getF(context: Ice.Context? = nil) async throws -> F? {
        return try await _impl._invoke(operation: "getF",
                                       mode: .Normal,
                                       read: { istr in
                                           var iceP_returnValue: F?
                                           try istr.read(F.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func setRecursive(_ iceP_p: Recursive?, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "setRecursive",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_p)
                                           ostr.writePendingValues()
                                       },
                                       context: context)
    }

    func setCycle(_ iceP_r: Recursive?, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "setCycle",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_r)
                                           ostr.writePendingValues()
                                       },
                                       context: context)
    }

    func acceptsClassCycles(context: Ice.Context? = nil) async throws -> Swift.Bool {
        return try await _impl._invoke(operation: "acceptsClassCycles",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: Swift.Bool = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func getMB(context: Ice.Context? = nil) async throws -> B? {
        return try await _impl._invoke(operation: "getMB",
                                       mode: .Normal,
                                       read: { istr in
                                           var iceP_returnValue: B?
                                           try istr.read(B.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func getAMDMB(context: Ice.Context? = nil) async throws -> B? {
        return try await _impl._invoke(operation: "getAMDMB",
                                       mode: .Normal,
                                       read: { istr in
                                           var iceP_returnValue: B?
                                           try istr.read(B.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func getAll(context: Ice.Context? = nil) async throws -> (b1: B?, b2: B?, theC: C?, theD: D?) {
        return try await _impl._invoke(operation: "getAll",
                                       mode: .Normal,
                                       read: { istr in
                                           var iceP_b1: B?
                                           try istr.read(B.self) { iceP_b1 = $0 }
                                           var iceP_b2: B?
                                           try istr.read(B.self) { iceP_b2 = $0 }
                                           var iceP_theC: C?
                                           try istr.read(C.self) { iceP_theC = $0 }
                                           var iceP_theD: D?
                                           try istr.read(D.self) { iceP_theD = $0 }
                                           try istr.readPendingValues()
                                           return (iceP_b1, iceP_b2, iceP_theC, iceP_theD)
                                       },
                                       context: context)
    }

    func getK(context: Ice.Context? = nil) async throws -> K? {
        return try await _impl._invoke(operation: "getK",
                                       mode: .Normal,
                                       read: { istr in
                                           var iceP_returnValue: K?
                                           try istr.read(K.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opValue(_ iceP_v1: Ice.Value?, context: Ice.Context? = nil) async throws -> (returnValue: Ice.Value?, v2: Ice.Value?) {
        return try await _impl._invoke(operation: "opValue",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_v1)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           var iceP_v2: Ice.Value?
                                           try istr.read() { iceP_v2 = $0 }
                                           var iceP_returnValue: Ice.Value?
                                           try istr.read() { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_v2)
                                       },
                                       context: context)
    }

    func opValueSeq(_ iceP_v1: ValueSeq, context: Ice.Context? = nil) async throws -> (returnValue: ValueSeq, v2: ValueSeq) {
        return try await _impl._invoke(operation: "opValueSeq",
                                       mode: .Normal,
                                       write: { ostr in
                                           ValueSeqHelper.write(to: ostr, value: iceP_v1)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           let iceP_v2: ValueSeq = try ValueSeqHelper.read(from: istr)
                                           let iceP_returnValue: ValueSeq = try ValueSeqHelper.read(from: istr)
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_v2)
                                       },
                                       context: context)
    }

    func opValueMap(_ iceP_v1: ValueMap, context: Ice.Context? = nil) async throws -> (returnValue: ValueMap, v2: ValueMap) {
        return try await _impl._invoke(operation: "opValueMap",
                                       mode: .Normal,
                                       write: { ostr in
                                           ValueMapHelper.write(to: ostr, value: iceP_v1)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           let iceP_v2: ValueMap = try ValueMapHelper.read(from: istr)
                                           let iceP_returnValue: ValueMap = try ValueMapHelper.read(from: istr)
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_v2)
                                       },
                                       context: context)
    }

    func getD1(_ iceP_d1: D1?, context: Ice.Context? = nil) async throws -> D1? {
        return try await _impl._invoke(operation: "getD1",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_d1)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           var iceP_returnValue: D1?
                                           try istr.read(D1.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func throwEDerived(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "throwEDerived",
                                       mode: .Normal,
                                       userException:{ ex in
                                           do  {
                                               throw ex
                                           } catch let error as EDerived {
                                               throw error
                                           } catch is Ice.UserException {}
                                       },
                                       context: context)
    }

    func setG(_ iceP_theG: G?, context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "setG",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_theG)
                                           ostr.writePendingValues()
                                       },
                                       context: context)
    }

    func opBaseSeq(_ iceP_inSeq: BaseSeq, context: Ice.Context? = nil) async throws -> (returnValue: BaseSeq, outSeq: BaseSeq) {
        return try await _impl._invoke(operation: "opBaseSeq",
                                       mode: .Normal,
                                       write: { ostr in
                                           BaseSeqHelper.write(to: ostr, value: iceP_inSeq)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           let iceP_outSeq: BaseSeq = try BaseSeqHelper.read(from: istr)
                                           let iceP_returnValue: BaseSeq = try BaseSeqHelper.read(from: istr)
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_outSeq)
                                       },
                                       context: context)
    }

    func getCompact(context: Ice.Context? = nil) async throws -> Compact? {
        return try await _impl._invoke(operation: "getCompact",
                                       mode: .Normal,
                                       read: { istr in
                                           var iceP_returnValue: Compact?
                                           try istr.read(Compact.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opM(_ iceP_v1: M?, context: Ice.Context? = nil) async throws -> (returnValue: M?, v2: M?) {
        return try await _impl._invoke(operation: "opM",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_v1)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           var iceP_v2: M?
                                           try istr.read(M.self) { iceP_v2 = $0 }
                                           var iceP_returnValue: M?
                                           try istr.read(M.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_v2)
                                       },
                                       context: context)
    }

    func opF1(_ iceP_f11: F1?, context: Ice.Context? = nil) async throws -> (returnValue: F1?, f12: F1?) {
        return try await _impl._invoke(operation: "opF1",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_f11)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           var iceP_f12: F1?
                                           try istr.read(F1.self) { iceP_f12 = $0 }
                                           var iceP_returnValue: F1?
                                           try istr.read(F1.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_f12)
                                       },
                                       context: context)
    }

    func opF2(_ iceP_f21: F2Prx?, context: Ice.Context? = nil) async throws -> (returnValue: F2Prx?, f22: F2Prx?) {
        return try await _impl._invoke(operation: "opF2",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_f21)
                                       },
                                       read: { istr in
                                           let iceP_f22: F2Prx? = try istr.read(F2Prx.self)
                                           let iceP_returnValue: F2Prx? = try istr.read(F2Prx.self)
                                           return (iceP_returnValue, iceP_f22)
                                       },
                                       context: context)
    }

    func opF3(_ iceP_f31: F3?, context: Ice.Context? = nil) async throws -> (returnValue: F3?, f32: F3?) {
        return try await _impl._invoke(operation: "opF3",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_f31)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           var iceP_f32: F3?
                                           try istr.read(F3.self) { iceP_f32 = $0 }
                                           var iceP_returnValue: F3?
                                           try istr.read(F3.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_f32)
                                       },
                                       context: context)
    }

    func hasF3(context: Ice.Context? = nil) async throws -> Swift.Bool {
        return try await _impl._invoke(operation: "hasF3",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: Swift.Bool = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}

/// :nodoc:
public class Base_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Base.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Base() -> Ice.ValueTypeResolver {
        return Base_TypeResolver()
    }
}

open class Base: Ice.Value {
    public var theS: S = S()
    public var str: Swift.String = ""

    public required init() {}

    public init(theS: S, str: Swift.String) {
        self.theS = theS
        self.str = str
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::Base" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.theS = try istr.read()
        self.str = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Base.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.theS)
        ostr.write(self.str)
        ostr.endSlice()
    }
}

/// :nodoc:
public class A_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return A.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_A() -> Ice.ValueTypeResolver {
        return A_TypeResolver()
    }
}

open class A: Ice.Value {
    public var theB: B? = nil
    public var theC: C? = nil
    public var preMarshalInvoked: Swift.Bool = false
    public var postUnmarshalInvoked: Swift.Bool = false

    public required init() {}

    public init(theB: B?, theC: C?, preMarshalInvoked: Swift.Bool, postUnmarshalInvoked: Swift.Bool) {
        self.theB = theB
        self.theC = theC
        self.preMarshalInvoked = preMarshalInvoked
        self.postUnmarshalInvoked = postUnmarshalInvoked
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::A" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(B.self) { self.theB = $0 }
        try istr.read(C.self) { self.theC = $0 }
        self.preMarshalInvoked = try istr.read()
        self.postUnmarshalInvoked = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: A.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.theB)
        ostr.write(self.theC)
        ostr.write(self.preMarshalInvoked)
        ostr.write(self.postUnmarshalInvoked)
        ostr.endSlice()
    }
}

/// :nodoc:
public class B_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return B.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_B() -> Ice.ValueTypeResolver {
        return B_TypeResolver()
    }
}

open class B: A {
    public var theA: A? = nil

    public required init() {
        super.init()
    }

    public init(theB: B?, theC: C?, preMarshalInvoked: Swift.Bool, postUnmarshalInvoked: Swift.Bool, theA: A?) {
        self.theA = theA
        super.init(theB: theB, theC: theC, preMarshalInvoked: preMarshalInvoked, postUnmarshalInvoked: postUnmarshalInvoked)
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::B" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(A.self) { self.theA = $0 }
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: B.ice_staticId(), compactId: -1, last: false)
        ostr.write(self.theA)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}

/// :nodoc:
public class C_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return C.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_C() -> Ice.ValueTypeResolver {
        return C_TypeResolver()
    }
}

open class C: Ice.Value {
    public var theB: B? = nil
    public var preMarshalInvoked: Swift.Bool = false
    public var postUnmarshalInvoked: Swift.Bool = false

    public required init() {}

    public init(theB: B?, preMarshalInvoked: Swift.Bool, postUnmarshalInvoked: Swift.Bool) {
        self.theB = theB
        self.preMarshalInvoked = preMarshalInvoked
        self.postUnmarshalInvoked = postUnmarshalInvoked
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::C" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(B.self) { self.theB = $0 }
        self.preMarshalInvoked = try istr.read()
        self.postUnmarshalInvoked = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: C.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.theB)
        ostr.write(self.preMarshalInvoked)
        ostr.write(self.postUnmarshalInvoked)
        ostr.endSlice()
    }
}

/// :nodoc:
public class D_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return D.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_D() -> Ice.ValueTypeResolver {
        return D_TypeResolver()
    }
}

open class D: Ice.Value {
    public var theA: A? = nil
    public var theB: B? = nil
    public var theC: C? = nil
    public var preMarshalInvoked: Swift.Bool = false
    public var postUnmarshalInvoked: Swift.Bool = false

    public required init() {}

    public init(theA: A?, theB: B?, theC: C?, preMarshalInvoked: Swift.Bool, postUnmarshalInvoked: Swift.Bool) {
        self.theA = theA
        self.theB = theB
        self.theC = theC
        self.preMarshalInvoked = preMarshalInvoked
        self.postUnmarshalInvoked = postUnmarshalInvoked
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::D" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(A.self) { self.theA = $0 }
        try istr.read(B.self) { self.theB = $0 }
        try istr.read(C.self) { self.theC = $0 }
        self.preMarshalInvoked = try istr.read()
        self.postUnmarshalInvoked = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: D.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.theA)
        ostr.write(self.theB)
        ostr.write(self.theC)
        ostr.write(self.preMarshalInvoked)
        ostr.write(self.postUnmarshalInvoked)
        ostr.endSlice()
    }
}

/// :nodoc:
public class E_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return E.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_E() -> Ice.ValueTypeResolver {
        return E_TypeResolver()
    }
}

open class E: Ice.Value {
    public var i: Swift.Int32 = 0
    public var s: Swift.String = ""

    public required init() {}

    public init(i: Swift.Int32, s: Swift.String) {
        self.i = i
        self.s = s
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::E" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.i = try istr.read()
        self.s = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: E.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.i)
        ostr.write(self.s)
        ostr.endSlice()
    }
}

/// :nodoc:
public class F_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return F.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_F() -> Ice.ValueTypeResolver {
        return F_TypeResolver()
    }
}

open class F: Ice.Value {
    public var e1: E? = nil
    public var e2: E? = nil

    public required init() {}

    public init(e1: E?, e2: E?) {
        self.e1 = e1
        self.e2 = e2
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::F" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(E.self) { self.e1 = $0 }
        try istr.read(E.self) { self.e2 = $0 }
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: F.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.e1)
        ostr.write(self.e2)
        ostr.endSlice()
    }
}

/// :nodoc:
public class G_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return G.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_G() -> Ice.ValueTypeResolver {
        return G_TypeResolver()
    }
}

open class G: Base {
    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::G" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: G.ice_staticId(), compactId: -1, last: false)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}

/// :nodoc:
public class Compact_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Compact.self
    }
}

public extension Ice.TypeIdResolver {
    @objc static func TypeId_1() -> Swift.String {
        return "::Test::Compact"
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Compact() -> Ice.ValueTypeResolver {
        return Compact_TypeResolver()
    }
}

open class Compact: Ice.Value {
    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::Compact" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Compact.ice_staticId(), compactId: 1, last: true)
        ostr.endSlice()
    }
}

/// :nodoc:
public class CompactExt_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return CompactExt.self
    }
}

public extension Ice.TypeIdResolver {
    @objc static func TypeId_789() -> Swift.String {
        return "::Test::CompactExt"
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_CompactExt() -> Ice.ValueTypeResolver {
        return CompactExt_TypeResolver()
    }
}

open class CompactExt: Compact {
    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::CompactExt" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: CompactExt.ice_staticId(), compactId: 789, last: false)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}

/// :nodoc:
public class A1_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return A1.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_A1() -> Ice.ValueTypeResolver {
        return A1_TypeResolver()
    }
}

open class A1: Ice.Value {
    public var name: Swift.String = ""

    public required init() {}

    public init(name: Swift.String) {
        self.name = name
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::A1" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.name = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: A1.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.name)
        ostr.endSlice()
    }
}

/// :nodoc:
public class B1_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return B1.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_B1() -> Ice.ValueTypeResolver {
        return B1_TypeResolver()
    }
}

open class B1: Ice.Value {
    public var a1: A1? = nil
    public var a2: A1? = nil

    public required init() {}

    public init(a1: A1?, a2: A1?) {
        self.a1 = a1
        self.a2 = a2
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::B1" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(A1.self) { self.a1 = $0 }
        try istr.read(A1.self) { self.a2 = $0 }
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: B1.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.a1)
        ostr.write(self.a2)
        ostr.endSlice()
    }
}

/// :nodoc:
public class D1_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return D1.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_D1() -> Ice.ValueTypeResolver {
        return D1_TypeResolver()
    }
}

open class D1: B1 {
    public var a3: A1? = nil
    public var a4: A1? = nil

    public required init() {
        super.init()
    }

    public init(a1: A1?, a2: A1?, a3: A1?, a4: A1?) {
        self.a3 = a3
        self.a4 = a4
        super.init(a1: a1, a2: a2)
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::D1" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(A1.self) { self.a3 = $0 }
        try istr.read(A1.self) { self.a4 = $0 }
        try istr.endSlice()
        try super._iceReadImpl(from: istr);
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: D1.ice_staticId(), compactId: -1, last: false)
        ostr.write(self.a3)
        ostr.write(self.a4)
        ostr.endSlice()
        super._iceWriteImpl(to: ostr);
    }
}

/// :nodoc:
public class Recursive_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Recursive.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Recursive() -> Ice.ValueTypeResolver {
        return Recursive_TypeResolver()
    }
}

open class Recursive: Ice.Value {
    public var v: Recursive? = nil

    public required init() {}

    public init(v: Recursive?) {
        self.v = v
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::Recursive" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(Recursive.self) { self.v = $0 }
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Recursive.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.v)
        ostr.endSlice()
    }
}

/// :nodoc:
public class K_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return K.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_K() -> Ice.ValueTypeResolver {
        return K_TypeResolver()
    }
}

open class K: Ice.Value {
    public var value: Ice.Value? = nil

    public required init() {}

    public init(value: Ice.Value?) {
        self.value = value
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::K" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read() { self.value = $0 }
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: K.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.value)
        ostr.endSlice()
    }
}

/// :nodoc:
public class L_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return L.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_L() -> Ice.ValueTypeResolver {
        return L_TypeResolver()
    }
}

open class L: Ice.Value {
    public var data: Swift.String = ""

    public required init() {}

    public init(data: Swift.String) {
        self.data = data
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::L" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.data = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: L.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.data)
        ostr.endSlice()
    }
}

/// :nodoc:
public class M_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return M.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_M() -> Ice.ValueTypeResolver {
        return M_TypeResolver()
    }
}

open class M: Ice.Value {
    public var v: LMap = LMap()

    public required init() {}

    public init(v: LMap) {
        self.v = v
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::M" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.v = try LMapHelper.read(from: istr)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: M.ice_staticId(), compactId: -1, last: true)
        LMapHelper.write(to: ostr, value: self.v)
        ostr.endSlice()
    }
}

/// :nodoc:
public class F3_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return F3.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_F3() -> Ice.ValueTypeResolver {
        return F3_TypeResolver()
    }
}

open class F3: Ice.Value {
    public var f1: F1? = nil
    public var f2: F2Prx? = nil

    public required init() {}

    public init(f1: F1?, f2: F2Prx?) {
        self.f1 = f1
        self.f2 = f2
    }

    /// Returns the Slice type ID of the interface supported by this object.
    ///
    /// - returns: `String` - The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::F3" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        try istr.read(F1.self) { self.f1 = $0 }
        self.f2 = try istr.read(F2Prx.self)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: F3.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.f1)
        ostr.write(self.f2)
        ostr.endSlice()
    }
}


/// Dispatcher for `Initial` servants.
public struct InitialDisp: Ice.Dispatcher {
    public let servant: Initial
    private static let defaultObject = Ice.ObjectI<InitialTraits>()

    public init(_ servant: Initial) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "acceptsClassCycles":
            try await servant._iceD_acceptsClassCycles(request)
        case "getAMDMB":
            try await servant._iceD_getAMDMB(request)
        case "getAll":
            try await servant._iceD_getAll(request)
        case "getB1":
            try await servant._iceD_getB1(request)
        case "getB2":
            try await servant._iceD_getB2(request)
        case "getC":
            try await servant._iceD_getC(request)
        case "getCompact":
            try await servant._iceD_getCompact(request)
        case "getD":
            try await servant._iceD_getD(request)
        case "getD1":
            try await servant._iceD_getD1(request)
        case "getE":
            try await servant._iceD_getE(request)
        case "getF":
            try await servant._iceD_getF(request)
        case "getK":
            try await servant._iceD_getK(request)
        case "getMB":
            try await servant._iceD_getMB(request)
        case "hasF3":
            try await servant._iceD_hasF3(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? InitialDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? InitialDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? InitialDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? InitialDisp.defaultObject)._iceD_ice_ping(request)
        case "opBaseSeq":
            try await servant._iceD_opBaseSeq(request)
        case "opF1":
            try await servant._iceD_opF1(request)
        case "opF2":
            try await servant._iceD_opF2(request)
        case "opF3":
            try await servant._iceD_opF3(request)
        case "opM":
            try await servant._iceD_opM(request)
        case "opValue":
            try await servant._iceD_opValue(request)
        case "opValueMap":
            try await servant._iceD_opValueMap(request)
        case "opValueSeq":
            try await servant._iceD_opValueSeq(request)
        case "setCycle":
            try await servant._iceD_setCycle(request)
        case "setG":
            try await servant._iceD_setG(request)
        case "setRecursive":
            try await servant._iceD_setRecursive(request)
        case "shutdown":
            try await servant._iceD_shutdown(request)
        case "throwEDerived":
            try await servant._iceD_throwEDerived(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol Initial {
    func shutdown(current: Ice.Current) async throws

    func getB1(current: Ice.Current) async throws -> B?

    func getB2(current: Ice.Current) async throws -> B?

    func getC(current: Ice.Current) async throws -> C?

    func getD(current: Ice.Current) async throws -> D?

    func getE(current: Ice.Current) async throws -> E?

    func getF(current: Ice.Current) async throws -> F?

    func setRecursive(p: Recursive?, current: Ice.Current) async throws

    func setCycle(r: Recursive?, current: Ice.Current) async throws

    func acceptsClassCycles(current: Ice.Current) async throws -> Swift.Bool

    func getMB(current: Ice.Current) async throws -> B?

    func getAMDMB(current: Ice.Current) async throws -> B?

    func getAll(current: Ice.Current) async throws -> (b1: B?, b2: B?, theC: C?, theD: D?)

    func getK(current: Ice.Current) async throws -> K?

    func opValue(v1: Ice.Value?, current: Ice.Current) async throws -> (returnValue: Ice.Value?, v2: Ice.Value?)

    func opValueSeq(v1: ValueSeq, current: Ice.Current) async throws -> (returnValue: ValueSeq, v2: ValueSeq)

    func opValueMap(v1: ValueMap, current: Ice.Current) async throws -> (returnValue: ValueMap, v2: ValueMap)

    func getD1(d1: D1?, current: Ice.Current) async throws -> D1?

    func throwEDerived(current: Ice.Current) async throws

    func setG(theG: G?, current: Ice.Current) async throws

    func opBaseSeq(inSeq: BaseSeq, current: Ice.Current) async throws -> (returnValue: BaseSeq, outSeq: BaseSeq)

    func getCompact(current: Ice.Current) async throws -> Compact?

    func opM(v1: M?, current: Ice.Current) async throws -> (returnValue: M?, v2: M?)

    func opF1(f11: F1?, current: Ice.Current) async throws -> (returnValue: F1?, f12: F1?)

    func opF2(f21: F2Prx?, current: Ice.Current) async throws -> (returnValue: F2Prx?, f22: F2Prx?)

    func opF3(f31: F3?, current: Ice.Current) async throws -> (returnValue: F3?, f32: F3?)

    func hasF3(current: Ice.Current) async throws -> Swift.Bool
}

extension Initial {
    public func _iceD_shutdown(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.shutdown(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_getB1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getB1(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_getB2(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getB2(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_getC(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getC(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_getD(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getD(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_getE(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getE(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_getF(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getF(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_setRecursive(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_p: Recursive?
        try istr.read(Recursive.self) { iceP_p = $0 }
        try istr.readPendingValues()
        try await self.setRecursive(p: iceP_p, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_setCycle(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_r: Recursive?
        try istr.read(Recursive.self) { iceP_r = $0 }
        try istr.readPendingValues()
        try await self.setCycle(r: iceP_r, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_acceptsClassCycles(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.acceptsClassCycles(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_getMB(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getMB(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_getAMDMB(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getAMDMB(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_getAll(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getAll(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_b1, iceP_b2, iceP_theC, iceP_theD) = value
            ostr.write(iceP_b1)
            ostr.write(iceP_b2)
            ostr.write(iceP_theC)
            ostr.write(iceP_theD)
            ostr.writePendingValues()
        }
    }

    public func _iceD_getK(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getK(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_opValue(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_v1: Ice.Value?
        try istr.read() { iceP_v1 = $0 }
        try istr.readPendingValues()
        let result = try await self.opValue(v1: iceP_v1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_v2) = value
            ostr.write(iceP_v2)
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_opValueSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_v1: ValueSeq = try ValueSeqHelper.read(from: istr)
        try istr.readPendingValues()
        let result = try await self.opValueSeq(v1: iceP_v1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_v2) = value
            ValueSeqHelper.write(to: ostr, value: iceP_v2)
            ValueSeqHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_opValueMap(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_v1: ValueMap = try ValueMapHelper.read(from: istr)
        try istr.readPendingValues()
        let result = try await self.opValueMap(v1: iceP_v1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_v2) = value
            ValueMapHelper.write(to: ostr, value: iceP_v2)
            ValueMapHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_getD1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_d1: D1?
        try istr.read(D1.self) { iceP_d1 = $0 }
        try istr.readPendingValues()
        let result = try await self.getD1(d1: iceP_d1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_throwEDerived(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.throwEDerived(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_setG(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_theG: G?
        try istr.read(G.self) { iceP_theG = $0 }
        try istr.readPendingValues()
        try await self.setG(theG: iceP_theG, current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_opBaseSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_inSeq: BaseSeq = try BaseSeqHelper.read(from: istr)
        try istr.readPendingValues()
        let result = try await self.opBaseSeq(inSeq: iceP_inSeq, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_outSeq) = value
            BaseSeqHelper.write(to: ostr, value: iceP_outSeq)
            BaseSeqHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_getCompact(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.getCompact(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_opM(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_v1: M?
        try istr.read(M.self) { iceP_v1 = $0 }
        try istr.readPendingValues()
        let result = try await self.opM(v1: iceP_v1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_v2) = value
            ostr.write(iceP_v2)
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_opF1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_f11: F1?
        try istr.read(F1.self) { iceP_f11 = $0 }
        try istr.readPendingValues()
        let result = try await self.opF1(f11: iceP_f11, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_f12) = value
            ostr.write(iceP_f12)
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_opF2(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_f21: F2Prx? = try istr.read(F2Prx.self)
        let result = try await self.opF2(f21: iceP_f21, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_f22) = value
            ostr.write(iceP_f22)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opF3(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_f31: F3?
        try istr.read(F3.self) { iceP_f31 = $0 }
        try istr.readPendingValues()
        let result = try await self.opF3(f31: iceP_f31, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_f32) = value
            ostr.write(iceP_f32)
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_hasF3(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.hasF3(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }
}
