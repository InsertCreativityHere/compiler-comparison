//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice
import PromiseKit

/// Traits for Slice interface`Empty`.
public struct EmptyTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Empty"]
    public static let staticId = "::Test::Empty"
}

/// Traits for Slice interface`A`.
public struct ATraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::A"]
    public static let staticId = "::Test::A"
}

/// Traits for Slice interface`B`.
public struct BTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::A", "::Test::B"]
    public static let staticId = "::Test::B"
}

/// Traits for Slice interface`C`.
public struct CTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::A", "::Test::C"]
    public static let staticId = "::Test::C"
}

/// Traits for Slice interface`D`.
public struct DTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::A", "::Test::B", "::Test::C", "::Test::D"]
    public static let staticId = "::Test::D"
}

/// Traits for Slice interface`E`.
public struct ETraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::E"]
    public static let staticId = "::Test::E"
}

/// Traits for Slice interface`F`.
public struct FTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::E", "::Test::F"]
    public static let staticId = "::Test::F"
}

/// Traits for Slice interface`G`.
public struct GTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::G"]
    public static let staticId = "::Test::G"
}

/// Traits for Slice interface`H`.
public struct HTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::G", "::Test::H"]
    public static let staticId = "::Test::H"
}

/// EmptyPrx overview.
public protocol EmptyPrx: Ice.ObjectPrx {}

private final class EmptyPrxI: Ice.ObjectPrxI, EmptyPrx {
    public override class func ice_staticId() -> Swift.String {
        return EmptyTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `EmptyPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `EmptyPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: EmptyPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> EmptyPrx? {
    return try EmptyPrxI.checkedCast(prx: prx, facet: facet, context: context) as EmptyPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `EmptyPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `EmptyPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: EmptyPrx.Protocol, facet: Swift.String? = nil) -> EmptyPrx {
    return EmptyPrxI.uncheckedCast(prx: prx, facet: facet) as EmptyPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `EmptyPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: EmptyPrx.Protocol) -> Swift.String {
    return EmptyTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `EmptyPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `EmptyPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `EmptyPrx?` - The extracted proxy
    func read(_ type: EmptyPrx.Protocol) throws -> EmptyPrx? {
        return try read() as EmptyPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `EmptyPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `EmptyPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: EmptyPrx.Protocol) throws -> EmptyPrx? {
        return try read(tag: tag) as EmptyPrxI?
    }
}

/// EmptyPrx overview.
public extension EmptyPrx {}

/// APrx overview.
///
/// APrx Methods:
///
///  - callA: 
///
///  - callAAsync: 
public protocol APrx: Ice.ObjectPrx {}

private final class APrxI: Ice.ObjectPrxI, APrx {
    public override class func ice_staticId() -> Swift.String {
        return ATraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `APrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `APrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: APrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> APrx? {
    return try APrxI.checkedCast(prx: prx, facet: facet, context: context) as APrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `APrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `APrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: APrx.Protocol, facet: Swift.String? = nil) -> APrx {
    return APrxI.uncheckedCast(prx: prx, facet: facet) as APrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `APrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: APrx.Protocol) -> Swift.String {
    return ATraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `APrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `APrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `APrx?` - The extracted proxy
    func read(_ type: APrx.Protocol) throws -> APrx? {
        return try read() as APrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `APrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `APrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: APrx.Protocol) throws -> APrx? {
        return try read(tag: tag) as APrxI?
    }
}

/// APrx overview.
///
/// APrx Methods:
///
///  - callA: 
///
///  - callAAsync: 
public extension APrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String`
    func callA(context: Ice.Context? = nil) throws -> Swift.String {
        return try _impl._invoke(operation: "callA",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: Swift.String = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.String>` - The result of the operation
    func callAAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.String> {
        return _impl._invokeAsync(operation: "callA",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_returnValue: Swift.String = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// BPrx overview.
///
/// BPrx Methods:
///
///  - callB: 
///
///  - callBAsync: 
public protocol BPrx: APrx {}

private final class BPrxI: Ice.ObjectPrxI, BPrx {
    public override class func ice_staticId() -> Swift.String {
        return BTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `BPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `BPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: BPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> BPrx? {
    return try BPrxI.checkedCast(prx: prx, facet: facet, context: context) as BPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `BPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `BPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: BPrx.Protocol, facet: Swift.String? = nil) -> BPrx {
    return BPrxI.uncheckedCast(prx: prx, facet: facet) as BPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `BPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: BPrx.Protocol) -> Swift.String {
    return BTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `BPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `BPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `BPrx?` - The extracted proxy
    func read(_ type: BPrx.Protocol) throws -> BPrx? {
        return try read() as BPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `BPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `BPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: BPrx.Protocol) throws -> BPrx? {
        return try read(tag: tag) as BPrxI?
    }
}

/// BPrx overview.
///
/// BPrx Methods:
///
///  - callB: 
///
///  - callBAsync: 
public extension BPrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String`
    func callB(context: Ice.Context? = nil) throws -> Swift.String {
        return try _impl._invoke(operation: "callB",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: Swift.String = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.String>` - The result of the operation
    func callBAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.String> {
        return _impl._invokeAsync(operation: "callB",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_returnValue: Swift.String = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// CPrx overview.
///
/// CPrx Methods:
///
///  - callC: 
///
///  - callCAsync: 
public protocol CPrx: APrx {}

private final class CPrxI: Ice.ObjectPrxI, CPrx {
    public override class func ice_staticId() -> Swift.String {
        return CTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `CPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `CPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: CPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> CPrx? {
    return try CPrxI.checkedCast(prx: prx, facet: facet, context: context) as CPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `CPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `CPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: CPrx.Protocol, facet: Swift.String? = nil) -> CPrx {
    return CPrxI.uncheckedCast(prx: prx, facet: facet) as CPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `CPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: CPrx.Protocol) -> Swift.String {
    return CTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `CPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `CPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `CPrx?` - The extracted proxy
    func read(_ type: CPrx.Protocol) throws -> CPrx? {
        return try read() as CPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `CPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `CPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: CPrx.Protocol) throws -> CPrx? {
        return try read(tag: tag) as CPrxI?
    }
}

/// CPrx overview.
///
/// CPrx Methods:
///
///  - callC: 
///
///  - callCAsync: 
public extension CPrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String`
    func callC(context: Ice.Context? = nil) throws -> Swift.String {
        return try _impl._invoke(operation: "callC",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: Swift.String = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.String>` - The result of the operation
    func callCAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.String> {
        return _impl._invokeAsync(operation: "callC",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_returnValue: Swift.String = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// DPrx overview.
///
/// DPrx Methods:
///
///  - callD: 
///
///  - callDAsync: 
public protocol DPrx: BPrx, CPrx {}

private final class DPrxI: Ice.ObjectPrxI, DPrx {
    public override class func ice_staticId() -> Swift.String {
        return DTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `DPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `DPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: DPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> DPrx? {
    return try DPrxI.checkedCast(prx: prx, facet: facet, context: context) as DPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `DPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `DPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: DPrx.Protocol, facet: Swift.String? = nil) -> DPrx {
    return DPrxI.uncheckedCast(prx: prx, facet: facet) as DPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `DPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: DPrx.Protocol) -> Swift.String {
    return DTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `DPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `DPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `DPrx?` - The extracted proxy
    func read(_ type: DPrx.Protocol) throws -> DPrx? {
        return try read() as DPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `DPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `DPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: DPrx.Protocol) throws -> DPrx? {
        return try read(tag: tag) as DPrxI?
    }
}

/// DPrx overview.
///
/// DPrx Methods:
///
///  - callD: 
///
///  - callDAsync: 
public extension DPrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String`
    func callD(context: Ice.Context? = nil) throws -> Swift.String {
        return try _impl._invoke(operation: "callD",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: Swift.String = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.String>` - The result of the operation
    func callDAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.String> {
        return _impl._invokeAsync(operation: "callD",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_returnValue: Swift.String = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// EPrx overview.
///
/// EPrx Methods:
///
///  - callE: 
///
///  - callEAsync: 
public protocol EPrx: Ice.ObjectPrx {}

private final class EPrxI: Ice.ObjectPrxI, EPrx {
    public override class func ice_staticId() -> Swift.String {
        return ETraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `EPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `EPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: EPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> EPrx? {
    return try EPrxI.checkedCast(prx: prx, facet: facet, context: context) as EPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `EPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `EPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: EPrx.Protocol, facet: Swift.String? = nil) -> EPrx {
    return EPrxI.uncheckedCast(prx: prx, facet: facet) as EPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `EPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: EPrx.Protocol) -> Swift.String {
    return ETraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `EPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `EPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `EPrx?` - The extracted proxy
    func read(_ type: EPrx.Protocol) throws -> EPrx? {
        return try read() as EPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `EPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `EPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: EPrx.Protocol) throws -> EPrx? {
        return try read(tag: tag) as EPrxI?
    }
}

/// EPrx overview.
///
/// EPrx Methods:
///
///  - callE: 
///
///  - callEAsync: 
public extension EPrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String`
    func callE(context: Ice.Context? = nil) throws -> Swift.String {
        return try _impl._invoke(operation: "callE",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: Swift.String = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.String>` - The result of the operation
    func callEAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.String> {
        return _impl._invokeAsync(operation: "callE",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_returnValue: Swift.String = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// FPrx overview.
///
/// FPrx Methods:
///
///  - callF: 
///
///  - callFAsync: 
public protocol FPrx: EPrx {}

private final class FPrxI: Ice.ObjectPrxI, FPrx {
    public override class func ice_staticId() -> Swift.String {
        return FTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `FPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `FPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: FPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> FPrx? {
    return try FPrxI.checkedCast(prx: prx, facet: facet, context: context) as FPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `FPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `FPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: FPrx.Protocol, facet: Swift.String? = nil) -> FPrx {
    return FPrxI.uncheckedCast(prx: prx, facet: facet) as FPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `FPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: FPrx.Protocol) -> Swift.String {
    return FTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `FPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `FPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `FPrx?` - The extracted proxy
    func read(_ type: FPrx.Protocol) throws -> FPrx? {
        return try read() as FPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `FPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `FPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: FPrx.Protocol) throws -> FPrx? {
        return try read(tag: tag) as FPrxI?
    }
}

/// FPrx overview.
///
/// FPrx Methods:
///
///  - callF: 
///
///  - callFAsync: 
public extension FPrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String`
    func callF(context: Ice.Context? = nil) throws -> Swift.String {
        return try _impl._invoke(operation: "callF",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: Swift.String = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.String>` - The result of the operation
    func callFAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.String> {
        return _impl._invokeAsync(operation: "callF",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_returnValue: Swift.String = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// GPrx overview.
///
/// GPrx Methods:
///
///  - shutdown: 
///
///  - shutdownAsync: 
///
///  - callG: 
///
///  - callGAsync: 
public protocol GPrx: Ice.ObjectPrx {}

private final class GPrxI: Ice.ObjectPrxI, GPrx {
    public override class func ice_staticId() -> Swift.String {
        return GTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `GPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `GPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: GPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> GPrx? {
    return try GPrxI.checkedCast(prx: prx, facet: facet, context: context) as GPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `GPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `GPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: GPrx.Protocol, facet: Swift.String? = nil) -> GPrx {
    return GPrxI.uncheckedCast(prx: prx, facet: facet) as GPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `GPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: GPrx.Protocol) -> Swift.String {
    return GTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `GPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `GPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `GPrx?` - The extracted proxy
    func read(_ type: GPrx.Protocol) throws -> GPrx? {
        return try read() as GPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `GPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `GPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: GPrx.Protocol) throws -> GPrx? {
        return try read(tag: tag) as GPrxI?
    }
}

/// GPrx overview.
///
/// GPrx Methods:
///
///  - shutdown: 
///
///  - shutdownAsync: 
///
///  - callG: 
///
///  - callGAsync: 
public extension GPrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    func shutdown(context: Ice.Context? = nil) throws {
        try _impl._invoke(operation: "shutdown",
                          mode: .Normal,
                          context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<>` - The result of the operation
    func shutdownAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.Void> {
        return _impl._invokeAsync(operation: "shutdown",
                                  mode: .Normal,
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String`
    func callG(context: Ice.Context? = nil) throws -> Swift.String {
        return try _impl._invoke(operation: "callG",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: Swift.String = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.String>` - The result of the operation
    func callGAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.String> {
        return _impl._invokeAsync(operation: "callG",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_returnValue: Swift.String = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}

/// HPrx overview.
///
/// HPrx Methods:
///
///  - callH: 
///
///  - callHAsync: 
public protocol HPrx: GPrx {}

private final class HPrxI: Ice.ObjectPrxI, HPrx {
    public override class func ice_staticId() -> Swift.String {
        return HTraits.staticId
    }
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - parameter prx: `Ice.ObjectPrx` - The proxy to be cast.
///
/// - parameter type: `HPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet.
///
/// - parameter context: `Ice.Context` The optional context dictionary for the remote invocation.
///
/// - returns: `HPrx` - A proxy with the requested type or nil if the objet does not
///   support this type.
///
/// - throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: HPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) throws -> HPrx? {
    return try HPrxI.checkedCast(prx: prx, facet: facet, context: context) as HPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - parameter prx: `Ice.ObjectPrx` The proxy to be cast.
///
/// - parameter type: `HPrx.Protocol` - The proxy type to cast to.
///
/// - parameter facet: `String` - The optional name of the desired facet
///
/// - returns: `HPrx` - A proxy with the requested type
public func uncheckedCast(prx: Ice.ObjectPrx, type: HPrx.Protocol, facet: Swift.String? = nil) -> HPrx {
    return HPrxI.uncheckedCast(prx: prx, facet: facet) as HPrxI
}

/// Returns the Slice type id of the interface or class associated with this proxy type.
///
/// parameter type: `HPrx.Protocol` -  The proxy type to retrieve the type id.
///
/// returns: `String` - The type id of the interface or class associated with this proxy type.
public func ice_staticId(_ type: HPrx.Protocol) -> Swift.String {
    return HTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxy of type
/// `HPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter type: `HPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `HPrx?` - The extracted proxy
    func read(_ type: HPrx.Protocol) throws -> HPrx? {
        return try read() as HPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - parameter tag: `Int32` - The numeric tag associated with the value.
    ///
    /// - parameter type: `HPrx.Protocol` - The type of the proxy to be extracted.
    ///
    /// - returns: `HPrx` - The extracted proxy.
    func read(tag: Swift.Int32, type: HPrx.Protocol) throws -> HPrx? {
        return try read(tag: tag) as HPrxI?
    }
}

/// HPrx overview.
///
/// HPrx Methods:
///
///  - callH: 
///
///  - callHAsync: 
public extension HPrx {
    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - returns: `Swift.String`
    func callH(context: Ice.Context? = nil) throws -> Swift.String {
        return try _impl._invoke(operation: "callH",
                                 mode: .Normal,
                                 read: { istr in
                                     let iceP_returnValue: Swift.String = try istr.read()
                                     return iceP_returnValue
                                 },
                                 context: context)
    }

    ///
    /// - parameter context: `Ice.Context` - Optional request context.
    ///
    /// - parameter sentOn: `Dispatch.DispatchQueue?` - Optional dispatch queue used to
    ///   dispatch the sent callback.
    ///
    /// - parameter sentFlags: `Dispatch.DispatchWorkItemFlags?` - Optional dispatch flags used
    ///   to dispatch the sent callback
    ///
    /// - parameter sent: `((Swift.Bool) -> Swift.Void)` - Optional sent callback.
    ///
    /// - returns: `PromiseKit.Promise<Swift.String>` - The result of the operation
    func callHAsync(context: Ice.Context? = nil, sentOn: Dispatch.DispatchQueue? = nil, sentFlags: Dispatch.DispatchWorkItemFlags? = nil, sent: ((Swift.Bool) -> Swift.Void)? = nil) -> PromiseKit.Promise<Swift.String> {
        return _impl._invokeAsync(operation: "callH",
                                  mode: .Normal,
                                  read: { istr in
                                      let iceP_returnValue: Swift.String = try istr.read()
                                      return iceP_returnValue
                                  },
                                  context: context,
                                  sentOn: sentOn,
                                  sentFlags: sentFlags,
                                  sent: sent)
    }
}


/// Dispatcher for `Empty` servants.
public struct EmptyDisp: Ice.Disp {
    public let servant: Empty
    private static let defaultObject = Ice.ObjectI<EmptyTraits>()

    public init(_ servant: Empty) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "ice_id":
            return try (servant as? Object ?? EmptyDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? EmptyDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? EmptyDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? EmptyDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol Empty {}


/// Dispatcher for `A` servants.
public struct ADisp: Ice.Disp {
    public let servant: A
    private static let defaultObject = Ice.ObjectI<ATraits>()

    public init(_ servant: A) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "callA":
            return try servant._iceD_callA(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? ADisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? ADisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? ADisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? ADisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol A {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String`
    func callA(current: Ice.Current) throws -> Swift.String
}


/// Dispatcher for `B` servants.
public struct BDisp: Ice.Disp {
    public let servant: B
    private static let defaultObject = Ice.ObjectI<BTraits>()

    public init(_ servant: B) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "callA":
            return try servant._iceD_callA(incoming: request, current: current)
        case "callB":
            return try servant._iceD_callB(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? BDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? BDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? BDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? BDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol B: A {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String`
    func callB(current: Ice.Current) throws -> Swift.String
}


/// Dispatcher for `C` servants.
public struct CDisp: Ice.Disp {
    public let servant: C
    private static let defaultObject = Ice.ObjectI<CTraits>()

    public init(_ servant: C) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "callA":
            return try servant._iceD_callA(incoming: request, current: current)
        case "callC":
            return try servant._iceD_callC(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? CDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? CDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? CDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? CDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol C: A {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String`
    func callC(current: Ice.Current) throws -> Swift.String
}


/// Dispatcher for `D` servants.
public struct DDisp: Ice.Disp {
    public let servant: D
    private static let defaultObject = Ice.ObjectI<DTraits>()

    public init(_ servant: D) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "callA":
            return try servant._iceD_callA(incoming: request, current: current)
        case "callB":
            return try servant._iceD_callB(incoming: request, current: current)
        case "callC":
            return try servant._iceD_callC(incoming: request, current: current)
        case "callD":
            return try servant._iceD_callD(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? DDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? DDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? DDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? DDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol D: B, C {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String`
    func callD(current: Ice.Current) throws -> Swift.String
}


/// Dispatcher for `E` servants.
public struct EDisp: Ice.Disp {
    public let servant: E
    private static let defaultObject = Ice.ObjectI<ETraits>()

    public init(_ servant: E) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "callE":
            return try servant._iceD_callE(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? EDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? EDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? EDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? EDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol E {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String`
    func callE(current: Ice.Current) throws -> Swift.String
}


/// Dispatcher for `F` servants.
public struct FDisp: Ice.Disp {
    public let servant: F
    private static let defaultObject = Ice.ObjectI<FTraits>()

    public init(_ servant: F) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "callE":
            return try servant._iceD_callE(incoming: request, current: current)
        case "callF":
            return try servant._iceD_callF(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? FDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? FDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? FDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? FDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol F: E {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String`
    func callF(current: Ice.Current) throws -> Swift.String
}


/// Dispatcher for `G` servants.
public struct GDisp: Ice.Disp {
    public let servant: G
    private static let defaultObject = Ice.ObjectI<GTraits>()

    public init(_ servant: G) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "callG":
            return try servant._iceD_callG(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? GDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? GDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? GDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? GDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "shutdown":
            return try servant._iceD_shutdown(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol G {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    func shutdown(current: Ice.Current) throws

    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String`
    func callG(current: Ice.Current) throws -> Swift.String
}


/// Dispatcher for `H` servants.
public struct HDisp: Ice.Disp {
    public let servant: H
    private static let defaultObject = Ice.ObjectI<HTraits>()

    public init(_ servant: H) {
        self.servant = servant
    }

    public func dispatch(request: Ice.Request, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        request.startOver()
        switch current.operation {
        case "callG":
            return try servant._iceD_callG(incoming: request, current: current)
        case "callH":
            return try servant._iceD_callH(incoming: request, current: current)
        case "ice_id":
            return try (servant as? Object ?? HDisp.defaultObject)._iceD_ice_id(incoming: request, current: current)
        case "ice_ids":
            return try (servant as? Object ?? HDisp.defaultObject)._iceD_ice_ids(incoming: request, current: current)
        case "ice_isA":
            return try (servant as? Object ?? HDisp.defaultObject)._iceD_ice_isA(incoming: request, current: current)
        case "ice_ping":
            return try (servant as? Object ?? HDisp.defaultObject)._iceD_ice_ping(incoming: request, current: current)
        case "shutdown":
            return try servant._iceD_shutdown(incoming: request, current: current)
        default:
            throw Ice.OperationNotExistException(id: current.id, facet: current.facet, operation: current.operation)
        }
    }
}

public protocol H: G {
    ///
    /// - parameter current: `Ice.Current` - The Current object for the dispatch.
    ///
    /// - returns: `Swift.String`
    func callH(current: Ice.Current) throws -> Swift.String
}

/// Empty overview.
public extension Empty {}

/// A overview.
///
/// A Methods:
///
///  - callA: 
public extension A {
    func _iceD_callA(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.callA(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }
}

/// B overview.
///
/// B Methods:
///
///  - callB: 
public extension B {
    func _iceD_callB(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.callB(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }
}

/// C overview.
///
/// C Methods:
///
///  - callC: 
public extension C {
    func _iceD_callC(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.callC(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }
}

/// D overview.
///
/// D Methods:
///
///  - callD: 
public extension D {
    func _iceD_callD(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.callD(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }
}

/// E overview.
///
/// E Methods:
///
///  - callE: 
public extension E {
    func _iceD_callE(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.callE(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }
}

/// F overview.
///
/// F Methods:
///
///  - callF: 
public extension F {
    func _iceD_callF(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.callF(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }
}

/// G overview.
///
/// G Methods:
///
///  - shutdown: 
///
///  - callG: 
public extension G {
    func _iceD_shutdown(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        try self.shutdown(current: current)

        return inS.setResult()
    }

    func _iceD_callG(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.callG(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }
}

/// H overview.
///
/// H Methods:
///
///  - callH: 
public extension H {
    func _iceD_callH(incoming inS: Ice.Incoming, current: Ice.Current) throws -> PromiseKit.Promise<Ice.OutputStream>? {
        try inS.readEmptyParams()

        let iceP_returnValue = try self.callH(current: current)

        return inS.setResult{ ostr in
            ostr.write(iceP_returnValue)
        }
    }
}
