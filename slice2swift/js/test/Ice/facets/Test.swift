//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

import Foundation
import Ice

/// Traits for Slice interface `Empty`.
public struct EmptyTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Empty"]
    public static let staticId = "::Test::Empty"
}

/// Traits for Slice interface `A`.
public struct ATraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::A"]
    public static let staticId = "::Test::A"
}

/// Traits for Slice interface `B`.
public struct BTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::A", "::Test::B"]
    public static let staticId = "::Test::B"
}

/// Traits for Slice interface `C`.
public struct CTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::A", "::Test::C"]
    public static let staticId = "::Test::C"
}

/// Traits for Slice interface `D`.
public struct DTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::A", "::Test::B", "::Test::C", "::Test::D"]
    public static let staticId = "::Test::D"
}

/// Traits for Slice interface `E`.
public struct ETraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::E"]
    public static let staticId = "::Test::E"
}

/// Traits for Slice interface `F`.
public struct FTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::E", "::Test::F"]
    public static let staticId = "::Test::F"
}

/// Traits for Slice interface `G`.
public struct GTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::G"]
    public static let staticId = "::Test::G"
}

/// Traits for Slice interface `H`.
public struct HTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::G", "::Test::H"]
    public static let staticId = "::Test::H"
}

/// Traits for Slice interface `Echo`.
public struct EchoTraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Echo"]
    public static let staticId = "::Test::Echo"
}

public protocol EmptyPrx: Ice.ObjectPrx {}

private final class EmptyPrxI: Ice.ObjectPrxI, EmptyPrx {
    public override class func ice_staticId() -> Swift.String {
        return EmptyTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: EmptyPrx.Protocol) throws -> EmptyPrx {
    try communicator.makeProxyImpl(proxyString) as EmptyPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: EmptyPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> EmptyPrx? {
    return try await EmptyPrxI.checkedCast(prx: prx, facet: facet, context: context) as EmptyPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: EmptyPrx.Protocol, facet: Swift.String? = nil) -> EmptyPrx {
    return EmptyPrxI.uncheckedCast(prx: prx, facet: facet) as EmptyPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: EmptyPrx.Protocol) -> Swift.String {
    return EmptyTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `EmptyPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: EmptyPrx.Protocol) throws -> EmptyPrx? {
        return try read() as EmptyPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: EmptyPrx.Protocol) throws -> EmptyPrx? {
        return try read(tag: tag) as EmptyPrxI?
    }
}

public extension EmptyPrx {}

public protocol APrx: Ice.ObjectPrx {}

private final class APrxI: Ice.ObjectPrxI, APrx {
    public override class func ice_staticId() -> Swift.String {
        return ATraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: APrx.Protocol) throws -> APrx {
    try communicator.makeProxyImpl(proxyString) as APrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: APrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> APrx? {
    return try await APrxI.checkedCast(prx: prx, facet: facet, context: context) as APrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: APrx.Protocol, facet: Swift.String? = nil) -> APrx {
    return APrxI.uncheckedCast(prx: prx, facet: facet) as APrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: APrx.Protocol) -> Swift.String {
    return ATraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `APrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: APrx.Protocol) throws -> APrx? {
        return try read() as APrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: APrx.Protocol) throws -> APrx? {
        return try read(tag: tag) as APrxI?
    }
}

public extension APrx {
    func callA(context: Ice.Context? = nil) async throws -> Swift.String {
        return try await _impl._invoke(operation: "callA",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: Swift.String = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}

public protocol BPrx: APrx {}

private final class BPrxI: Ice.ObjectPrxI, BPrx {
    public override class func ice_staticId() -> Swift.String {
        return BTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: BPrx.Protocol) throws -> BPrx {
    try communicator.makeProxyImpl(proxyString) as BPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: BPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> BPrx? {
    return try await BPrxI.checkedCast(prx: prx, facet: facet, context: context) as BPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: BPrx.Protocol, facet: Swift.String? = nil) -> BPrx {
    return BPrxI.uncheckedCast(prx: prx, facet: facet) as BPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: BPrx.Protocol) -> Swift.String {
    return BTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `BPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: BPrx.Protocol) throws -> BPrx? {
        return try read() as BPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: BPrx.Protocol) throws -> BPrx? {
        return try read(tag: tag) as BPrxI?
    }
}

public extension BPrx {
    func callB(context: Ice.Context? = nil) async throws -> Swift.String {
        return try await _impl._invoke(operation: "callB",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: Swift.String = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}

public protocol CPrx: APrx {}

private final class CPrxI: Ice.ObjectPrxI, CPrx {
    public override class func ice_staticId() -> Swift.String {
        return CTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: CPrx.Protocol) throws -> CPrx {
    try communicator.makeProxyImpl(proxyString) as CPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: CPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> CPrx? {
    return try await CPrxI.checkedCast(prx: prx, facet: facet, context: context) as CPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: CPrx.Protocol, facet: Swift.String? = nil) -> CPrx {
    return CPrxI.uncheckedCast(prx: prx, facet: facet) as CPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: CPrx.Protocol) -> Swift.String {
    return CTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `CPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: CPrx.Protocol) throws -> CPrx? {
        return try read() as CPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: CPrx.Protocol) throws -> CPrx? {
        return try read(tag: tag) as CPrxI?
    }
}

public extension CPrx {
    func callC(context: Ice.Context? = nil) async throws -> Swift.String {
        return try await _impl._invoke(operation: "callC",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: Swift.String = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}

public protocol DPrx: BPrx, CPrx {}

private final class DPrxI: Ice.ObjectPrxI, DPrx {
    public override class func ice_staticId() -> Swift.String {
        return DTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: DPrx.Protocol) throws -> DPrx {
    try communicator.makeProxyImpl(proxyString) as DPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: DPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> DPrx? {
    return try await DPrxI.checkedCast(prx: prx, facet: facet, context: context) as DPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: DPrx.Protocol, facet: Swift.String? = nil) -> DPrx {
    return DPrxI.uncheckedCast(prx: prx, facet: facet) as DPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: DPrx.Protocol) -> Swift.String {
    return DTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `DPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: DPrx.Protocol) throws -> DPrx? {
        return try read() as DPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: DPrx.Protocol) throws -> DPrx? {
        return try read(tag: tag) as DPrxI?
    }
}

public extension DPrx {
    func callD(context: Ice.Context? = nil) async throws -> Swift.String {
        return try await _impl._invoke(operation: "callD",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: Swift.String = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}

public protocol EPrx: Ice.ObjectPrx {}

private final class EPrxI: Ice.ObjectPrxI, EPrx {
    public override class func ice_staticId() -> Swift.String {
        return ETraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: EPrx.Protocol) throws -> EPrx {
    try communicator.makeProxyImpl(proxyString) as EPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: EPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> EPrx? {
    return try await EPrxI.checkedCast(prx: prx, facet: facet, context: context) as EPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: EPrx.Protocol, facet: Swift.String? = nil) -> EPrx {
    return EPrxI.uncheckedCast(prx: prx, facet: facet) as EPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: EPrx.Protocol) -> Swift.String {
    return ETraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `EPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: EPrx.Protocol) throws -> EPrx? {
        return try read() as EPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: EPrx.Protocol) throws -> EPrx? {
        return try read(tag: tag) as EPrxI?
    }
}

public extension EPrx {
    func callE(context: Ice.Context? = nil) async throws -> Swift.String {
        return try await _impl._invoke(operation: "callE",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: Swift.String = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}

public protocol FPrx: EPrx {}

private final class FPrxI: Ice.ObjectPrxI, FPrx {
    public override class func ice_staticId() -> Swift.String {
        return FTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: FPrx.Protocol) throws -> FPrx {
    try communicator.makeProxyImpl(proxyString) as FPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: FPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> FPrx? {
    return try await FPrxI.checkedCast(prx: prx, facet: facet, context: context) as FPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: FPrx.Protocol, facet: Swift.String? = nil) -> FPrx {
    return FPrxI.uncheckedCast(prx: prx, facet: facet) as FPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: FPrx.Protocol) -> Swift.String {
    return FTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `FPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: FPrx.Protocol) throws -> FPrx? {
        return try read() as FPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: FPrx.Protocol) throws -> FPrx? {
        return try read(tag: tag) as FPrxI?
    }
}

public extension FPrx {
    func callF(context: Ice.Context? = nil) async throws -> Swift.String {
        return try await _impl._invoke(operation: "callF",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: Swift.String = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}

public protocol GPrx: Ice.ObjectPrx {}

private final class GPrxI: Ice.ObjectPrxI, GPrx {
    public override class func ice_staticId() -> Swift.String {
        return GTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: GPrx.Protocol) throws -> GPrx {
    try communicator.makeProxyImpl(proxyString) as GPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: GPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> GPrx? {
    return try await GPrxI.checkedCast(prx: prx, facet: facet, context: context) as GPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: GPrx.Protocol, facet: Swift.String? = nil) -> GPrx {
    return GPrxI.uncheckedCast(prx: prx, facet: facet) as GPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: GPrx.Protocol) -> Swift.String {
    return GTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `GPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: GPrx.Protocol) throws -> GPrx? {
        return try read() as GPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: GPrx.Protocol) throws -> GPrx? {
        return try read(tag: tag) as GPrxI?
    }
}

public extension GPrx {
    func shutdown(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "shutdown",
                                       mode: .Normal,
                                       context: context)
    }

    func callG(context: Ice.Context? = nil) async throws -> Swift.String {
        return try await _impl._invoke(operation: "callG",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: Swift.String = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}

public protocol HPrx: GPrx {}

private final class HPrxI: Ice.ObjectPrxI, HPrx {
    public override class func ice_staticId() -> Swift.String {
        return HTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: HPrx.Protocol) throws -> HPrx {
    try communicator.makeProxyImpl(proxyString) as HPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: HPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> HPrx? {
    return try await HPrxI.checkedCast(prx: prx, facet: facet, context: context) as HPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: HPrx.Protocol, facet: Swift.String? = nil) -> HPrx {
    return HPrxI.uncheckedCast(prx: prx, facet: facet) as HPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: HPrx.Protocol) -> Swift.String {
    return HTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `HPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: HPrx.Protocol) throws -> HPrx? {
        return try read() as HPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: HPrx.Protocol) throws -> HPrx? {
        return try read(tag: tag) as HPrxI?
    }
}

public extension HPrx {
    func callH(context: Ice.Context? = nil) async throws -> Swift.String {
        return try await _impl._invoke(operation: "callH",
                                       mode: .Normal,
                                       read: { istr in
                                           let iceP_returnValue: Swift.String = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }
}

public protocol EchoPrx: Ice.ObjectPrx {}

private final class EchoPrxI: Ice.ObjectPrxI, EchoPrx {
    public override class func ice_staticId() -> Swift.String {
        return EchoTraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: EchoPrx.Protocol) throws -> EchoPrx {
    try communicator.makeProxyImpl(proxyString) as EchoPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: EchoPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> EchoPrx? {
    return try await EchoPrxI.checkedCast(prx: prx, facet: facet, context: context) as EchoPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: EchoPrx.Protocol, facet: Swift.String? = nil) -> EchoPrx {
    return EchoPrxI.uncheckedCast(prx: prx, facet: facet) as EchoPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: EchoPrx.Protocol) -> Swift.String {
    return EchoTraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `EchoPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: EchoPrx.Protocol) throws -> EchoPrx? {
        return try read() as EchoPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: EchoPrx.Protocol) throws -> EchoPrx? {
        return try read(tag: tag) as EchoPrxI?
    }
}

public extension EchoPrx {
    func setConnection(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "setConnection",
                                       mode: .Normal,
                                       context: context)
    }

    func startBatch(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "startBatch",
                                       mode: .Normal,
                                       context: context)
    }

    func flushBatch(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "flushBatch",
                                       mode: .Normal,
                                       context: context)
    }

    func shutdown(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "shutdown",
                                       mode: .Normal,
                                       context: context)
    }
}


/// Dispatcher for `Empty` servants.
public struct EmptyDisp: Ice.Dispatcher {
    public let servant: Empty
    private static let defaultObject = Ice.ObjectI<EmptyTraits>()

    public init(_ servant: Empty) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "ice_id":
            try await (servant as? Ice.Object ?? EmptyDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? EmptyDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? EmptyDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? EmptyDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol Empty {}


/// Dispatcher for `A` servants.
public struct ADisp: Ice.Dispatcher {
    public let servant: A
    private static let defaultObject = Ice.ObjectI<ATraits>()

    public init(_ servant: A) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "callA":
            try await servant._iceD_callA(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? ADisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? ADisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? ADisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? ADisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol A {
    func callA(current: Ice.Current) async throws -> Swift.String
}


/// Dispatcher for `B` servants.
public struct BDisp: Ice.Dispatcher {
    public let servant: B
    private static let defaultObject = Ice.ObjectI<BTraits>()

    public init(_ servant: B) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "callA":
            try await servant._iceD_callA(request)
        case "callB":
            try await servant._iceD_callB(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? BDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? BDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? BDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? BDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol B: A {
    func callB(current: Ice.Current) async throws -> Swift.String
}


/// Dispatcher for `C` servants.
public struct CDisp: Ice.Dispatcher {
    public let servant: C
    private static let defaultObject = Ice.ObjectI<CTraits>()

    public init(_ servant: C) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "callA":
            try await servant._iceD_callA(request)
        case "callC":
            try await servant._iceD_callC(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? CDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? CDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? CDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? CDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol C: A {
    func callC(current: Ice.Current) async throws -> Swift.String
}


/// Dispatcher for `D` servants.
public struct DDisp: Ice.Dispatcher {
    public let servant: D
    private static let defaultObject = Ice.ObjectI<DTraits>()

    public init(_ servant: D) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "callA":
            try await servant._iceD_callA(request)
        case "callB":
            try await servant._iceD_callB(request)
        case "callC":
            try await servant._iceD_callC(request)
        case "callD":
            try await servant._iceD_callD(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? DDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? DDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? DDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? DDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol D: B, C {
    func callD(current: Ice.Current) async throws -> Swift.String
}


/// Dispatcher for `E` servants.
public struct EDisp: Ice.Dispatcher {
    public let servant: E
    private static let defaultObject = Ice.ObjectI<ETraits>()

    public init(_ servant: E) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "callE":
            try await servant._iceD_callE(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? EDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? EDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? EDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? EDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol E {
    func callE(current: Ice.Current) async throws -> Swift.String
}


/// Dispatcher for `F` servants.
public struct FDisp: Ice.Dispatcher {
    public let servant: F
    private static let defaultObject = Ice.ObjectI<FTraits>()

    public init(_ servant: F) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "callE":
            try await servant._iceD_callE(request)
        case "callF":
            try await servant._iceD_callF(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? FDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? FDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? FDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? FDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol F: E {
    func callF(current: Ice.Current) async throws -> Swift.String
}


/// Dispatcher for `G` servants.
public struct GDisp: Ice.Dispatcher {
    public let servant: G
    private static let defaultObject = Ice.ObjectI<GTraits>()

    public init(_ servant: G) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "callG":
            try await servant._iceD_callG(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? GDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? GDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? GDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? GDisp.defaultObject)._iceD_ice_ping(request)
        case "shutdown":
            try await servant._iceD_shutdown(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol G {
    func shutdown(current: Ice.Current) async throws

    func callG(current: Ice.Current) async throws -> Swift.String
}


/// Dispatcher for `H` servants.
public struct HDisp: Ice.Dispatcher {
    public let servant: H
    private static let defaultObject = Ice.ObjectI<HTraits>()

    public init(_ servant: H) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "callG":
            try await servant._iceD_callG(request)
        case "callH":
            try await servant._iceD_callH(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? HDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? HDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? HDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? HDisp.defaultObject)._iceD_ice_ping(request)
        case "shutdown":
            try await servant._iceD_shutdown(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol H: G {
    func callH(current: Ice.Current) async throws -> Swift.String
}


/// Dispatcher for `Echo` servants.
public struct EchoDisp: Ice.Dispatcher {
    public let servant: Echo
    private static let defaultObject = Ice.ObjectI<EchoTraits>()

    public init(_ servant: Echo) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "flushBatch":
            try await servant._iceD_flushBatch(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? EchoDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? EchoDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? EchoDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? EchoDisp.defaultObject)._iceD_ice_ping(request)
        case "setConnection":
            try await servant._iceD_setConnection(request)
        case "shutdown":
            try await servant._iceD_shutdown(request)
        case "startBatch":
            try await servant._iceD_startBatch(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol Echo {
    func setConnection(current: Ice.Current) async throws

    func startBatch(current: Ice.Current) async throws

    func flushBatch(current: Ice.Current) async throws

    func shutdown(current: Ice.Current) async throws
}

extension Empty {}

extension A {
    public func _iceD_callA(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.callA(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }
}

extension B {
    public func _iceD_callB(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.callB(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }
}

extension C {
    public func _iceD_callC(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.callC(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }
}

extension D {
    public func _iceD_callD(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.callD(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }
}

extension E {
    public func _iceD_callE(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.callE(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }
}

extension F {
    public func _iceD_callF(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.callF(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }
}

extension G {
    public func _iceD_shutdown(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.shutdown(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_callG(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.callG(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }
}

extension H {
    public func _iceD_callH(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        let result = try await self.callH(current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }
}

extension Echo {
    public func _iceD_setConnection(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.setConnection(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_startBatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.startBatch(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_flushBatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.flushBatch(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }

    public func _iceD_shutdown(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.shutdown(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}
