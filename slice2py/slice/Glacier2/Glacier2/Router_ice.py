# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.8.0-alpha.0
#
# <auto-generated>
#
# Generated from file `Router.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

import Ice, IcePy
import Ice.Router_ice
import Glacier2.Session_ice
import Glacier2.PermissionsVerifier_ice

# Included module Ice
_M_Ice = Ice.openModule('Ice')

# Included module Glacier2
_M_Glacier2 = Ice.openModule('Glacier2')

# Start of module Glacier2
__name__ = 'Glacier2'
_M_Glacier2.__doc__ = """
 Glacier2 is a firewall solution for Ice. Glacier2 authenticates and filters client requests and allows callbacks to
 the client in a secure fashion. In combination with IceSSL, Glacier2 provides a security solution that is both
 non-intrusive and easy to configure.
"""

if 'SessionNotExistException' not in _M_Glacier2.__dict__:
    _M_Glacier2.SessionNotExistException = Ice.createTempClass()
    class SessionNotExistException(Ice.UserException):
        """
         This exception is raised if a client tries to destroy a session with a router, but no session exists for the
         client.
        """
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Glacier2::SessionNotExistException'

    _M_Glacier2._t_SessionNotExistException = IcePy.defineException('::Glacier2::SessionNotExistException', SessionNotExistException, (), None, ())
    SessionNotExistException._ice_type = _M_Glacier2._t_SessionNotExistException

    _M_Glacier2.SessionNotExistException = SessionNotExistException
    del SessionNotExistException

_M_Glacier2._t_Router = IcePy.defineValue('::Glacier2::Router', Ice.Value, -1, (), True, None, ())

if 'RouterPrx' not in _M_Glacier2.__dict__:
    _M_Glacier2.RouterPrx = Ice.createTempClass()
    class RouterPrx(_M_Ice.RouterPrx):

        """
         This category must be used in the identities of all of the client's callback objects. This is necessary in
         order for the router to forward callback requests to the intended client. If the Glacier2 server endpoints
         are not set, the returned category is an empty string.
        Arguments:
        context -- The request context for the invocation.
        Returns: The category.
        """
        def getCategoryForClient(self, context=None):
            return _M_Glacier2.Router._op_getCategoryForClient.invoke(self, ((), context))

        """
         This category must be used in the identities of all of the client's callback objects. This is necessary in
         order for the router to forward callback requests to the intended client. If the Glacier2 server endpoints
         are not set, the returned category is an empty string.
        Arguments:
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getCategoryForClientAsync(self, context=None):
            return _M_Glacier2.Router._op_getCategoryForClient.invokeAsync(self, ((), context))

        """
         Create a per-client session with the router. If a SessionManager has been installed, a proxy to a
         Session object is returned to the client. Otherwise, null is returned and only an internal session
         (i.e., not visible to the client) is created.
         If a session proxy is returned, it must be configured to route through the router that created it. This will
         happen automatically if the router is configured as the client's default router at the time the session
         proxy is created in the client process, otherwise the client must configure the session proxy explicitly.
        Arguments:
        userId -- The user id for which to check the password.
        password -- The password for the given user id.
        context -- The request context for the invocation.
        Returns: A proxy for the newly created session, or null if no SessionManager has been installed.
        Throws:
        CannotCreateSessionException -- Raised if the session cannot be created.
        PermissionDeniedException -- Raised if the password for the given user id is not correct, or if the user is not allowed access.
        """
        def createSession(self, userId, password, context=None):
            return _M_Glacier2.Router._op_createSession.invoke(self, ((userId, password), context))

        """
         Create a per-client session with the router. If a SessionManager has been installed, a proxy to a
         Session object is returned to the client. Otherwise, null is returned and only an internal session
         (i.e., not visible to the client) is created.
         If a session proxy is returned, it must be configured to route through the router that created it. This will
         happen automatically if the router is configured as the client's default router at the time the session
         proxy is created in the client process, otherwise the client must configure the session proxy explicitly.
        Arguments:
        userId -- The user id for which to check the password.
        password -- The password for the given user id.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def createSessionAsync(self, userId, password, context=None):
            return _M_Glacier2.Router._op_createSession.invokeAsync(self, ((userId, password), context))

        """
         Create a per-client session with the router. The user is authenticated through the SSL certificates that
         have been associated with the connection. If a SessionManager has been installed, a proxy to a
         Session object is returned to the client. Otherwise, null is returned and only an internal session
         (i.e., not visible to the client) is created.
         If a session proxy is returned, it must be configured to route through the router that created it. This will
         happen automatically if the router is configured as the client's default router at the time the session
         proxy is created in the client process, otherwise the client must configure the session proxy explicitly.
        Arguments:
        context -- The request context for the invocation.
        Returns: A proxy for the newly created session, or null if no SessionManager has been installed.
        Throws:
        CannotCreateSessionException -- Raised if the session cannot be created.
        PermissionDeniedException -- Raised if the user cannot be authenticated or if the user is not allowed access.
        """
        def createSessionFromSecureConnection(self, context=None):
            return _M_Glacier2.Router._op_createSessionFromSecureConnection.invoke(self, ((), context))

        """
         Create a per-client session with the router. The user is authenticated through the SSL certificates that
         have been associated with the connection. If a SessionManager has been installed, a proxy to a
         Session object is returned to the client. Otherwise, null is returned and only an internal session
         (i.e., not visible to the client) is created.
         If a session proxy is returned, it must be configured to route through the router that created it. This will
         happen automatically if the router is configured as the client's default router at the time the session
         proxy is created in the client process, otherwise the client must configure the session proxy explicitly.
        Arguments:
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def createSessionFromSecureConnectionAsync(self, context=None):
            return _M_Glacier2.Router._op_createSessionFromSecureConnection.invokeAsync(self, ((), context))

        """
         Keep the calling client's session with this router alive.
        Arguments:
        context -- The request context for the invocation.
        Throws:
        SessionNotExistException -- Raised if no session exists for the calling client.
        """
        def refreshSession(self, context=None):
            return _M_Glacier2.Router._op_refreshSession.invoke(self, ((), context))

        """
         Keep the calling client's session with this router alive.
        Arguments:
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def refreshSessionAsync(self, context=None):
            return _M_Glacier2.Router._op_refreshSession.invokeAsync(self, ((), context))

        """
         Destroy the calling client's session with this router.
        Arguments:
        context -- The request context for the invocation.
        Throws:
        SessionNotExistException -- Raised if no session exists for the calling client.
        """
        def destroySession(self, context=None):
            return _M_Glacier2.Router._op_destroySession.invoke(self, ((), context))

        """
         Destroy the calling client's session with this router.
        Arguments:
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def destroySessionAsync(self, context=None):
            return _M_Glacier2.Router._op_destroySession.invokeAsync(self, ((), context))

        """
         Get the value of the session timeout. Sessions are destroyed if they see no activity for this period of
         time.
        Arguments:
        context -- The request context for the invocation.
        Returns: The timeout (in seconds).
        """
        def getSessionTimeout(self, context=None):
            return _M_Glacier2.Router._op_getSessionTimeout.invoke(self, ((), context))

        """
         Get the value of the session timeout. Sessions are destroyed if they see no activity for this period of
         time.
        Arguments:
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getSessionTimeoutAsync(self, context=None):
            return _M_Glacier2.Router._op_getSessionTimeout.invokeAsync(self, ((), context))

        """
         Get the value of the ACM timeout. Clients supporting connection heartbeats can enable them instead of
         explicitly sending keep alives requests. This method is only available since Ice 3.6.
        Arguments:
        context -- The request context for the invocation.
        Returns: The timeout (in seconds).
        """
        def getACMTimeout(self, context=None):
            return _M_Glacier2.Router._op_getACMTimeout.invoke(self, ((), context))

        """
         Get the value of the ACM timeout. Clients supporting connection heartbeats can enable them instead of
         explicitly sending keep alives requests. This method is only available since Ice 3.6.
        Arguments:
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getACMTimeoutAsync(self, context=None):
            return _M_Glacier2.Router._op_getACMTimeout.invokeAsync(self, ((), context))

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Glacier2.RouterPrx.ice_checkedCast(proxy, '::Glacier2::Router', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Glacier2.RouterPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Glacier2::Router'
    _M_Glacier2._t_RouterPrx = IcePy.defineProxy('::Glacier2::Router', RouterPrx)

    _M_Glacier2.RouterPrx = RouterPrx
    del RouterPrx

    _M_Glacier2.Router = Ice.createTempClass()
    class Router(_M_Ice.Router):

        def ice_ids(self, current=None):
            return ('::Glacier2::Router', '::Ice::Object', '::Ice::Router')

        def ice_id(self, current=None):
            return '::Glacier2::Router'

        @staticmethod
        def ice_staticId():
            return '::Glacier2::Router'

        def getCategoryForClient(self, current=None):
            """
             This category must be used in the identities of all of the client's callback objects. This is necessary in
             order for the router to forward callback requests to the intended client. If the Glacier2 server endpoints
             are not set, the returned category is an empty string.
            Arguments:
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getCategoryForClient' not implemented")

        def createSession(self, userId, password, current=None):
            """
             Create a per-client session with the router. If a SessionManager has been installed, a proxy to a
             Session object is returned to the client. Otherwise, null is returned and only an internal session
             (i.e., not visible to the client) is created.
             If a session proxy is returned, it must be configured to route through the router that created it. This will
             happen automatically if the router is configured as the client's default router at the time the session
             proxy is created in the client process, otherwise the client must configure the session proxy explicitly.
            Arguments:
            userId -- The user id for which to check the password.
            password -- The password for the given user id.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            Throws:
            CannotCreateSessionException -- Raised if the session cannot be created.
            PermissionDeniedException -- Raised if the password for the given user id is not correct, or if the user is not allowed access.
            """
            raise NotImplementedError("servant method 'createSession' not implemented")

        def createSessionFromSecureConnection(self, current=None):
            """
             Create a per-client session with the router. The user is authenticated through the SSL certificates that
             have been associated with the connection. If a SessionManager has been installed, a proxy to a
             Session object is returned to the client. Otherwise, null is returned and only an internal session
             (i.e., not visible to the client) is created.
             If a session proxy is returned, it must be configured to route through the router that created it. This will
             happen automatically if the router is configured as the client's default router at the time the session
             proxy is created in the client process, otherwise the client must configure the session proxy explicitly.
            Arguments:
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            Throws:
            CannotCreateSessionException -- Raised if the session cannot be created.
            PermissionDeniedException -- Raised if the user cannot be authenticated or if the user is not allowed access.
            """
            raise NotImplementedError("servant method 'createSessionFromSecureConnection' not implemented")

        def refreshSession(self, current=None):
            """
             Keep the calling client's session with this router alive.
            Arguments:
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            Throws:
            SessionNotExistException -- Raised if no session exists for the calling client.
            """
            raise NotImplementedError("servant method 'refreshSession' not implemented")

        def destroySession(self, current=None):
            """
             Destroy the calling client's session with this router.
            Arguments:
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            Throws:
            SessionNotExistException -- Raised if no session exists for the calling client.
            """
            raise NotImplementedError("servant method 'destroySession' not implemented")

        def getSessionTimeout(self, current=None):
            """
             Get the value of the session timeout. Sessions are destroyed if they see no activity for this period of
             time.
            Arguments:
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getSessionTimeout' not implemented")

        def getACMTimeout(self, current=None):
            """
             Get the value of the ACM timeout. Clients supporting connection heartbeats can enable them instead of
             explicitly sending keep alives requests. This method is only available since Ice 3.6.
            Arguments:
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getACMTimeout' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Glacier2._t_RouterDisp)

        __repr__ = __str__

    _M_Glacier2._t_RouterDisp = IcePy.defineClass('::Glacier2::Router', Router, (), None, (_M_Ice._t_RouterDisp,))
    Router._ice_type = _M_Glacier2._t_RouterDisp

    Router._op_getCategoryForClient = IcePy.Operation('getCategoryForClient', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), ((), IcePy._t_string, False, 0), ())
    Router._op_createSession = IcePy.Operation('createSession', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, Ice.FormatType.SlicedFormat, (), (((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0)), (), ((), _M_Glacier2._t_SessionPrx, False, 0), (_M_Glacier2._t_PermissionDeniedException, _M_Glacier2._t_CannotCreateSessionException))
    Router._op_createSessionFromSecureConnection = IcePy.Operation('createSessionFromSecureConnection', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, Ice.FormatType.SlicedFormat, (), (), (), ((), _M_Glacier2._t_SessionPrx, False, 0), (_M_Glacier2._t_PermissionDeniedException, _M_Glacier2._t_CannotCreateSessionException))
    Router._op_refreshSession = IcePy.Operation('refreshSession', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (), (), None, (_M_Glacier2._t_SessionNotExistException,))
    Router._op_destroySession = IcePy.Operation('destroySession', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, (_M_Glacier2._t_SessionNotExistException,))
    Router._op_getSessionTimeout = IcePy.Operation('getSessionTimeout', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), ((), IcePy._t_long, False, 0), ())
    Router._op_getACMTimeout = IcePy.Operation('getACMTimeout', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), ((), IcePy._t_int, False, 0), ())

    _M_Glacier2.Router = Router
    del Router

# End of module Glacier2
