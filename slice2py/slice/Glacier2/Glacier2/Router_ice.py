# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.8.0-alpha.0
#
# <auto-generated>
#
# Generated from file `Router.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

import Ice
import IcePy
import builtins as _builtins
import Ice.Router_ice
import Glacier2.Session_ice
import Glacier2.PermissionsVerifier_ice

# Included module Ice
_M_Ice = Ice.openModule('Ice')

# Included module Glacier2
_M_Glacier2 = Ice.openModule('Glacier2')

# Start of module Glacier2
__name__ = 'Glacier2'
_M_Glacier2.__doc__ = """
Glacier2 is a firewall solution for Ice. Glacier2 authenticates and filters client requests and allows callbacks to
the client in a secure fashion. In combination with IceSSL, Glacier2 provides a security solution that is both
non-intrusive and easy to configure.
"""

if 'SessionNotExistException' not in _M_Glacier2.__dict__:
    _M_Glacier2.SessionNotExistException = None
    class SessionNotExistException(Ice.UserException):
        """
        This exception is raised if a client tries to destroy a session with a router, but no session exists for the
        client.
        """
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Glacier2::SessionNotExistException'

    _M_Glacier2._t_SessionNotExistException = IcePy.defineException('::Glacier2::SessionNotExistException', SessionNotExistException, (), None, ())
    SessionNotExistException._ice_type = _M_Glacier2._t_SessionNotExistException

    _M_Glacier2.SessionNotExistException = SessionNotExistException
    del SessionNotExistException

if 'RouterPrx' not in _M_Glacier2.__dict__:
    _M_Glacier2.RouterPrx = None
    class RouterPrx(_M_Ice.RouterPrx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new RouterPrx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        def getCategoryForClient(self, context=None):
            """
            This category must be used in the identities of all of the client's callback objects. This is necessary in
            order for the router to forward callback requests to the intended client. If the Glacier2 server endpoints
            are not set, the returned category is an empty string.
            
            Parameters
            ----------
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            str
                The category.
            """
            return _M_Glacier2.Router._op_getCategoryForClient.invoke(self, ((), context))

        def getCategoryForClientAsync(self, context=None):
            """
            This category must be used in the identities of all of the client's callback objects. This is necessary in
            order for the router to forward callback requests to the intended client. If the Glacier2 server endpoints
            are not set, the returned category is an empty string.
            
            Parameters
            ----------
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_Glacier2.Router._op_getCategoryForClient.invokeAsync(self, ((), context))

        def createSession(self, userId, password, context=None):
            """
            Create a per-client session with the router. If a SessionManager has been installed, a proxy to a
            Session object is returned to the client. Otherwise, null is returned and only an internal session
            (i.e., not visible to the client) is created.
            If a session proxy is returned, it must be configured to route through the router that created it. This will
            happen automatically if the router is configured as the client's default router at the time the session
            proxy is created in the client process, otherwise the client must configure the session proxy explicitly.
            
            Parameters
            ----------
            userId : str
                The user id for which to check the password.
            password : str
                The password for the given user id.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            (Glacier2.SessionPrx or None)
                A proxy for the newly created session, or null if no SessionManager has been installed.
            
            Raises
            ------
            CannotCreateSessionException
                Raised if the session cannot be created.
            PermissionDeniedException
                Raised if the password for the given user id is not correct, or if the
                user is not allowed access.
            """
            return _M_Glacier2.Router._op_createSession.invoke(self, ((userId, password), context))

        def createSessionAsync(self, userId, password, context=None):
            """
            Create a per-client session with the router. If a SessionManager has been installed, a proxy to a
            Session object is returned to the client. Otherwise, null is returned and only an internal session
            (i.e., not visible to the client) is created.
            If a session proxy is returned, it must be configured to route through the router that created it. This will
            happen automatically if the router is configured as the client's default router at the time the session
            proxy is created in the client process, otherwise the client must configure the session proxy explicitly.
            
            Parameters
            ----------
            userId : str
                The user id for which to check the password.
            password : str
                The password for the given user id.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_Glacier2.Router._op_createSession.invokeAsync(self, ((userId, password), context))

        def createSessionFromSecureConnection(self, context=None):
            """
            Create a per-client session with the router. The user is authenticated through the SSL certificates that
            have been associated with the connection. If a SessionManager has been installed, a proxy to a
            Session object is returned to the client. Otherwise, null is returned and only an internal session
            (i.e., not visible to the client) is created.
            If a session proxy is returned, it must be configured to route through the router that created it. This will
            happen automatically if the router is configured as the client's default router at the time the session
            proxy is created in the client process, otherwise the client must configure the session proxy explicitly.
            
            Parameters
            ----------
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            (Glacier2.SessionPrx or None)
                A proxy for the newly created session, or null if no SessionManager has been installed.
            
            Raises
            ------
            CannotCreateSessionException
                Raised if the session cannot be created.
            PermissionDeniedException
                Raised if the user cannot be authenticated or if the user is not allowed
                access.
            """
            return _M_Glacier2.Router._op_createSessionFromSecureConnection.invoke(self, ((), context))

        def createSessionFromSecureConnectionAsync(self, context=None):
            """
            Create a per-client session with the router. The user is authenticated through the SSL certificates that
            have been associated with the connection. If a SessionManager has been installed, a proxy to a
            Session object is returned to the client. Otherwise, null is returned and only an internal session
            (i.e., not visible to the client) is created.
            If a session proxy is returned, it must be configured to route through the router that created it. This will
            happen automatically if the router is configured as the client's default router at the time the session
            proxy is created in the client process, otherwise the client must configure the session proxy explicitly.
            
            Parameters
            ----------
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_Glacier2.Router._op_createSessionFromSecureConnection.invokeAsync(self, ((), context))

        def refreshSession(self, context=None):
            """
            Keep the session with this router alive. This operation is provided for backward compatibility with Ice 3.7
            and earlier and does nothing in newer versions of Glacier2.
            
            Parameters
            ----------
            context : Ice.Context
                The request context for the invocation.
            
            Raises
            ------
            SessionNotExistException
                Raised if no session exists for the caller (client).
            """
            return _M_Glacier2.Router._op_refreshSession.invoke(self, ((), context))

        def refreshSessionAsync(self, context=None):
            """
            Keep the session with this router alive. This operation is provided for backward compatibility with Ice 3.7
            and earlier and does nothing in newer versions of Glacier2.
            
            Parameters
            ----------
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_Glacier2.Router._op_refreshSession.invokeAsync(self, ((), context))

        def destroySession(self, context=None):
            """
            Destroy the calling client's session with this router.
            
            Parameters
            ----------
            context : Ice.Context
                The request context for the invocation.
            
            Raises
            ------
            SessionNotExistException
                Raised if no session exists for the calling client.
            """
            return _M_Glacier2.Router._op_destroySession.invoke(self, ((), context))

        def destroySessionAsync(self, context=None):
            """
            Destroy the calling client's session with this router.
            
            Parameters
            ----------
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_Glacier2.Router._op_destroySession.invokeAsync(self, ((), context))

        def getSessionTimeout(self, context=None):
            """
            Get the idle timeout used by the server-side of the connection.
            
            Parameters
            ----------
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            int
                The idle timeout (in seconds).
            """
            return _M_Glacier2.Router._op_getSessionTimeout.invoke(self, ((), context))

        def getSessionTimeoutAsync(self, context=None):
            """
            Get the idle timeout used by the server-side of the connection.
            
            Parameters
            ----------
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_Glacier2.Router._op_getSessionTimeout.invokeAsync(self, ((), context))

        def getACMTimeout(self, context=None):
            """
            Get the idle timeout used by the server-side of the connection.
            
            Parameters
            ----------
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            int
                The idle timeout (in seconds).
            """
            return _M_Glacier2.Router._op_getACMTimeout.invoke(self, ((), context))

        def getACMTimeoutAsync(self, context=None):
            """
            Get the idle timeout used by the server-side of the connection.
            
            Parameters
            ----------
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_Glacier2.Router._op_getACMTimeout.invokeAsync(self, ((), context))

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Glacier2.RouterPrx.ice_checkedCast(proxy, '::Glacier2::Router', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Glacier2.RouterPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Glacier2::Router'
    _M_Glacier2._t_RouterPrx = IcePy.defineProxy('::Glacier2::Router', RouterPrx)

    _M_Glacier2.RouterPrx = RouterPrx
    del RouterPrx

    _M_Glacier2.Router = None
    class Router(_M_Ice.Router):

        def ice_ids(self, current=None):
            return ('::Glacier2::Router', '::Ice::Object', '::Ice::Router')

        def ice_id(self, current=None):
            return '::Glacier2::Router'

        @staticmethod
        def ice_staticId():
            return '::Glacier2::Router'

        def getCategoryForClient(self, current=None):
            """
            This category must be used in the identities of all of the client's callback objects. This is necessary in
            order for the router to forward callback requests to the intended client. If the Glacier2 server endpoints
            are not set, the returned category is an empty string.
            
            Parameters
            ----------
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 'getCategoryForClient' not implemented")

        def createSession(self, userId, password, current=None):
            """
            Create a per-client session with the router. If a SessionManager has been installed, a proxy to a
            Session object is returned to the client. Otherwise, null is returned and only an internal session
            (i.e., not visible to the client) is created.
            If a session proxy is returned, it must be configured to route through the router that created it. This will
            happen automatically if the router is configured as the client's default router at the time the session
            proxy is created in the client process, otherwise the client must configure the session proxy explicitly.
            
            Parameters
            ----------
            userId : str
                The user id for which to check the password.
            password : str
                The password for the given user id.
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            
            Raises
            ------
            CannotCreateSessionException
                Raised if the session cannot be created.
            PermissionDeniedException
                Raised if the password for the given user id is not correct, or if the
                user is not allowed access.
            """
            raise NotImplementedError("servant method 'createSession' not implemented")

        def createSessionFromSecureConnection(self, current=None):
            """
            Create a per-client session with the router. The user is authenticated through the SSL certificates that
            have been associated with the connection. If a SessionManager has been installed, a proxy to a
            Session object is returned to the client. Otherwise, null is returned and only an internal session
            (i.e., not visible to the client) is created.
            If a session proxy is returned, it must be configured to route through the router that created it. This will
            happen automatically if the router is configured as the client's default router at the time the session
            proxy is created in the client process, otherwise the client must configure the session proxy explicitly.
            
            Parameters
            ----------
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            
            Raises
            ------
            CannotCreateSessionException
                Raised if the session cannot be created.
            PermissionDeniedException
                Raised if the user cannot be authenticated or if the user is not allowed
                access.
            """
            raise NotImplementedError("servant method 'createSessionFromSecureConnection' not implemented")

        def refreshSession(self, current=None):
            """
            Keep the session with this router alive. This operation is provided for backward compatibility with Ice 3.7
            and earlier and does nothing in newer versions of Glacier2.
            
            Parameters
            ----------
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            
            Raises
            ------
            SessionNotExistException
                Raised if no session exists for the caller (client).
            """
            raise NotImplementedError("servant method 'refreshSession' not implemented")

        def destroySession(self, current=None):
            """
            Destroy the calling client's session with this router.
            
            Parameters
            ----------
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            
            Raises
            ------
            SessionNotExistException
                Raised if no session exists for the calling client.
            """
            raise NotImplementedError("servant method 'destroySession' not implemented")

        def getSessionTimeout(self, current=None):
            """
            Get the idle timeout used by the server-side of the connection.
            
            Parameters
            ----------
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 'getSessionTimeout' not implemented")

        def getACMTimeout(self, current=None):
            """
            Get the idle timeout used by the server-side of the connection.
            
            Parameters
            ----------
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 'getACMTimeout' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Glacier2._t_RouterDisp)

        __repr__ = __str__

    Router._op_getCategoryForClient = IcePy.Operation('getCategoryForClient', Ice.OperationMode.Idempotent, False, None, (), (), (), ((), IcePy._t_string, False, 0), ())
    Router._op_createSession = IcePy.Operation('createSession', Ice.OperationMode.Normal, True, None, (), (((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0)), (), ((), _M_Glacier2._t_SessionPrx, False, 0), (_M_Glacier2._t_PermissionDeniedException, _M_Glacier2._t_CannotCreateSessionException))
    Router._op_createSessionFromSecureConnection = IcePy.Operation('createSessionFromSecureConnection', Ice.OperationMode.Normal, True, None, (), (), (), ((), _M_Glacier2._t_SessionPrx, False, 0), (_M_Glacier2._t_PermissionDeniedException, _M_Glacier2._t_CannotCreateSessionException))
    Router._op_refreshSession = IcePy.Operation('refreshSession', Ice.OperationMode.Normal, False, None, (), (), (), None, (_M_Glacier2._t_SessionNotExistException,))
    Router._op_destroySession = IcePy.Operation('destroySession', Ice.OperationMode.Normal, False, None, (), (), (), None, (_M_Glacier2._t_SessionNotExistException,))
    Router._op_getSessionTimeout = IcePy.Operation('getSessionTimeout', Ice.OperationMode.Idempotent, False, None, (), (), (), ((), IcePy._t_long, False, 0), ())
    Router._op_getACMTimeout = IcePy.Operation('getACMTimeout', Ice.OperationMode.Idempotent, False, None, (), (), (), ((), IcePy._t_int, False, 0), ())

    _M_Glacier2.Router = Router
    del Router

# End of module Glacier2
