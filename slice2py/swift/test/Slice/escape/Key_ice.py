# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.8.0-alpha.0
#
# <auto-generated>
#
# Generated from file `Key.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

import Ice
import IcePy
import builtins as _builtins

# Start of module _and
_M__and = Ice.openModule('_and')
__name__ = '_and'

if '_continue' not in _M__and.__dict__:
    _M__and._continue = None
    class _continue(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    _continue.let = _continue("let", 0)
    _continue.var = _continue("var", 1)
    _continue._enumerators = { 0:_continue.let, 1:_continue.var }

    _M__and._t__continue = IcePy.defineEnum('::and::continue', _continue, (), _continue._enumerators)

    _M__and._continue = _continue
    del _continue

if 'guard' not in _M__and.__dict__:
    _M__and.guard = None
    class guard(object):
        def __init__(self, default=0):
            self.default = default

        def __hash__(self):
            _h = 0
            _h = 5 * _h + _builtins.hash(self.default)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M__and.guard):
                return NotImplemented
            else:
                if self.default is None or other.default is None:
                    if self.default != other.default:
                        return (-1 if self.default is None else 1)
                else:
                    if self.default < other.default:
                        return -1
                    elif self.default > other.default:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M__and._t_guard)

        __repr__ = __str__

    _M__and._t_guard = IcePy.defineStruct('::and::guard', guard, (), (('default', (), IcePy._t_int),))

    _M__and.guard = guard
    del guard

if 'defer' not in _M__and.__dict__:
    _M__and.defer = None
    class defer(object):
        def __init__(self, _else=''):
            self._else = _else

        def __hash__(self):
            _h = 0
            _h = 5 * _h + _builtins.hash(self._else)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M__and.defer):
                return NotImplemented
            else:
                if self._else is None or other._else is None:
                    if self._else != other._else:
                        return (-1 if self._else is None else 1)
                else:
                    if self._else < other._else:
                        return -1
                    elif self._else > other._else:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M__and._t_defer)

        __repr__ = __str__

    _M__and._t_defer = IcePy.defineStruct('::and::defer', defer, (), (('_else', (), IcePy._t_string),))

    _M__and.defer = defer
    del defer

if 'breakPrx' not in _M__and.__dict__:
    _M__and.breakPrx = None
    class breakPrx(Ice.ObjectPrx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new breakPrx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        def _case(self, catch, context=None):
            return _M__and._break._op_case.invoke(self, ((catch, ), context))

        def caseAsync(self, catch, context=None):
            return _M__and._break._op_case.invokeAsync(self, ((catch, ), context))

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M__and.breakPrx.ice_checkedCast(proxy, '::and::break', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M__and.breakPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::and::break'
    _M__and._t_breakPrx = IcePy.defineProxy('::and::break', breakPrx)

    _M__and.breakPrx = breakPrx
    del breakPrx

    _M__and._break = None
    class _break(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::and::break')

        def ice_id(self, current=None):
            return '::and::break'

        @staticmethod
        def ice_staticId():
            return '::and::break'

        def _case(self, catch, current=None):
            raise NotImplementedError("servant method '_case' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M__and._t_breakDisp)

        __repr__ = __str__

    _break._op_case = IcePy.Operation('case', Ice.OperationMode.Normal, True, None, (), (((), IcePy._t_int, False, 0),), (((), IcePy._t_int, False, 0),), None, ())

    _M__and._break = _break
    del _break

if 'funcPrx' not in _M__and.__dict__:
    _M__and.funcPrx = None
    class funcPrx(Ice.ObjectPrx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new funcPrx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        def public(self, context=None):
            return _M__and.func._op_public.invoke(self, ((), context))

        def publicAsync(self, context=None):
            return _M__and.func._op_public.invokeAsync(self, ((), context))

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M__and.funcPrx.ice_checkedCast(proxy, '::and::func', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M__and.funcPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::and::func'
    _M__and._t_funcPrx = IcePy.defineProxy('::and::func', funcPrx)

    _M__and.funcPrx = funcPrx
    del funcPrx

    _M__and.func = None
    class func(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::and::func')

        def ice_id(self, current=None):
            return '::and::func'

        @staticmethod
        def ice_staticId():
            return '::and::func'

        def public(self, current=None):
            raise NotImplementedError("servant method 'public' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M__and._t_funcDisp)

        __repr__ = __str__

    func._op_public = IcePy.Operation('public', Ice.OperationMode.Normal, False, None, (), (), (), None, ())

    _M__and.func = func
    del func

if 'switch' not in _M__and.__dict__:
    _M__and.switch = None
    class switch(Ice.Value):
        def __init__(self, _if=0, export=None, volatile=0):
            self._if = _if
            self.export = export
            self.volatile = volatile

        def ice_id(self):
            return '::and::switch'

        @staticmethod
        def ice_staticId():
            return '::and::switch'

        def __str__(self):
            return IcePy.stringify(self, _M__and._t_switch)

        __repr__ = __str__

    _M__and._t_switch = IcePy.defineValue('::and::switch', switch, -1, (), False, None, (
        ('_if', (), IcePy._t_int, False, 0),
        ('export', (), _M__and._t_funcPrx, False, 0),
        ('volatile', (), IcePy._t_int, False, 0)
    ))
    switch._ice_type = _M__and._t_switch

    _M__and.switch = switch
    del switch

if 'doPrx' not in _M__and.__dict__:
    _M__and.doPrx = None
    class doPrx(_M__and.funcPrx, _M__and.breakPrx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new doPrx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M__and.doPrx.ice_checkedCast(proxy, '::and::do', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M__and.doPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::and::do'
    _M__and._t_doPrx = IcePy.defineProxy('::and::do', doPrx)

    _M__and.doPrx = doPrx
    del doPrx

    _M__and.do = None
    class do(_M__and.func, _M__and._break):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::and::break', '::and::do', '::and::func')

        def ice_id(self, current=None):
            return '::and::do'

        @staticmethod
        def ice_staticId():
            return '::and::do'

        def __str__(self):
            return IcePy.stringify(self, _M__and._t_doDisp)

        __repr__ = __str__

    _M__and.do = do
    del do

if '_t_fileprivate' not in _M__and.__dict__:
    _M__and._t_fileprivate = IcePy.defineSequence('::and::fileprivate', (), _M__and._t_guard)

if '_t__for' not in _M__and.__dict__:
    _M__and._t__for = IcePy.defineDictionary('::and::for', (), IcePy._t_string, _M__and._t_guard)

if '_return' not in _M__and.__dict__:
    _M__and._return = None
    class _return(Ice.UserException):
        def __init__(self, Int32=0):
            self.Int32 = Int32

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::and::return'

    _M__and._t__return = IcePy.defineException('::and::return', _return, (), None, (('Int32', (), IcePy._t_int, False, 0),))
    _return._ice_type = _M__and._t__return

    _M__and._return = _return
    del _return

if '_as' not in _M__and.__dict__:
    _M__and._as = None
    class _as(_M__and._return):
        def __init__(self, Int32=0, static=0, switch=0):
            _M__and._return.__init__(self, Int32)
            self.static = static
            self.switch = switch

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::and::as'

    _M__and._t__as = IcePy.defineException('::and::as', _as, (), _M__and._t__return, (
        ('static', (), IcePy._t_int, False, 0),
        ('switch', (), IcePy._t_int, False, 0)
    ))
    _as._ice_type = _M__and._t__as

    _M__and._as = _as
    del _as

if 'friendPrx' not in _M__and.__dict__:
    _M__and.friendPrx = None
    class friendPrx(Ice.ObjectPrx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new friendPrx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        def goto(self, _if, d, inline, private, mutable, namespace, new, _not, operator, _or, protected, public, register, context=None):
            return _M__and.friend._op_goto.invoke(self, ((_if, d, inline, private, mutable, namespace, new, _not, operator, _or, protected, public, register), context))

        def gotoAsync(self, _if, d, inline, private, mutable, namespace, new, _not, operator, _or, protected, public, register, context=None):
            return _M__and.friend._op_goto.invokeAsync(self, ((_if, d, inline, private, mutable, namespace, new, _not, operator, _or, protected, public, register), context))

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M__and.friendPrx.ice_checkedCast(proxy, '::and::friend', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M__and.friendPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::and::friend'
    _M__and._t_friendPrx = IcePy.defineProxy('::and::friend', friendPrx)

    _M__and.friendPrx = friendPrx
    del friendPrx

    _M__and.friend = None
    class friend(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::and::friend')

        def ice_id(self, current=None):
            return '::and::friend'

        @staticmethod
        def ice_staticId():
            return '::and::friend'

        def goto(self, _if, d, inline, private, mutable, namespace, new, _not, operator, _or, protected, public, register, current=None):
            raise NotImplementedError("servant method 'goto' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M__and._t_friendDisp)

        __repr__ = __str__

    friend._op_goto = IcePy.Operation('goto', Ice.OperationMode.Normal, False, None, (), (((), _M__and._t__continue, False, 0), ((), _M__and._t_guard, False, 0), ((), _M__and._t_defer, False, 0), ((), _M__and._t_switch, False, 0), ((), _M__and._t_doPrx, False, 0), ((), _M__and._t_breakPrx, False, 0), ((), _M__and._t_funcPrx, False, 0), ((), _M__and._t_switch, False, 0), ((), _M__and._t_doPrx, False, 0), ((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0)), (), ((), _M__and._t_guard, False, 0), (_M__and._t__return, _M__and._t__as))

    _M__and.friend = friend
    del friend

_M__and._is = 0

_M__and.self = 0

_M__and.throw = 0

_M__and.typealias = 0

_M__and.internal = 0

_M__and._while = 0

_M__and._import = 0

# End of module _and
