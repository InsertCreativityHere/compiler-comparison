# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.8.0-alpha.0
#
# <auto-generated>
#
# Generated from file `Test.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

import Ice
import IcePy
import builtins as _builtins

# Start of module Test
_M_Test = Ice.openModule('Test')
__name__ = 'Test'

# Start of module Test.MA
_M_Test.MA = Ice.openModule('Test.MA')
__name__ = 'Test.MA'

if 'IAPrx' not in _M_Test.MA.__dict__:
    _M_Test.MA.IAPrx = None
    class IAPrx(Ice.ObjectPrx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new IAPrx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        def iaop(self, p, context=None):
            return _M_Test.MA.IA._op_iaop.invoke(self, ((p, ), context))

        def iaopAsync(self, p, context=None):
            return _M_Test.MA.IA._op_iaop.invokeAsync(self, ((p, ), context))

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Test.MA.IAPrx.ice_checkedCast(proxy, '::Test::MA::IA', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Test.MA.IAPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Test::MA::IA'
    _M_Test.MA._t_IAPrx = IcePy.defineProxy('::Test::MA::IA', IAPrx)

    _M_Test.MA.IAPrx = IAPrx
    del IAPrx

    _M_Test.MA.IA = None
    class IA(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Test::MA::IA')

        def ice_id(self, current=None):
            return '::Test::MA::IA'

        @staticmethod
        def ice_staticId():
            return '::Test::MA::IA'

        def iaop(self, p, current=None):
            raise NotImplementedError("servant method 'iaop' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Test.MA._t_IADisp)

        __repr__ = __str__

    IA._op_iaop = IcePy.Operation('iaop', Ice.OperationMode.Normal, False, None, (), (((), _M_Test.MA._t_IAPrx, False, 0),), (), ((), _M_Test.MA._t_IAPrx, False, 0), ())

    _M_Test.MA.IA = IA
    del IA

# End of module Test.MA

__name__ = 'Test'

# Start of module Test.MB
_M_Test.MB = Ice.openModule('Test.MB')
__name__ = 'Test.MB'

if 'IB1Prx' not in _M_Test.MB.__dict__:
    _M_Test.MB.IB1Prx = None
    class IB1Prx(_M_Test.MA.IAPrx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new IB1Prx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        def ib1op(self, p, context=None):
            return _M_Test.MB.IB1._op_ib1op.invoke(self, ((p, ), context))

        def ib1opAsync(self, p, context=None):
            return _M_Test.MB.IB1._op_ib1op.invokeAsync(self, ((p, ), context))

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Test.MB.IB1Prx.ice_checkedCast(proxy, '::Test::MB::IB1', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Test.MB.IB1Prx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Test::MB::IB1'
    _M_Test.MB._t_IB1Prx = IcePy.defineProxy('::Test::MB::IB1', IB1Prx)

    _M_Test.MB.IB1Prx = IB1Prx
    del IB1Prx

    _M_Test.MB.IB1 = None
    class IB1(_M_Test.MA.IA):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Test::MA::IA', '::Test::MB::IB1')

        def ice_id(self, current=None):
            return '::Test::MB::IB1'

        @staticmethod
        def ice_staticId():
            return '::Test::MB::IB1'

        def ib1op(self, p, current=None):
            raise NotImplementedError("servant method 'ib1op' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Test.MB._t_IB1Disp)

        __repr__ = __str__

    IB1._op_ib1op = IcePy.Operation('ib1op', Ice.OperationMode.Normal, False, None, (), (((), _M_Test.MB._t_IB1Prx, False, 0),), (), ((), _M_Test.MB._t_IB1Prx, False, 0), ())

    _M_Test.MB.IB1 = IB1
    del IB1

if 'IB2Prx' not in _M_Test.MB.__dict__:
    _M_Test.MB.IB2Prx = None
    class IB2Prx(_M_Test.MA.IAPrx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new IB2Prx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        def ib2op(self, p, context=None):
            return _M_Test.MB.IB2._op_ib2op.invoke(self, ((p, ), context))

        def ib2opAsync(self, p, context=None):
            return _M_Test.MB.IB2._op_ib2op.invokeAsync(self, ((p, ), context))

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Test.MB.IB2Prx.ice_checkedCast(proxy, '::Test::MB::IB2', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Test.MB.IB2Prx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Test::MB::IB2'
    _M_Test.MB._t_IB2Prx = IcePy.defineProxy('::Test::MB::IB2', IB2Prx)

    _M_Test.MB.IB2Prx = IB2Prx
    del IB2Prx

    _M_Test.MB.IB2 = None
    class IB2(_M_Test.MA.IA):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Test::MA::IA', '::Test::MB::IB2')

        def ice_id(self, current=None):
            return '::Test::MB::IB2'

        @staticmethod
        def ice_staticId():
            return '::Test::MB::IB2'

        def ib2op(self, p, current=None):
            raise NotImplementedError("servant method 'ib2op' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Test.MB._t_IB2Disp)

        __repr__ = __str__

    IB2._op_ib2op = IcePy.Operation('ib2op', Ice.OperationMode.Normal, False, None, (), (((), _M_Test.MB._t_IB2Prx, False, 0),), (), ((), _M_Test.MB._t_IB2Prx, False, 0), ())

    _M_Test.MB.IB2 = IB2
    del IB2

# End of module Test.MB

__name__ = 'Test'

# Start of module Test.MA
__name__ = 'Test.MA'

if 'ICPrx' not in _M_Test.MA.__dict__:
    _M_Test.MA.ICPrx = None
    class ICPrx(_M_Test.MB.IB1Prx, _M_Test.MB.IB2Prx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new ICPrx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        def icop(self, p, context=None):
            return _M_Test.MA.IC._op_icop.invoke(self, ((p, ), context))

        def icopAsync(self, p, context=None):
            return _M_Test.MA.IC._op_icop.invokeAsync(self, ((p, ), context))

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Test.MA.ICPrx.ice_checkedCast(proxy, '::Test::MA::IC', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Test.MA.ICPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Test::MA::IC'
    _M_Test.MA._t_ICPrx = IcePy.defineProxy('::Test::MA::IC', ICPrx)

    _M_Test.MA.ICPrx = ICPrx
    del ICPrx

    _M_Test.MA.IC = None
    class IC(_M_Test.MB.IB1, _M_Test.MB.IB2):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Test::MA::IA', '::Test::MA::IC', '::Test::MB::IB1', '::Test::MB::IB2')

        def ice_id(self, current=None):
            return '::Test::MA::IC'

        @staticmethod
        def ice_staticId():
            return '::Test::MA::IC'

        def icop(self, p, current=None):
            raise NotImplementedError("servant method 'icop' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Test.MA._t_ICDisp)

        __repr__ = __str__

    IC._op_icop = IcePy.Operation('icop', Ice.OperationMode.Normal, False, None, (), (((), _M_Test.MA._t_ICPrx, False, 0),), (), ((), _M_Test.MA._t_ICPrx, False, 0), ())

    _M_Test.MA.IC = IC
    del IC

# End of module Test.MA

__name__ = 'Test'

if 'InitialPrx' not in _M_Test.__dict__:
    _M_Test.InitialPrx = None
    class InitialPrx(Ice.ObjectPrx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new InitialPrx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        def shutdown(self, context=None):
            return _M_Test.Initial._op_shutdown.invoke(self, ((), context))

        def shutdownAsync(self, context=None):
            return _M_Test.Initial._op_shutdown.invokeAsync(self, ((), context))

        def iaop(self, context=None):
            return _M_Test.Initial._op_iaop.invoke(self, ((), context))

        def iaopAsync(self, context=None):
            return _M_Test.Initial._op_iaop.invokeAsync(self, ((), context))

        def ib1op(self, context=None):
            return _M_Test.Initial._op_ib1op.invoke(self, ((), context))

        def ib1opAsync(self, context=None):
            return _M_Test.Initial._op_ib1op.invokeAsync(self, ((), context))

        def ib2op(self, context=None):
            return _M_Test.Initial._op_ib2op.invoke(self, ((), context))

        def ib2opAsync(self, context=None):
            return _M_Test.Initial._op_ib2op.invokeAsync(self, ((), context))

        def icop(self, context=None):
            return _M_Test.Initial._op_icop.invoke(self, ((), context))

        def icopAsync(self, context=None):
            return _M_Test.Initial._op_icop.invokeAsync(self, ((), context))

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Test.InitialPrx.ice_checkedCast(proxy, '::Test::Initial', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Test.InitialPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Test::Initial'
    _M_Test._t_InitialPrx = IcePy.defineProxy('::Test::Initial', InitialPrx)

    _M_Test.InitialPrx = InitialPrx
    del InitialPrx

    _M_Test.Initial = None
    class Initial(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Test::Initial')

        def ice_id(self, current=None):
            return '::Test::Initial'

        @staticmethod
        def ice_staticId():
            return '::Test::Initial'

        def shutdown(self, current=None):
            raise NotImplementedError("servant method 'shutdown' not implemented")

        def iaop(self, current=None):
            raise NotImplementedError("servant method 'iaop' not implemented")

        def ib1op(self, current=None):
            raise NotImplementedError("servant method 'ib1op' not implemented")

        def ib2op(self, current=None):
            raise NotImplementedError("servant method 'ib2op' not implemented")

        def icop(self, current=None):
            raise NotImplementedError("servant method 'icop' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Test._t_InitialDisp)

        __repr__ = __str__

    Initial._op_shutdown = IcePy.Operation('shutdown', Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    Initial._op_iaop = IcePy.Operation('iaop', Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_Test.MA._t_IAPrx, False, 0), ())
    Initial._op_ib1op = IcePy.Operation('ib1op', Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_Test.MB._t_IB1Prx, False, 0), ())
    Initial._op_ib2op = IcePy.Operation('ib2op', Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_Test.MB._t_IB2Prx, False, 0), ())
    Initial._op_icop = IcePy.Operation('icop', Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_Test.MA._t_ICPrx, False, 0), ())

    _M_Test.Initial = Initial
    del Initial

# Start of module Test.MC
_M_Test.MC = Ice.openModule('Test.MC')
__name__ = 'Test.MC'

if 'A' not in _M_Test.MC.__dict__:
    _M_Test.MC.A = None
    class A(Ice.Value):
        def __init__(self, aA=0):
            self.aA = aA

        def ice_id(self):
            return '::Test::MC::A'

        @staticmethod
        def ice_staticId():
            return '::Test::MC::A'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.MC._t_A)

        __repr__ = __str__

    _M_Test.MC._t_A = IcePy.defineValue('::Test::MC::A', A, -1, (), False, None, (('aA', (), IcePy._t_int, False, 0),))
    A._ice_type = _M_Test.MC._t_A

    _M_Test.MC.A = A
    del A

if 'B' not in _M_Test.MC.__dict__:
    _M_Test.MC.B = None
    class B(_M_Test.MC.A):
        def __init__(self, aA=0, bB=0):
            _M_Test.MC.A.__init__(self, aA)
            self.bB = bB

        def ice_id(self):
            return '::Test::MC::B'

        @staticmethod
        def ice_staticId():
            return '::Test::MC::B'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.MC._t_B)

        __repr__ = __str__

    _M_Test.MC._t_B = IcePy.defineValue('::Test::MC::B', B, -1, (), False, _M_Test.MC._t_A, (('bB', (), IcePy._t_int, False, 0),))
    B._ice_type = _M_Test.MC._t_B

    _M_Test.MC.B = B
    del B

if 'C' not in _M_Test.MC.__dict__:
    _M_Test.MC.C = None
    class C(_M_Test.MC.B):
        def __init__(self, aA=0, bB=0, cC=0):
            _M_Test.MC.B.__init__(self, aA, bB)
            self.cC = cC

        def ice_id(self):
            return '::Test::MC::C'

        @staticmethod
        def ice_staticId():
            return '::Test::MC::C'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.MC._t_C)

        __repr__ = __str__

    _M_Test.MC._t_C = IcePy.defineValue('::Test::MC::C', C, -1, (), False, _M_Test.MC._t_B, (('cC', (), IcePy._t_int, False, 0),))
    C._ice_type = _M_Test.MC._t_C

    _M_Test.MC.C = C
    del C

if 'D' not in _M_Test.MC.__dict__:
    _M_Test.MC.D = None
    class D(_M_Test.MC.C):
        def __init__(self, aA=0, bB=0, cC=0, dD=0):
            _M_Test.MC.C.__init__(self, aA, bB, cC)
            self.dD = dD

        def ice_id(self):
            return '::Test::MC::D'

        @staticmethod
        def ice_staticId():
            return '::Test::MC::D'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.MC._t_D)

        __repr__ = __str__

    _M_Test.MC._t_D = IcePy.defineValue('::Test::MC::D', D, -1, (), False, _M_Test.MC._t_C, (('dD', (), IcePy._t_int, False, 0),))
    D._ice_type = _M_Test.MC._t_D

    _M_Test.MC.D = D
    del D

# End of module Test.MC

__name__ = 'Test'

# Start of module Test.MD
_M_Test.MD = Ice.openModule('Test.MD')
__name__ = 'Test.MD'

if 'A' not in _M_Test.MD.__dict__:
    _M_Test.MD.A = None
    class A(Ice.Value):
        def __init__(self, aA=0):
            self.aA = aA

        def ice_id(self):
            return '::Test::MD::A'

        @staticmethod
        def ice_staticId():
            return '::Test::MD::A'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.MD._t_A)

        __repr__ = __str__

    _M_Test.MD._t_A = IcePy.defineValue('::Test::MD::A', A, -1, (), False, None, (('aA', (), IcePy._t_int, False, 0),))
    A._ice_type = _M_Test.MD._t_A

    _M_Test.MD.A = A
    del A

if 'B' not in _M_Test.MD.__dict__:
    _M_Test.MD.B = None
    class B(_M_Test.MD.A):
        def __init__(self, aA=0, bB=0):
            _M_Test.MD.A.__init__(self, aA)
            self.bB = bB

        def ice_id(self):
            return '::Test::MD::B'

        @staticmethod
        def ice_staticId():
            return '::Test::MD::B'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.MD._t_B)

        __repr__ = __str__

    _M_Test.MD._t_B = IcePy.defineValue('::Test::MD::B', B, -1, (), False, _M_Test.MD._t_A, (('bB', (), IcePy._t_int, False, 0),))
    B._ice_type = _M_Test.MD._t_B

    _M_Test.MD.B = B
    del B

if 'C' not in _M_Test.MD.__dict__:
    _M_Test.MD.C = None
    class C(_M_Test.MD.B):
        def __init__(self, aA=0, bB=0, cC=0):
            _M_Test.MD.B.__init__(self, aA, bB)
            self.cC = cC

        def ice_id(self):
            return '::Test::MD::C'

        @staticmethod
        def ice_staticId():
            return '::Test::MD::C'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.MD._t_C)

        __repr__ = __str__

    _M_Test.MD._t_C = IcePy.defineValue('::Test::MD::C', C, -1, (), False, _M_Test.MD._t_B, (('cC', (), IcePy._t_int, False, 0),))
    C._ice_type = _M_Test.MD._t_C

    _M_Test.MD.C = C
    del C

if 'D' not in _M_Test.MD.__dict__:
    _M_Test.MD.D = None
    class D(_M_Test.MD.C):
        def __init__(self, aA=0, bB=0, cC=0, dD=0):
            _M_Test.MD.C.__init__(self, aA, bB, cC)
            self.dD = dD

        def ice_id(self):
            return '::Test::MD::D'

        @staticmethod
        def ice_staticId():
            return '::Test::MD::D'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.MD._t_D)

        __repr__ = __str__

    _M_Test.MD._t_D = IcePy.defineValue('::Test::MD::D', D, -1, (), False, _M_Test.MD._t_C, (('dD', (), IcePy._t_int, False, 0),))
    D._ice_type = _M_Test.MD._t_D

    _M_Test.MD.D = D
    del D

# End of module Test.MD

__name__ = 'Test'

# Start of module Test.ME
_M_Test.ME = Ice.openModule('Test.ME')
__name__ = 'Test.ME'

if 'A' not in _M_Test.ME.__dict__:
    _M_Test.ME.A = None
    class A(Ice.Value):
        def __init__(self, aA=0):
            self.aA = aA

        def ice_id(self):
            return '::Test::ME::A'

        @staticmethod
        def ice_staticId():
            return '::Test::ME::A'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.ME._t_A)

        __repr__ = __str__

    _M_Test.ME._t_A = IcePy.defineValue('::Test::ME::A', A, -1, (), False, None, (('aA', (), IcePy._t_int, False, 0),))
    A._ice_type = _M_Test.ME._t_A

    _M_Test.ME.A = A
    del A

if 'B' not in _M_Test.ME.__dict__:
    _M_Test.ME.B = None
    class B(_M_Test.ME.A):
        def __init__(self, aA=0, bB=0):
            _M_Test.ME.A.__init__(self, aA)
            self.bB = bB

        def ice_id(self):
            return '::Test::ME::B'

        @staticmethod
        def ice_staticId():
            return '::Test::ME::B'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.ME._t_B)

        __repr__ = __str__

    _M_Test.ME._t_B = IcePy.defineValue('::Test::ME::B', B, -1, (), False, _M_Test.ME._t_A, (('bB', (), IcePy._t_int, False, 0),))
    B._ice_type = _M_Test.ME._t_B

    _M_Test.ME.B = B
    del B

if 'C' not in _M_Test.ME.__dict__:
    _M_Test.ME.C = None
    class C(_M_Test.ME.B):
        def __init__(self, aA=0, bB=0, cC=0):
            _M_Test.ME.B.__init__(self, aA, bB)
            self.cC = cC

        def ice_id(self):
            return '::Test::ME::C'

        @staticmethod
        def ice_staticId():
            return '::Test::ME::C'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.ME._t_C)

        __repr__ = __str__

    _M_Test.ME._t_C = IcePy.defineValue('::Test::ME::C', C, -1, (), False, _M_Test.ME._t_B, (('cC', (), IcePy._t_int, False, 0),))
    C._ice_type = _M_Test.ME._t_C

    _M_Test.ME.C = C
    del C

if 'D' not in _M_Test.ME.__dict__:
    _M_Test.ME.D = None
    class D(_M_Test.ME.C):
        def __init__(self, aA=0, bB=0, cC=0, dD=0):
            _M_Test.ME.C.__init__(self, aA, bB, cC)
            self.dD = dD

        def ice_id(self):
            return '::Test::ME::D'

        @staticmethod
        def ice_staticId():
            return '::Test::ME::D'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.ME._t_D)

        __repr__ = __str__

    _M_Test.ME._t_D = IcePy.defineValue('::Test::ME::D', D, -1, (), False, _M_Test.ME._t_C, (('dD', (), IcePy._t_int, False, 0),))
    D._ice_type = _M_Test.ME._t_D

    _M_Test.ME.D = D
    del D

# End of module Test.ME

__name__ = 'Test'

# Start of module Test.MF
_M_Test.MF = Ice.openModule('Test.MF')
__name__ = 'Test.MF'

if 'A' not in _M_Test.MF.__dict__:
    _M_Test.MF.A = None
    class A(Ice.Value):
        def __init__(self, aA=0):
            self.aA = aA

        def ice_id(self):
            return '::Test::MF::A'

        @staticmethod
        def ice_staticId():
            return '::Test::MF::A'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.MF._t_A)

        __repr__ = __str__

    _M_Test.MF._t_A = IcePy.defineValue('::Test::MF::A', A, -1, (), False, None, (('aA', (), IcePy._t_int, False, 0),))
    A._ice_type = _M_Test.MF._t_A

    _M_Test.MF.A = A
    del A

if 'B' not in _M_Test.MF.__dict__:
    _M_Test.MF.B = None
    class B(_M_Test.MF.A):
        def __init__(self, aA=0, bB=0):
            _M_Test.MF.A.__init__(self, aA)
            self.bB = bB

        def ice_id(self):
            return '::Test::MF::B'

        @staticmethod
        def ice_staticId():
            return '::Test::MF::B'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.MF._t_B)

        __repr__ = __str__

    _M_Test.MF._t_B = IcePy.defineValue('::Test::MF::B', B, -1, (), False, _M_Test.MF._t_A, (('bB', (), IcePy._t_int, False, 0),))
    B._ice_type = _M_Test.MF._t_B

    _M_Test.MF.B = B
    del B

if 'C' not in _M_Test.MF.__dict__:
    _M_Test.MF.C = None
    class C(_M_Test.MF.B):
        def __init__(self, aA=0, bB=0, cC=0):
            _M_Test.MF.B.__init__(self, aA, bB)
            self.cC = cC

        def ice_id(self):
            return '::Test::MF::C'

        @staticmethod
        def ice_staticId():
            return '::Test::MF::C'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.MF._t_C)

        __repr__ = __str__

    _M_Test.MF._t_C = IcePy.defineValue('::Test::MF::C', C, -1, (), False, _M_Test.MF._t_B, (('cC', (), IcePy._t_int, False, 0),))
    C._ice_type = _M_Test.MF._t_C

    _M_Test.MF.C = C
    del C

if 'D' not in _M_Test.MF.__dict__:
    _M_Test.MF.D = None
    class D(_M_Test.MF.C):
        def __init__(self, aA=0, bB=0, cC=0, dD=0):
            _M_Test.MF.C.__init__(self, aA, bB, cC)
            self.dD = dD

        def ice_id(self):
            return '::Test::MF::D'

        @staticmethod
        def ice_staticId():
            return '::Test::MF::D'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.MF._t_D)

        __repr__ = __str__

    _M_Test.MF._t_D = IcePy.defineValue('::Test::MF::D', D, -1, (), False, _M_Test.MF._t_C, (('dD', (), IcePy._t_int, False, 0),))
    D._ice_type = _M_Test.MF._t_D

    _M_Test.MF.D = D
    del D

# End of module Test.MF

__name__ = 'Test'

# Start of module Test.MG
_M_Test.MG = Ice.openModule('Test.MG')
__name__ = 'Test.MG'

if 'A' not in _M_Test.MG.__dict__:
    _M_Test.MG.A = None
    class A(Ice.Value):
        def __init__(self, aA=0):
            self.aA = aA

        def ice_id(self):
            return '::Test::MG::A'

        @staticmethod
        def ice_staticId():
            return '::Test::MG::A'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.MG._t_A)

        __repr__ = __str__

    _M_Test.MG._t_A = IcePy.defineValue('::Test::MG::A', A, -1, (), False, None, (('aA', (), IcePy._t_int, False, 0),))
    A._ice_type = _M_Test.MG._t_A

    _M_Test.MG.A = A
    del A

if 'B' not in _M_Test.MG.__dict__:
    _M_Test.MG.B = None
    class B(_M_Test.MG.A):
        def __init__(self, aA=0, bB=0):
            _M_Test.MG.A.__init__(self, aA)
            self.bB = bB

        def ice_id(self):
            return '::Test::MG::B'

        @staticmethod
        def ice_staticId():
            return '::Test::MG::B'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.MG._t_B)

        __repr__ = __str__

    _M_Test.MG._t_B = IcePy.defineValue('::Test::MG::B', B, -1, (), False, _M_Test.MG._t_A, (('bB', (), IcePy._t_int, False, 0),))
    B._ice_type = _M_Test.MG._t_B

    _M_Test.MG.B = B
    del B

if 'C' not in _M_Test.MG.__dict__:
    _M_Test.MG.C = None
    class C(_M_Test.MG.B):
        def __init__(self, aA=0, bB=0, cC=0):
            _M_Test.MG.B.__init__(self, aA, bB)
            self.cC = cC

        def ice_id(self):
            return '::Test::MG::C'

        @staticmethod
        def ice_staticId():
            return '::Test::MG::C'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.MG._t_C)

        __repr__ = __str__

    _M_Test.MG._t_C = IcePy.defineValue('::Test::MG::C', C, -1, (), False, _M_Test.MG._t_B, (('cC', (), IcePy._t_int, False, 0),))
    C._ice_type = _M_Test.MG._t_C

    _M_Test.MG.C = C
    del C

if 'D' not in _M_Test.MG.__dict__:
    _M_Test.MG.D = None
    class D(_M_Test.MG.C):
        def __init__(self, aA=0, bB=0, cC=0, dD=0):
            _M_Test.MG.C.__init__(self, aA, bB, cC)
            self.dD = dD

        def ice_id(self):
            return '::Test::MG::D'

        @staticmethod
        def ice_staticId():
            return '::Test::MG::D'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.MG._t_D)

        __repr__ = __str__

    _M_Test.MG._t_D = IcePy.defineValue('::Test::MG::D', D, -1, (), False, _M_Test.MG._t_C, (('dD', (), IcePy._t_int, False, 0),))
    D._ice_type = _M_Test.MG._t_D

    _M_Test.MG.D = D
    del D

# End of module Test.MG

__name__ = 'Test'

# Start of module Test.MH
_M_Test.MH = Ice.openModule('Test.MH')
__name__ = 'Test.MH'

if 'A' not in _M_Test.MH.__dict__:
    _M_Test.MH.A = None
    class A(Ice.Value):
        def __init__(self, aA=0):
            self.aA = aA

        def ice_id(self):
            return '::Test::MH::A'

        @staticmethod
        def ice_staticId():
            return '::Test::MH::A'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.MH._t_A)

        __repr__ = __str__

    _M_Test.MH._t_A = IcePy.defineValue('::Test::MH::A', A, -1, (), False, None, (('aA', (), IcePy._t_int, False, 0),))
    A._ice_type = _M_Test.MH._t_A

    _M_Test.MH.A = A
    del A

if 'B' not in _M_Test.MH.__dict__:
    _M_Test.MH.B = None
    class B(_M_Test.MH.A):
        def __init__(self, aA=0, bB=0):
            _M_Test.MH.A.__init__(self, aA)
            self.bB = bB

        def ice_id(self):
            return '::Test::MH::B'

        @staticmethod
        def ice_staticId():
            return '::Test::MH::B'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.MH._t_B)

        __repr__ = __str__

    _M_Test.MH._t_B = IcePy.defineValue('::Test::MH::B', B, -1, (), False, _M_Test.MH._t_A, (('bB', (), IcePy._t_int, False, 0),))
    B._ice_type = _M_Test.MH._t_B

    _M_Test.MH.B = B
    del B

if 'C' not in _M_Test.MH.__dict__:
    _M_Test.MH.C = None
    class C(_M_Test.MH.B):
        def __init__(self, aA=0, bB=0, cC=0):
            _M_Test.MH.B.__init__(self, aA, bB)
            self.cC = cC

        def ice_id(self):
            return '::Test::MH::C'

        @staticmethod
        def ice_staticId():
            return '::Test::MH::C'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.MH._t_C)

        __repr__ = __str__

    _M_Test.MH._t_C = IcePy.defineValue('::Test::MH::C', C, -1, (), False, _M_Test.MH._t_B, (('cC', (), IcePy._t_int, False, 0),))
    C._ice_type = _M_Test.MH._t_C

    _M_Test.MH.C = C
    del C

if 'D' not in _M_Test.MH.__dict__:
    _M_Test.MH.D = None
    class D(_M_Test.MH.C):
        def __init__(self, aA=0, bB=0, cC=0, dD=0):
            _M_Test.MH.C.__init__(self, aA, bB, cC)
            self.dD = dD

        def ice_id(self):
            return '::Test::MH::D'

        @staticmethod
        def ice_staticId():
            return '::Test::MH::D'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.MH._t_D)

        __repr__ = __str__

    _M_Test.MH._t_D = IcePy.defineValue('::Test::MH::D', D, -1, (), False, _M_Test.MH._t_C, (('dD', (), IcePy._t_int, False, 0),))
    D._ice_type = _M_Test.MH._t_D

    _M_Test.MH.D = D
    del D

# End of module Test.MH

__name__ = 'Test'

# End of module Test
