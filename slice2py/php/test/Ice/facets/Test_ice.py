# Copyright (c) ZeroC, Inc.
#
# Ice version 3.8.0-alpha.0
#
# <auto-generated>
#
# Generated from file 'Test.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>

import Ice
import IcePy
import builtins as _builtins

# Start of module Test
_M_Test = Ice.openModule('Test')
__name__ = 'Test'

if 'Empty' not in _M_Test.__dict__:
    _M_Test._t_EmptyPrx = IcePy.declareProxy('::Test::Empty')

if 'EmptyPrx' not in _M_Test.__dict__:
    _M_Test.EmptyPrx = None
    class EmptyPrx(Ice.ObjectPrx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new EmptyPrx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Test.EmptyPrx.ice_checkedCast(proxy, '::Test::Empty', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Test.EmptyPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Test::Empty'
    _M_Test._t_EmptyPrx = IcePy.defineProxy('::Test::Empty', EmptyPrx)

    _M_Test.EmptyPrx = EmptyPrx
    del EmptyPrx

    _M_Test.Empty = None
    class Empty(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Test::Empty')

        def ice_id(self, current=None):
            return '::Test::Empty'

        @staticmethod
        def ice_staticId():
            return '::Test::Empty'

        def __str__(self):
            return IcePy.stringify(self, _M_Test._t_EmptyDisp)

        __repr__ = __str__

    _M_Test.Empty = Empty
    del Empty

if 'A' not in _M_Test.__dict__:
    _M_Test._t_APrx = IcePy.declareProxy('::Test::A')

if 'APrx' not in _M_Test.__dict__:
    _M_Test.APrx = None
    class APrx(Ice.ObjectPrx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new APrx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        def callA(self, context=None):
            return _M_Test.A._op_callA.invoke(self, ((), context))

        def callAAsync(self, context=None):
            return _M_Test.A._op_callA.invokeAsync(self, ((), context))

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Test.APrx.ice_checkedCast(proxy, '::Test::A', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Test.APrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Test::A'
    _M_Test._t_APrx = IcePy.defineProxy('::Test::A', APrx)

    _M_Test.APrx = APrx
    del APrx

    _M_Test.A = None
    class A(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Test::A')

        def ice_id(self, current=None):
            return '::Test::A'

        @staticmethod
        def ice_staticId():
            return '::Test::A'

        def callA(self, current=None):
            raise NotImplementedError("servant method 'callA' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Test._t_ADisp)

        __repr__ = __str__

    A._op_callA = IcePy.Operation('callA', Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_string, False, 0), ())

    _M_Test.A = A
    del A

if 'B' not in _M_Test.__dict__:
    _M_Test._t_BPrx = IcePy.declareProxy('::Test::B')

if 'BPrx' not in _M_Test.__dict__:
    _M_Test.BPrx = None
    class BPrx(_M_Test.APrx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new BPrx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        def callB(self, context=None):
            return _M_Test.B._op_callB.invoke(self, ((), context))

        def callBAsync(self, context=None):
            return _M_Test.B._op_callB.invokeAsync(self, ((), context))

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Test.BPrx.ice_checkedCast(proxy, '::Test::B', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Test.BPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Test::B'
    _M_Test._t_BPrx = IcePy.defineProxy('::Test::B', BPrx)

    _M_Test.BPrx = BPrx
    del BPrx

    _M_Test.B = None
    class B(_M_Test.A):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Test::A', '::Test::B')

        def ice_id(self, current=None):
            return '::Test::B'

        @staticmethod
        def ice_staticId():
            return '::Test::B'

        def callB(self, current=None):
            raise NotImplementedError("servant method 'callB' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Test._t_BDisp)

        __repr__ = __str__

    B._op_callB = IcePy.Operation('callB', Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_string, False, 0), ())

    _M_Test.B = B
    del B

if 'C' not in _M_Test.__dict__:
    _M_Test._t_CPrx = IcePy.declareProxy('::Test::C')

if 'CPrx' not in _M_Test.__dict__:
    _M_Test.CPrx = None
    class CPrx(_M_Test.APrx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new CPrx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        def callC(self, context=None):
            return _M_Test.C._op_callC.invoke(self, ((), context))

        def callCAsync(self, context=None):
            return _M_Test.C._op_callC.invokeAsync(self, ((), context))

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Test.CPrx.ice_checkedCast(proxy, '::Test::C', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Test.CPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Test::C'
    _M_Test._t_CPrx = IcePy.defineProxy('::Test::C', CPrx)

    _M_Test.CPrx = CPrx
    del CPrx

    _M_Test.C = None
    class C(_M_Test.A):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Test::A', '::Test::C')

        def ice_id(self, current=None):
            return '::Test::C'

        @staticmethod
        def ice_staticId():
            return '::Test::C'

        def callC(self, current=None):
            raise NotImplementedError("servant method 'callC' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Test._t_CDisp)

        __repr__ = __str__

    C._op_callC = IcePy.Operation('callC', Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_string, False, 0), ())

    _M_Test.C = C
    del C

if 'D' not in _M_Test.__dict__:
    _M_Test._t_DPrx = IcePy.declareProxy('::Test::D')

if 'DPrx' not in _M_Test.__dict__:
    _M_Test.DPrx = None
    class DPrx(_M_Test.BPrx, _M_Test.CPrx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new DPrx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        def callD(self, context=None):
            return _M_Test.D._op_callD.invoke(self, ((), context))

        def callDAsync(self, context=None):
            return _M_Test.D._op_callD.invokeAsync(self, ((), context))

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Test.DPrx.ice_checkedCast(proxy, '::Test::D', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Test.DPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Test::D'
    _M_Test._t_DPrx = IcePy.defineProxy('::Test::D', DPrx)

    _M_Test.DPrx = DPrx
    del DPrx

    _M_Test.D = None
    class D(_M_Test.B, _M_Test.C):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Test::A', '::Test::B', '::Test::C', '::Test::D')

        def ice_id(self, current=None):
            return '::Test::D'

        @staticmethod
        def ice_staticId():
            return '::Test::D'

        def callD(self, current=None):
            raise NotImplementedError("servant method 'callD' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Test._t_DDisp)

        __repr__ = __str__

    D._op_callD = IcePy.Operation('callD', Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_string, False, 0), ())

    _M_Test.D = D
    del D

if 'E' not in _M_Test.__dict__:
    _M_Test._t_EPrx = IcePy.declareProxy('::Test::E')

if 'EPrx' not in _M_Test.__dict__:
    _M_Test.EPrx = None
    class EPrx(Ice.ObjectPrx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new EPrx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        def callE(self, context=None):
            return _M_Test.E._op_callE.invoke(self, ((), context))

        def callEAsync(self, context=None):
            return _M_Test.E._op_callE.invokeAsync(self, ((), context))

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Test.EPrx.ice_checkedCast(proxy, '::Test::E', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Test.EPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Test::E'
    _M_Test._t_EPrx = IcePy.defineProxy('::Test::E', EPrx)

    _M_Test.EPrx = EPrx
    del EPrx

    _M_Test.E = None
    class E(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Test::E')

        def ice_id(self, current=None):
            return '::Test::E'

        @staticmethod
        def ice_staticId():
            return '::Test::E'

        def callE(self, current=None):
            raise NotImplementedError("servant method 'callE' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Test._t_EDisp)

        __repr__ = __str__

    E._op_callE = IcePy.Operation('callE', Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_string, False, 0), ())

    _M_Test.E = E
    del E

if 'F' not in _M_Test.__dict__:
    _M_Test._t_FPrx = IcePy.declareProxy('::Test::F')

if 'FPrx' not in _M_Test.__dict__:
    _M_Test.FPrx = None
    class FPrx(_M_Test.EPrx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new FPrx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        def callF(self, context=None):
            return _M_Test.F._op_callF.invoke(self, ((), context))

        def callFAsync(self, context=None):
            return _M_Test.F._op_callF.invokeAsync(self, ((), context))

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Test.FPrx.ice_checkedCast(proxy, '::Test::F', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Test.FPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Test::F'
    _M_Test._t_FPrx = IcePy.defineProxy('::Test::F', FPrx)

    _M_Test.FPrx = FPrx
    del FPrx

    _M_Test.F = None
    class F(_M_Test.E):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Test::E', '::Test::F')

        def ice_id(self, current=None):
            return '::Test::F'

        @staticmethod
        def ice_staticId():
            return '::Test::F'

        def callF(self, current=None):
            raise NotImplementedError("servant method 'callF' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Test._t_FDisp)

        __repr__ = __str__

    F._op_callF = IcePy.Operation('callF', Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_string, False, 0), ())

    _M_Test.F = F
    del F

if 'G' not in _M_Test.__dict__:
    _M_Test._t_GPrx = IcePy.declareProxy('::Test::G')

if 'GPrx' not in _M_Test.__dict__:
    _M_Test.GPrx = None
    class GPrx(Ice.ObjectPrx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new GPrx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        def shutdown(self, context=None):
            return _M_Test.G._op_shutdown.invoke(self, ((), context))

        def shutdownAsync(self, context=None):
            return _M_Test.G._op_shutdown.invokeAsync(self, ((), context))

        def callG(self, context=None):
            return _M_Test.G._op_callG.invoke(self, ((), context))

        def callGAsync(self, context=None):
            return _M_Test.G._op_callG.invokeAsync(self, ((), context))

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Test.GPrx.ice_checkedCast(proxy, '::Test::G', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Test.GPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Test::G'
    _M_Test._t_GPrx = IcePy.defineProxy('::Test::G', GPrx)

    _M_Test.GPrx = GPrx
    del GPrx

    _M_Test.G = None
    class G(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Test::G')

        def ice_id(self, current=None):
            return '::Test::G'

        @staticmethod
        def ice_staticId():
            return '::Test::G'

        def shutdown(self, current=None):
            raise NotImplementedError("servant method 'shutdown' not implemented")

        def callG(self, current=None):
            raise NotImplementedError("servant method 'callG' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Test._t_GDisp)

        __repr__ = __str__

    G._op_shutdown = IcePy.Operation('shutdown', Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    G._op_callG = IcePy.Operation('callG', Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_string, False, 0), ())

    _M_Test.G = G
    del G

if 'H' not in _M_Test.__dict__:
    _M_Test._t_HPrx = IcePy.declareProxy('::Test::H')

if 'HPrx' not in _M_Test.__dict__:
    _M_Test.HPrx = None
    class HPrx(_M_Test.GPrx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new HPrx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        def callH(self, context=None):
            return _M_Test.H._op_callH.invoke(self, ((), context))

        def callHAsync(self, context=None):
            return _M_Test.H._op_callH.invokeAsync(self, ((), context))

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Test.HPrx.ice_checkedCast(proxy, '::Test::H', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Test.HPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Test::H'
    _M_Test._t_HPrx = IcePy.defineProxy('::Test::H', HPrx)

    _M_Test.HPrx = HPrx
    del HPrx

    _M_Test.H = None
    class H(_M_Test.G):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Test::G', '::Test::H')

        def ice_id(self, current=None):
            return '::Test::H'

        @staticmethod
        def ice_staticId():
            return '::Test::H'

        def callH(self, current=None):
            raise NotImplementedError("servant method 'callH' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Test._t_HDisp)

        __repr__ = __str__

    H._op_callH = IcePy.Operation('callH', Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_string, False, 0), ())

    _M_Test.H = H
    del H

# End of module Test
