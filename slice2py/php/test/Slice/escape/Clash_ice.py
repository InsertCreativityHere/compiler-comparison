# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.8.0-alpha.0
#
# <auto-generated>
#
# Generated from file `Clash.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

import Ice
import IcePy
import builtins as _builtins

# Start of module Clash
_M_Clash = Ice.openModule('Clash')
__name__ = 'Clash'

_M_Clash._t_Intf = IcePy.defineValue('::Clash::Intf', Ice.Value, -1, (), True, None, ())

if 'IntfPrx' not in _M_Clash.__dict__:
    _M_Clash.IntfPrx = None
    class IntfPrx(Ice.ObjectPrx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new IntfPrx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        def context(self, context=None):
            return _M_Clash.Intf._op_context.invoke(self, ((), context))

        def contextAsync(self, context=None):
            return _M_Clash.Intf._op_context.invokeAsync(self, ((), context))

        def current(self, context=None):
            return _M_Clash.Intf._op_current.invoke(self, ((), context))

        def currentAsync(self, context=None):
            return _M_Clash.Intf._op_current.invokeAsync(self, ((), context))

        def response(self, context=None):
            return _M_Clash.Intf._op_response.invoke(self, ((), context))

        def responseAsync(self, context=None):
            return _M_Clash.Intf._op_response.invokeAsync(self, ((), context))

        def upCast(self, context=None):
            return _M_Clash.Intf._op_upCast.invoke(self, ((), context))

        def upCastAsync(self, context=None):
            return _M_Clash.Intf._op_upCast.invokeAsync(self, ((), context))

        def typeId(self, context=None):
            return _M_Clash.Intf._op_typeId.invoke(self, ((), context))

        def typeIdAsync(self, context=None):
            return _M_Clash.Intf._op_typeId.invokeAsync(self, ((), context))

        def _del(self, context=None):
            return _M_Clash.Intf._op_del.invoke(self, ((), context))

        def delAsync(self, context=None):
            return _M_Clash.Intf._op_del.invokeAsync(self, ((), context))

        def cookie(self, context=None):
            return _M_Clash.Intf._op_cookie.invoke(self, ((), context))

        def cookieAsync(self, context=None):
            return _M_Clash.Intf._op_cookie.invokeAsync(self, ((), context))

        def sync(self, context=None):
            return _M_Clash.Intf._op_sync.invoke(self, ((), context))

        def syncAsync(self, context=None):
            return _M_Clash.Intf._op_sync.invokeAsync(self, ((), context))

        def inS(self, context=None):
            return _M_Clash.Intf._op_inS.invoke(self, ((), context))

        def inSAsync(self, context=None):
            return _M_Clash.Intf._op_inS.invokeAsync(self, ((), context))

        def istr(self, context=None):
            return _M_Clash.Intf._op_istr.invoke(self, ((), context))

        def istrAsync(self, context=None):
            return _M_Clash.Intf._op_istr.invokeAsync(self, ((), context))

        def op(self, context, current, response, ex, sent, cookie, sync, result, istr, ostr, proxy=Ice.Unset, context_=None):
            return _M_Clash.Intf._op_op.invoke(self, ((context, current, response, ex, sent, cookie, sync, result, istr, ostr, proxy), context_))

        def opAsync(self, context, current, response, ex, sent, cookie, sync, result, istr, ostr, proxy, context_=None):
            return _M_Clash.Intf._op_op.invokeAsync(self, ((context, current, response, ex, sent, cookie, sync, result, istr, ostr, proxy), context_))

        def opOut(self, context_=None):
            return _M_Clash.Intf._op_opOut.invoke(self, ((), context_))

        def opOutAsync(self, context_=None):
            return _M_Clash.Intf._op_opOut.invokeAsync(self, ((), context_))

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Clash.IntfPrx.ice_checkedCast(proxy, '::Clash::Intf', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Clash.IntfPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Clash::Intf'
    _M_Clash._t_IntfPrx = IcePy.defineProxy('::Clash::Intf', IntfPrx)

    _M_Clash.IntfPrx = IntfPrx
    del IntfPrx

    _M_Clash.Intf = None
    class Intf(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Clash::Intf', '::Ice::Object')

        def ice_id(self, current=None):
            return '::Clash::Intf'

        @staticmethod
        def ice_staticId():
            return '::Clash::Intf'

        def context(self, current=None):
            raise NotImplementedError("servant method 'context' not implemented")

        def current(self, current=None):
            raise NotImplementedError("servant method 'current' not implemented")

        def response(self, current=None):
            raise NotImplementedError("servant method 'response' not implemented")

        def upCast(self, current=None):
            raise NotImplementedError("servant method 'upCast' not implemented")

        def typeId(self, current=None):
            raise NotImplementedError("servant method 'typeId' not implemented")

        def _del(self, current=None):
            raise NotImplementedError("servant method '_del' not implemented")

        def cookie(self, current=None):
            raise NotImplementedError("servant method 'cookie' not implemented")

        def sync(self, current=None):
            raise NotImplementedError("servant method 'sync' not implemented")

        def inS(self, current=None):
            raise NotImplementedError("servant method 'inS' not implemented")

        def istr(self, current=None):
            raise NotImplementedError("servant method 'istr' not implemented")

        def op(self, context, current, response, ex, sent, cookie, sync, result, istr, ostr, proxy, current_=None):
            raise NotImplementedError("servant method 'op' not implemented")

        def opOut(self, current_=None):
            raise NotImplementedError("servant method 'opOut' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Clash._t_IntfDisp)

        __repr__ = __str__

    _M_Clash._t_IntfDisp = IcePy.defineClass('::Clash::Intf', Intf, (), None, ())
    Intf._ice_type = _M_Clash._t_IntfDisp

    Intf._op_context = IcePy.Operation('context', Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    Intf._op_current = IcePy.Operation('current', Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    Intf._op_response = IcePy.Operation('response', Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    Intf._op_upCast = IcePy.Operation('upCast', Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    Intf._op_typeId = IcePy.Operation('typeId', Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    Intf._op_del = IcePy.Operation('del', Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    Intf._op_cookie = IcePy.Operation('cookie', Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    Intf._op_sync = IcePy.Operation('sync', Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    Intf._op_inS = IcePy.Operation('inS', Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    Intf._op_istr = IcePy.Operation('istr', Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    Intf._op_op = IcePy.Operation('op', Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0), ((), IcePy._t_string, True, 1)), (), None, ())
    Intf._op_opOut = IcePy.Operation('opOut', Ice.OperationMode.Normal, False, None, (), (), (((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0), ((), IcePy._t_string, True, 1)), None, ())

    _M_Clash.Intf = Intf
    del Intf

if 'Cls' not in _M_Clash.__dict__:
    _M_Clash.Cls = None
    class Cls(Ice.Value):
        def __init__(self, s=None, context='', current=0, response=0, upCast='', typeId=0, _del=0, cookie=Ice.Unset, ex='', result=0, istr='', ostr='', inS='', _in='', proxy=''):
            self.s = s
            self.context = context
            self.current = current
            self.response = response
            self.upCast = upCast
            self.typeId = typeId
            self._del = _del
            self.cookie = cookie
            self.ex = ex
            self.result = result
            self.istr = istr
            self.ostr = ostr
            self.inS = inS
            self._in = _in
            self.proxy = proxy

        def ice_id(self):
            return '::Clash::Cls'

        @staticmethod
        def ice_staticId():
            return '::Clash::Cls'

        def __str__(self):
            return IcePy.stringify(self, _M_Clash._t_Cls)

        __repr__ = __str__

    _M_Clash._t_Cls = IcePy.defineValue('::Clash::Cls', Cls, -1, (), False, None, (
        ('s', (), _M_Clash._t_IntfPrx, False, 0),
        ('context', (), IcePy._t_string, False, 0),
        ('current', (), IcePy._t_int, False, 0),
        ('response', (), IcePy._t_short, False, 0),
        ('upCast', (), IcePy._t_string, False, 0),
        ('typeId', (), IcePy._t_int, False, 0),
        ('_del', (), IcePy._t_short, False, 0),
        ('cookie', (), IcePy._t_short, True, 1),
        ('ex', (), IcePy._t_string, False, 0),
        ('result', (), IcePy._t_int, False, 0),
        ('istr', (), IcePy._t_string, False, 0),
        ('ostr', (), IcePy._t_string, False, 0),
        ('inS', (), IcePy._t_string, False, 0),
        ('_in', (), IcePy._t_string, False, 0),
        ('proxy', (), IcePy._t_string, False, 0)
    ))
    Cls._ice_type = _M_Clash._t_Cls

    _M_Clash.Cls = Cls
    del Cls

if 'St' not in _M_Clash.__dict__:
    _M_Clash.St = None
    class St(object):
        def __init__(self, v='', istr=0, ostr=0, rhs=0, other=''):
            self.v = v
            self.istr = istr
            self.ostr = ostr
            self.rhs = rhs
            self.other = other

        def __hash__(self):
            _h = 0
            _h = 5 * _h + _builtins.hash(self.v)
            _h = 5 * _h + _builtins.hash(self.istr)
            _h = 5 * _h + _builtins.hash(self.ostr)
            _h = 5 * _h + _builtins.hash(self.rhs)
            _h = 5 * _h + _builtins.hash(self.other)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_Clash.St):
                return NotImplemented
            else:
                if self.v is None or other.v is None:
                    if self.v != other.v:
                        return (-1 if self.v is None else 1)
                else:
                    if self.v < other.v:
                        return -1
                    elif self.v > other.v:
                        return 1
                if self.istr is None or other.istr is None:
                    if self.istr != other.istr:
                        return (-1 if self.istr is None else 1)
                else:
                    if self.istr < other.istr:
                        return -1
                    elif self.istr > other.istr:
                        return 1
                if self.ostr is None or other.ostr is None:
                    if self.ostr != other.ostr:
                        return (-1 if self.ostr is None else 1)
                else:
                    if self.ostr < other.ostr:
                        return -1
                    elif self.ostr > other.ostr:
                        return 1
                if self.rhs is None or other.rhs is None:
                    if self.rhs != other.rhs:
                        return (-1 if self.rhs is None else 1)
                else:
                    if self.rhs < other.rhs:
                        return -1
                    elif self.rhs > other.rhs:
                        return 1
                if self.other is None or other.other is None:
                    if self.other != other.other:
                        return (-1 if self.other is None else 1)
                else:
                    if self.other < other.other:
                        return -1
                    elif self.other > other.other:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_Clash._t_St)

        __repr__ = __str__

    _M_Clash._t_St = IcePy.defineStruct('::Clash::St', St, (), (
        ('v', (), IcePy._t_string),
        ('istr', (), IcePy._t_short),
        ('ostr', (), IcePy._t_int),
        ('rhs', (), IcePy._t_int),
        ('other', (), IcePy._t_string)
    ))

    _M_Clash.St = St
    del St

if 'Ex' not in _M_Clash.__dict__:
    _M_Clash.Ex = None
    class Ex(Ice.UserException):
        def __init__(self, istr=0, ostr=0):
            self.istr = istr
            self.ostr = ostr

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Clash::Ex'

    _M_Clash._t_Ex = IcePy.defineException('::Clash::Ex', Ex, (), None, (
        ('istr', (), IcePy._t_short, False, 0),
        ('ostr', (), IcePy._t_int, False, 0)
    ))
    Ex._ice_type = _M_Clash._t_Ex

    _M_Clash.Ex = Ex
    del Ex

# End of module Clash
