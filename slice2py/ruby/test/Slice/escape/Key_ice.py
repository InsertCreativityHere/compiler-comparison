# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.10
#
# <auto-generated>
#
# Generated from file `Key.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

from sys import version_info as _version_info_
import Ice, IcePy

# Start of module BEGIN
_M_BEGIN = Ice.openModule('BEGIN')
__name__ = 'BEGIN'

if 'END' not in _M_BEGIN.__dict__:
    _M_BEGIN.END = Ice.createTempClass()
    class END(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    END.alias = END("alias", 0)
    END._enumerators = { 0:END.alias }

    _M_BEGIN._t_END = IcePy.defineEnum('::BEGIN::END', END, (), END._enumerators)

    _M_BEGIN.END = END
    del END

if '_and' not in _M_BEGIN.__dict__:
    _M_BEGIN._and = Ice.createTempClass()
    class _and(object):
        def __init__(self, begin=0):
            self.begin = begin

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.begin)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_BEGIN._and):
                return NotImplemented
            else:
                if self.begin is None or other.begin is None:
                    if self.begin != other.begin:
                        return (-1 if self.begin is None else 1)
                else:
                    if self.begin < other.begin:
                        return -1
                    elif self.begin > other.begin:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_BEGIN._t__and)

        __repr__ = __str__

    _M_BEGIN._t__and = IcePy.defineStruct('::BEGIN::and', _and, (), (('begin', (), IcePy._t_int),))

    _M_BEGIN._and = _and
    del _and

_M_BEGIN._t__break = IcePy.defineValue('::BEGIN::break', Ice.Value, -1, (), False, True, None, ())

if 'breakPrx' not in _M_BEGIN.__dict__:
    _M_BEGIN.breakPrx = Ice.createTempClass()
    class breakPrx(Ice.ObjectPrx):

        def _case(self, clone, _def, context=None):
            return _M_BEGIN._break._op_case.invoke(self, ((clone, _def), context))

        def caseAsync(self, clone, _def, context=None):
            return _M_BEGIN._break._op_case.invokeAsync(self, ((clone, _def), context))

        def begin_case(self, clone, _def, _response=None, _ex=None, _sent=None, context=None):
            return _M_BEGIN._break._op_case.begin(self, ((clone, _def), _response, _ex, _sent, context))

        def end_case(self, _r):
            return _M_BEGIN._break._op_case.end(self, _r)

        def to_a(self, context=None):
            return _M_BEGIN._break._op_to_a.invoke(self, ((), context))

        def to_aAsync(self, context=None):
            return _M_BEGIN._break._op_to_a.invokeAsync(self, ((), context))

        def begin_to_a(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_BEGIN._break._op_to_a.begin(self, ((), _response, _ex, _sent, context))

        def end_to_a(self, _r):
            return _M_BEGIN._break._op_to_a.end(self, _r)

        def instance_variable_set(self, context=None):
            return _M_BEGIN._break._op_instance_variable_set.invoke(self, ((), context))

        def instance_variable_setAsync(self, context=None):
            return _M_BEGIN._break._op_instance_variable_set.invokeAsync(self, ((), context))

        def begin_instance_variable_set(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_BEGIN._break._op_instance_variable_set.begin(self, ((), _response, _ex, _sent, context))

        def end_instance_variable_set(self, _r):
            return _M_BEGIN._break._op_instance_variable_set.end(self, _r)

        def instance_variables(self, context=None):
            return _M_BEGIN._break._op_instance_variables.invoke(self, ((), context))

        def instance_variablesAsync(self, context=None):
            return _M_BEGIN._break._op_instance_variables.invokeAsync(self, ((), context))

        def begin_instance_variables(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_BEGIN._break._op_instance_variables.begin(self, ((), _response, _ex, _sent, context))

        def end_instance_variables(self, _r):
            return _M_BEGIN._break._op_instance_variables.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_BEGIN.breakPrx.ice_checkedCast(proxy, '::BEGIN::break', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_BEGIN.breakPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::BEGIN::break'
    _M_BEGIN._t_breakPrx = IcePy.defineProxy('::BEGIN::break', breakPrx)

    _M_BEGIN.breakPrx = breakPrx
    del breakPrx

    _M_BEGIN._break = Ice.createTempClass()
    class _break(Ice.Object):

        def ice_ids(self, current=None):
            return ('::BEGIN::break', '::Ice::Object')

        def ice_id(self, current=None):
            return '::BEGIN::break'

        @staticmethod
        def ice_staticId():
            return '::BEGIN::break'

        def _case(self, clone, _def, current=None):
            raise NotImplementedError("servant method '_case' not implemented")

        def to_a(self, current=None):
            raise NotImplementedError("servant method 'to_a' not implemented")

        def instance_variable_set(self, current=None):
            raise NotImplementedError("servant method 'instance_variable_set' not implemented")

        def instance_variables(self, current=None):
            raise NotImplementedError("servant method 'instance_variables' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_BEGIN._t_breakDisp)

        __repr__ = __str__

    _M_BEGIN._t_breakDisp = IcePy.defineClass('::BEGIN::break', _break, (), None, ())
    _break._ice_type = _M_BEGIN._t_breakDisp

    _break._op_case = IcePy.Operation('case', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0)), (), None, ())
    _break._op_to_a = IcePy.Operation('to_a', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    _break._op_instance_variable_set = IcePy.Operation('instance_variable_set', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    _break._op_instance_variables = IcePy.Operation('instance_variables', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())

    _M_BEGIN._break = _break
    del _break

if 'display' not in _M_BEGIN.__dict__:
    _M_BEGIN.display = Ice.createTempClass()
    class display(Ice.Value):
        def __init__(self, when=0, do=0, dup=None, _else=0):
            self.when = when
            self.do = do
            self.dup = dup
            self._else = _else

        def ice_id(self):
            return '::BEGIN::display'

        @staticmethod
        def ice_staticId():
            return '::BEGIN::display'

        def __str__(self):
            return IcePy.stringify(self, _M_BEGIN._t_display)

        __repr__ = __str__

    _M_BEGIN._t_display = IcePy.defineValue('::BEGIN::display', display, -1, (), False, False, None, (
        ('when', (), IcePy._t_int, False, 0),
        ('do', (), IcePy._t_int, False, 0),
        ('dup', (), _M_BEGIN._t_breakPrx, False, 0),
        ('_else', (), IcePy._t_int, False, 0)
    ))
    display._ice_type = _M_BEGIN._t_display

    _M_BEGIN.display = display
    del display

_M_BEGIN._t_elsif = IcePy.defineValue('::BEGIN::elsif', Ice.Value, -1, (), False, True, None, ())

if 'elsifPrx' not in _M_BEGIN.__dict__:
    _M_BEGIN.elsifPrx = Ice.createTempClass()
    class elsifPrx(_M_BEGIN.breakPrx):

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_BEGIN.elsifPrx.ice_checkedCast(proxy, '::BEGIN::elsif', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_BEGIN.elsifPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::BEGIN::elsif'
    _M_BEGIN._t_elsifPrx = IcePy.defineProxy('::BEGIN::elsif', elsifPrx)

    _M_BEGIN.elsifPrx = elsifPrx
    del elsifPrx

    _M_BEGIN.elsif = Ice.createTempClass()
    class elsif(_M_BEGIN._break):

        def ice_ids(self, current=None):
            return ('::BEGIN::break', '::BEGIN::elsif', '::Ice::Object')

        def ice_id(self, current=None):
            return '::BEGIN::elsif'

        @staticmethod
        def ice_staticId():
            return '::BEGIN::elsif'

        def __str__(self):
            return IcePy.stringify(self, _M_BEGIN._t_elsifDisp)

        __repr__ = __str__

    _M_BEGIN._t_elsifDisp = IcePy.defineClass('::BEGIN::elsif', elsif, (), None, (_M_BEGIN._t_breakDisp,))
    elsif._ice_type = _M_BEGIN._t_elsifDisp

    _M_BEGIN.elsif = elsif
    del elsif

if '_t_rescue' not in _M_BEGIN.__dict__:
    _M_BEGIN._t_rescue = IcePy.defineSequence('::BEGIN::rescue', (), _M_BEGIN._t_END)

if '_t_ensure' not in _M_BEGIN.__dict__:
    _M_BEGIN._t_ensure = IcePy.defineDictionary('::BEGIN::ensure', (), IcePy._t_string, _M_BEGIN._t_END)

if 'next' not in _M_BEGIN.__dict__:
    _M_BEGIN.next = Ice.createTempClass()
    class next(Ice.UserException):
        def __init__(self, new=0):
            self.new = new

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::BEGIN::next'

    _M_BEGIN._t_next = IcePy.defineException('::BEGIN::next', next, (), False, None, (('new', (), IcePy._t_int, False, 0),))
    next._ice_type = _M_BEGIN._t_next

    _M_BEGIN.next = next
    del next

if 'nil' not in _M_BEGIN.__dict__:
    _M_BEGIN.nil = Ice.createTempClass()
    class nil(_M_BEGIN.next):
        def __init__(self, new=0, _not=0, _or=0):
            _M_BEGIN.next.__init__(self, new)
            self._not = _not
            self._or = _or

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::BEGIN::nil'

    _M_BEGIN._t_nil = IcePy.defineException('::BEGIN::nil', nil, (), False, _M_BEGIN._t_next, (
        ('_not', (), IcePy._t_int, False, 0),
        ('_or', (), IcePy._t_int, False, 0)
    ))
    nil._ice_type = _M_BEGIN._t_nil

    _M_BEGIN.nil = nil
    del nil

if 'extend' not in _M_BEGIN.__dict__:
    _M_BEGIN.extend = Ice.createTempClass()
    class extend(object):
        def __init__(self):
            if Ice.getType(self) == _M_BEGIN.extend:
                raise RuntimeError('BEGIN.extend is an abstract class')

        def _for(self, freeze, hash, _if, inspect, method, methods):
            raise NotImplementedError("method '_for' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_BEGIN._t_extend)

        __repr__ = __str__

    _M_BEGIN._t_extend = IcePy.defineValue('::BEGIN::extend', extend, -1, (), False, True, None, ())
    extend._ice_type = _M_BEGIN._t_extend

    _M_BEGIN.extend = extend
    del extend

_M_BEGIN.redo = 1

# End of module BEGIN
