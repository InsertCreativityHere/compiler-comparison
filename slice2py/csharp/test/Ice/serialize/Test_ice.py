# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.10
#
# <auto-generated>
#
# Generated from file `Test.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

from sys import version_info as _version_info_
import Ice, IcePy
import Ice.BuiltinSequences_ice

# Included module Ice
_M_Ice = Ice.openModule('Ice')

# Start of module Test
_M_Test = Ice.openModule('Test')
__name__ = 'Test'

if 'MyEnum' not in _M_Test.__dict__:
    _M_Test.MyEnum = Ice.createTempClass()
    class MyEnum(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    MyEnum.enum1 = MyEnum("enum1", 0)
    MyEnum.enum2 = MyEnum("enum2", 1)
    MyEnum.enum3 = MyEnum("enum3", 2)
    MyEnum._enumerators = { 0:MyEnum.enum1, 1:MyEnum.enum2, 2:MyEnum.enum3 }

    _M_Test._t_MyEnum = IcePy.defineEnum('::Test::MyEnum', MyEnum, (), MyEnum._enumerators)

    _M_Test.MyEnum = MyEnum
    del MyEnum

if 'MyClass' not in _M_Test.__dict__:
    _M_Test._t_MyClass = IcePy.declareValue('::Test::MyClass')

if 'ValStruct' not in _M_Test.__dict__:
    _M_Test.ValStruct = Ice.createTempClass()
    class ValStruct(object):
        def __init__(self, bo=False, by=0, sh=0, i=0, l=0, e=_M_Test.MyEnum.enum1):
            self.bo = bo
            self.by = by
            self.sh = sh
            self.i = i
            self.l = l
            self.e = e

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.bo)
            _h = 5 * _h + Ice.getHash(self.by)
            _h = 5 * _h + Ice.getHash(self.sh)
            _h = 5 * _h + Ice.getHash(self.i)
            _h = 5 * _h + Ice.getHash(self.l)
            _h = 5 * _h + Ice.getHash(self.e)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_Test.ValStruct):
                return NotImplemented
            else:
                if self.bo is None or other.bo is None:
                    if self.bo != other.bo:
                        return (-1 if self.bo is None else 1)
                else:
                    if self.bo < other.bo:
                        return -1
                    elif self.bo > other.bo:
                        return 1
                if self.by is None or other.by is None:
                    if self.by != other.by:
                        return (-1 if self.by is None else 1)
                else:
                    if self.by < other.by:
                        return -1
                    elif self.by > other.by:
                        return 1
                if self.sh is None or other.sh is None:
                    if self.sh != other.sh:
                        return (-1 if self.sh is None else 1)
                else:
                    if self.sh < other.sh:
                        return -1
                    elif self.sh > other.sh:
                        return 1
                if self.i is None or other.i is None:
                    if self.i != other.i:
                        return (-1 if self.i is None else 1)
                else:
                    if self.i < other.i:
                        return -1
                    elif self.i > other.i:
                        return 1
                if self.l is None or other.l is None:
                    if self.l != other.l:
                        return (-1 if self.l is None else 1)
                else:
                    if self.l < other.l:
                        return -1
                    elif self.l > other.l:
                        return 1
                if self.e is None or other.e is None:
                    if self.e != other.e:
                        return (-1 if self.e is None else 1)
                else:
                    if self.e < other.e:
                        return -1
                    elif self.e > other.e:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_Test._t_ValStruct)

        __repr__ = __str__

    _M_Test._t_ValStruct = IcePy.defineStruct('::Test::ValStruct', ValStruct, (), (
        ('bo', (), IcePy._t_bool),
        ('by', (), IcePy._t_byte),
        ('sh', (), IcePy._t_short),
        ('i', (), IcePy._t_int),
        ('l', (), IcePy._t_long),
        ('e', (), _M_Test._t_MyEnum)
    ))

    _M_Test.ValStruct = ValStruct
    del ValStruct

_M_Test._t_MyInterface = IcePy.defineValue('::Test::MyInterface', Ice.Value, -1, (), False, True, None, ())

if 'MyInterfacePrx' not in _M_Test.__dict__:
    _M_Test.MyInterfacePrx = Ice.createTempClass()
    class MyInterfacePrx(Ice.ObjectPrx):

        def op(self, context=None):
            return _M_Test.MyInterface._op_op.invoke(self, ((), context))

        def opAsync(self, context=None):
            return _M_Test.MyInterface._op_op.invokeAsync(self, ((), context))

        def begin_op(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Test.MyInterface._op_op.begin(self, ((), _response, _ex, _sent, context))

        def end_op(self, _r):
            return _M_Test.MyInterface._op_op.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Test.MyInterfacePrx.ice_checkedCast(proxy, '::Test::MyInterface', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Test.MyInterfacePrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Test::MyInterface'
    _M_Test._t_MyInterfacePrx = IcePy.defineProxy('::Test::MyInterface', MyInterfacePrx)

    _M_Test.MyInterfacePrx = MyInterfacePrx
    del MyInterfacePrx

    _M_Test.MyInterface = Ice.createTempClass()
    class MyInterface(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Test::MyInterface')

        def ice_id(self, current=None):
            return '::Test::MyInterface'

        @staticmethod
        def ice_staticId():
            return '::Test::MyInterface'

        def op(self, current=None):
            raise NotImplementedError("servant method 'op' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Test._t_MyInterfaceDisp)

        __repr__ = __str__

    _M_Test._t_MyInterfaceDisp = IcePy.defineClass('::Test::MyInterface', MyInterface, (), None, ())
    MyInterface._ice_type = _M_Test._t_MyInterfaceDisp

    MyInterface._op_op = IcePy.Operation('op', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())

    _M_Test.MyInterface = MyInterface
    del MyInterface

if '_t_ProxySeq' not in _M_Test.__dict__:
    _M_Test._t_ProxySeq = IcePy.defineSequence('::Test::ProxySeq', (), _M_Test._t_MyInterfacePrx)

if 'RefStruct' not in _M_Test.__dict__:
    _M_Test.RefStruct = Ice.createTempClass()
    class RefStruct(object):
        def __init__(self, s='', sp='', c=None, p=None, seq=None):
            self.s = s
            self.sp = sp
            self.c = c
            self.p = p
            self.seq = seq

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_Test.RefStruct):
                return NotImplemented
            else:
                if self.s != other.s:
                    return False
                if self.sp != other.sp:
                    return False
                if self.c != other.c:
                    return False
                if self.p != other.p:
                    return False
                if self.seq != other.seq:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_Test._t_RefStruct)

        __repr__ = __str__

    _M_Test._t_RefStruct = IcePy.defineStruct('::Test::RefStruct', RefStruct, (), (
        ('s', (), IcePy._t_string),
        ('sp', (), IcePy._t_string),
        ('c', (), _M_Test._t_MyClass),
        ('p', (), _M_Test._t_MyInterfacePrx),
        ('seq', (), _M_Test._t_ProxySeq)
    ))

    _M_Test.RefStruct = RefStruct
    del RefStruct

if '_t_ValStructS' not in _M_Test.__dict__:
    _M_Test._t_ValStructS = IcePy.defineSequence('::Test::ValStructS', (), _M_Test._t_ValStruct)

if '_t_ValStructList' not in _M_Test.__dict__:
    _M_Test._t_ValStructList = IcePy.defineSequence('::Test::ValStructList', (), _M_Test._t_ValStruct)

if '_t_ValStructLinkedList' not in _M_Test.__dict__:
    _M_Test._t_ValStructLinkedList = IcePy.defineSequence('::Test::ValStructLinkedList', (), _M_Test._t_ValStruct)

if '_t_ValStructStack' not in _M_Test.__dict__:
    _M_Test._t_ValStructStack = IcePy.defineSequence('::Test::ValStructStack', (), _M_Test._t_ValStruct)

if '_t_ValStructQueue' not in _M_Test.__dict__:
    _M_Test._t_ValStructQueue = IcePy.defineSequence('::Test::ValStructQueue', (), _M_Test._t_ValStruct)

if '_t_IntStringD' not in _M_Test.__dict__:
    _M_Test._t_IntStringD = IcePy.defineDictionary('::Test::IntStringD', (), IcePy._t_int, IcePy._t_string)

if '_t_IntValStructD' not in _M_Test.__dict__:
    _M_Test._t_IntValStructD = IcePy.defineDictionary('::Test::IntValStructD', (), IcePy._t_int, _M_Test._t_ValStruct)

if '_t_IntProxyD' not in _M_Test.__dict__:
    _M_Test._t_IntProxyD = IcePy.defineDictionary('::Test::IntProxyD', (), IcePy._t_int, _M_Test._t_MyInterfacePrx)

if '_t_IntStringSD' not in _M_Test.__dict__:
    _M_Test._t_IntStringSD = IcePy.defineDictionary('::Test::IntStringSD', (), IcePy._t_int, IcePy._t_string)

if 'Base' not in _M_Test.__dict__:
    _M_Test.Base = Ice.createTempClass()
    class Base(Ice.Value):
        def __init__(self, bo=False, by=0, sh=0, i=0, l=0, e=_M_Test.MyEnum.enum1):
            self.bo = bo
            self.by = by
            self.sh = sh
            self.i = i
            self.l = l
            self.e = e

        def ice_id(self):
            return '::Test::Base'

        @staticmethod
        def ice_staticId():
            return '::Test::Base'

        def __str__(self):
            return IcePy.stringify(self, _M_Test._t_Base)

        __repr__ = __str__

    _M_Test._t_Base = IcePy.defineValue('::Test::Base', Base, -1, (), False, False, None, (
        ('bo', (), IcePy._t_bool, False, 0),
        ('by', (), IcePy._t_byte, False, 0),
        ('sh', (), IcePy._t_short, False, 0),
        ('i', (), IcePy._t_int, False, 0),
        ('l', (), IcePy._t_long, False, 0),
        ('e', (), _M_Test._t_MyEnum, False, 0)
    ))
    Base._ice_type = _M_Test._t_Base

    _M_Test.Base = Base
    del Base

if 'MyClass' not in _M_Test.__dict__:
    _M_Test.MyClass = Ice.createTempClass()
    class MyClass(_M_Test.Base):
        def __init__(self, bo=False, by=0, sh=0, i=0, l=0, e=_M_Test.MyEnum.enum1, c=None, o=None, s=Ice._struct_marker):
            _M_Test.Base.__init__(self, bo, by, sh, i, l, e)
            self.c = c
            self.o = o
            if s is Ice._struct_marker:
                self.s = _M_Test.ValStruct()
            else:
                self.s = s

        def ice_id(self):
            return '::Test::MyClass'

        @staticmethod
        def ice_staticId():
            return '::Test::MyClass'

        def __str__(self):
            return IcePy.stringify(self, _M_Test._t_MyClass)

        __repr__ = __str__

    _M_Test._t_MyClass = IcePy.defineValue('::Test::MyClass', MyClass, -1, (), False, False, _M_Test._t_Base, (
        ('c', (), _M_Test._t_MyClass, False, 0),
        ('o', (), IcePy._t_Value, False, 0),
        ('s', (), _M_Test._t_ValStruct, False, 0)
    ))
    MyClass._ice_type = _M_Test._t_MyClass

    _M_Test.MyClass = MyClass
    del MyClass

if 'MyException' not in _M_Test.__dict__:
    _M_Test.MyException = Ice.createTempClass()
    class MyException(Ice.UserException):
        def __init__(self, name='', b=0, s=0, i=0, l=0, vs=Ice._struct_marker, rs=Ice._struct_marker, c=None, p=None, vss=None, vsl=None, vsll=None, vssk=None, vsq=None, isd=None, ivd=None, ipd=None, issd=None, optName=Ice.Unset, optInt=Ice.Unset, optValStruct=Ice.Unset, optRefStruct=Ice.Unset, optEnum=Ice.Unset, optClass=Ice.Unset, optProxy=Ice.Unset):
            self.name = name
            self.b = b
            self.s = s
            self.i = i
            self.l = l
            if vs is Ice._struct_marker:
                self.vs = _M_Test.ValStruct()
            else:
                self.vs = vs
            if rs is Ice._struct_marker:
                self.rs = _M_Test.RefStruct()
            else:
                self.rs = rs
            self.c = c
            self.p = p
            self.vss = vss
            self.vsl = vsl
            self.vsll = vsll
            self.vssk = vssk
            self.vsq = vsq
            self.isd = isd
            self.ivd = ivd
            self.ipd = ipd
            self.issd = issd
            self.optName = optName
            self.optInt = optInt
            self.optValStruct = optValStruct
            self.optRefStruct = optRefStruct
            self.optEnum = optEnum
            self.optClass = optClass
            self.optProxy = optProxy

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Test::MyException'

    _M_Test._t_MyException = IcePy.defineException('::Test::MyException', MyException, (), False, None, (
        ('name', (), IcePy._t_string, False, 0),
        ('b', (), IcePy._t_byte, False, 0),
        ('s', (), IcePy._t_short, False, 0),
        ('i', (), IcePy._t_int, False, 0),
        ('l', (), IcePy._t_long, False, 0),
        ('vs', (), _M_Test._t_ValStruct, False, 0),
        ('rs', (), _M_Test._t_RefStruct, False, 0),
        ('c', (), _M_Test._t_MyClass, False, 0),
        ('p', (), _M_Test._t_MyInterfacePrx, False, 0),
        ('vss', (), _M_Test._t_ValStructS, False, 0),
        ('vsl', (), _M_Test._t_ValStructList, False, 0),
        ('vsll', (), _M_Test._t_ValStructLinkedList, False, 0),
        ('vssk', (), _M_Test._t_ValStructStack, False, 0),
        ('vsq', (), _M_Test._t_ValStructQueue, False, 0),
        ('isd', (), _M_Test._t_IntStringD, False, 0),
        ('ivd', (), _M_Test._t_IntValStructD, False, 0),
        ('ipd', (), _M_Test._t_IntProxyD, False, 0),
        ('issd', (), _M_Test._t_IntStringSD, False, 0),
        ('optName', (), IcePy._t_string, True, 1),
        ('optInt', (), IcePy._t_int, True, 2),
        ('optValStruct', (), _M_Test._t_ValStruct, True, 3),
        ('optRefStruct', (), _M_Test._t_RefStruct, True, 4),
        ('optEnum', (), _M_Test._t_MyEnum, True, 5),
        ('optClass', (), _M_Test._t_MyClass, True, 6),
        ('optProxy', (), _M_Test._t_MyInterfacePrx, True, 7)
    ))
    MyException._ice_type = _M_Test._t_MyException

    _M_Test.MyException = MyException
    del MyException

# End of module Test
