# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.10
#
# <auto-generated>
#
# Generated from file `Test.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

import Ice, IcePy
import Ice.BuiltinSequences_ice

# Included module Ice
_M_Ice = Ice.openModule('Ice')

# Start of module Test
_M_Test = Ice.openModule('Test')
__name__ = 'Test'

if 'MyEnum' not in _M_Test.__dict__:
    _M_Test.MyEnum = Ice.createTempClass()
    class MyEnum(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    MyEnum.enum1 = MyEnum("enum1", 0)
    MyEnum.enum2 = MyEnum("enum2", 1)
    MyEnum.enum3 = MyEnum("enum3", 2)
    MyEnum._enumerators = { 0:MyEnum.enum1, 1:MyEnum.enum2, 2:MyEnum.enum3 }

    _M_Test._t_MyEnum = IcePy.defineEnum('::Test::MyEnum', MyEnum, (), MyEnum._enumerators)

    _M_Test.MyEnum = MyEnum
    del MyEnum

if 'MyClass' not in _M_Test.__dict__:
    _M_Test._t_MyClass = IcePy.declareValue('::Test::MyClass')

if 'MyInterface' not in _M_Test.__dict__:
    _M_Test._t_MyInterfaceDisp = IcePy.declareClass('::Test::MyInterface')
    _M_Test._t_MyInterfacePrx = IcePy.declareProxy('::Test::MyInterface')

if 'SmallStruct' not in _M_Test.__dict__:
    _M_Test.SmallStruct = Ice.createTempClass()
    class SmallStruct(object):
        def __init__(self, bo=False, by=0, sh=0, i=0, l=0, f=0.0, d=0.0, str='', e=_M_Test.MyEnum.enum1, p=None):
            self.bo = bo
            self.by = by
            self.sh = sh
            self.i = i
            self.l = l
            self.f = f
            self.d = d
            self.str = str
            self.e = e
            self.p = p

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_Test.SmallStruct):
                return NotImplemented
            else:
                if self.bo != other.bo:
                    return False
                if self.by != other.by:
                    return False
                if self.sh != other.sh:
                    return False
                if self.i != other.i:
                    return False
                if self.l != other.l:
                    return False
                if self.f != other.f:
                    return False
                if self.d != other.d:
                    return False
                if self.str != other.str:
                    return False
                if self.e != other.e:
                    return False
                if self.p != other.p:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_Test._t_SmallStruct)

        __repr__ = __str__

    _M_Test._t_SmallStruct = IcePy.defineStruct('::Test::SmallStruct', SmallStruct, (), (
        ('bo', (), IcePy._t_bool),
        ('by', (), IcePy._t_byte),
        ('sh', (), IcePy._t_short),
        ('i', (), IcePy._t_int),
        ('l', (), IcePy._t_long),
        ('f', (), IcePy._t_float),
        ('d', (), IcePy._t_double),
        ('str', (), IcePy._t_string),
        ('e', (), _M_Test._t_MyEnum),
        ('p', (), _M_Test._t_MyInterfacePrx)
    ))

    _M_Test.SmallStruct = SmallStruct
    del SmallStruct

if 'OptionalClass' not in _M_Test.__dict__:
    _M_Test.OptionalClass = Ice.createTempClass()
    class OptionalClass(Ice.Value):
        def __init__(self, bo=False, by=0, sh=Ice.Unset, i=Ice.Unset):
            self.bo = bo
            self.by = by
            self.sh = sh
            self.i = i

        def ice_id(self):
            return '::Test::OptionalClass'

        @staticmethod
        def ice_staticId():
            return '::Test::OptionalClass'

        def __str__(self):
            return IcePy.stringify(self, _M_Test._t_OptionalClass)

        __repr__ = __str__

    _M_Test._t_OptionalClass = IcePy.defineValue('::Test::OptionalClass', OptionalClass, -1, (), False, False, None, (
        ('bo', (), IcePy._t_bool, False, 0),
        ('by', (), IcePy._t_byte, False, 0),
        ('sh', (), IcePy._t_short, True, 1),
        ('i', (), IcePy._t_int, True, 2)
    ))
    OptionalClass._ice_type = _M_Test._t_OptionalClass

    _M_Test.OptionalClass = OptionalClass
    del OptionalClass

if '_t_MyEnumS' not in _M_Test.__dict__:
    _M_Test._t_MyEnumS = IcePy.defineSequence('::Test::MyEnumS', (), _M_Test._t_MyEnum)

if '_t_MyClassS' not in _M_Test.__dict__:
    _M_Test._t_MyClassS = IcePy.defineSequence('::Test::MyClassS', (), _M_Test._t_MyClass)

if '_t_BoolSS' not in _M_Test.__dict__:
    _M_Test._t_BoolSS = IcePy.defineSequence('::Test::BoolSS', (), _M_Ice._t_BoolSeq)

if '_t_ByteSS' not in _M_Test.__dict__:
    _M_Test._t_ByteSS = IcePy.defineSequence('::Test::ByteSS', (), _M_Ice._t_ByteSeq)

if '_t_ShortSS' not in _M_Test.__dict__:
    _M_Test._t_ShortSS = IcePy.defineSequence('::Test::ShortSS', (), _M_Ice._t_ShortSeq)

if '_t_IntSS' not in _M_Test.__dict__:
    _M_Test._t_IntSS = IcePy.defineSequence('::Test::IntSS', (), _M_Ice._t_IntSeq)

if '_t_LongSS' not in _M_Test.__dict__:
    _M_Test._t_LongSS = IcePy.defineSequence('::Test::LongSS', (), _M_Ice._t_LongSeq)

if '_t_FloatSS' not in _M_Test.__dict__:
    _M_Test._t_FloatSS = IcePy.defineSequence('::Test::FloatSS', (), _M_Ice._t_FloatSeq)

if '_t_DoubleSS' not in _M_Test.__dict__:
    _M_Test._t_DoubleSS = IcePy.defineSequence('::Test::DoubleSS', (), _M_Ice._t_DoubleSeq)

if '_t_StringSS' not in _M_Test.__dict__:
    _M_Test._t_StringSS = IcePy.defineSequence('::Test::StringSS', (), _M_Ice._t_StringSeq)

if '_t_MyEnumSS' not in _M_Test.__dict__:
    _M_Test._t_MyEnumSS = IcePy.defineSequence('::Test::MyEnumSS', (), _M_Test._t_MyEnumS)

if '_t_MyClassSS' not in _M_Test.__dict__:
    _M_Test._t_MyClassSS = IcePy.defineSequence('::Test::MyClassSS', (), _M_Test._t_MyClassS)

if '_t_ByteBoolD' not in _M_Test.__dict__:
    _M_Test._t_ByteBoolD = IcePy.defineDictionary('::Test::ByteBoolD', (), IcePy._t_byte, IcePy._t_bool)

if '_t_ShortIntD' not in _M_Test.__dict__:
    _M_Test._t_ShortIntD = IcePy.defineDictionary('::Test::ShortIntD', (), IcePy._t_short, IcePy._t_int)

if '_t_LongFloatD' not in _M_Test.__dict__:
    _M_Test._t_LongFloatD = IcePy.defineDictionary('::Test::LongFloatD', (), IcePy._t_long, IcePy._t_float)

if '_t_StringStringD' not in _M_Test.__dict__:
    _M_Test._t_StringStringD = IcePy.defineDictionary('::Test::StringStringD', (), IcePy._t_string, IcePy._t_string)

if '_t_StringMyClassD' not in _M_Test.__dict__:
    _M_Test._t_StringMyClassD = IcePy.defineDictionary('::Test::StringMyClassD', (), IcePy._t_string, _M_Test._t_MyClass)

if '_t_BoolList' not in _M_Test.__dict__:
    _M_Test._t_BoolList = IcePy.defineSequence('::Test::BoolList', (), IcePy._t_bool)

if '_t_ByteList' not in _M_Test.__dict__:
    _M_Test._t_ByteList = IcePy.defineSequence('::Test::ByteList', (), IcePy._t_byte)

if '_t_MyEnumList' not in _M_Test.__dict__:
    _M_Test._t_MyEnumList = IcePy.defineSequence('::Test::MyEnumList', (), _M_Test._t_MyEnum)

if '_t_SmallStructList' not in _M_Test.__dict__:
    _M_Test._t_SmallStructList = IcePy.defineSequence('::Test::SmallStructList', (), _M_Test._t_SmallStruct)

if '_t_MyClassList' not in _M_Test.__dict__:
    _M_Test._t_MyClassList = IcePy.defineSequence('::Test::MyClassList', (), _M_Test._t_MyClass)

if '_t_MyInterfaceProxyList' not in _M_Test.__dict__:
    _M_Test._t_MyInterfaceProxyList = IcePy.defineSequence('::Test::MyInterfaceProxyList', (), _M_Test._t_MyInterfacePrx)

if '_t_ShortLinkedList' not in _M_Test.__dict__:
    _M_Test._t_ShortLinkedList = IcePy.defineSequence('::Test::ShortLinkedList', (), IcePy._t_short)

if '_t_IntLinkedList' not in _M_Test.__dict__:
    _M_Test._t_IntLinkedList = IcePy.defineSequence('::Test::IntLinkedList', (), IcePy._t_int)

if '_t_MyEnumLinkedList' not in _M_Test.__dict__:
    _M_Test._t_MyEnumLinkedList = IcePy.defineSequence('::Test::MyEnumLinkedList', (), _M_Test._t_MyEnum)

if '_t_SmallStructLinkedList' not in _M_Test.__dict__:
    _M_Test._t_SmallStructLinkedList = IcePy.defineSequence('::Test::SmallStructLinkedList', (), _M_Test._t_SmallStruct)

if '_t_LongStack' not in _M_Test.__dict__:
    _M_Test._t_LongStack = IcePy.defineSequence('::Test::LongStack', (), IcePy._t_long)

if '_t_FloatStack' not in _M_Test.__dict__:
    _M_Test._t_FloatStack = IcePy.defineSequence('::Test::FloatStack', (), IcePy._t_float)

if '_t_SmallStructStack' not in _M_Test.__dict__:
    _M_Test._t_SmallStructStack = IcePy.defineSequence('::Test::SmallStructStack', (), _M_Test._t_SmallStruct)

if '_t_MyInterfaceProxyStack' not in _M_Test.__dict__:
    _M_Test._t_MyInterfaceProxyStack = IcePy.defineSequence('::Test::MyInterfaceProxyStack', (), _M_Test._t_MyInterfacePrx)

if '_t_ObjectStack' not in _M_Test.__dict__:
    _M_Test._t_ObjectStack = IcePy.defineSequence('::Test::ObjectStack', (), IcePy._t_Value)

if '_t_MyClassStack' not in _M_Test.__dict__:
    _M_Test._t_MyClassStack = IcePy.defineSequence('::Test::MyClassStack', (), _M_Test._t_MyClass)

if '_t_DoubleQueue' not in _M_Test.__dict__:
    _M_Test._t_DoubleQueue = IcePy.defineSequence('::Test::DoubleQueue', (), IcePy._t_double)

if '_t_StringQueue' not in _M_Test.__dict__:
    _M_Test._t_StringQueue = IcePy.defineSequence('::Test::StringQueue', (), IcePy._t_string)

if '_t_SmallStructQueue' not in _M_Test.__dict__:
    _M_Test._t_SmallStructQueue = IcePy.defineSequence('::Test::SmallStructQueue', (), _M_Test._t_SmallStruct)

if '_t_StringSList' not in _M_Test.__dict__:
    _M_Test._t_StringSList = IcePy.defineSequence('::Test::StringSList', (), _M_Ice._t_StringSeq)

if '_t_StringSStack' not in _M_Test.__dict__:
    _M_Test._t_StringSStack = IcePy.defineSequence('::Test::StringSStack', (), _M_Ice._t_StringSeq)

if '_t_SortedStringStringD' not in _M_Test.__dict__:
    _M_Test._t_SortedStringStringD = IcePy.defineDictionary('::Test::SortedStringStringD', (), IcePy._t_string, IcePy._t_string)

if 'MyClass' not in _M_Test.__dict__:
    _M_Test.MyClass = Ice.createTempClass()
    class MyClass(Ice.Value):
        def __init__(self, c=None, o=None, s=Ice._struct_marker, seq1=None, seq2=None, seq3=None, seq4=None, seq5=None, seq6=None, seq7=None, seq8=None, seq9=None, seq10=None, d=None):
            self.c = c
            self.o = o
            if s is Ice._struct_marker:
                self.s = _M_Test.SmallStruct()
            else:
                self.s = s
            self.seq1 = seq1
            self.seq2 = seq2
            self.seq3 = seq3
            self.seq4 = seq4
            self.seq5 = seq5
            self.seq6 = seq6
            self.seq7 = seq7
            self.seq8 = seq8
            self.seq9 = seq9
            self.seq10 = seq10
            self.d = d

        def ice_id(self):
            return '::Test::MyClass'

        @staticmethod
        def ice_staticId():
            return '::Test::MyClass'

        def __str__(self):
            return IcePy.stringify(self, _M_Test._t_MyClass)

        __repr__ = __str__

    _M_Test._t_MyClass = IcePy.defineValue('::Test::MyClass', MyClass, -1, (), False, False, None, (
        ('c', (), _M_Test._t_MyClass, False, 0),
        ('o', (), IcePy._t_Value, False, 0),
        ('s', (), _M_Test._t_SmallStruct, False, 0),
        ('seq1', (), _M_Ice._t_BoolSeq, False, 0),
        ('seq2', (), _M_Ice._t_ByteSeq, False, 0),
        ('seq3', (), _M_Ice._t_ShortSeq, False, 0),
        ('seq4', (), _M_Ice._t_IntSeq, False, 0),
        ('seq5', (), _M_Ice._t_LongSeq, False, 0),
        ('seq6', (), _M_Ice._t_FloatSeq, False, 0),
        ('seq7', (), _M_Ice._t_DoubleSeq, False, 0),
        ('seq8', (), _M_Ice._t_StringSeq, False, 0),
        ('seq9', (), _M_Test._t_MyEnumS, False, 0),
        ('seq10', (), _M_Test._t_MyClassS, False, 0),
        ('d', (), _M_Test._t_StringMyClassD, False, 0)
    ))
    MyClass._ice_type = _M_Test._t_MyClass

    _M_Test.MyClass = MyClass
    del MyClass

if 'MyException' not in _M_Test.__dict__:
    _M_Test.MyException = Ice.createTempClass()
    class MyException(Ice.UserException):
        def __init__(self, c=None):
            self.c = c

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Test::MyException'

    _M_Test._t_MyException = IcePy.defineException('::Test::MyException', MyException, (), False, None, (('c', (), _M_Test._t_MyClass, False, 0),))
    MyException._ice_type = _M_Test._t_MyException

    _M_Test.MyException = MyException
    del MyException

_M_Test._t_MyInterface = IcePy.defineValue('::Test::MyInterface', Ice.Value, -1, (), False, True, None, ())

if 'MyInterfacePrx' not in _M_Test.__dict__:
    _M_Test.MyInterfacePrx = Ice.createTempClass()
    class MyInterfacePrx(Ice.ObjectPrx):

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Test.MyInterfacePrx.ice_checkedCast(proxy, '::Test::MyInterface', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Test.MyInterfacePrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Test::MyInterface'
    _M_Test._t_MyInterfacePrx = IcePy.defineProxy('::Test::MyInterface', MyInterfacePrx)

    _M_Test.MyInterfacePrx = MyInterfacePrx
    del MyInterfacePrx

    _M_Test.MyInterface = Ice.createTempClass()
    class MyInterface(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Test::MyInterface')

        def ice_id(self, current=None):
            return '::Test::MyInterface'

        @staticmethod
        def ice_staticId():
            return '::Test::MyInterface'

        def __str__(self):
            return IcePy.stringify(self, _M_Test._t_MyInterfaceDisp)

        __repr__ = __str__

    _M_Test._t_MyInterfaceDisp = IcePy.defineClass('::Test::MyInterface', MyInterface, (), None, ())
    MyInterface._ice_type = _M_Test._t_MyInterfaceDisp

    _M_Test.MyInterface = MyInterface
    del MyInterface

# End of module Test
