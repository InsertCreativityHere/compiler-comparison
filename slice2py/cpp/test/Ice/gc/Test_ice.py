# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.9
#
# <auto-generated>
#
# Generated from file `Test.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

from sys import version_info as _version_info_
import Ice, IcePy

# Start of module Test
_M_Test = Ice.openModule('Test')
__name__ = 'Test'

if 'C' not in _M_Test.__dict__:
    _M_Test.C = Ice.createTempClass()
    class C(Ice.Value):
        def __init__(self, left=None, right=None):
            self.left = left
            self.right = right

        def ice_id(self):
            return '::Test::C'

        @staticmethod
        def ice_staticId():
            return '::Test::C'

        def __str__(self):
            return IcePy.stringify(self, _M_Test._t_C)

        __repr__ = __str__

    _M_Test._t_C = IcePy.declareValue('::Test::C')

    _M_Test._t_C = IcePy.defineValue('::Test::C', C, -1, (), False, False, None, (
        ('left', (), _M_Test._t_C, False, 0),
        ('right', (), _M_Test._t_C, False, 0)
    ))
    C._ice_type = _M_Test._t_C

    _M_Test.C = C
    del C

if '_t_CSeq' not in _M_Test.__dict__:
    _M_Test._t_CSeq = IcePy.defineSequence('::Test::CSeq', (), _M_Test._t_C)

if '_t_CDict' not in _M_Test.__dict__:
    _M_Test._t_CDict = IcePy.defineDictionary('::Test::CDict', (), IcePy._t_int, _M_Test._t_C)

if 'S' not in _M_Test.__dict__:
    _M_Test.S = Ice.createTempClass()
    class S(object):
        def __init__(self, theC=None):
            self.theC = theC

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_Test.S):
                return NotImplemented
            else:
                if self.theC != other.theC:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_Test._t_S)

        __repr__ = __str__

    _M_Test._t_S = IcePy.defineStruct('::Test::S', S, (), (('theC', (), _M_Test._t_C),))

    _M_Test.S = S
    del S

if '_t_SSeq' not in _M_Test.__dict__:
    _M_Test._t_SSeq = IcePy.defineSequence('::Test::SSeq', (), _M_Test._t_S)

if 'C2' not in _M_Test.__dict__:
    _M_Test._t_C2 = IcePy.declareValue('::Test::C2')

if '_t_C2Dict' not in _M_Test.__dict__:
    _M_Test._t_C2Dict = IcePy.defineDictionary('::Test::C2Dict', (), IcePy._t_int, _M_Test._t_C2)

if 'S2' not in _M_Test.__dict__:
    _M_Test.S2 = Ice.createTempClass()
    class S2(object):
        def __init__(self, theC2Dict=None):
            self.theC2Dict = theC2Dict

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_Test.S2):
                return NotImplemented
            else:
                if self.theC2Dict != other.theC2Dict:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_Test._t_S2)

        __repr__ = __str__

    _M_Test._t_S2 = IcePy.defineStruct('::Test::S2', S2, (), (('theC2Dict', (), _M_Test._t_C2Dict),))

    _M_Test.S2 = S2
    del S2

if '_t_S2Seq' not in _M_Test.__dict__:
    _M_Test._t_S2Seq = IcePy.defineSequence('::Test::S2Seq', (), _M_Test._t_S2)

if 'C2' not in _M_Test.__dict__:
    _M_Test.C2 = Ice.createTempClass()
    class C2(Ice.Value):
        def __init__(self, theS2Seq=None):
            self.theS2Seq = theS2Seq

        def ice_id(self):
            return '::Test::C2'

        @staticmethod
        def ice_staticId():
            return '::Test::C2'

        def __str__(self):
            return IcePy.stringify(self, _M_Test._t_C2)

        __repr__ = __str__

    _M_Test._t_C2 = IcePy.defineValue('::Test::C2', C2, -1, (), False, False, None, (('theS2Seq', (), _M_Test._t_S2Seq, False, 0),))
    C2._ice_type = _M_Test._t_C2

    _M_Test.C2 = C2
    del C2

if 'Leaf' not in _M_Test.__dict__:
    _M_Test.Leaf = Ice.createTempClass()
    class Leaf(Ice.Value):
        def __init__(self, i=0):
            self.i = i

        def ice_id(self):
            return '::Test::Leaf'

        @staticmethod
        def ice_staticId():
            return '::Test::Leaf'

        def __str__(self):
            return IcePy.stringify(self, _M_Test._t_Leaf)

        __repr__ = __str__

    _M_Test._t_Leaf = IcePy.defineValue('::Test::Leaf', Leaf, -1, (), False, False, None, (('i', (), IcePy._t_int, False, 0),))
    Leaf._ice_type = _M_Test._t_Leaf

    _M_Test.Leaf = Leaf
    del Leaf

if 'Node' not in _M_Test.__dict__:
    _M_Test.Node = Ice.createTempClass()
    class Node(Ice.Value):
        def __init__(self, l=None, n=None):
            self.l = l
            self.n = n

        def ice_id(self):
            return '::Test::Node'

        @staticmethod
        def ice_staticId():
            return '::Test::Node'

        def __str__(self):
            return IcePy.stringify(self, _M_Test._t_Node)

        __repr__ = __str__

    _M_Test._t_Node = IcePy.declareValue('::Test::Node')

    _M_Test._t_Node = IcePy.defineValue('::Test::Node', Node, -1, (), False, False, None, (
        ('l', (), _M_Test._t_Leaf, False, 0),
        ('n', (), _M_Test._t_Node, False, 0)
    ))
    Node._ice_type = _M_Test._t_Node

    _M_Test.Node = Node
    del Node

if '_t_C2DictSeq' not in _M_Test.__dict__:
    _M_Test._t_C2DictSeq = IcePy.defineSequence('::Test::C2DictSeq', (), _M_Test._t_C2Dict)

if '_t_CSeqSeq' not in _M_Test.__dict__:
    _M_Test._t_CSeqSeq = IcePy.defineSequence('::Test::CSeqSeq', (), _M_Test._t_CSeq)

if 'A' not in _M_Test.__dict__:
    _M_Test.A = Ice.createTempClass()
    class A(object):
        def __init__(self, theSSeq=None):
            self.theSSeq = theSSeq

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_Test.A):
                return NotImplemented
            else:
                if self.theSSeq != other.theSSeq:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_Test._t_A)

        __repr__ = __str__

    _M_Test._t_A = IcePy.defineStruct('::Test::A', A, (), (('theSSeq', (), _M_Test._t_SSeq),))

    _M_Test.A = A
    del A

if 'B' not in _M_Test.__dict__:
    _M_Test.B = Ice.createTempClass()
    class B(object):
        def __init__(self, theS=Ice._struct_marker):
            if theS is Ice._struct_marker:
                self.theS = _M_Test.S()
            else:
                self.theS = theS

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_Test.B):
                return NotImplemented
            else:
                if self.theS != other.theS:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_Test._t_B)

        __repr__ = __str__

    _M_Test._t_B = IcePy.defineStruct('::Test::B', B, (), (('theS', (), _M_Test._t_S),))

    _M_Test.B = B
    del B

if '_t_CSeqDict' not in _M_Test.__dict__:
    _M_Test._t_CSeqDict = IcePy.defineDictionary('::Test::CSeqDict', (), IcePy._t_int, _M_Test._t_CSeq)

if '_t_SDict' not in _M_Test.__dict__:
    _M_Test._t_SDict = IcePy.defineDictionary('::Test::SDict', (), IcePy._t_int, _M_Test._t_S)

if '_t_CDictDict' not in _M_Test.__dict__:
    _M_Test._t_CDictDict = IcePy.defineDictionary('::Test::CDictDict', (), IcePy._t_int, _M_Test._t_CDict)

if 'CTest' not in _M_Test.__dict__:
    _M_Test.CTest = Ice.createTempClass()
    class CTest(Ice.Value):
        def __init__(self, theCSeq=None, theSSeq=None, theC2DictSeq=None, theCSeqSeq=None, theS=Ice._struct_marker, theA=Ice._struct_marker, theS2=Ice._struct_marker, theB=Ice._struct_marker, theCDict=None, theCSeqDict=None, theSDict=None, theCDictDict=None):
            self.theCSeq = theCSeq
            self.theSSeq = theSSeq
            self.theC2DictSeq = theC2DictSeq
            self.theCSeqSeq = theCSeqSeq
            if theS is Ice._struct_marker:
                self.theS = _M_Test.S()
            else:
                self.theS = theS
            if theA is Ice._struct_marker:
                self.theA = _M_Test.A()
            else:
                self.theA = theA
            if theS2 is Ice._struct_marker:
                self.theS2 = _M_Test.S2()
            else:
                self.theS2 = theS2
            if theB is Ice._struct_marker:
                self.theB = _M_Test.B()
            else:
                self.theB = theB
            self.theCDict = theCDict
            self.theCSeqDict = theCSeqDict
            self.theSDict = theSDict
            self.theCDictDict = theCDictDict

        def ice_id(self):
            return '::Test::CTest'

        @staticmethod
        def ice_staticId():
            return '::Test::CTest'

        def __str__(self):
            return IcePy.stringify(self, _M_Test._t_CTest)

        __repr__ = __str__

    _M_Test._t_CTest = IcePy.declareValue('::Test::CTest')

    _M_Test._t_CTest = IcePy.defineValue('::Test::CTest', CTest, -1, (), False, False, None, (
        ('theCSeq', (), _M_Test._t_CSeq, False, 0),
        ('theSSeq', (), _M_Test._t_SSeq, False, 0),
        ('theC2DictSeq', (), _M_Test._t_C2DictSeq, False, 0),
        ('theCSeqSeq', (), _M_Test._t_CSeqSeq, False, 0),
        ('theS', (), _M_Test._t_S, False, 0),
        ('theA', (), _M_Test._t_A, False, 0),
        ('theS2', (), _M_Test._t_S2, False, 0),
        ('theB', (), _M_Test._t_B, False, 0),
        ('theCDict', (), _M_Test._t_CDict, False, 0),
        ('theCSeqDict', (), _M_Test._t_CSeqDict, False, 0),
        ('theSDict', (), _M_Test._t_SDict, False, 0),
        ('theCDictDict', (), _M_Test._t_CDictDict, False, 0)
    ))
    CTest._ice_type = _M_Test._t_CTest

    _M_Test.CTest = CTest
    del CTest

# Start of module Test.AAA
_M_Test.AAA = Ice.openModule('Test.AAA')
__name__ = 'Test.AAA'

if 'B' not in _M_Test.AAA.__dict__:
    _M_Test.AAA._t_B = IcePy.declareValue('::Test::AAA::B')

if '_t_BSeq' not in _M_Test.AAA.__dict__:
    _M_Test.AAA._t_BSeq = IcePy.defineSequence('::Test::AAA::BSeq', (), _M_Test.AAA._t_B)

if '_t_BDict' not in _M_Test.AAA.__dict__:
    _M_Test.AAA._t_BDict = IcePy.defineDictionary('::Test::AAA::BDict', (), IcePy._t_int, _M_Test.AAA._t_B)

if 'BStruct' not in _M_Test.AAA.__dict__:
    _M_Test.AAA.BStruct = Ice.createTempClass()
    class BStruct(object):
        def __init__(self, bMem=None):
            self.bMem = bMem

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_Test.AAA.BStruct):
                return NotImplemented
            else:
                if self.bMem != other.bMem:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_Test.AAA._t_BStruct)

        __repr__ = __str__

    _M_Test.AAA._t_BStruct = IcePy.defineStruct('::Test::AAA::BStruct', BStruct, (), (('bMem', (), _M_Test.AAA._t_B),))

    _M_Test.AAA.BStruct = BStruct
    del BStruct

if 'C' not in _M_Test.AAA.__dict__:
    _M_Test.AAA.C = Ice.createTempClass()
    class C(Ice.Value):
        def __init__(self, obj1=None, obj2=None, b1=None, b2=None, x=None, y=None, z=Ice._struct_marker):
            self.obj1 = obj1
            self.obj2 = obj2
            self.b1 = b1
            self.b2 = b2
            self.x = x
            self.y = y
            if z is Ice._struct_marker:
                self.z = _M_Test.AAA.BStruct()
            else:
                self.z = z

        def ice_id(self):
            return '::Test::AAA::C'

        @staticmethod
        def ice_staticId():
            return '::Test::AAA::C'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.AAA._t_C)

        __repr__ = __str__

    _M_Test.AAA._t_C = IcePy.declareValue('::Test::AAA::C')

    _M_Test.AAA._t_C = IcePy.defineValue('::Test::AAA::C', C, -1, (), False, False, None, (
        ('obj1', (), IcePy._t_Value, False, 0),
        ('obj2', (), IcePy._t_Value, False, 0),
        ('b1', (), _M_Test.AAA._t_B, False, 0),
        ('b2', (), _M_Test.AAA._t_B, False, 0),
        ('x', (), _M_Test.AAA._t_BSeq, False, 0),
        ('y', (), _M_Test.AAA._t_BDict, False, 0),
        ('z', (), _M_Test.AAA._t_BStruct, False, 0)
    ))
    C._ice_type = _M_Test.AAA._t_C

    _M_Test.AAA.C = C
    del C

# End of module Test.AAA

__name__ = 'Test'

# Start of module Test.AAA
__name__ = 'Test.AAA'

if '_t_CSeq' not in _M_Test.AAA.__dict__:
    _M_Test.AAA._t_CSeq = IcePy.defineSequence('::Test::AAA::CSeq', (), _M_Test.AAA._t_C)

if '_t_CDict' not in _M_Test.AAA.__dict__:
    _M_Test.AAA._t_CDict = IcePy.defineDictionary('::Test::AAA::CDict', (), IcePy._t_int, _M_Test.AAA._t_C)

if 'CStruct' not in _M_Test.AAA.__dict__:
    _M_Test.AAA.CStruct = Ice.createTempClass()
    class CStruct(object):
        def __init__(self, cMem=None):
            self.cMem = cMem

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_Test.AAA.CStruct):
                return NotImplemented
            else:
                if self.cMem != other.cMem:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_Test.AAA._t_CStruct)

        __repr__ = __str__

    _M_Test.AAA._t_CStruct = IcePy.defineStruct('::Test::AAA::CStruct', CStruct, (), (('cMem', (), _M_Test.AAA._t_C),))

    _M_Test.AAA.CStruct = CStruct
    del CStruct

if 'B' not in _M_Test.AAA.__dict__:
    _M_Test.AAA.B = Ice.createTempClass()
    class B(Ice.Value):
        def __init__(self, obj1=None, obj2=None, c1=None, c2=None, x=None, y=None, z=Ice._struct_marker):
            self.obj1 = obj1
            self.obj2 = obj2
            self.c1 = c1
            self.c2 = c2
            self.x = x
            self.y = y
            if z is Ice._struct_marker:
                self.z = _M_Test.AAA.CStruct()
            else:
                self.z = z

        def ice_id(self):
            return '::Test::AAA::B'

        @staticmethod
        def ice_staticId():
            return '::Test::AAA::B'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.AAA._t_B)

        __repr__ = __str__

    _M_Test.AAA._t_B = IcePy.defineValue('::Test::AAA::B', B, -1, (), False, False, None, (
        ('obj1', (), IcePy._t_Value, False, 0),
        ('obj2', (), IcePy._t_Value, False, 0),
        ('c1', (), _M_Test.AAA._t_C, False, 0),
        ('c2', (), _M_Test.AAA._t_C, False, 0),
        ('x', (), _M_Test.AAA._t_CSeq, False, 0),
        ('y', (), _M_Test.AAA._t_CDict, False, 0),
        ('z', (), _M_Test.AAA._t_CStruct, False, 0)
    ))
    B._ice_type = _M_Test.AAA._t_B

    _M_Test.AAA.B = B
    del B

# End of module Test.AAA

__name__ = 'Test'

# Start of module Test.CCC
_M_Test.CCC = Ice.openModule('Test.CCC')
__name__ = 'Test.CCC'

if 'Forward' not in _M_Test.CCC.__dict__:
    _M_Test.CCC._t_Forward = IcePy.declareValue('::Test::CCC::Forward')

if '_t_ForwardProxySeq' not in _M_Test.CCC.__dict__:
    _M_Test.CCC._t_ForwardProxySeq = IcePy.defineSequence('::Test::CCC::ForwardProxySeq', (), IcePy._t_ObjectPrx)

# End of module Test.CCC

__name__ = 'Test'

# Start of module Test.CCC
__name__ = 'Test.CCC'

if 'Forward' not in _M_Test.CCC.__dict__:
    _M_Test.CCC.Forward = Ice.createTempClass()
    class Forward(Ice.Value):
        def __init__(self):
            pass

        def ice_id(self):
            return '::Test::CCC::Forward'

        @staticmethod
        def ice_staticId():
            return '::Test::CCC::Forward'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.CCC._t_Forward)

        __repr__ = __str__

    _M_Test.CCC._t_Forward = IcePy.defineValue('::Test::CCC::Forward', Forward, -1, (), False, False, None, ())
    Forward._ice_type = _M_Test.CCC._t_Forward

    _M_Test.CCC.Forward = Forward
    del Forward

# End of module Test.CCC

__name__ = 'Test'

# Start of module Test.DDD
_M_Test.DDD = Ice.openModule('Test.DDD')
__name__ = 'Test.DDD'

_M_Test.DDD._t_I = IcePy.defineValue('::Test::DDD::I', Ice.Value, -1, (), False, True, None, ())

if 'IPrx' not in _M_Test.DDD.__dict__:
    _M_Test.DDD.IPrx = Ice.createTempClass()
    class IPrx(Ice.ObjectPrx):

        def op(self, context=None):
            return _M_Test.DDD.I._op_op.invoke(self, ((), context))

        def opAsync(self, context=None):
            return _M_Test.DDD.I._op_op.invokeAsync(self, ((), context))

        def begin_op(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Test.DDD.I._op_op.begin(self, ((), _response, _ex, _sent, context))

        def end_op(self, _r):
            return _M_Test.DDD.I._op_op.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Test.DDD.IPrx.ice_checkedCast(proxy, '::Test::DDD::I', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Test.DDD.IPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Test::DDD::I'
    _M_Test.DDD._t_IPrx = IcePy.defineProxy('::Test::DDD::I', IPrx)

    _M_Test.DDD.IPrx = IPrx
    del IPrx

    _M_Test.DDD.I = Ice.createTempClass()
    class I(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Test::DDD::I')

        def ice_id(self, current=None):
            return '::Test::DDD::I'

        @staticmethod
        def ice_staticId():
            return '::Test::DDD::I'

        def op(self, current=None):
            raise NotImplementedError("servant method 'op' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Test.DDD._t_IDisp)

        __repr__ = __str__

    _M_Test.DDD._t_IDisp = IcePy.defineClass('::Test::DDD::I', I, (), None, ())
    I._ice_type = _M_Test.DDD._t_IDisp

    I._op_op = IcePy.Operation('op', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())

    _M_Test.DDD.I = I
    del I

if 'C' not in _M_Test.DDD.__dict__:
    _M_Test.DDD.C = Ice.createTempClass()
    class C(Ice.Value):
        def __init__(self):
            pass

        def ice_id(self):
            return '::Test::DDD::C'

        @staticmethod
        def ice_staticId():
            return '::Test::DDD::C'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.DDD._t_C)

        __repr__ = __str__

    _M_Test.DDD._t_C = IcePy.defineValue('::Test::DDD::C', C, -1, (), False, False, None, ())
    C._ice_type = _M_Test.DDD._t_C

    _M_Test.DDD.C = C
    del C

if 'C2' not in _M_Test.DDD.__dict__:
    _M_Test.DDD._t_C2 = IcePy.declareValue('::Test::DDD::C2')

if 'U' not in _M_Test.DDD.__dict__:
    _M_Test.DDD.U = Ice.createTempClass()
    class U(Ice.Value):
        def __init__(self, myI=None, myIstar=None, myC=None, myCstar=None, myC2=None, myC2star=None):
            self.myI = myI
            self.myIstar = myIstar
            self.myC = myC
            self.myCstar = myCstar
            self.myC2 = myC2
            self.myC2star = myC2star

        def ice_id(self):
            return '::Test::DDD::U'

        @staticmethod
        def ice_staticId():
            return '::Test::DDD::U'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.DDD._t_U)

        __repr__ = __str__

    _M_Test.DDD._t_U = IcePy.declareValue('::Test::DDD::U')

    _M_Test.DDD._t_U = IcePy.defineValue('::Test::DDD::U', U, -1, (), False, False, None, (
        ('myI', (), _M_Test.DDD._t_I, False, 0),
        ('myIstar', (), _M_Test.DDD._t_IPrx, False, 0),
        ('myC', (), _M_Test.DDD._t_C, False, 0),
        ('myCstar', (), IcePy._t_ObjectPrx, False, 0),
        ('myC2', (), _M_Test.DDD._t_C2, False, 0),
        ('myC2star', (), IcePy._t_ObjectPrx, False, 0)
    ))
    U._ice_type = _M_Test.DDD._t_U

    _M_Test.DDD.U = U
    del U

if 'C2' not in _M_Test.DDD.__dict__:
    _M_Test.DDD.C2 = Ice.createTempClass()
    class C2(Ice.Value):
        def __init__(self):
            pass

        def ice_id(self):
            return '::Test::DDD::C2'

        @staticmethod
        def ice_staticId():
            return '::Test::DDD::C2'

        def __str__(self):
            return IcePy.stringify(self, _M_Test.DDD._t_C2)

        __repr__ = __str__

    _M_Test.DDD._t_C2 = IcePy.defineValue('::Test::DDD::C2', C2, -1, (), False, False, None, ())
    C2._ice_type = _M_Test.DDD._t_C2

    _M_Test.DDD.C2 = C2
    del C2

# End of module Test.DDD

__name__ = 'Test'

# End of module Test
