# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.10
#
# <auto-generated>
#
# Generated from file `Instrumentation.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

from sys import version_info as _version_info_
import Ice, IcePy
import Ice.Instrumentation_ice
import IceStorm.IceStorm_ice

# Included module Ice
_M_Ice = Ice.openModule('Ice')

# Included module Ice.Instrumentation
_M_Ice.Instrumentation = Ice.openModule('Ice.Instrumentation')

# Included module IceMX
_M_IceMX = Ice.openModule('IceMX')

# Included module IceStorm
_M_IceStorm = Ice.openModule('IceStorm')

# Start of module IceStorm
__name__ = 'IceStorm'

# Start of module IceStorm.Instrumentation
_M_IceStorm.Instrumentation = Ice.openModule('IceStorm.Instrumentation')
__name__ = 'IceStorm.Instrumentation'

if 'TopicObserver' not in _M_IceStorm.Instrumentation.__dict__:
    _M_IceStorm.Instrumentation.TopicObserver = Ice.createTempClass()
    class TopicObserver(_M_Ice.Instrumentation.Observer):
        def __init__(self):
            if Ice.getType(self) == _M_IceStorm.Instrumentation.TopicObserver:
                raise RuntimeError('IceStorm.Instrumentation.TopicObserver is an abstract class')

        def published(self):
            """
             Notification of an event published on the topic by a publisher.
            """
            raise NotImplementedError("method 'published' not implemented")

        def forwarded(self):
            """
             Notification of an event forwared on the topic by another topic.
            """
            raise NotImplementedError("method 'forwarded' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_IceStorm.Instrumentation._t_TopicObserver)

        __repr__ = __str__

    _M_IceStorm.Instrumentation._t_TopicObserver = IcePy.defineValue('::IceStorm::Instrumentation::TopicObserver', TopicObserver, -1, (), False, True, None, ())
    TopicObserver._ice_type = _M_IceStorm.Instrumentation._t_TopicObserver

    _M_IceStorm.Instrumentation.TopicObserver = TopicObserver
    del TopicObserver

if 'SubscriberObserver' not in _M_IceStorm.Instrumentation.__dict__:
    _M_IceStorm.Instrumentation.SubscriberObserver = Ice.createTempClass()
    class SubscriberObserver(_M_Ice.Instrumentation.Observer):
        def __init__(self):
            if Ice.getType(self) == _M_IceStorm.Instrumentation.SubscriberObserver:
                raise RuntimeError('IceStorm.Instrumentation.SubscriberObserver is an abstract class')

        def queued(self, count):
            """
             Notification of some events being queued.
            Arguments:
            count -- 
            """
            raise NotImplementedError("method 'queued' not implemented")

        def outstanding(self, count):
            """
             Notification of a some events being sent.
            Arguments:
            count -- 
            """
            raise NotImplementedError("method 'outstanding' not implemented")

        def delivered(self, count):
            """
             Notification of some events being delivered.
            Arguments:
            count -- 
            """
            raise NotImplementedError("method 'delivered' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_IceStorm.Instrumentation._t_SubscriberObserver)

        __repr__ = __str__

    _M_IceStorm.Instrumentation._t_SubscriberObserver = IcePy.defineValue('::IceStorm::Instrumentation::SubscriberObserver', SubscriberObserver, -1, (), False, True, None, ())
    SubscriberObserver._ice_type = _M_IceStorm.Instrumentation._t_SubscriberObserver

    _M_IceStorm.Instrumentation.SubscriberObserver = SubscriberObserver
    del SubscriberObserver

if 'ObserverUpdater' not in _M_IceStorm.Instrumentation.__dict__:
    _M_IceStorm.Instrumentation.ObserverUpdater = Ice.createTempClass()
    class ObserverUpdater(object):
        """
         The ObserverUpdater interface is implemented by IceStorm and an instance of this interface is provided on
         initialization to the TopicManagerObserver object.
         This interface can be used by add-ins imlementing the TopicManagerObserver interface to update the obsevers of
         observed objects.
        """
        def __init__(self):
            if Ice.getType(self) == _M_IceStorm.Instrumentation.ObserverUpdater:
                raise RuntimeError('IceStorm.Instrumentation.ObserverUpdater is an abstract class')

        def updateTopicObservers(self):
            """
             Update topic observers associated with each topics.
             When called, this method goes through all the topics and for each topic TopicManagerObserver::getTopicObserver
             is called. The implementation of getTopicObserver has the possibility to return an updated observer if
             necessary.
            """
            raise NotImplementedError("method 'updateTopicObservers' not implemented")

        def updateSubscriberObservers(self):
            """
             Update subscriber observers associated with each subscriber.
             When called, this method goes through all the subscribers and for each subscriber
             TopicManagerObserver::getSubscriberObserver is called. The implementation of getSubscriberObserver has the
             possibility to return an updated observer if necessary.
            """
            raise NotImplementedError("method 'updateSubscriberObservers' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_IceStorm.Instrumentation._t_ObserverUpdater)

        __repr__ = __str__

    _M_IceStorm.Instrumentation._t_ObserverUpdater = IcePy.defineValue('::IceStorm::Instrumentation::ObserverUpdater', ObserverUpdater, -1, (), False, True, None, ())
    ObserverUpdater._ice_type = _M_IceStorm.Instrumentation._t_ObserverUpdater

    _M_IceStorm.Instrumentation.ObserverUpdater = ObserverUpdater
    del ObserverUpdater

if 'SubscriberState' not in _M_IceStorm.Instrumentation.__dict__:
    _M_IceStorm.Instrumentation.SubscriberState = Ice.createTempClass()
    class SubscriberState(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    SubscriberState.SubscriberStateOnline = SubscriberState("SubscriberStateOnline", 0)
    SubscriberState.SubscriberStateOffline = SubscriberState("SubscriberStateOffline", 1)
    SubscriberState.SubscriberStateError = SubscriberState("SubscriberStateError", 2)
    SubscriberState._enumerators = { 0:SubscriberState.SubscriberStateOnline, 1:SubscriberState.SubscriberStateOffline, 2:SubscriberState.SubscriberStateError }

    _M_IceStorm.Instrumentation._t_SubscriberState = IcePy.defineEnum('::IceStorm::Instrumentation::SubscriberState', SubscriberState, (), SubscriberState._enumerators)

    _M_IceStorm.Instrumentation.SubscriberState = SubscriberState
    del SubscriberState

if 'TopicManagerObserver' not in _M_IceStorm.Instrumentation.__dict__:
    _M_IceStorm.Instrumentation.TopicManagerObserver = Ice.createTempClass()
    class TopicManagerObserver(object):
        """
         The topic manager observer interface used by the Ice run-time to obtain and update observers for its observeable
         objects. This interface should be implemented by add-ins that wish to observe IceStorm objects in order to collect
         statistics.
        """
        def __init__(self):
            if Ice.getType(self) == _M_IceStorm.Instrumentation.TopicManagerObserver:
                raise RuntimeError('IceStorm.Instrumentation.TopicManagerObserver is an abstract class')

        def getTopicObserver(self, svc, name, old):
            """
             This method should return an observer for the given topic.
            Arguments:
            svc -- The service name.
            name -- The topic name.
            old -- The previous observer, only set when updating an existing observer.
            """
            raise NotImplementedError("method 'getTopicObserver' not implemented")

        def getSubscriberObserver(self, svc, topic, prx, q, link, s, old):
            """
             This method should return an observer for the given subscriber.
            Arguments:
            svc -- 
            topic -- The name of the topic subscribed.
            prx -- 
            q -- 
            link -- The proxy of the linked topic if this subscriber forwards events to a linked topic.
            s -- 
            old -- The previous observer, only set when updating an existing observer.
            """
            raise NotImplementedError("method 'getSubscriberObserver' not implemented")

        def setObserverUpdater(self, updater):
            """
             IceStorm calls this method on initialization. The add-in implementing this interface can use this object to
             get IceStorm to re-obtain observers for topics and subscribers.
            Arguments:
            updater -- The observer updater object.
            """
            raise NotImplementedError("method 'setObserverUpdater' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_IceStorm.Instrumentation._t_TopicManagerObserver)

        __repr__ = __str__

    _M_IceStorm.Instrumentation._t_TopicManagerObserver = IcePy.defineValue('::IceStorm::Instrumentation::TopicManagerObserver', TopicManagerObserver, -1, (), False, True, None, ())
    TopicManagerObserver._ice_type = _M_IceStorm.Instrumentation._t_TopicManagerObserver

    _M_IceStorm.Instrumentation.TopicManagerObserver = TopicManagerObserver
    del TopicManagerObserver

# End of module IceStorm.Instrumentation

__name__ = 'IceStorm'

# End of module IceStorm
