# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.8.0-alpha.0
#
# <auto-generated>
#
# Generated from file `Contract.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

import Ice
import IcePy
import builtins as _builtins
import Ice.Identity_ice
import Ice.BuiltinSequences_ice
import DataStorm_Sample_ice

# Included module Ice
_M_Ice = Ice.openModule('Ice')

# Included module DataStorm
_M_DataStorm = Ice.openModule('DataStorm')

# Start of module DataStormContract
_M_DataStormContract = Ice.openModule('DataStormContract')
__name__ = 'DataStormContract'

if 'ClearHistoryPolicy' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.ClearHistoryPolicy = None
    class ClearHistoryPolicy(Ice.EnumBase):
        """
        The ClearHistoryPolicy enumeration defines the policy that determines when a reader clears its
        DataSample history in response to various events.
        Enumerators:
        OnAdd -- The reader clears its history when a new DataSample is added.
        OnRemove -- The reader clears its history when a DataSample is removed.
        OnAll -- The reader clears its history when any DataSample event occurs.
        OnAllExceptPartialUpdate -- The reader clears its history when any DataSample event occurs, except for PartialUpdate events.
        Never -- The reader never clears its history.
        """

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    ClearHistoryPolicy.OnAdd = ClearHistoryPolicy("OnAdd", 0)
    ClearHistoryPolicy.OnRemove = ClearHistoryPolicy("OnRemove", 1)
    ClearHistoryPolicy.OnAll = ClearHistoryPolicy("OnAll", 2)
    ClearHistoryPolicy.OnAllExceptPartialUpdate = ClearHistoryPolicy("OnAllExceptPartialUpdate", 3)
    ClearHistoryPolicy.Never = ClearHistoryPolicy("Never", 4)
    ClearHistoryPolicy._enumerators = { 0:ClearHistoryPolicy.OnAdd, 1:ClearHistoryPolicy.OnRemove, 2:ClearHistoryPolicy.OnAll, 3:ClearHistoryPolicy.OnAllExceptPartialUpdate, 4:ClearHistoryPolicy.Never }

    _M_DataStormContract._t_ClearHistoryPolicy = IcePy.defineEnum('::DataStormContract::ClearHistoryPolicy', ClearHistoryPolicy, (), ClearHistoryPolicy._enumerators)

    _M_DataStormContract.ClearHistoryPolicy = ClearHistoryPolicy
    del ClearHistoryPolicy

if '_t_LongLongDict' not in _M_DataStormContract.__dict__:
    _M_DataStormContract._t_LongLongDict = IcePy.defineDictionary('::DataStormContract::LongLongDict', (), IcePy._t_long, IcePy._t_long)

if 'DataSample' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.DataSample = None
    class DataSample(object):
        def __init__(self, id=0, keyId=0, keyValue=None, timestamp=0, tag=0, event=_M_DataStorm.SampleEvent.Add, value=None):
            self.id = id
            self.keyId = keyId
            self.keyValue = keyValue
            self.timestamp = timestamp
            self.tag = tag
            self.event = event
            self.value = value

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_DataStormContract.DataSample):
                return NotImplemented
            else:
                if self.id != other.id:
                    return False
                if self.keyId != other.keyId:
                    return False
                if self.keyValue != other.keyValue:
                    return False
                if self.timestamp != other.timestamp:
                    return False
                if self.tag != other.tag:
                    return False
                if self.event != other.event:
                    return False
                if self.value != other.value:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_DataSample)

        __repr__ = __str__

    _M_DataStormContract._t_DataSample = IcePy.defineStruct('::DataStormContract::DataSample', DataSample, (), (
        ('id', (), IcePy._t_long),
        ('keyId', (), IcePy._t_long),
        ('keyValue', (), _M_Ice._t_ByteSeq),
        ('timestamp', (), IcePy._t_long),
        ('tag', (), IcePy._t_long),
        ('event', (), _M_DataStorm._t_SampleEvent),
        ('value', (), _M_Ice._t_ByteSeq)
    ))

    _M_DataStormContract.DataSample = DataSample
    del DataSample

if '_t_DataSampleSeq' not in _M_DataStormContract.__dict__:
    _M_DataStormContract._t_DataSampleSeq = IcePy.defineSequence('::DataStormContract::DataSampleSeq', (), _M_DataStormContract._t_DataSample)

if 'DataSamples' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.DataSamples = None
    class DataSamples(object):
        def __init__(self, id=0, samples=None):
            self.id = id
            self.samples = samples

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_DataStormContract.DataSamples):
                return NotImplemented
            else:
                if self.id != other.id:
                    return False
                if self.samples != other.samples:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_DataSamples)

        __repr__ = __str__

    _M_DataStormContract._t_DataSamples = IcePy.defineStruct('::DataStormContract::DataSamples', DataSamples, (), (
        ('id', (), IcePy._t_long),
        ('samples', (), _M_DataStormContract._t_DataSampleSeq)
    ))

    _M_DataStormContract.DataSamples = DataSamples
    del DataSamples

if '_t_DataSamplesSeq' not in _M_DataStormContract.__dict__:
    _M_DataStormContract._t_DataSamplesSeq = IcePy.defineSequence('::DataStormContract::DataSamplesSeq', (), _M_DataStormContract._t_DataSamples)

if 'ElementInfo' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.ElementInfo = None
    class ElementInfo(object):
        def __init__(self, id=0, name='', value=None):
            self.id = id
            self.name = name
            self.value = value

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_DataStormContract.ElementInfo):
                return NotImplemented
            else:
                if self.id != other.id:
                    return False
                if self.name != other.name:
                    return False
                if self.value != other.value:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_ElementInfo)

        __repr__ = __str__

    _M_DataStormContract._t_ElementInfo = IcePy.defineStruct('::DataStormContract::ElementInfo', ElementInfo, (), (
        ('id', (), IcePy._t_long),
        ('name', (), IcePy._t_string),
        ('value', (), _M_Ice._t_ByteSeq)
    ))

    _M_DataStormContract.ElementInfo = ElementInfo
    del ElementInfo

if '_t_ElementInfoSeq' not in _M_DataStormContract.__dict__:
    _M_DataStormContract._t_ElementInfoSeq = IcePy.defineSequence('::DataStormContract::ElementInfoSeq', (), _M_DataStormContract._t_ElementInfo)

if 'TopicInfo' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.TopicInfo = None
    class TopicInfo(object):
        def __init__(self, name='', ids=None):
            self.name = name
            self.ids = ids

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_DataStormContract.TopicInfo):
                return NotImplemented
            else:
                if self.name != other.name:
                    return False
                if self.ids != other.ids:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_TopicInfo)

        __repr__ = __str__

    _M_DataStormContract._t_TopicInfo = IcePy.defineStruct('::DataStormContract::TopicInfo', TopicInfo, (), (
        ('name', (), IcePy._t_string),
        ('ids', (), _M_Ice._t_LongSeq)
    ))

    _M_DataStormContract.TopicInfo = TopicInfo
    del TopicInfo

if '_t_TopicInfoSeq' not in _M_DataStormContract.__dict__:
    _M_DataStormContract._t_TopicInfoSeq = IcePy.defineSequence('::DataStormContract::TopicInfoSeq', (), _M_DataStormContract._t_TopicInfo)

if 'TopicSpec' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.TopicSpec = None
    class TopicSpec(object):
        def __init__(self, id=0, name='', elements=None, tags=None):
            self.id = id
            self.name = name
            self.elements = elements
            self.tags = tags

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_DataStormContract.TopicSpec):
                return NotImplemented
            else:
                if self.id != other.id:
                    return False
                if self.name != other.name:
                    return False
                if self.elements != other.elements:
                    return False
                if self.tags != other.tags:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_TopicSpec)

        __repr__ = __str__

    _M_DataStormContract._t_TopicSpec = IcePy.defineStruct('::DataStormContract::TopicSpec', TopicSpec, (), (
        ('id', (), IcePy._t_long),
        ('name', (), IcePy._t_string),
        ('elements', (), _M_DataStormContract._t_ElementInfoSeq),
        ('tags', (), _M_DataStormContract._t_ElementInfoSeq)
    ))

    _M_DataStormContract.TopicSpec = TopicSpec
    del TopicSpec

if 'FilterInfo' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.FilterInfo = None
    class FilterInfo(object):
        def __init__(self, name='', criteria=None):
            self.name = name
            self.criteria = criteria

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_DataStormContract.FilterInfo):
                return NotImplemented
            else:
                if self.name != other.name:
                    return False
                if self.criteria != other.criteria:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_FilterInfo)

        __repr__ = __str__

    _M_DataStormContract._t_FilterInfo = IcePy.defineStruct('::DataStormContract::FilterInfo', FilterInfo, (), (
        ('name', (), IcePy._t_string),
        ('criteria', (), _M_Ice._t_ByteSeq)
    ))

    _M_DataStormContract.FilterInfo = FilterInfo
    del FilterInfo

if 'ElementConfig' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.ElementConfig = None
    class ElementConfig(Ice.Value):
        def __init__(self, facet=None, sampleFilter=None, name=None, priority=None, sampleCount=None, sampleLifetime=None, clearHistory=None):
            self.facet = facet
            self.sampleFilter = sampleFilter
            self.name = name
            self.priority = priority
            self.sampleCount = sampleCount
            self.sampleLifetime = sampleLifetime
            self.clearHistory = clearHistory

        def ice_id(self):
            return '::DataStormContract::ElementConfig'

        @staticmethod
        def ice_staticId():
            return '::DataStormContract::ElementConfig'

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_ElementConfig)

        __repr__ = __str__

    _M_DataStormContract._t_ElementConfig = IcePy.defineValue('::DataStormContract::ElementConfig', ElementConfig, 1, (), False, None, (
        ('facet', (), IcePy._t_string, True, 1),
        ('sampleFilter', (), _M_DataStormContract._t_FilterInfo, True, 2),
        ('name', (), IcePy._t_string, True, 3),
        ('priority', (), IcePy._t_int, True, 4),
        ('sampleCount', (), IcePy._t_int, True, 10),
        ('sampleLifetime', (), IcePy._t_int, True, 11),
        ('clearHistory', (), _M_DataStormContract._t_ClearHistoryPolicy, True, 12)
    ))
    ElementConfig._ice_type = _M_DataStormContract._t_ElementConfig

    _M_DataStormContract.ElementConfig = ElementConfig
    del ElementConfig

if 'ElementData' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.ElementData = None
    class ElementData(object):
        def __init__(self, id=0, config=None, lastIds=None):
            self.id = id
            self.config = config
            self.lastIds = lastIds

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_DataStormContract.ElementData):
                return NotImplemented
            else:
                if self.id != other.id:
                    return False
                if self.config != other.config:
                    return False
                if self.lastIds != other.lastIds:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_ElementData)

        __repr__ = __str__

    _M_DataStormContract._t_ElementData = IcePy.defineStruct('::DataStormContract::ElementData', ElementData, (), (
        ('id', (), IcePy._t_long),
        ('config', (), _M_DataStormContract._t_ElementConfig),
        ('lastIds', (), _M_DataStormContract._t_LongLongDict)
    ))

    _M_DataStormContract.ElementData = ElementData
    del ElementData

if '_t_ElementDataSeq' not in _M_DataStormContract.__dict__:
    _M_DataStormContract._t_ElementDataSeq = IcePy.defineSequence('::DataStormContract::ElementDataSeq', (), _M_DataStormContract._t_ElementData)

if 'ElementSpec' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.ElementSpec = None
    class ElementSpec(object):
        def __init__(self, elements=None, id=0, name='', value=None, peerId=0, peerName=''):
            self.elements = elements
            self.id = id
            self.name = name
            self.value = value
            self.peerId = peerId
            self.peerName = peerName

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_DataStormContract.ElementSpec):
                return NotImplemented
            else:
                if self.elements != other.elements:
                    return False
                if self.id != other.id:
                    return False
                if self.name != other.name:
                    return False
                if self.value != other.value:
                    return False
                if self.peerId != other.peerId:
                    return False
                if self.peerName != other.peerName:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_ElementSpec)

        __repr__ = __str__

    _M_DataStormContract._t_ElementSpec = IcePy.defineStruct('::DataStormContract::ElementSpec', ElementSpec, (), (
        ('elements', (), _M_DataStormContract._t_ElementDataSeq),
        ('id', (), IcePy._t_long),
        ('name', (), IcePy._t_string),
        ('value', (), _M_Ice._t_ByteSeq),
        ('peerId', (), IcePy._t_long),
        ('peerName', (), IcePy._t_string)
    ))

    _M_DataStormContract.ElementSpec = ElementSpec
    del ElementSpec

if '_t_ElementSpecSeq' not in _M_DataStormContract.__dict__:
    _M_DataStormContract._t_ElementSpecSeq = IcePy.defineSequence('::DataStormContract::ElementSpecSeq', (), _M_DataStormContract._t_ElementSpec)

if 'ElementDataAck' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.ElementDataAck = None
    class ElementDataAck(object):
        def __init__(self, id=0, config=None, lastIds=None, samples=None, peerId=0):
            self.id = id
            self.config = config
            self.lastIds = lastIds
            self.samples = samples
            self.peerId = peerId

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_DataStormContract.ElementDataAck):
                return NotImplemented
            else:
                if self.id != other.id:
                    return False
                if self.config != other.config:
                    return False
                if self.lastIds != other.lastIds:
                    return False
                if self.samples != other.samples:
                    return False
                if self.peerId != other.peerId:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_ElementDataAck)

        __repr__ = __str__

    _M_DataStormContract._t_ElementDataAck = IcePy.defineStruct('::DataStormContract::ElementDataAck', ElementDataAck, (), (
        ('id', (), IcePy._t_long),
        ('config', (), _M_DataStormContract._t_ElementConfig),
        ('lastIds', (), _M_DataStormContract._t_LongLongDict),
        ('samples', (), _M_DataStormContract._t_DataSampleSeq),
        ('peerId', (), IcePy._t_long)
    ))

    _M_DataStormContract.ElementDataAck = ElementDataAck
    del ElementDataAck

if '_t_ElementDataAckSeq' not in _M_DataStormContract.__dict__:
    _M_DataStormContract._t_ElementDataAckSeq = IcePy.defineSequence('::DataStormContract::ElementDataAckSeq', (), _M_DataStormContract._t_ElementDataAck)

if 'ElementSpecAck' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.ElementSpecAck = None
    class ElementSpecAck(object):
        def __init__(self, elements=None, id=0, name='', value=None, peerId=0, peerName=''):
            self.elements = elements
            self.id = id
            self.name = name
            self.value = value
            self.peerId = peerId
            self.peerName = peerName

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_DataStormContract.ElementSpecAck):
                return NotImplemented
            else:
                if self.elements != other.elements:
                    return False
                if self.id != other.id:
                    return False
                if self.name != other.name:
                    return False
                if self.value != other.value:
                    return False
                if self.peerId != other.peerId:
                    return False
                if self.peerName != other.peerName:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_ElementSpecAck)

        __repr__ = __str__

    _M_DataStormContract._t_ElementSpecAck = IcePy.defineStruct('::DataStormContract::ElementSpecAck', ElementSpecAck, (), (
        ('elements', (), _M_DataStormContract._t_ElementDataAckSeq),
        ('id', (), IcePy._t_long),
        ('name', (), IcePy._t_string),
        ('value', (), _M_Ice._t_ByteSeq),
        ('peerId', (), IcePy._t_long),
        ('peerName', (), IcePy._t_string)
    ))

    _M_DataStormContract.ElementSpecAck = ElementSpecAck
    del ElementSpecAck

if '_t_ElementSpecAckSeq' not in _M_DataStormContract.__dict__:
    _M_DataStormContract._t_ElementSpecAckSeq = IcePy.defineSequence('::DataStormContract::ElementSpecAckSeq', (), _M_DataStormContract._t_ElementSpecAck)

if 'SessionPrx' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.SessionPrx = None
    class SessionPrx(Ice.ObjectPrx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new SessionPrx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        def announceTopics(self, topics, initialize, context=None):
            """
            Called by sessions to announce topics to the peer. A publisher session announces the topics it writes,
            while a subscriber session announces the topics it reads.
            
            Parameters
            ----------
            topics : DataStormContract.TopicInfo[]
                The topics to announce.
            initialize : bool
                currently unused.
            context : Ice.Context
                The request context for the invocation.
            """
            return _M_DataStormContract.Session._op_announceTopics.invoke(self, ((topics, initialize), context))

        def announceTopicsAsync(self, topics, initialize, context=None):
            """
            Called by sessions to announce topics to the peer. A publisher session announces the topics it writes,
            while a subscriber session announces the topics it reads.
            
            Parameters
            ----------
            topics : DataStormContract.TopicInfo[]
                The topics to announce.
            initialize : bool
                currently unused.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_DataStormContract.Session._op_announceTopics.invokeAsync(self, ((topics, initialize), context))

        def attachTopic(self, topic, context=None):
            return _M_DataStormContract.Session._op_attachTopic.invoke(self, ((topic, ), context))

        def attachTopicAsync(self, topic, context=None):
            return _M_DataStormContract.Session._op_attachTopic.invokeAsync(self, ((topic, ), context))

        def detachTopic(self, topic, context=None):
            return _M_DataStormContract.Session._op_detachTopic.invoke(self, ((topic, ), context))

        def detachTopicAsync(self, topic, context=None):
            return _M_DataStormContract.Session._op_detachTopic.invokeAsync(self, ((topic, ), context))

        def attachTags(self, topic, tags, initialize, context=None):
            return _M_DataStormContract.Session._op_attachTags.invoke(self, ((topic, tags, initialize), context))

        def attachTagsAsync(self, topic, tags, initialize, context=None):
            return _M_DataStormContract.Session._op_attachTags.invokeAsync(self, ((topic, tags, initialize), context))

        def detachTags(self, topic, tags, context=None):
            return _M_DataStormContract.Session._op_detachTags.invoke(self, ((topic, tags), context))

        def detachTagsAsync(self, topic, tags, context=None):
            return _M_DataStormContract.Session._op_detachTags.invokeAsync(self, ((topic, tags), context))

        def announceElements(self, topic, keys, context=None):
            return _M_DataStormContract.Session._op_announceElements.invoke(self, ((topic, keys), context))

        def announceElementsAsync(self, topic, keys, context=None):
            return _M_DataStormContract.Session._op_announceElements.invokeAsync(self, ((topic, keys), context))

        def attachElements(self, topic, elements, initialize, context=None):
            return _M_DataStormContract.Session._op_attachElements.invoke(self, ((topic, elements, initialize), context))

        def attachElementsAsync(self, topic, elements, initialize, context=None):
            return _M_DataStormContract.Session._op_attachElements.invokeAsync(self, ((topic, elements, initialize), context))

        def attachElementsAck(self, topic, elements, context=None):
            return _M_DataStormContract.Session._op_attachElementsAck.invoke(self, ((topic, elements), context))

        def attachElementsAckAsync(self, topic, elements, context=None):
            return _M_DataStormContract.Session._op_attachElementsAck.invokeAsync(self, ((topic, elements), context))

        def detachElements(self, topic, keys, context=None):
            return _M_DataStormContract.Session._op_detachElements.invoke(self, ((topic, keys), context))

        def detachElementsAsync(self, topic, keys, context=None):
            return _M_DataStormContract.Session._op_detachElements.invokeAsync(self, ((topic, keys), context))

        def initSamples(self, topic, samples, context=None):
            return _M_DataStormContract.Session._op_initSamples.invoke(self, ((topic, samples), context))

        def initSamplesAsync(self, topic, samples, context=None):
            return _M_DataStormContract.Session._op_initSamples.invokeAsync(self, ((topic, samples), context))

        def disconnected(self, context=None):
            return _M_DataStormContract.Session._op_disconnected.invoke(self, ((), context))

        def disconnectedAsync(self, context=None):
            return _M_DataStormContract.Session._op_disconnected.invokeAsync(self, ((), context))

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_DataStormContract.SessionPrx.ice_checkedCast(proxy, '::DataStormContract::Session', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_DataStormContract.SessionPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::DataStormContract::Session'
    _M_DataStormContract._t_SessionPrx = IcePy.defineProxy('::DataStormContract::Session', SessionPrx)

    _M_DataStormContract.SessionPrx = SessionPrx
    del SessionPrx

    _M_DataStormContract.Session = None
    class Session(Ice.Object):

        def ice_ids(self, current=None):
            return ('::DataStormContract::Session', '::Ice::Object')

        def ice_id(self, current=None):
            return '::DataStormContract::Session'

        @staticmethod
        def ice_staticId():
            return '::DataStormContract::Session'

        def announceTopics(self, topics, initialize, current=None):
            """
            Called by sessions to announce topics to the peer. A publisher session announces the topics it writes,
            while a subscriber session announces the topics it reads.
            
            Parameters
            ----------
            topics : DataStormContract.TopicInfo[]
                The topics to announce.
            initialize : bool
                currently unused.
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 'announceTopics' not implemented")

        def attachTopic(self, topic, current=None):
            raise NotImplementedError("servant method 'attachTopic' not implemented")

        def detachTopic(self, topic, current=None):
            raise NotImplementedError("servant method 'detachTopic' not implemented")

        def attachTags(self, topic, tags, initialize, current=None):
            raise NotImplementedError("servant method 'attachTags' not implemented")

        def detachTags(self, topic, tags, current=None):
            raise NotImplementedError("servant method 'detachTags' not implemented")

        def announceElements(self, topic, keys, current=None):
            raise NotImplementedError("servant method 'announceElements' not implemented")

        def attachElements(self, topic, elements, initialize, current=None):
            raise NotImplementedError("servant method 'attachElements' not implemented")

        def attachElementsAck(self, topic, elements, current=None):
            raise NotImplementedError("servant method 'attachElementsAck' not implemented")

        def detachElements(self, topic, keys, current=None):
            raise NotImplementedError("servant method 'detachElements' not implemented")

        def initSamples(self, topic, samples, current=None):
            raise NotImplementedError("servant method 'initSamples' not implemented")

        def disconnected(self, current=None):
            raise NotImplementedError("servant method 'disconnected' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_SessionDisp)

        __repr__ = __str__

    Session._op_announceTopics = IcePy.Operation('announceTopics', Ice.OperationMode.Normal, False, None, (), (((), _M_DataStormContract._t_TopicInfoSeq, False, 0), ((), IcePy._t_bool, False, 0)), (), None, ())
    Session._op_attachTopic = IcePy.Operation('attachTopic', Ice.OperationMode.Normal, False, None, (), (((), _M_DataStormContract._t_TopicSpec, False, 0),), (), None, ())
    Session._op_detachTopic = IcePy.Operation('detachTopic', Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_long, False, 0),), (), None, ())
    Session._op_attachTags = IcePy.Operation('attachTags', Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_long, False, 0), ((), _M_DataStormContract._t_ElementInfoSeq, False, 0), ((), IcePy._t_bool, False, 0)), (), None, ())
    Session._op_detachTags = IcePy.Operation('detachTags', Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_long, False, 0), ((), _M_Ice._t_LongSeq, False, 0)), (), None, ())
    Session._op_announceElements = IcePy.Operation('announceElements', Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_long, False, 0), ((), _M_DataStormContract._t_ElementInfoSeq, False, 0)), (), None, ())
    Session._op_attachElements = IcePy.Operation('attachElements', Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_long, False, 0), ((), _M_DataStormContract._t_ElementSpecSeq, False, 0), ((), IcePy._t_bool, False, 0)), (), None, ())
    Session._op_attachElementsAck = IcePy.Operation('attachElementsAck', Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_long, False, 0), ((), _M_DataStormContract._t_ElementSpecAckSeq, False, 0)), (), None, ())
    Session._op_detachElements = IcePy.Operation('detachElements', Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_long, False, 0), ((), _M_Ice._t_LongSeq, False, 0)), (), None, ())
    Session._op_initSamples = IcePy.Operation('initSamples', Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_long, False, 0), ((), _M_DataStormContract._t_DataSamplesSeq, False, 0)), (), None, ())
    Session._op_disconnected = IcePy.Operation('disconnected', Ice.OperationMode.Normal, False, None, (), (), (), None, ())

    _M_DataStormContract.Session = Session
    del Session

if 'PublisherSessionPrx' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.PublisherSessionPrx = None
    class PublisherSessionPrx(_M_DataStormContract.SessionPrx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new PublisherSessionPrx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_DataStormContract.PublisherSessionPrx.ice_checkedCast(proxy, '::DataStormContract::PublisherSession', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_DataStormContract.PublisherSessionPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::DataStormContract::PublisherSession'
    _M_DataStormContract._t_PublisherSessionPrx = IcePy.defineProxy('::DataStormContract::PublisherSession', PublisherSessionPrx)

    _M_DataStormContract.PublisherSessionPrx = PublisherSessionPrx
    del PublisherSessionPrx

    _M_DataStormContract.PublisherSession = None
    class PublisherSession(_M_DataStormContract.Session):

        def ice_ids(self, current=None):
            return ('::DataStormContract::PublisherSession', '::DataStormContract::Session', '::Ice::Object')

        def ice_id(self, current=None):
            return '::DataStormContract::PublisherSession'

        @staticmethod
        def ice_staticId():
            return '::DataStormContract::PublisherSession'

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_PublisherSessionDisp)

        __repr__ = __str__

    _M_DataStormContract.PublisherSession = PublisherSession
    del PublisherSession

if 'SubscriberSessionPrx' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.SubscriberSessionPrx = None
    class SubscriberSessionPrx(_M_DataStormContract.SessionPrx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new SubscriberSessionPrx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        def s(self, topicId, elementId, sample, context=None):
            return _M_DataStormContract.SubscriberSession._op_s.invoke(self, ((topicId, elementId, sample), context))

        def sAsync(self, topicId, elementId, sample, context=None):
            return _M_DataStormContract.SubscriberSession._op_s.invokeAsync(self, ((topicId, elementId, sample), context))

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_DataStormContract.SubscriberSessionPrx.ice_checkedCast(proxy, '::DataStormContract::SubscriberSession', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_DataStormContract.SubscriberSessionPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::DataStormContract::SubscriberSession'
    _M_DataStormContract._t_SubscriberSessionPrx = IcePy.defineProxy('::DataStormContract::SubscriberSession', SubscriberSessionPrx)

    _M_DataStormContract.SubscriberSessionPrx = SubscriberSessionPrx
    del SubscriberSessionPrx

    _M_DataStormContract.SubscriberSession = None
    class SubscriberSession(_M_DataStormContract.Session):

        def ice_ids(self, current=None):
            return ('::DataStormContract::Session', '::DataStormContract::SubscriberSession', '::Ice::Object')

        def ice_id(self, current=None):
            return '::DataStormContract::SubscriberSession'

        @staticmethod
        def ice_staticId():
            return '::DataStormContract::SubscriberSession'

        def s(self, topicId, elementId, sample, current=None):
            raise NotImplementedError("servant method 's' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_SubscriberSessionDisp)

        __repr__ = __str__

    SubscriberSession._op_s = IcePy.Operation('s', Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_long, False, 0), ((), IcePy._t_long, False, 0), ((), _M_DataStormContract._t_DataSample, False, 0)), (), None, ())

    _M_DataStormContract.SubscriberSession = SubscriberSession
    del SubscriberSession

if 'NodePrx' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.NodePrx = None
    class NodePrx(Ice.ObjectPrx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new NodePrx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        def initiateCreateSession(self, publisher, context=None):
            """
            Initiate the creation of a publisher session with a node, after the target node has announced a topic
            reader for which this node has a corresponding topic writer.
            
            Parameters
            ----------
            publisher : (DataStormContract.NodePrx or None)
                The publisher node initiating the session. The proxy is never null.
            context : Ice.Context
                The request context for the invocation.
            """
            return _M_DataStormContract.Node._op_initiateCreateSession.invoke(self, ((publisher, ), context))

        def initiateCreateSessionAsync(self, publisher, context=None):
            """
            Initiate the creation of a publisher session with a node, after the target node has announced a topic
            reader for which this node has a corresponding topic writer.
            
            Parameters
            ----------
            publisher : (DataStormContract.NodePrx or None)
                The publisher node initiating the session. The proxy is never null.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_DataStormContract.Node._op_initiateCreateSession.invokeAsync(self, ((publisher, ), context))

        def createSession(self, subscriber, session, fromRelay, context=None):
            """
            Initiate the creation of a subscriber session with a node, after the target node has announced a topic
            writer for which this node has a corresponding topic reader, or after the node has called
            Node::initiateCreateSession.
            
            Parameters
            ----------
            subscriber : (DataStormContract.NodePrx or None)
                The subscriber node initiating the session. The proxy is never null.
            session : (DataStormContract.SubscriberSessionPrx or None)
                The subscriber session being created. The proxy is never null.
            fromRelay : bool
                Indicates if the session is being created from a relay node.
            context : Ice.Context
                The request context for the invocation.
            """
            return _M_DataStormContract.Node._op_createSession.invoke(self, ((subscriber, session, fromRelay), context))

        def createSessionAsync(self, subscriber, session, fromRelay, context=None):
            """
            Initiate the creation of a subscriber session with a node, after the target node has announced a topic
            writer for which this node has a corresponding topic reader, or after the node has called
            Node::initiateCreateSession.
            
            Parameters
            ----------
            subscriber : (DataStormContract.NodePrx or None)
                The subscriber node initiating the session. The proxy is never null.
            session : (DataStormContract.SubscriberSessionPrx or None)
                The subscriber session being created. The proxy is never null.
            fromRelay : bool
                Indicates if the session is being created from a relay node.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_DataStormContract.Node._op_createSession.invokeAsync(self, ((subscriber, session, fromRelay), context))

        def confirmCreateSession(self, publisher, session, context=None):
            """
            Confirm the creation of a publisher session with a node.
            
            Parameters
            ----------
            publisher : (DataStormContract.NodePrx or None)
                The publisher node confirming the session. The proxy is never null.
            session : (DataStormContract.PublisherSessionPrx or None)
                The publisher session being confirmed. The proxy is never null.
            context : Ice.Context
                The request context for the invocation.
            """
            return _M_DataStormContract.Node._op_confirmCreateSession.invoke(self, ((publisher, session), context))

        def confirmCreateSessionAsync(self, publisher, session, context=None):
            """
            Confirm the creation of a publisher session with a node.
            
            Parameters
            ----------
            publisher : (DataStormContract.NodePrx or None)
                The publisher node confirming the session. The proxy is never null.
            session : (DataStormContract.PublisherSessionPrx or None)
                The publisher session being confirmed. The proxy is never null.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_DataStormContract.Node._op_confirmCreateSession.invokeAsync(self, ((publisher, session), context))

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_DataStormContract.NodePrx.ice_checkedCast(proxy, '::DataStormContract::Node', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_DataStormContract.NodePrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::DataStormContract::Node'
    _M_DataStormContract._t_NodePrx = IcePy.defineProxy('::DataStormContract::Node', NodePrx)

    _M_DataStormContract.NodePrx = NodePrx
    del NodePrx

    _M_DataStormContract.Node = None
    class Node(Ice.Object):

        def ice_ids(self, current=None):
            return ('::DataStormContract::Node', '::Ice::Object')

        def ice_id(self, current=None):
            return '::DataStormContract::Node'

        @staticmethod
        def ice_staticId():
            return '::DataStormContract::Node'

        def initiateCreateSession(self, publisher, current=None):
            """
            Initiate the creation of a publisher session with a node, after the target node has announced a topic
            reader for which this node has a corresponding topic writer.
            
            Parameters
            ----------
            publisher : (DataStormContract.NodePrx or None)
                The publisher node initiating the session. The proxy is never null.
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 'initiateCreateSession' not implemented")

        def createSession(self, subscriber, session, fromRelay, current=None):
            """
            Initiate the creation of a subscriber session with a node, after the target node has announced a topic
            writer for which this node has a corresponding topic reader, or after the node has called
            Node::initiateCreateSession.
            
            Parameters
            ----------
            subscriber : (DataStormContract.NodePrx or None)
                The subscriber node initiating the session. The proxy is never null.
            session : (DataStormContract.SubscriberSessionPrx or None)
                The subscriber session being created. The proxy is never null.
            fromRelay : bool
                Indicates if the session is being created from a relay node.
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 'createSession' not implemented")

        def confirmCreateSession(self, publisher, session, current=None):
            """
            Confirm the creation of a publisher session with a node.
            
            Parameters
            ----------
            publisher : (DataStormContract.NodePrx or None)
                The publisher node confirming the session. The proxy is never null.
            session : (DataStormContract.PublisherSessionPrx or None)
                The publisher session being confirmed. The proxy is never null.
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 'confirmCreateSession' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_NodeDisp)

        __repr__ = __str__

    Node._op_initiateCreateSession = IcePy.Operation('initiateCreateSession', Ice.OperationMode.Normal, False, None, (), (((), _M_DataStormContract._t_NodePrx, False, 0),), (), None, ())
    Node._op_createSession = IcePy.Operation('createSession', Ice.OperationMode.Normal, False, None, (), (((), _M_DataStormContract._t_NodePrx, False, 0), ((), _M_DataStormContract._t_SubscriberSessionPrx, False, 0), ((), IcePy._t_bool, False, 0)), (), None, ())
    Node._op_confirmCreateSession = IcePy.Operation('confirmCreateSession', Ice.OperationMode.Normal, False, None, (), (((), _M_DataStormContract._t_NodePrx, False, 0), ((), _M_DataStormContract._t_PublisherSessionPrx, False, 0)), (), None, ())

    _M_DataStormContract.Node = Node
    del Node

if 'LookupPrx' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.LookupPrx = None
    class LookupPrx(Ice.ObjectPrx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new LookupPrx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        def announceTopicReader(self, topic, node, context=None):
            """
            Announce a topic reader.
            
            Parameters
            ----------
            topic : str
                The name of the topic.
            node : (DataStormContract.NodePrx or None)
                The node reading the topic. The proxy is never null.
            context : Ice.Context
                The request context for the invocation.
            """
            return _M_DataStormContract.Lookup._op_announceTopicReader.invoke(self, ((topic, node), context))

        def announceTopicReaderAsync(self, topic, node, context=None):
            """
            Announce a topic reader.
            
            Parameters
            ----------
            topic : str
                The name of the topic.
            node : (DataStormContract.NodePrx or None)
                The node reading the topic. The proxy is never null.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_DataStormContract.Lookup._op_announceTopicReader.invokeAsync(self, ((topic, node), context))

        def announceTopicWriter(self, topic, node, context=None):
            """
            Announce a topic writer.
            
            Parameters
            ----------
            topic : str
                The name of the topic.
            node : (DataStormContract.NodePrx or None)
                The node writing the topic. The proxy is never null.
            context : Ice.Context
                The request context for the invocation.
            """
            return _M_DataStormContract.Lookup._op_announceTopicWriter.invoke(self, ((topic, node), context))

        def announceTopicWriterAsync(self, topic, node, context=None):
            """
            Announce a topic writer.
            
            Parameters
            ----------
            topic : str
                The name of the topic.
            node : (DataStormContract.NodePrx or None)
                The node writing the topic. The proxy is never null.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_DataStormContract.Lookup._op_announceTopicWriter.invokeAsync(self, ((topic, node), context))

        def announceTopics(self, readers, writers, node, context=None):
            """
            Announce a set of topic readers and writers.
            
            Parameters
            ----------
            readers : str[]
                A sequence of topic names for readers.
            writers : str[]
                A sequence of topic names for writers.
            node : (DataStormContract.NodePrx or None)
                The node reading or writing the topics. The proxy is never null.
            context : Ice.Context
                The request context for the invocation.
            """
            return _M_DataStormContract.Lookup._op_announceTopics.invoke(self, ((readers, writers, node), context))

        def announceTopicsAsync(self, readers, writers, node, context=None):
            """
            Announce a set of topic readers and writers.
            
            Parameters
            ----------
            readers : str[]
                A sequence of topic names for readers.
            writers : str[]
                A sequence of topic names for writers.
            node : (DataStormContract.NodePrx or None)
                The node reading or writing the topics. The proxy is never null.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_DataStormContract.Lookup._op_announceTopics.invokeAsync(self, ((readers, writers, node), context))

        def createSession(self, node, context=None):
            """
            Establish a connection between this node and another node.
            
            Parameters
            ----------
            node : (DataStormContract.NodePrx or None)
                The node initiating the connection. The proxy is never null.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            (DataStormContract.NodePrx or None)
                A proxy to this node. The proxy is never null.
            """
            return _M_DataStormContract.Lookup._op_createSession.invoke(self, ((node, ), context))

        def createSessionAsync(self, node, context=None):
            """
            Establish a connection between this node and another node.
            
            Parameters
            ----------
            node : (DataStormContract.NodePrx or None)
                The node initiating the connection. The proxy is never null.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_DataStormContract.Lookup._op_createSession.invokeAsync(self, ((node, ), context))

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_DataStormContract.LookupPrx.ice_checkedCast(proxy, '::DataStormContract::Lookup', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_DataStormContract.LookupPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::DataStormContract::Lookup'
    _M_DataStormContract._t_LookupPrx = IcePy.defineProxy('::DataStormContract::Lookup', LookupPrx)

    _M_DataStormContract.LookupPrx = LookupPrx
    del LookupPrx

    _M_DataStormContract.Lookup = None
    class Lookup(Ice.Object):

        def ice_ids(self, current=None):
            return ('::DataStormContract::Lookup', '::Ice::Object')

        def ice_id(self, current=None):
            return '::DataStormContract::Lookup'

        @staticmethod
        def ice_staticId():
            return '::DataStormContract::Lookup'

        def announceTopicReader(self, topic, node, current=None):
            """
            Announce a topic reader.
            
            Parameters
            ----------
            topic : str
                The name of the topic.
            node : (DataStormContract.NodePrx or None)
                The node reading the topic. The proxy is never null.
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 'announceTopicReader' not implemented")

        def announceTopicWriter(self, topic, node, current=None):
            """
            Announce a topic writer.
            
            Parameters
            ----------
            topic : str
                The name of the topic.
            node : (DataStormContract.NodePrx or None)
                The node writing the topic. The proxy is never null.
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 'announceTopicWriter' not implemented")

        def announceTopics(self, readers, writers, node, current=None):
            """
            Announce a set of topic readers and writers.
            
            Parameters
            ----------
            readers : str[]
                A sequence of topic names for readers.
            writers : str[]
                A sequence of topic names for writers.
            node : (DataStormContract.NodePrx or None)
                The node reading or writing the topics. The proxy is never null.
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 'announceTopics' not implemented")

        def createSession(self, node, current=None):
            """
            Establish a connection between this node and another node.
            
            Parameters
            ----------
            node : (DataStormContract.NodePrx or None)
                The node initiating the connection. The proxy is never null.
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 'createSession' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_LookupDisp)

        __repr__ = __str__

    Lookup._op_announceTopicReader = IcePy.Operation('announceTopicReader', Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_string, False, 0), ((), _M_DataStormContract._t_NodePrx, False, 0)), (), None, ())
    Lookup._op_announceTopicWriter = IcePy.Operation('announceTopicWriter', Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_string, False, 0), ((), _M_DataStormContract._t_NodePrx, False, 0)), (), None, ())
    Lookup._op_announceTopics = IcePy.Operation('announceTopics', Ice.OperationMode.Idempotent, False, None, (), (((), _M_Ice._t_StringSeq, False, 0), ((), _M_Ice._t_StringSeq, False, 0), ((), _M_DataStormContract._t_NodePrx, False, 0)), (), None, ())
    Lookup._op_createSession = IcePy.Operation('createSession', Ice.OperationMode.Normal, False, None, (), (((), _M_DataStormContract._t_NodePrx, False, 0),), (), ((), _M_DataStormContract._t_NodePrx, False, 0), ())

    _M_DataStormContract.Lookup = Lookup
    del Lookup

# End of module DataStormContract
