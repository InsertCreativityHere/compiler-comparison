# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.8.0-alpha.0
#
# <auto-generated>
#
# Generated from file 'Contract.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

import Ice
import IcePy
import builtins as _builtins
import Ice.Identity_ice
import Ice.BuiltinSequences_ice
import DataStorm_Sample_ice

# Included module Ice
_M_Ice = Ice.openModule('Ice')

# Included module DataStorm
_M_DataStorm = Ice.openModule('DataStorm')

# Start of module DataStormContract
_M_DataStormContract = Ice.openModule('DataStormContract')
__name__ = 'DataStormContract'

if 'ClearHistoryPolicy' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.ClearHistoryPolicy = None
    class ClearHistoryPolicy(Ice.EnumBase):
        """
        Defines policies for clearing the data sample history of a reader in response to sample events.
        
        Enumerators:
        OnAdd -- The reader clears its history when a new data sample is added.
        OnRemove -- The reader clears its history when a data sample is removed.
        OnAll -- The reader clears its history when any data sample event occurs.
        OnAllExceptPartialUpdate -- The reader clears its history for all data sample events except for partial update events.
        Never -- The reader never clears its history.
        """

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    ClearHistoryPolicy.OnAdd = ClearHistoryPolicy("OnAdd", 0)
    ClearHistoryPolicy.OnRemove = ClearHistoryPolicy("OnRemove", 1)
    ClearHistoryPolicy.OnAll = ClearHistoryPolicy("OnAll", 2)
    ClearHistoryPolicy.OnAllExceptPartialUpdate = ClearHistoryPolicy("OnAllExceptPartialUpdate", 3)
    ClearHistoryPolicy.Never = ClearHistoryPolicy("Never", 4)
    ClearHistoryPolicy._enumerators = { 0:ClearHistoryPolicy.OnAdd, 1:ClearHistoryPolicy.OnRemove, 2:ClearHistoryPolicy.OnAll, 3:ClearHistoryPolicy.OnAllExceptPartialUpdate, 4:ClearHistoryPolicy.Never }

    _M_DataStormContract._t_ClearHistoryPolicy = IcePy.defineEnum('::DataStormContract::ClearHistoryPolicy', ClearHistoryPolicy, (), ClearHistoryPolicy._enumerators)

    _M_DataStormContract.ClearHistoryPolicy = ClearHistoryPolicy
    del ClearHistoryPolicy

if '_t_LongLongDict' not in _M_DataStormContract.__dict__:
    _M_DataStormContract._t_LongLongDict = IcePy.defineDictionary('::DataStormContract::LongLongDict', (), IcePy._t_long, IcePy._t_long)

if 'DataSample' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.DataSample = None
    class DataSample(object):
        """
        Represents a data sample, the fundamental unit of data exchanged between DataStorm readers and writers.
        
        Attributes
        ----------
        id : int
            The unique identifier for the sample.
        keyId : int
            The unique identifier for the associated key.
            A negative value (< 0) indicates a key filter.
        keyValue : int[]
            The encoded key value, used when keyId < 0 (key filter).
        timestamp : int
            The timestamp when the sample was written, in milliseconds since the epoch.
        tag : int
            An update tag, used for PartialUpdate sample events.
        event : DataStorm.SampleEvent
            The event type associated with this sample (e.g., Add, Update, PartialUpdate, Remove).
        value : int[]
            The payload data of the sample.
        """
        def __init__(self, id=0, keyId=0, keyValue=None, timestamp=0, tag=0, event=_M_DataStorm.SampleEvent.Add, value=None):
            self.id = id
            self.keyId = keyId
            self.keyValue = keyValue
            self.timestamp = timestamp
            self.tag = tag
            self.event = event
            self.value = value

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_DataStormContract.DataSample):
                return NotImplemented
            else:
                if self.id != other.id:
                    return False
                if self.keyId != other.keyId:
                    return False
                if self.keyValue != other.keyValue:
                    return False
                if self.timestamp != other.timestamp:
                    return False
                if self.tag != other.tag:
                    return False
                if self.event != other.event:
                    return False
                if self.value != other.value:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_DataSample)

        __repr__ = __str__

    _M_DataStormContract._t_DataSample = IcePy.defineStruct('::DataStormContract::DataSample', DataSample, (), (
        ('id', (), IcePy._t_long),
        ('keyId', (), IcePy._t_long),
        ('keyValue', (), _M_Ice._t_ByteSeq),
        ('timestamp', (), IcePy._t_long),
        ('tag', (), IcePy._t_long),
        ('event', (), _M_DataStorm._t_SampleEvent),
        ('value', (), _M_Ice._t_ByteSeq)
    ))

    _M_DataStormContract.DataSample = DataSample
    del DataSample

if '_t_DataSampleSeq' not in _M_DataStormContract.__dict__:
    _M_DataStormContract._t_DataSampleSeq = IcePy.defineSequence('::DataStormContract::DataSampleSeq', (), _M_DataStormContract._t_DataSample)

if 'DataSamples' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.DataSamples = None
    class DataSamples(object):
        """
        Represents a collection of data samples produced by a specific writer.
        
        Attributes
        ----------
        id : int
            The unique identifier for the writer.
        samples : DataStormContract.DataSample[]
            The sequence of samples produced by the writer.
        """
        def __init__(self, id=0, samples=None):
            self.id = id
            self.samples = samples

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_DataStormContract.DataSamples):
                return NotImplemented
            else:
                if self.id != other.id:
                    return False
                if self.samples != other.samples:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_DataSamples)

        __repr__ = __str__

    _M_DataStormContract._t_DataSamples = IcePy.defineStruct('::DataStormContract::DataSamples', DataSamples, (), (
        ('id', (), IcePy._t_long),
        ('samples', (), _M_DataStormContract._t_DataSampleSeq)
    ))

    _M_DataStormContract.DataSamples = DataSamples
    del DataSamples

if '_t_DataSamplesSeq' not in _M_DataStormContract.__dict__:
    _M_DataStormContract._t_DataSamplesSeq = IcePy.defineSequence('::DataStormContract::DataSamplesSeq', (), _M_DataStormContract._t_DataSamples)

if 'ElementInfo' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.ElementInfo = None
    class ElementInfo(object):
        """
        Provides metadata about an element, such as a key, filter, or tag.
        
        Attributes
        ----------
        id : int
            The unique identifier for the element.
            Negative values indicate filter IDs; positive values indicate key or tag IDs.
        name : str
            The name of the element. Empty for key and tag elements.
        value : int[]
            The encoded value of the element.
        """
        def __init__(self, id=0, name='', value=None):
            self.id = id
            self.name = name
            self.value = value

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_DataStormContract.ElementInfo):
                return NotImplemented
            else:
                if self.id != other.id:
                    return False
                if self.name != other.name:
                    return False
                if self.value != other.value:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_ElementInfo)

        __repr__ = __str__

    _M_DataStormContract._t_ElementInfo = IcePy.defineStruct('::DataStormContract::ElementInfo', ElementInfo, (), (
        ('id', (), IcePy._t_long),
        ('name', (), IcePy._t_string),
        ('value', (), _M_Ice._t_ByteSeq)
    ))

    _M_DataStormContract.ElementInfo = ElementInfo
    del ElementInfo

if '_t_ElementInfoSeq' not in _M_DataStormContract.__dict__:
    _M_DataStormContract._t_ElementInfoSeq = IcePy.defineSequence('::DataStormContract::ElementInfoSeq', (), _M_DataStormContract._t_ElementInfo)

if 'TopicInfo' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.TopicInfo = None
    class TopicInfo(object):
        """
        Contains metadata about a topic, including its name and associated reader/writer IDs.
        
        Attributes
        ----------
        name : str
            The name of the topic.
        ids : int[]
            The list of active topic reader or writer IDs.
            
            - In a publisher session,  the `ids` field contains the active topic writer IDs.
            - In a subscriber session,  the `ids` field contains the active topic reader IDs.
        """
        def __init__(self, name='', ids=None):
            self.name = name
            self.ids = ids

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_DataStormContract.TopicInfo):
                return NotImplemented
            else:
                if self.name != other.name:
                    return False
                if self.ids != other.ids:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_TopicInfo)

        __repr__ = __str__

    _M_DataStormContract._t_TopicInfo = IcePy.defineStruct('::DataStormContract::TopicInfo', TopicInfo, (), (
        ('name', (), IcePy._t_string),
        ('ids', (), _M_Ice._t_LongSeq)
    ))

    _M_DataStormContract.TopicInfo = TopicInfo
    del TopicInfo

if '_t_TopicInfoSeq' not in _M_DataStormContract.__dict__:
    _M_DataStormContract._t_TopicInfoSeq = IcePy.defineSequence('::DataStormContract::TopicInfoSeq', (), _M_DataStormContract._t_TopicInfo)

if 'TopicSpec' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.TopicSpec = None
    class TopicSpec(object):
        """
        Provides detailed information about topic readers and topic writers, including its ID, name, keys, filters,
        and tags.
        
        Attributes
        ----------
        id : int
            The unique identifier for the topic.
            The ID uniquely identifies a topic reader or topic writer within a node.
        name : str
            The name of the topic.
        elements : DataStormContract.ElementInfo[]
            The topic's keys and filters.
        tags : DataStormContract.ElementInfo[]
            The topic update tags.
        """
        def __init__(self, id=0, name='', elements=None, tags=None):
            self.id = id
            self.name = name
            self.elements = elements
            self.tags = tags

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_DataStormContract.TopicSpec):
                return NotImplemented
            else:
                if self.id != other.id:
                    return False
                if self.name != other.name:
                    return False
                if self.elements != other.elements:
                    return False
                if self.tags != other.tags:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_TopicSpec)

        __repr__ = __str__

    _M_DataStormContract._t_TopicSpec = IcePy.defineStruct('::DataStormContract::TopicSpec', TopicSpec, (), (
        ('id', (), IcePy._t_long),
        ('name', (), IcePy._t_string),
        ('elements', (), _M_DataStormContract._t_ElementInfoSeq),
        ('tags', (), _M_DataStormContract._t_ElementInfoSeq)
    ))

    _M_DataStormContract.TopicSpec = TopicSpec
    del TopicSpec

if 'FilterInfo' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.FilterInfo = None
    class FilterInfo(object):
        """
        Represents a sample filter that specifies which samples should be sent to a data reader.
        
        Attributes
        ----------
        name : str
            The unique name of the filter, used for identification.
        criteria : int[]
            The encoded criteria for instantiating the filter.
        """
        def __init__(self, name='', criteria=None):
            self.name = name
            self.criteria = criteria

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_DataStormContract.FilterInfo):
                return NotImplemented
            else:
                if self.name != other.name:
                    return False
                if self.criteria != other.criteria:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_FilterInfo)

        __repr__ = __str__

    _M_DataStormContract._t_FilterInfo = IcePy.defineStruct('::DataStormContract::FilterInfo', FilterInfo, (), (
        ('name', (), IcePy._t_string),
        ('criteria', (), _M_Ice._t_ByteSeq)
    ))

    _M_DataStormContract.FilterInfo = FilterInfo
    del FilterInfo

if 'ElementConfig' not in _M_DataStormContract.__dict__:
    _M_DataStormContract._t_ElementConfig = IcePy.declareValue('::DataStormContract::ElementConfig')

if 'ElementConfig' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.ElementConfig = None
    class ElementConfig(Ice.Value):
        """
        Represents the configuration of a data reader or data writer, including optional filters and priorities.
        
        Attributes
        ----------
        facet : (str or None)
            A facet that is used to process the samples when sample filtering is enabled.
        sampleFilter : (DataStormContract.FilterInfo or None)
            An optional sample filter associated with the reader. Sample filters are specified on the reader side.
        name : (str or None)
            An optional name for the reader or writer.
        priority : (int or None)
            An optional priority for the writer.
            See also the `DataStorm.Topic.Priority` property.
        sampleCount : (int or None)
            An optional sample count, specifying the number of samples queued in the writer or reader sample queue.
            See also the `DataStorm.Topic.SampleCount` property.
        sampleLifetime : (int or None)
            An optional lifetime, specified in milliseconds, representing the maximum time samples are kept in the
            writer or reader sample queue. See also the `DataStorm.Topic.SampleLifetime` property.
        clearHistory : (DataStormContract.ClearHistoryPolicy or None)
            An optional clear history policy that determines when the reader or writer sample history is cleared.
            See also the `DataStorm.Topic.ClearHistory` property.
        """
        def __init__(self, facet=None, sampleFilter=None, name=None, priority=None, sampleCount=None, sampleLifetime=None, clearHistory=None):
            self.facet = facet
            self.sampleFilter = sampleFilter
            self.name = name
            self.priority = priority
            self.sampleCount = sampleCount
            self.sampleLifetime = sampleLifetime
            self.clearHistory = clearHistory

        def ice_id(self):
            return '::DataStormContract::ElementConfig'

        @staticmethod
        def ice_staticId():
            return '::DataStormContract::ElementConfig'

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_ElementConfig)

        __repr__ = __str__

    _M_DataStormContract._t_ElementConfig = IcePy.defineValue('::DataStormContract::ElementConfig', ElementConfig, 1, (), False, None, (
        ('facet', (), IcePy._t_string, True, 1),
        ('sampleFilter', (), _M_DataStormContract._t_FilterInfo, True, 2),
        ('name', (), IcePy._t_string, True, 3),
        ('priority', (), IcePy._t_int, True, 4),
        ('sampleCount', (), IcePy._t_int, True, 10),
        ('sampleLifetime', (), IcePy._t_int, True, 11),
        ('clearHistory', (), _M_DataStormContract._t_ClearHistoryPolicy, True, 12)
    ))
    ElementConfig._ice_type = _M_DataStormContract._t_ElementConfig

    _M_DataStormContract.ElementConfig = ElementConfig
    del ElementConfig

if 'ElementData' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.ElementData = None
    class ElementData(object):
        """
        Encapsulates the state and configuration data for a data reader or data writer.
        
        Attributes
        ----------
        id : int
            The unique identifier for the data reader or data writer.
        config : DataStormContract.ElementConfig
            The configuration settings for the data reader or data writer.
        lastIds : dict where keys are int and values are int
            A mapping of data writer IDs to the last sample IDs received by the data reader.
            
            - The key represents the data writer ID.
            - The value represents the last sample ID received from the corresponding data writer.
        """
        def __init__(self, id=0, config=None, lastIds=None):
            self.id = id
            self.config = config
            self.lastIds = lastIds

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_DataStormContract.ElementData):
                return NotImplemented
            else:
                if self.id != other.id:
                    return False
                if self.config != other.config:
                    return False
                if self.lastIds != other.lastIds:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_ElementData)

        __repr__ = __str__

    _M_DataStormContract._t_ElementData = IcePy.defineStruct('::DataStormContract::ElementData', ElementData, (), (
        ('id', (), IcePy._t_long),
        ('config', (), _M_DataStormContract._t_ElementConfig),
        ('lastIds', (), _M_DataStormContract._t_LongLongDict)
    ))

    _M_DataStormContract.ElementData = ElementData
    del ElementData

if '_t_ElementDataSeq' not in _M_DataStormContract.__dict__:
    _M_DataStormContract._t_ElementDataSeq = IcePy.defineSequence('::DataStormContract::ElementDataSeq', (), _M_DataStormContract._t_ElementData)

if 'ElementSpec' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.ElementSpec = None
    class ElementSpec(object):
        """
        Represents detailed information about topic elements, which can be a key or a filter.
        
        Attributes
        ----------
        elements : DataStormContract.ElementData[]
            A sequence of data readers and writers associated with the key or filter.
        id : int
            The unique identifier for the key or filter.
        name : str
            The name of the filter.
            This field is empty if the element is a key.
        value : int[]
            The encoded value of the key or filter.
        peerId : int
            The unique identifier for the key or filter on the peer.
        peerName : str
            The name of the filter on the peer.
            This field is empty if the element is a key.
        """
        def __init__(self, elements=None, id=0, name='', value=None, peerId=0, peerName=''):
            self.elements = elements
            self.id = id
            self.name = name
            self.value = value
            self.peerId = peerId
            self.peerName = peerName

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_DataStormContract.ElementSpec):
                return NotImplemented
            else:
                if self.elements != other.elements:
                    return False
                if self.id != other.id:
                    return False
                if self.name != other.name:
                    return False
                if self.value != other.value:
                    return False
                if self.peerId != other.peerId:
                    return False
                if self.peerName != other.peerName:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_ElementSpec)

        __repr__ = __str__

    _M_DataStormContract._t_ElementSpec = IcePy.defineStruct('::DataStormContract::ElementSpec', ElementSpec, (), (
        ('elements', (), _M_DataStormContract._t_ElementDataSeq),
        ('id', (), IcePy._t_long),
        ('name', (), IcePy._t_string),
        ('value', (), _M_Ice._t_ByteSeq),
        ('peerId', (), IcePy._t_long),
        ('peerName', (), IcePy._t_string)
    ))

    _M_DataStormContract.ElementSpec = ElementSpec
    del ElementSpec

if '_t_ElementSpecSeq' not in _M_DataStormContract.__dict__:
    _M_DataStormContract._t_ElementSpecSeq = IcePy.defineSequence('::DataStormContract::ElementSpecSeq', (), _M_DataStormContract._t_ElementSpec)

if 'ElementDataAck' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.ElementDataAck = None
    class ElementDataAck(object):
        """
        Represents an acknowledgment of the attachment of data readers or data writers associated with a key or filter.
        
        Attributes
        ----------
        id : int
            The unique identifier for the data reader or data writer.
        config : DataStormContract.ElementConfig
            The configuration settings for the data reader or data writer.
        lastIds : dict where keys are int and values are int
            A mapping of data writer IDs to the last sample IDs received by the data reader.
            
            - The key represents the data writer ID.
            - The value represents the last sample ID received from the corresponding data writer.
        samples : DataStormContract.DataSample[]
            A sequence of samples in the writer's queue, used to initialize the reader.
            
            - When this struct is sent from a subscriber to a publisher, this field is empty.
            - When sent from a publisher to a subscriber, this field contains the queued samples.
        peerId : int
            The unique identifier for the peer's data reader or data writer.
        """
        def __init__(self, id=0, config=None, lastIds=None, samples=None, peerId=0):
            self.id = id
            self.config = config
            self.lastIds = lastIds
            self.samples = samples
            self.peerId = peerId

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_DataStormContract.ElementDataAck):
                return NotImplemented
            else:
                if self.id != other.id:
                    return False
                if self.config != other.config:
                    return False
                if self.lastIds != other.lastIds:
                    return False
                if self.samples != other.samples:
                    return False
                if self.peerId != other.peerId:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_ElementDataAck)

        __repr__ = __str__

    _M_DataStormContract._t_ElementDataAck = IcePy.defineStruct('::DataStormContract::ElementDataAck', ElementDataAck, (), (
        ('id', (), IcePy._t_long),
        ('config', (), _M_DataStormContract._t_ElementConfig),
        ('lastIds', (), _M_DataStormContract._t_LongLongDict),
        ('samples', (), _M_DataStormContract._t_DataSampleSeq),
        ('peerId', (), IcePy._t_long)
    ))

    _M_DataStormContract.ElementDataAck = ElementDataAck
    del ElementDataAck

if '_t_ElementDataAckSeq' not in _M_DataStormContract.__dict__:
    _M_DataStormContract._t_ElementDataAckSeq = IcePy.defineSequence('::DataStormContract::ElementDataAckSeq', (), _M_DataStormContract._t_ElementDataAck)

if 'ElementSpecAck' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.ElementSpecAck = None
    class ElementSpecAck(object):
        """
        Represents an acknowledgment of the attachment of an element, which can be a key or a filter.
        
        Attributes
        ----------
        elements : DataStormContract.ElementDataAck[]
            A sequence of acknowledgments for the readers or writers associated with the key or filter.
        id : int
            The unique identifier for the key or filter.
        name : str
            The name of the filter.
            This field is empty if the element is a key.
        value : int[]
            The encoded value of the key or filter.
        peerId : int
            The unique identifier for the key or filter on the peer.
        peerName : str
            The name of the filter on the peer.
            This field is empty if the element is a key.
        """
        def __init__(self, elements=None, id=0, name='', value=None, peerId=0, peerName=''):
            self.elements = elements
            self.id = id
            self.name = name
            self.value = value
            self.peerId = peerId
            self.peerName = peerName

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_DataStormContract.ElementSpecAck):
                return NotImplemented
            else:
                if self.elements != other.elements:
                    return False
                if self.id != other.id:
                    return False
                if self.name != other.name:
                    return False
                if self.value != other.value:
                    return False
                if self.peerId != other.peerId:
                    return False
                if self.peerName != other.peerName:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_ElementSpecAck)

        __repr__ = __str__

    _M_DataStormContract._t_ElementSpecAck = IcePy.defineStruct('::DataStormContract::ElementSpecAck', ElementSpecAck, (), (
        ('elements', (), _M_DataStormContract._t_ElementDataAckSeq),
        ('id', (), IcePy._t_long),
        ('name', (), IcePy._t_string),
        ('value', (), _M_Ice._t_ByteSeq),
        ('peerId', (), IcePy._t_long),
        ('peerName', (), IcePy._t_string)
    ))

    _M_DataStormContract.ElementSpecAck = ElementSpecAck
    del ElementSpecAck

if '_t_ElementSpecAckSeq' not in _M_DataStormContract.__dict__:
    _M_DataStormContract._t_ElementSpecAckSeq = IcePy.defineSequence('::DataStormContract::ElementSpecAckSeq', (), _M_DataStormContract._t_ElementSpecAck)

if 'Session' not in _M_DataStormContract.__dict__:
    _M_DataStormContract._t_SessionPrx = IcePy.declareProxy('::DataStormContract::Session')

if 'SessionPrx' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.SessionPrx = None
    class SessionPrx(Ice.ObjectPrx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new SessionPrx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        def announceTopics(self, topics, initialize, context=None):
            """
            Announces topics to the peer during session establishment or when adding new topics.
            
            - During session establishment, announces existing topics.
            - For established sessions, announces newly added topics.
            
            A publisher session announces the topics it writes, and a subscriber session announces the topics it reads.
            
            The receiving peer invokes attachTopic for topics it is interested in.
            
            Parameters
            ----------
            topics : DataStormContract.TopicInfo[]
                The sequence of topics to announce.
            initialize : bool
                Currently unused.
            context : Ice.Context
                The request context for the invocation.
            """
            return _M_DataStormContract.Session._op_announceTopics.invoke(self, ((topics, initialize), context))

        def announceTopicsAsync(self, topics, initialize, context=None):
            """
            Announces topics to the peer during session establishment or when adding new topics.
            
            - During session establishment, announces existing topics.
            - For established sessions, announces newly added topics.
            
            A publisher session announces the topics it writes, and a subscriber session announces the topics it reads.
            
            The receiving peer invokes attachTopic for topics it is interested in.
            
            Parameters
            ----------
            topics : DataStormContract.TopicInfo[]
                The sequence of topics to announce.
            initialize : bool
                Currently unused.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_DataStormContract.Session._op_announceTopics.invokeAsync(self, ((topics, initialize), context))

        def attachTopic(self, topic, context=None):
            """
            This operation is invoked if the session is interested in the announced topic. Which occurs when:
            
            - The session has a reader for a topic that the peer writes, or
            - The session has a writer for a topic that the peer reads.
            
            Parameters
            ----------
            topic : DataStormContract.TopicSpec
                The TopicSpec describing the topic to attach.
            context : Ice.Context
                The request context for the invocation.
            """
            return _M_DataStormContract.Session._op_attachTopic.invoke(self, ((topic, ), context))

        def attachTopicAsync(self, topic, context=None):
            """
            This operation is invoked if the session is interested in the announced topic. Which occurs when:
            
            - The session has a reader for a topic that the peer writes, or
            - The session has a writer for a topic that the peer reads.
            
            Parameters
            ----------
            topic : DataStormContract.TopicSpec
                The TopicSpec describing the topic to attach.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_DataStormContract.Session._op_attachTopic.invokeAsync(self, ((topic, ), context))

        def detachTopic(self, topicId, context=None):
            """
            Detaches a topic from the session, typically called when the topic is destroyed.
            
            This operation is invoked by the topic on listener sessions during its destruction.
            
            Parameters
            ----------
            topicId : int
                The unique identifier for the topic to detach.
            context : Ice.Context
                The request context for the invocation.
            """
            return _M_DataStormContract.Session._op_detachTopic.invoke(self, ((topicId, ), context))

        def detachTopicAsync(self, topicId, context=None):
            """
            Detaches a topic from the session, typically called when the topic is destroyed.
            
            This operation is invoked by the topic on listener sessions during its destruction.
            
            Parameters
            ----------
            topicId : int
                The unique identifier for the topic to detach.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_DataStormContract.Session._op_detachTopic.invokeAsync(self, ((topicId, ), context))

        def attachTags(self, topicId, tags, initialize, context=None):
            """
            Attaches the specified tags to the subscriber of a topic.
            
            Tags are used to support partial update samples.
            
            Parameters
            ----------
            topicId : int
                The unique identifier for the topic to which the tags will be attached.
            tags : DataStormContract.ElementInfo[]
                The sequence of tags to attach, representing the partial update associations.
            initialize : bool
                Indicates whether the tags are being attached during session initialization.
            context : Ice.Context
                The request context for the invocation.
            """
            return _M_DataStormContract.Session._op_attachTags.invoke(self, ((topicId, tags, initialize), context))

        def attachTagsAsync(self, topicId, tags, initialize, context=None):
            """
            Attaches the specified tags to the subscriber of a topic.
            
            Tags are used to support partial update samples.
            
            Parameters
            ----------
            topicId : int
                The unique identifier for the topic to which the tags will be attached.
            tags : DataStormContract.ElementInfo[]
                The sequence of tags to attach, representing the partial update associations.
            initialize : bool
                Indicates whether the tags are being attached during session initialization.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_DataStormContract.Session._op_attachTags.invokeAsync(self, ((topicId, tags, initialize), context))

        def detachTags(self, topicId, tags, context=None):
            """
            Detaches tags from the session.
            
            Parameters
            ----------
            topicId : int
                The unique identifier for the topic.
            tags : int[]
                The sequence of tag identifiers to detach.
            context : Ice.Context
                The request context for the invocation.
            """
            return _M_DataStormContract.Session._op_detachTags.invoke(self, ((topicId, tags), context))

        def detachTagsAsync(self, topicId, tags, context=None):
            """
            Detaches tags from the session.
            
            Parameters
            ----------
            topicId : int
                The unique identifier for the topic.
            tags : int[]
                The sequence of tag identifiers to detach.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_DataStormContract.Session._op_detachTags.invokeAsync(self, ((topicId, tags), context))

        def announceElements(self, topicId, elements, context=None):
            """
            Announces elements associated with a topic to the peer.
            
            This operation informs the peer about new data readers or data writers associated with the specified topic.
            The receiving peer will invoke `attachElements` for any elements it is interested in.
            
            - A publisher session announces its data writers.
            - A subscriber session announces its data readers.
            
            Parameters
            ----------
            topicId : int
                The unique identifier for the topic to which the elements belong.
            elements : DataStormContract.ElementInfo[]
                The sequence of elements to announce, representing the data readers or data writers.
            context : Ice.Context
                The request context for the invocation.
            """
            return _M_DataStormContract.Session._op_announceElements.invoke(self, ((topicId, elements), context))

        def announceElementsAsync(self, topicId, elements, context=None):
            """
            Announces elements associated with a topic to the peer.
            
            This operation informs the peer about new data readers or data writers associated with the specified topic.
            The receiving peer will invoke `attachElements` for any elements it is interested in.
            
            - A publisher session announces its data writers.
            - A subscriber session announces its data readers.
            
            Parameters
            ----------
            topicId : int
                The unique identifier for the topic to which the elements belong.
            elements : DataStormContract.ElementInfo[]
                The sequence of elements to announce, representing the data readers or data writers.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_DataStormContract.Session._op_announceElements.invokeAsync(self, ((topicId, elements), context))

        def attachElements(self, topicId, elements, initialize, context=None):
            """
            Attaches the specified elements to the subscribers of a topic.
            
            This operation associates the provided elements, such as keys or filters, with the subscribers of the given
            topic.
            
            Parameters
            ----------
            topicId : int
                The unique identifier for the topic to which the elements belong.
            elements : DataStormContract.ElementSpec[]
                The sequence of `ElementSpec` objects representing the elements to attach.
            initialize : bool
                Indicates whether the elements are being attached during session initialization.
            context : Ice.Context
                The request context for the invocation.
            """
            return _M_DataStormContract.Session._op_attachElements.invoke(self, ((topicId, elements, initialize), context))

        def attachElementsAsync(self, topicId, elements, initialize, context=None):
            """
            Attaches the specified elements to the subscribers of a topic.
            
            This operation associates the provided elements, such as keys or filters, with the subscribers of the given
            topic.
            
            Parameters
            ----------
            topicId : int
                The unique identifier for the topic to which the elements belong.
            elements : DataStormContract.ElementSpec[]
                The sequence of `ElementSpec` objects representing the elements to attach.
            initialize : bool
                Indicates whether the elements are being attached during session initialization.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_DataStormContract.Session._op_attachElements.invokeAsync(self, ((topicId, elements, initialize), context))

        def attachElementsAck(self, topicId, elements, context=None):
            """
            Acknowledges the attachment of elements to the session in response to a previous attachElements request.
            
            This method confirms that the specified elements, such as keys or filters, have been successfully attached
            to the session.
            
            Parameters
            ----------
            topicId : int
                The unique identifier for the topic to which the elements belong.
            elements : DataStormContract.ElementSpecAck[]
                A sequence of `ElementSpecAck` objects representing the confirmed attachments.
            context : Ice.Context
                The request context for the invocation.
            """
            return _M_DataStormContract.Session._op_attachElementsAck.invoke(self, ((topicId, elements), context))

        def attachElementsAckAsync(self, topicId, elements, context=None):
            """
            Acknowledges the attachment of elements to the session in response to a previous attachElements request.
            
            This method confirms that the specified elements, such as keys or filters, have been successfully attached
            to the session.
            
            Parameters
            ----------
            topicId : int
                The unique identifier for the topic to which the elements belong.
            elements : DataStormContract.ElementSpecAck[]
                A sequence of `ElementSpecAck` objects representing the confirmed attachments.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_DataStormContract.Session._op_attachElementsAck.invokeAsync(self, ((topicId, elements), context))

        def detachElements(self, topicId, elements, context=None):
            """
            Instructs the peer to detach specific elements associated with a topic.
            
            This operation is invoked when the specified elements, such as keys or filters, are no longer valid
            and should be removed from the peer's session.
            
            Parameters
            ----------
            topicId : int
                The unique identifier for the topic to which the elements belong.
            elements : int[]
                A sequence of element identifiers representing the keys or filters to detach.
            context : Ice.Context
                The request context for the invocation.
            """
            return _M_DataStormContract.Session._op_detachElements.invoke(self, ((topicId, elements), context))

        def detachElementsAsync(self, topicId, elements, context=None):
            """
            Instructs the peer to detach specific elements associated with a topic.
            
            This operation is invoked when the specified elements, such as keys or filters, are no longer valid
            and should be removed from the peer's session.
            
            Parameters
            ----------
            topicId : int
                The unique identifier for the topic to which the elements belong.
            elements : int[]
                A sequence of element identifiers representing the keys or filters to detach.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_DataStormContract.Session._op_detachElements.invokeAsync(self, ((topicId, elements), context))

        def initSamples(self, topicId, samples, context=None):
            """
            Initializes the subscriber with the publisher queued samples for a topic during session establishment.
            
            Parameters
            ----------
            topicId : int
                The unique identifier for the topic.
            samples : DataStormContract.DataSamples[]
                A sequence of `DataSamples` containing the queued samples to initialize the subscriber.
            context : Ice.Context
                The request context for the invocation.
            """
            return _M_DataStormContract.Session._op_initSamples.invoke(self, ((topicId, samples), context))

        def initSamplesAsync(self, topicId, samples, context=None):
            """
            Initializes the subscriber with the publisher queued samples for a topic during session establishment.
            
            Parameters
            ----------
            topicId : int
                The unique identifier for the topic.
            samples : DataStormContract.DataSamples[]
                A sequence of `DataSamples` containing the queued samples to initialize the subscriber.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_DataStormContract.Session._op_initSamples.invokeAsync(self, ((topicId, samples), context))

        def disconnected(self, context=None):
            """
            Notifies the peer that the session is being disconnected.
            
            For sessions established through a relay node, this operation is invoked by the relay node if the connection
            between the relay node and the target node is lost.
            
            Parameters
            ----------
            context : Ice.Context
                The request context for the invocation.
            """
            return _M_DataStormContract.Session._op_disconnected.invoke(self, ((), context))

        def disconnectedAsync(self, context=None):
            """
            Notifies the peer that the session is being disconnected.
            
            For sessions established through a relay node, this operation is invoked by the relay node if the connection
            between the relay node and the target node is lost.
            
            Parameters
            ----------
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_DataStormContract.Session._op_disconnected.invokeAsync(self, ((), context))

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_DataStormContract.SessionPrx.ice_checkedCast(proxy, '::DataStormContract::Session', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_DataStormContract.SessionPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::DataStormContract::Session'
    _M_DataStormContract._t_SessionPrx = IcePy.defineProxy('::DataStormContract::Session', SessionPrx)

    _M_DataStormContract.SessionPrx = SessionPrx
    del SessionPrx

    _M_DataStormContract.Session = None
    class Session(Ice.Object):

        def ice_ids(self, current=None):
            return ('::DataStormContract::Session', '::Ice::Object')

        def ice_id(self, current=None):
            return '::DataStormContract::Session'

        @staticmethod
        def ice_staticId():
            return '::DataStormContract::Session'

        def announceTopics(self, topics, initialize, current=None):
            """
            Announces topics to the peer during session establishment or when adding new topics.
            
            - During session establishment, announces existing topics.
            - For established sessions, announces newly added topics.
            
            A publisher session announces the topics it writes, and a subscriber session announces the topics it reads.
            
            The receiving peer invokes attachTopic for topics it is interested in.
            
            Parameters
            ----------
            topics : DataStormContract.TopicInfo[]
                The sequence of topics to announce.
            initialize : bool
                Currently unused.
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 'announceTopics' not implemented")

        def attachTopic(self, topic, current=None):
            """
            This operation is invoked if the session is interested in the announced topic. Which occurs when:
            
            - The session has a reader for a topic that the peer writes, or
            - The session has a writer for a topic that the peer reads.
            
            Parameters
            ----------
            topic : DataStormContract.TopicSpec
                The TopicSpec describing the topic to attach.
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 'attachTopic' not implemented")

        def detachTopic(self, topicId, current=None):
            """
            Detaches a topic from the session, typically called when the topic is destroyed.
            
            This operation is invoked by the topic on listener sessions during its destruction.
            
            Parameters
            ----------
            topicId : int
                The unique identifier for the topic to detach.
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 'detachTopic' not implemented")

        def attachTags(self, topicId, tags, initialize, current=None):
            """
            Attaches the specified tags to the subscriber of a topic.
            
            Tags are used to support partial update samples.
            
            Parameters
            ----------
            topicId : int
                The unique identifier for the topic to which the tags will be attached.
            tags : DataStormContract.ElementInfo[]
                The sequence of tags to attach, representing the partial update associations.
            initialize : bool
                Indicates whether the tags are being attached during session initialization.
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 'attachTags' not implemented")

        def detachTags(self, topicId, tags, current=None):
            """
            Detaches tags from the session.
            
            Parameters
            ----------
            topicId : int
                The unique identifier for the topic.
            tags : int[]
                The sequence of tag identifiers to detach.
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 'detachTags' not implemented")

        def announceElements(self, topicId, elements, current=None):
            """
            Announces elements associated with a topic to the peer.
            
            This operation informs the peer about new data readers or data writers associated with the specified topic.
            The receiving peer will invoke `attachElements` for any elements it is interested in.
            
            - A publisher session announces its data writers.
            - A subscriber session announces its data readers.
            
            Parameters
            ----------
            topicId : int
                The unique identifier for the topic to which the elements belong.
            elements : DataStormContract.ElementInfo[]
                The sequence of elements to announce, representing the data readers or data writers.
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 'announceElements' not implemented")

        def attachElements(self, topicId, elements, initialize, current=None):
            """
            Attaches the specified elements to the subscribers of a topic.
            
            This operation associates the provided elements, such as keys or filters, with the subscribers of the given
            topic.
            
            Parameters
            ----------
            topicId : int
                The unique identifier for the topic to which the elements belong.
            elements : DataStormContract.ElementSpec[]
                The sequence of `ElementSpec` objects representing the elements to attach.
            initialize : bool
                Indicates whether the elements are being attached during session initialization.
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 'attachElements' not implemented")

        def attachElementsAck(self, topicId, elements, current=None):
            """
            Acknowledges the attachment of elements to the session in response to a previous attachElements request.
            
            This method confirms that the specified elements, such as keys or filters, have been successfully attached
            to the session.
            
            Parameters
            ----------
            topicId : int
                The unique identifier for the topic to which the elements belong.
            elements : DataStormContract.ElementSpecAck[]
                A sequence of `ElementSpecAck` objects representing the confirmed attachments.
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 'attachElementsAck' not implemented")

        def detachElements(self, topicId, elements, current=None):
            """
            Instructs the peer to detach specific elements associated with a topic.
            
            This operation is invoked when the specified elements, such as keys or filters, are no longer valid
            and should be removed from the peer's session.
            
            Parameters
            ----------
            topicId : int
                The unique identifier for the topic to which the elements belong.
            elements : int[]
                A sequence of element identifiers representing the keys or filters to detach.
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 'detachElements' not implemented")

        def initSamples(self, topicId, samples, current=None):
            """
            Initializes the subscriber with the publisher queued samples for a topic during session establishment.
            
            Parameters
            ----------
            topicId : int
                The unique identifier for the topic.
            samples : DataStormContract.DataSamples[]
                A sequence of `DataSamples` containing the queued samples to initialize the subscriber.
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 'initSamples' not implemented")

        def disconnected(self, current=None):
            """
            Notifies the peer that the session is being disconnected.
            
            For sessions established through a relay node, this operation is invoked by the relay node if the connection
            between the relay node and the target node is lost.
            
            Parameters
            ----------
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 'disconnected' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_SessionDisp)

        __repr__ = __str__

    Session._op_announceTopics = IcePy.Operation('announceTopics', Ice.OperationMode.Normal, False, None, (), (((), _M_DataStormContract._t_TopicInfoSeq, False, 0), ((), IcePy._t_bool, False, 0)), (), None, ())
    Session._op_attachTopic = IcePy.Operation('attachTopic', Ice.OperationMode.Normal, False, None, (), (((), _M_DataStormContract._t_TopicSpec, False, 0),), (), None, ())
    Session._op_detachTopic = IcePy.Operation('detachTopic', Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_long, False, 0),), (), None, ())
    Session._op_attachTags = IcePy.Operation('attachTags', Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_long, False, 0), ((), _M_DataStormContract._t_ElementInfoSeq, False, 0), ((), IcePy._t_bool, False, 0)), (), None, ())
    Session._op_detachTags = IcePy.Operation('detachTags', Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_long, False, 0), ((), _M_Ice._t_LongSeq, False, 0)), (), None, ())
    Session._op_announceElements = IcePy.Operation('announceElements', Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_long, False, 0), ((), _M_DataStormContract._t_ElementInfoSeq, False, 0)), (), None, ())
    Session._op_attachElements = IcePy.Operation('attachElements', Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_long, False, 0), ((), _M_DataStormContract._t_ElementSpecSeq, False, 0), ((), IcePy._t_bool, False, 0)), (), None, ())
    Session._op_attachElementsAck = IcePy.Operation('attachElementsAck', Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_long, False, 0), ((), _M_DataStormContract._t_ElementSpecAckSeq, False, 0)), (), None, ())
    Session._op_detachElements = IcePy.Operation('detachElements', Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_long, False, 0), ((), _M_Ice._t_LongSeq, False, 0)), (), None, ())
    Session._op_initSamples = IcePy.Operation('initSamples', Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_long, False, 0), ((), _M_DataStormContract._t_DataSamplesSeq, False, 0)), (), None, ())
    Session._op_disconnected = IcePy.Operation('disconnected', Ice.OperationMode.Normal, False, None, (), (), (), None, ())

    _M_DataStormContract.Session = Session
    del Session

if 'PublisherSession' not in _M_DataStormContract.__dict__:
    _M_DataStormContract._t_PublisherSessionPrx = IcePy.declareProxy('::DataStormContract::PublisherSession')

if 'PublisherSessionPrx' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.PublisherSessionPrx = None
    class PublisherSessionPrx(_M_DataStormContract.SessionPrx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new PublisherSessionPrx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_DataStormContract.PublisherSessionPrx.ice_checkedCast(proxy, '::DataStormContract::PublisherSession', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_DataStormContract.PublisherSessionPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::DataStormContract::PublisherSession'
    _M_DataStormContract._t_PublisherSessionPrx = IcePy.defineProxy('::DataStormContract::PublisherSession', PublisherSessionPrx)

    _M_DataStormContract.PublisherSessionPrx = PublisherSessionPrx
    del PublisherSessionPrx

    _M_DataStormContract.PublisherSession = None
    class PublisherSession(_M_DataStormContract.Session):

        def ice_ids(self, current=None):
            return ('::DataStormContract::PublisherSession', '::DataStormContract::Session', '::Ice::Object')

        def ice_id(self, current=None):
            return '::DataStormContract::PublisherSession'

        @staticmethod
        def ice_staticId():
            return '::DataStormContract::PublisherSession'

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_PublisherSessionDisp)

        __repr__ = __str__

    _M_DataStormContract.PublisherSession = PublisherSession
    del PublisherSession

if 'SubscriberSession' not in _M_DataStormContract.__dict__:
    _M_DataStormContract._t_SubscriberSessionPrx = IcePy.declareProxy('::DataStormContract::SubscriberSession')

if 'SubscriberSessionPrx' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.SubscriberSessionPrx = None
    class SubscriberSessionPrx(_M_DataStormContract.SessionPrx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new SubscriberSessionPrx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        def s(self, topicId, elementId, sample, context=None):
            """
            Queue a sample with the subscribers of the topic element.
            
            Parameters
            ----------
            topicId : int
                The unique identifier for the topic to which the sample belong.
            elementId : int
                The unique identifier for the element to which the sample belong.
            sample : DataStormContract.DataSample
                The sample to queue.
            context : Ice.Context
                The request context for the invocation.
            """
            return _M_DataStormContract.SubscriberSession._op_s.invoke(self, ((topicId, elementId, sample), context))

        def sAsync(self, topicId, elementId, sample, context=None):
            """
            Queue a sample with the subscribers of the topic element.
            
            Parameters
            ----------
            topicId : int
                The unique identifier for the topic to which the sample belong.
            elementId : int
                The unique identifier for the element to which the sample belong.
            sample : DataStormContract.DataSample
                The sample to queue.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_DataStormContract.SubscriberSession._op_s.invokeAsync(self, ((topicId, elementId, sample), context))

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_DataStormContract.SubscriberSessionPrx.ice_checkedCast(proxy, '::DataStormContract::SubscriberSession', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_DataStormContract.SubscriberSessionPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::DataStormContract::SubscriberSession'
    _M_DataStormContract._t_SubscriberSessionPrx = IcePy.defineProxy('::DataStormContract::SubscriberSession', SubscriberSessionPrx)

    _M_DataStormContract.SubscriberSessionPrx = SubscriberSessionPrx
    del SubscriberSessionPrx

    _M_DataStormContract.SubscriberSession = None
    class SubscriberSession(_M_DataStormContract.Session):

        def ice_ids(self, current=None):
            return ('::DataStormContract::Session', '::DataStormContract::SubscriberSession', '::Ice::Object')

        def ice_id(self, current=None):
            return '::DataStormContract::SubscriberSession'

        @staticmethod
        def ice_staticId():
            return '::DataStormContract::SubscriberSession'

        def s(self, topicId, elementId, sample, current=None):
            """
            Queue a sample with the subscribers of the topic element.
            
            Parameters
            ----------
            topicId : int
                The unique identifier for the topic to which the sample belong.
            elementId : int
                The unique identifier for the element to which the sample belong.
            sample : DataStormContract.DataSample
                The sample to queue.
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 's' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_SubscriberSessionDisp)

        __repr__ = __str__

    SubscriberSession._op_s = IcePy.Operation('s', Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_long, False, 0), ((), IcePy._t_long, False, 0), ((), _M_DataStormContract._t_DataSample, False, 0)), (), None, ())

    _M_DataStormContract.SubscriberSession = SubscriberSession
    del SubscriberSession

if 'Node' not in _M_DataStormContract.__dict__:
    _M_DataStormContract._t_NodePrx = IcePy.declareProxy('::DataStormContract::Node')

if 'NodePrx' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.NodePrx = None
    class NodePrx(Ice.ObjectPrx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new NodePrx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        def initiateCreateSession(self, publisher, context=None):
            """
            Initiate the creation of a publisher session with a node, after the target node has announced a topic
            reader for which this node has a corresponding topic writer.
            
            Parameters
            ----------
            publisher : (DataStormContract.NodePrx or None)
                The publisher node initiating the session. The proxy is never null.
            context : Ice.Context
                The request context for the invocation.
            """
            return _M_DataStormContract.Node._op_initiateCreateSession.invoke(self, ((publisher, ), context))

        def initiateCreateSessionAsync(self, publisher, context=None):
            """
            Initiate the creation of a publisher session with a node, after the target node has announced a topic
            reader for which this node has a corresponding topic writer.
            
            Parameters
            ----------
            publisher : (DataStormContract.NodePrx or None)
                The publisher node initiating the session. The proxy is never null.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_DataStormContract.Node._op_initiateCreateSession.invokeAsync(self, ((publisher, ), context))

        def createSession(self, subscriber, session, fromRelay, context=None):
            """
            Initiates the creation of a subscriber session with a node. The subscriber node sends this request to a
            publisher node in one of the following scenarios:
            
            - The subscriber has received a topic writer announcement from the publisher and has a matching topic
            reader.
            - The publisher node has previously sent a initiateCreateSession request.
            
            The publisher node dispatching this request then sends a confirmCreateSession request to the subscriber node
            to continue session establishment. If an active session already exists with the subscriber node, the
            request is ignored.
            
            Parameters
            ----------
            subscriber : (DataStormContract.NodePrx or None)
                The subscriber node initiating the session. This proxy is never null.
            session : (DataStormContract.SubscriberSessionPrx or None)
                The subscriber session being created. This proxy is never null.
            fromRelay : bool
                Indicates whether the session is being created from a relay node.
            context : Ice.Context
                The request context for the invocation.
            """
            return _M_DataStormContract.Node._op_createSession.invoke(self, ((subscriber, session, fromRelay), context))

        def createSessionAsync(self, subscriber, session, fromRelay, context=None):
            """
            Initiates the creation of a subscriber session with a node. The subscriber node sends this request to a
            publisher node in one of the following scenarios:
            
            - The subscriber has received a topic writer announcement from the publisher and has a matching topic
            reader.
            - The publisher node has previously sent a initiateCreateSession request.
            
            The publisher node dispatching this request then sends a confirmCreateSession request to the subscriber node
            to continue session establishment. If an active session already exists with the subscriber node, the
            request is ignored.
            
            Parameters
            ----------
            subscriber : (DataStormContract.NodePrx or None)
                The subscriber node initiating the session. This proxy is never null.
            session : (DataStormContract.SubscriberSessionPrx or None)
                The subscriber session being created. This proxy is never null.
            fromRelay : bool
                Indicates whether the session is being created from a relay node.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_DataStormContract.Node._op_createSession.invokeAsync(self, ((subscriber, session, fromRelay), context))

        def confirmCreateSession(self, publisher, session, context=None):
            """
            Confirm the creation of a publisher session with a node.
            
            Parameters
            ----------
            publisher : (DataStormContract.NodePrx or None)
                The publisher node confirming the session. The proxy is never null.
            session : (DataStormContract.PublisherSessionPrx or None)
                The publisher session being confirmed. The proxy is never null.
            context : Ice.Context
                The request context for the invocation.
            """
            return _M_DataStormContract.Node._op_confirmCreateSession.invoke(self, ((publisher, session), context))

        def confirmCreateSessionAsync(self, publisher, session, context=None):
            """
            Confirm the creation of a publisher session with a node.
            
            Parameters
            ----------
            publisher : (DataStormContract.NodePrx or None)
                The publisher node confirming the session. The proxy is never null.
            session : (DataStormContract.PublisherSessionPrx or None)
                The publisher session being confirmed. The proxy is never null.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_DataStormContract.Node._op_confirmCreateSession.invokeAsync(self, ((publisher, session), context))

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_DataStormContract.NodePrx.ice_checkedCast(proxy, '::DataStormContract::Node', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_DataStormContract.NodePrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::DataStormContract::Node'
    _M_DataStormContract._t_NodePrx = IcePy.defineProxy('::DataStormContract::Node', NodePrx)

    _M_DataStormContract.NodePrx = NodePrx
    del NodePrx

    _M_DataStormContract.Node = None
    class Node(Ice.Object):

        def ice_ids(self, current=None):
            return ('::DataStormContract::Node', '::Ice::Object')

        def ice_id(self, current=None):
            return '::DataStormContract::Node'

        @staticmethod
        def ice_staticId():
            return '::DataStormContract::Node'

        def initiateCreateSession(self, publisher, current=None):
            """
            Initiate the creation of a publisher session with a node, after the target node has announced a topic
            reader for which this node has a corresponding topic writer.
            
            Parameters
            ----------
            publisher : (DataStormContract.NodePrx or None)
                The publisher node initiating the session. The proxy is never null.
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 'initiateCreateSession' not implemented")

        def createSession(self, subscriber, session, fromRelay, current=None):
            """
            Initiates the creation of a subscriber session with a node. The subscriber node sends this request to a
            publisher node in one of the following scenarios:
            
            - The subscriber has received a topic writer announcement from the publisher and has a matching topic
            reader.
            - The publisher node has previously sent a initiateCreateSession request.
            
            The publisher node dispatching this request then sends a confirmCreateSession request to the subscriber node
            to continue session establishment. If an active session already exists with the subscriber node, the
            request is ignored.
            
            Parameters
            ----------
            subscriber : (DataStormContract.NodePrx or None)
                The subscriber node initiating the session. This proxy is never null.
            session : (DataStormContract.SubscriberSessionPrx or None)
                The subscriber session being created. This proxy is never null.
            fromRelay : bool
                Indicates whether the session is being created from a relay node.
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 'createSession' not implemented")

        def confirmCreateSession(self, publisher, session, current=None):
            """
            Confirm the creation of a publisher session with a node.
            
            Parameters
            ----------
            publisher : (DataStormContract.NodePrx or None)
                The publisher node confirming the session. The proxy is never null.
            session : (DataStormContract.PublisherSessionPrx or None)
                The publisher session being confirmed. The proxy is never null.
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 'confirmCreateSession' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_NodeDisp)

        __repr__ = __str__

    Node._op_initiateCreateSession = IcePy.Operation('initiateCreateSession', Ice.OperationMode.Normal, False, None, (), (((), _M_DataStormContract._t_NodePrx, False, 0),), (), None, ())
    Node._op_createSession = IcePy.Operation('createSession', Ice.OperationMode.Normal, False, None, (), (((), _M_DataStormContract._t_NodePrx, False, 0), ((), _M_DataStormContract._t_SubscriberSessionPrx, False, 0), ((), IcePy._t_bool, False, 0)), (), None, ())
    Node._op_confirmCreateSession = IcePy.Operation('confirmCreateSession', Ice.OperationMode.Normal, False, None, (), (((), _M_DataStormContract._t_NodePrx, False, 0), ((), _M_DataStormContract._t_PublisherSessionPrx, False, 0)), (), None, ())

    _M_DataStormContract.Node = Node
    del Node

if 'Lookup' not in _M_DataStormContract.__dict__:
    _M_DataStormContract._t_LookupPrx = IcePy.declareProxy('::DataStormContract::Lookup')

if 'LookupPrx' not in _M_DataStormContract.__dict__:
    _M_DataStormContract.LookupPrx = None
    class LookupPrx(Ice.ObjectPrx):

        def __init__(self, communicator, proxyString):
            """
            Creates a new LookupPrx proxy
            
            Parameters
            ----------
            communicator : Ice.Communicator
                The communicator of the new proxy.
            proxyString : str
                The string representation of the proxy.
            
            Raises
            ------
            ParseException
                Thrown when proxyString is not a valid proxy string.
            """
            super().__init__(communicator, proxyString)

        def announceTopicReader(self, topic, subscriber, context=None):
            """
            Announce a topic reader.
            
            Parameters
            ----------
            topic : str
                The name of the topic.
            subscriber : (DataStormContract.NodePrx or None)
                The node reading the topic. The subscriber proxy is never null.
            context : Ice.Context
                The request context for the invocation.
            """
            return _M_DataStormContract.Lookup._op_announceTopicReader.invoke(self, ((topic, subscriber), context))

        def announceTopicReaderAsync(self, topic, subscriber, context=None):
            """
            Announce a topic reader.
            
            Parameters
            ----------
            topic : str
                The name of the topic.
            subscriber : (DataStormContract.NodePrx or None)
                The node reading the topic. The subscriber proxy is never null.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_DataStormContract.Lookup._op_announceTopicReader.invokeAsync(self, ((topic, subscriber), context))

        def announceTopicWriter(self, topic, node, context=None):
            """
            Announce a topic writer.
            
            Parameters
            ----------
            topic : str
                The name of the topic.
            node : (DataStormContract.NodePrx or None)
                The node writing the topic. The proxy is never null.
            context : Ice.Context
                The request context for the invocation.
            """
            return _M_DataStormContract.Lookup._op_announceTopicWriter.invoke(self, ((topic, node), context))

        def announceTopicWriterAsync(self, topic, node, context=None):
            """
            Announce a topic writer.
            
            Parameters
            ----------
            topic : str
                The name of the topic.
            node : (DataStormContract.NodePrx or None)
                The node writing the topic. The proxy is never null.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_DataStormContract.Lookup._op_announceTopicWriter.invokeAsync(self, ((topic, node), context))

        def announceTopics(self, readers, writers, node, context=None):
            """
            Announce a set of topic readers and writers.
            
            Parameters
            ----------
            readers : str[]
                A sequence of topic names for readers.
            writers : str[]
                A sequence of topic names for writers.
            node : (DataStormContract.NodePrx or None)
                The node reading or writing the topics. The proxy is never null.
            context : Ice.Context
                The request context for the invocation.
            """
            return _M_DataStormContract.Lookup._op_announceTopics.invoke(self, ((readers, writers, node), context))

        def announceTopicsAsync(self, readers, writers, node, context=None):
            """
            Announce a set of topic readers and writers.
            
            Parameters
            ----------
            readers : str[]
                A sequence of topic names for readers.
            writers : str[]
                A sequence of topic names for writers.
            node : (DataStormContract.NodePrx or None)
                The node reading or writing the topics. The proxy is never null.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_DataStormContract.Lookup._op_announceTopics.invokeAsync(self, ((readers, writers, node), context))

        def createSession(self, node, context=None):
            """
            Establish a connection between this node and the caller node.
            
            Parameters
            ----------
            node : (DataStormContract.NodePrx or None)
                The node initiating the connection. The proxy is never null.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            (DataStormContract.NodePrx or None)
                A proxy to this node. The proxy is never null.
            """
            return _M_DataStormContract.Lookup._op_createSession.invoke(self, ((node, ), context))

        def createSessionAsync(self, node, context=None):
            """
            Establish a connection between this node and the caller node.
            
            Parameters
            ----------
            node : (DataStormContract.NodePrx or None)
                The node initiating the connection. The proxy is never null.
            context : Ice.Context
                The request context for the invocation.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the invocation.
            """
            return _M_DataStormContract.Lookup._op_createSession.invokeAsync(self, ((node, ), context))

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_DataStormContract.LookupPrx.ice_checkedCast(proxy, '::DataStormContract::Lookup', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_DataStormContract.LookupPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::DataStormContract::Lookup'
    _M_DataStormContract._t_LookupPrx = IcePy.defineProxy('::DataStormContract::Lookup', LookupPrx)

    _M_DataStormContract.LookupPrx = LookupPrx
    del LookupPrx

    _M_DataStormContract.Lookup = None
    class Lookup(Ice.Object):

        def ice_ids(self, current=None):
            return ('::DataStormContract::Lookup', '::Ice::Object')

        def ice_id(self, current=None):
            return '::DataStormContract::Lookup'

        @staticmethod
        def ice_staticId():
            return '::DataStormContract::Lookup'

        def announceTopicReader(self, topic, subscriber, current=None):
            """
            Announce a topic reader.
            
            Parameters
            ----------
            topic : str
                The name of the topic.
            subscriber : (DataStormContract.NodePrx or None)
                The node reading the topic. The subscriber proxy is never null.
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 'announceTopicReader' not implemented")

        def announceTopicWriter(self, topic, node, current=None):
            """
            Announce a topic writer.
            
            Parameters
            ----------
            topic : str
                The name of the topic.
            node : (DataStormContract.NodePrx or None)
                The node writing the topic. The proxy is never null.
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 'announceTopicWriter' not implemented")

        def announceTopics(self, readers, writers, node, current=None):
            """
            Announce a set of topic readers and writers.
            
            Parameters
            ----------
            readers : str[]
                A sequence of topic names for readers.
            writers : str[]
                A sequence of topic names for writers.
            node : (DataStormContract.NodePrx or None)
                The node reading or writing the topics. The proxy is never null.
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 'announceTopics' not implemented")

        def createSession(self, node, current=None):
            """
            Establish a connection between this node and the caller node.
            
            Parameters
            ----------
            node : (DataStormContract.NodePrx or None)
                The node initiating the connection. The proxy is never null.
            current : Ice.Current
                The Current object for the dispatch.
            
            Returns
            -------
            Ice.Future
                A future object that is completed with the result of the dispatch.
            """
            raise NotImplementedError("servant method 'createSession' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_DataStormContract._t_LookupDisp)

        __repr__ = __str__

    Lookup._op_announceTopicReader = IcePy.Operation('announceTopicReader', Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_string, False, 0), ((), _M_DataStormContract._t_NodePrx, False, 0)), (), None, ())
    Lookup._op_announceTopicWriter = IcePy.Operation('announceTopicWriter', Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_string, False, 0), ((), _M_DataStormContract._t_NodePrx, False, 0)), (), None, ())
    Lookup._op_announceTopics = IcePy.Operation('announceTopics', Ice.OperationMode.Idempotent, False, None, (), (((), _M_Ice._t_StringSeq, False, 0), ((), _M_Ice._t_StringSeq, False, 0), ((), _M_DataStormContract._t_NodePrx, False, 0)), (), None, ())
    Lookup._op_createSession = IcePy.Operation('createSession', Ice.OperationMode.Normal, False, None, (), (((), _M_DataStormContract._t_NodePrx, False, 0),), (), ((), _M_DataStormContract._t_NodePrx, False, 0), ())

    _M_DataStormContract.Lookup = Lookup
    del Lookup

# End of module DataStormContract
