//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file 'Key.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

/* eslint-disable */
/* jshint ignore: start */

import { Ice } from "ice";


export const and = {};

and.assert = Ice.defineEnum([
    ['_break', 0]]);

and._continue = class
{
    constructor(def = 0)
    {
        this.def = def;
    }

    _write(ostr)
    {
        ostr.writeInt(this.def);
    }

    _read(istr)
    {
        this.def = istr.readInt();
    }

    static get minWireSize()
    {
        return  4;
    }
};

Ice.defineStruct(and._continue, true, false);

const iceC_and_del_ids = [
    "::Ice::Object",
    "::and::del"
];

and.del = class extends Ice.Object
{
};

and.delPrx = class extends Ice.ObjectPrx
{
};
Ice.TypeRegistry.declareProxyType("and.delPrx", and.delPrx);

Ice.defineOperations(
    and.del,
    and.delPrx,
    iceC_and_del_ids,
    "::and::del",
    {
        "elif": [, , , , [[3]], [[3]], , , ]
    });

const iceC_and_exec_ids = [
    "::Ice::Object",
    "::and::exec"
];

and.exec = class extends Ice.Object
{
};

and.execPrx = class extends Ice.ObjectPrx
{
};
Ice.TypeRegistry.declareProxyType("and.execPrx", and.execPrx);

Ice.defineOperations(
    and.exec,
    and.execPrx,
    iceC_and_exec_ids,
    "::and::exec",
    {
        "finally": ["_finally", , , , , , , , ]
    });

and._for = class extends Ice.Value
{
    constructor(lambda = 0, from = null, global = 0)
    {
        super();
        this.lambda = lambda;
        this.from = from;
        this.global = global;
    }

    _iceWriteMemberImpl(ostr)
    {
        ostr.writeInt(this.lambda);
        ostr.writeProxy(this.from);
        ostr.writeInt(this.global);
    }

    _iceReadMemberImpl(istr)
    {
        this.lambda = istr.readInt();
        this.from = istr.readProxy();
        this.global = istr.readInt();
    }
};

Ice.defineValue(and._for, "::and::for");
Ice.TypeRegistry.declareValueType("and._for", and._for);

const iceC_and__if_ids = [
    "::Ice::Object",
    "::and::del",
    "::and::exec",
    "::and::if"
];

and._if = class extends Ice.Object
{
    static get _iceImplements()
    {
        return [
            and.exec,
            and.del
        ];
    }
};

and.ifPrx = class extends Ice.ObjectPrx
{
    static get _implements()
    {
        return [
            and.execPrx,
            and.delPrx];
    }
};
Ice.TypeRegistry.declareProxyType("and.ifPrx", and.ifPrx);

Ice.defineOperations(
    and._if,
    and.ifPrx,
    iceC_and__if_ids,
    "::and::if");

and._importHelper = Ice.StreamHelpers.generateSeqHelper(and.assert._helper, false);

[and._in, and._inHelper] = Ice.defineDictionary(Ice.StringHelper, and.assert._helper, false, undefined);

and.is = class extends Ice.UserException
{
    constructor(lambda = 0, _cause = "")
    {
        super(_cause);
        this.lambda = lambda;
    }

    static get _parent()
    {
        return Ice.UserException;
    }

    static get _ice_id()
    {
        return "::and::is";
    }

    _mostDerivedType()
    {
        return and.is;
    }

    _writeMemberImpl(ostr)
    {
        ostr.writeInt(this.lambda);
    }

    _readMemberImpl(istr)
    {
        this.lambda = istr.readInt();
    }
};
Ice.TypeRegistry.declareUserExceptionType(
    "and.is",
    and.is);

and.not = class extends and.is
{
    constructor(lambda, or = 0, pass = 0, _cause = "")
    {
        super(lambda, _cause);
        this.or = or;
        this.pass = pass;
    }

    static get _parent()
    {
        return and.is;
    }

    static get _ice_id()
    {
        return "::and::not";
    }

    _mostDerivedType()
    {
        return and.not;
    }

    _writeMemberImpl(ostr)
    {
        ostr.writeInt(this.or);
        ostr.writeInt(this.pass);
    }

    _readMemberImpl(istr)
    {
        this.or = istr.readInt();
        this.pass = istr.readInt();
    }
};
Ice.TypeRegistry.declareUserExceptionType(
    "and.not",
    and.not);

const iceC_and_print_ids = [
    "::Ice::Object",
    "::and::print"
];

and.print = class extends Ice.Object
{
};

and.printPrx = class extends Ice.ObjectPrx
{
};
Ice.TypeRegistry.declareProxyType("and.printPrx", and.printPrx);

Ice.defineOperations(
    and.print,
    and.printPrx,
    iceC_and_print_ids,
    "::and::print",
    {
        "raise": [, , , [and.assert._helper], [[and._continue], ["and._for", true], ["and.delPrx"], ["and.execPrx"], ["and.ifPrx"], [3]], ,
        [
            and.is
        ], true, ]
    });

Object.defineProperty(and, 'lambda', {
    enumerable: true,
    value: 0
});

and.EnumNone = Ice.defineEnum([
    ['None', 0]]);
