//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Key.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

/* eslint-disable */
/* jshint ignore: start */

(function(module, require, exports)
{
    const Ice = require("ice").Ice;
    const _ModuleRegistry = Ice._ModuleRegistry;
    const Slice = Ice.Slice;

    let abstract = _ModuleRegistry.module("abstract");

    abstract.assert = Slice.defineEnum([
        ['boolean', 0]]);

    abstract._break = class
    {
        constructor(_case = 0)
        {
            this._case = _case;
        }

        _write(ostr)
        {
            ostr.writeInt(this._case);
        }

        _read(istr)
        {
            this._case = istr.readInt();
        }

        static get minWireSize()
        {
            return  4;
        }
    };

    Slice.defineStruct(abstract._break, true, false);

    const iceC_abstract__catch_ids = [
        "::Ice::Object",
        "::abstract::catch"
    ];

    abstract.catch = class extends Ice.Object
    {
    };

    abstract.catchPrx = class extends Ice.ObjectPrx
    {
    };

    Slice.defineOperations(abstract.catch, abstract.catchPrx, iceC_abstract__catch_ids, 1,
    {
        "checkedCast": [, , , , , [[3]], [[3]], , , ]
    });

    const iceC_abstract__default_ids = [
        "::Ice::Object",
        "::abstract::default"
    ];

    abstract.default = class extends Ice.Object
    {
    };

    abstract.defaultPrx = class extends Ice.ObjectPrx
    {
    };

    Slice.defineOperations(abstract.default, abstract.defaultPrx, iceC_abstract__default_ids, 1,
    {
        "do": ["_do", , , , , , , , , ]
    });

    const iceC_abstract__else_ids = [
        "::Ice::Object",
        "::abstract::else"
    ];

    abstract._else = class extends Ice.Value
    {
        constructor(_if = 0, equals = null, final = 0)
        {
            super();
            this._if = _if;
            this.equals = equals;
            this.final = final;
        }

        _iceWriteMemberImpl(ostr)
        {
            ostr.writeInt(this._if);
            abstract.defaultPrx.write(ostr, this.equals);
            ostr.writeInt(this.final);
        }

        _iceReadMemberImpl(istr)
        {
            this._if = istr.readInt();
            this.equals = abstract.defaultPrx.read(istr, this.equals);
            this.final = istr.readInt();
        }
    };

    Slice.defineValue(abstract._else, iceC_abstract__else_ids[1], false);

    const iceC_abstract_finalize_ids = [
        "::Ice::Object",
        "::abstract::catch",
        "::abstract::default",
        "::abstract::finalize"
    ];

    abstract.finalize = class extends Ice.Object
    {
        static get _iceImplements()
        {
            return [
                abstract.default,
                abstract.catch
            ];
        }
    };

    abstract.finalizePrx = class extends Ice.ObjectPrx
    {
        static get _implements()
        {
            return [
                abstract.defaultPrx,
                abstract.catchPrx];
        }
    };

    Slice.defineOperations(abstract.finalize, abstract.finalizePrx, iceC_abstract_finalize_ids, 3);

    Slice.defineSequence(abstract, "_forHelper", "abstract.assert._helper", false);

    Slice.defineDictionary(abstract, "goto", "gotoHelper", "Ice.StringHelper", "abstract.assert._helper", false, undefined, undefined);

    abstract.hashCode = class extends Ice.UserException
    {
        constructor(_if = 0, _cause = "")
        {
            super(_cause);
            this._if = _if;
        }

        static get _parent()
        {
            return Ice.UserException;
        }

        static get _id()
        {
            return "::abstract::hashCode";
        }

        _mostDerivedType()
        {
            return abstract.hashCode;
        }

        _writeMemberImpl(ostr)
        {
            ostr.writeInt(this._if);
        }

        _readMemberImpl(istr)
        {
            this._if = istr.readInt();
        }
    };

    abstract._import = class extends abstract.hashCode
    {
        constructor(_if, _instanceof = 0, native = 0, _cause = "")
        {
            super(_if, _cause);
            this._instanceof = _instanceof;
            this.native = native;
        }

        static get _parent()
        {
            return abstract.hashCode;
        }

        static get _id()
        {
            return "::abstract::import";
        }

        _mostDerivedType()
        {
            return abstract._import;
        }

        _writeMemberImpl(ostr)
        {
            ostr.writeInt(this._instanceof);
            ostr.writeInt(this.native);
        }

        _readMemberImpl(istr)
        {
            this._instanceof = istr.readInt();
            this.native = istr.readInt();
        }
    };

    const iceC_abstract__new_ids = [
        "::Ice::Object",
        "::abstract::new"
    ];

    abstract.new = class extends Ice.Object
    {
    };

    abstract.newPrx = class extends Ice.ObjectPrx
    {
    };

    Slice.defineOperations(abstract.new, abstract.newPrx, iceC_abstract__new_ids, 1,
    {
        "notify": [, , , , [abstract.assert._helper], [[abstract._break], ["abstract._else", true], ["abstract.finalizePrx"], ["abstract.catchPrx"], ["abstract.defaultPrx"], [3], [3], [3]], ,
        [
            abstract._import,
            abstract.hashCode
        ], true, ]
    });

    Object.defineProperty(abstract, '_switch', {
        value: 0
    });

    Object.defineProperty(abstract, 'synchronized', {
        value: 0
    });

    Object.defineProperty(abstract, '_this', {
        value: 0
    });

    Object.defineProperty(abstract, '_throw', {
        value: 0
    });

    Object.defineProperty(abstract, 'toString', {
        value: 0
    });

    Object.defineProperty(abstract, '_try', {
        value: 0
    });

    Object.defineProperty(abstract, 'uncheckedCast', {
        value: 0
    });

    Object.defineProperty(abstract, 'volatile', {
        value: 0
    });

    Object.defineProperty(abstract, 'wait', {
        value: 0
    });

    Object.defineProperty(abstract, '_while', {
        value: 0
    });

    Object.defineProperty(abstract, '_finally', {
        value: 0
    });

    Object.defineProperty(abstract, 'getClass', {
        value: 0
    });
    exports.abstract = abstract;
}
(typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? module : undefined,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? require :
 (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) ? self.Ice._require : window.Ice._require,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? exports :
 (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) ? self : window));
