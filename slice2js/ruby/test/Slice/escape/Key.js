//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Key.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

/* eslint-disable */
/* jshint ignore: start */

(function(module, require, exports)
{
    const Ice = require("ice").Ice;
    const _ModuleRegistry = Ice._ModuleRegistry;
    const Slice = Ice.Slice;

    let BEGIN = _ModuleRegistry.module("BEGIN");

    BEGIN.END = Slice.defineEnum([
        ['alias', 0]]);

    BEGIN.and = class
    {
        constructor(begin = 0)
        {
            this.begin = begin;
        }

        _write(ostr)
        {
            ostr.writeInt(this.begin);
        }

        _read(istr)
        {
            this.begin = istr.readInt();
        }

        static get minWireSize()
        {
            return  4;
        }
    };

    Slice.defineStruct(BEGIN.and, true, false);

    const iceC_BEGIN__break_ids = [
        "::BEGIN::break",
        "::Ice::Object"
    ];

    BEGIN.break = class extends Ice.Object
    {
    };

    BEGIN.breakPrx = class extends Ice.ObjectPrx
    {
    };

    Slice.defineOperations(BEGIN.break, BEGIN.breakPrx, iceC_BEGIN__break_ids, 0,
    {
        "case": ["_case", , , , , [[3], [3]], , , , ],
        "to_a": [, , , , , , , , , ],
        "instance_variable_set": [, , , , , , , , , ],
        "instance_variables": [, , , , , , , , , ]
    });

    const iceC_BEGIN_display_ids = [
        "::BEGIN::display",
        "::Ice::Object"
    ];

    BEGIN.display = class extends Ice.Value
    {
        constructor(when = 0, _do = 0, dup = null, _else = 0)
        {
            super();
            this.when = when;
            this._do = _do;
            this.dup = dup;
            this._else = _else;
        }

        _iceWriteMemberImpl(ostr)
        {
            ostr.writeInt(this.when);
            ostr.writeInt(this._do);
            BEGIN.breakPrx.write(ostr, this.dup);
            ostr.writeInt(this._else);
        }

        _iceReadMemberImpl(istr)
        {
            this.when = istr.readInt();
            this._do = istr.readInt();
            this.dup = BEGIN.breakPrx.read(istr, this.dup);
            this._else = istr.readInt();
        }
    };

    Slice.defineValue(BEGIN.display, iceC_BEGIN_display_ids[0], false);

    const iceC_BEGIN_elsif_ids = [
        "::BEGIN::break",
        "::BEGIN::elsif",
        "::Ice::Object"
    ];

    BEGIN.elsif = class extends Ice.Object
    {
        static get _iceImplements()
        {
            return [
                BEGIN.break
            ];
        }
    };

    BEGIN.elsifPrx = class extends Ice.ObjectPrx
    {
        static get _implements()
        {
            return [
                BEGIN.breakPrx];
        }
    };

    Slice.defineOperations(BEGIN.elsif, BEGIN.elsifPrx, iceC_BEGIN_elsif_ids, 1);

    Slice.defineSequence(BEGIN, "rescueHelper", "BEGIN.END._helper", false);

    Slice.defineDictionary(BEGIN, "ensure", "ensureHelper", "Ice.StringHelper", "BEGIN.END._helper", false, undefined, undefined);

    BEGIN.next = class extends Ice.UserException
    {
        constructor(_new = 0, _cause = "")
        {
            super(_cause);
            this._new = _new;
        }

        static get _parent()
        {
            return Ice.UserException;
        }

        static get _id()
        {
            return "::BEGIN::next";
        }

        _mostDerivedType()
        {
            return BEGIN.next;
        }

        _writeMemberImpl(ostr)
        {
            ostr.writeInt(this._new);
        }

        _readMemberImpl(istr)
        {
            this._new = istr.readInt();
        }
    };

    BEGIN.nil = class extends BEGIN.next
    {
        constructor(_new, not = 0, or = 0, _cause = "")
        {
            super(_new, _cause);
            this.not = not;
            this.or = or;
        }

        static get _parent()
        {
            return BEGIN.next;
        }

        static get _id()
        {
            return "::BEGIN::nil";
        }

        _mostDerivedType()
        {
            return BEGIN.nil;
        }

        _writeMemberImpl(ostr)
        {
            ostr.writeInt(this.not);
            ostr.writeInt(this.or);
        }

        _readMemberImpl(istr)
        {
            this.not = istr.readInt();
            this.or = istr.readInt();
        }
    };

    const iceC_BEGIN_extend_ids = [
        "::BEGIN::extend",
        "::Ice::Object"
    ];

    BEGIN.extend = class extends Ice.Object
    {
    };

    BEGIN.extendPrx = class extends Ice.ObjectPrx
    {
    };

    Slice.defineOperations(BEGIN.extend, BEGIN.extendPrx, iceC_BEGIN_extend_ids, 0,
    {
        "for": ["_for", , , , [BEGIN.END._helper], [["BEGIN.display", true], ["BEGIN.elsifPrx"], ["BEGIN.breakPrx"], ["BEGIN.display", true], ["BEGIN.elsifPrx"], [3]], ,
        [
            BEGIN.nil
        ], true, ]
    });

    Object.defineProperty(BEGIN, 'redo', {
        value: 1
    });
    exports.BEGIN = BEGIN;
}
(typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? module : undefined,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? require :
 (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) ? self.Ice._require : window.Ice._require,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? exports :
 (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) ? self : window));
