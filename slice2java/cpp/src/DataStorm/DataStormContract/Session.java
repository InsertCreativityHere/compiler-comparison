// Copyright (c) ZeroC, Inc.
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file 'Contract.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>

package DataStormContract;

/**
 * The base interface for publisher and subscriber sessions.
 *
 * This interface specifies the operations for communication between publisher and subscriber sessions.
 *
 * @see PublisherSession
 * @see SubscriberSession
 **/
public interface Session extends com.zeroc.Ice.Object
{
    /**
     * Announces topics to the peer during session establishment or when adding new topics.
     *
     * - During session establishment, announces existing topics.
     * - For established sessions, announces newly added topics.
     *
     * A publisher session announces the topics it writes, and a subscriber session announces the topics it reads.
     *
     * The receiving peer invokes attachTopic for topics it is interested in.
     * @param topics The sequence of topics to announce.
     * @param initialize Currently unused.
     * @param current The Current object for the invocation.
     *
     * @see attachTopic
     **/
    void announceTopics(TopicInfo[] topics, boolean initialize, com.zeroc.Ice.Current current);

    /**
     * This operation is invoked if the session is interested in the announced topic. Which occurs when:
     *
     * - The session has a reader for a topic that the peer writes, or
     * - The session has a writer for a topic that the peer reads.
     * @param topic The TopicSpec describing the topic to attach.
     * @param current The Current object for the invocation.
     **/
    void attachTopic(TopicSpec topic, com.zeroc.Ice.Current current);

    /**
     * Detaches a topic from the session, typically called when the topic is destroyed.
     *
     * This operation is invoked by the topic on listener sessions during its destruction.
     * @param topicId The unique identifier for the topic to detach.
     * @param current The Current object for the invocation.
     **/
    void detachTopic(long topicId, com.zeroc.Ice.Current current);

    /**
     * Attaches the specified tags to the subscriber of a topic.
     *
     * Tags are used to support partial update samples.
     * @param topicId The unique identifier for the topic to which the tags will be attached.
     * @param tags The sequence of tags to attach, representing the partial update associations.
     * @param initialize Indicates whether the tags are being attached during session initialization.
     * @param current The Current object for the invocation.
     **/
    void attachTags(long topicId, ElementInfo[] tags, boolean initialize, com.zeroc.Ice.Current current);

    /**
     * Detaches tags from the session.
     * @param topicId The unique identifier for the topic.
     * @param tags The sequence of tag identifiers to detach.
     * @param current The Current object for the invocation.
     **/
    void detachTags(long topicId, long[] tags, com.zeroc.Ice.Current current);

    /**
     * Announces elements associated with a topic to the peer.
     *
     * This operation informs the peer about new data readers or data writers associated with the specified topic.
     * The receiving peer will invoke `attachElements` for any elements it is interested in.
     *
     * - A publisher session announces its data writers.
     * - A subscriber session announces its data readers.
     * @param topicId The unique identifier for the topic to which the elements belong.
     * @param elements The sequence of elements to announce, representing the data readers or data writers.
     * @param current The Current object for the invocation.
     *
     * @see attachElements
     **/
    void announceElements(long topicId, ElementInfo[] elements, com.zeroc.Ice.Current current);

    /**
     * Attaches the specified elements to the subscribers of a topic.
     *
     * This operation associates the provided elements, such as keys or filters, with the subscribers of the given
     * topic.
     * @param topicId The unique identifier for the topic to which the elements belong.
     * @param elements The sequence of `ElementSpec` objects representing the elements to attach.
     * @param initialize Indicates whether the elements are being attached during session initialization.
     * @param current The Current object for the invocation.
     **/
    void attachElements(long topicId, ElementSpec[] elements, boolean initialize, com.zeroc.Ice.Current current);

    /**
     * Acknowledges the attachment of elements to the session in response to a previous attachElements request.
     *
     * This method confirms that the specified elements, such as keys or filters, have been successfully attached
     * to the session.
     * @param topicId The unique identifier for the topic to which the elements belong.
     * @param elements A sequence of `ElementSpecAck` objects representing the confirmed attachments.
     * @param current The Current object for the invocation.
     **/
    void attachElementsAck(long topicId, ElementSpecAck[] elements, com.zeroc.Ice.Current current);

    /**
     * Instructs the peer to detach specific elements associated with a topic.
     *
     * This operation is invoked when the specified elements, such as keys or filters, are no longer valid
     * and should be removed from the peer's session.
     * @param topicId The unique identifier for the topic to which the elements belong.
     * @param elements A sequence of element identifiers representing the keys or filters to detach.
     * @param current The Current object for the invocation.
     **/
    void detachElements(long topicId, long[] elements, com.zeroc.Ice.Current current);

    /**
     * Initializes the subscriber with the publisher queued samples for a topic during session establishment.
     * @param topicId The unique identifier for the topic.
     * @param samples A sequence of `DataSamples` containing the queued samples to initialize the subscriber.
     * @param current The Current object for the invocation.
     **/
    void initSamples(long topicId, DataSamples[] samples, com.zeroc.Ice.Current current);

    /**
     * Notifies the peer that the session is being disconnected.
     *
     * For sessions established through a relay node, this operation is invoked by the relay node if the connection
     * between the relay node and the target node is lost.
     * @param current The Current object for the invocation.
     **/
    void disconnected(com.zeroc.Ice.Current current);

    /** @hidden */
    static final String[] _iceIds =
    {
        "::DataStormContract::Session",
        "::Ice::Object"
    };

    @Override
    default String[] ice_ids(com.zeroc.Ice.Current current)
    {
        return _iceIds;
    }

    @Override
    default String ice_id(com.zeroc.Ice.Current current)
    {
        return ice_staticId();
    }

    static String ice_staticId()
    {
        return "::DataStormContract::Session";
    }

    /** @hidden */
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutgoingResponse> _iceD_announceTopics(Session obj, com.zeroc.Ice.IncomingRequest request)
    {
        com.zeroc.Ice.Object._iceCheckMode(null, request.current.mode);
        com.zeroc.Ice.InputStream istr = request.inputStream;
        istr.startEncapsulation();
        TopicInfo[] iceP_topics;
        boolean iceP_initialize;
        iceP_topics = TopicInfoSeqHelper.read(istr);
        iceP_initialize = istr.readBool();
        istr.endEncapsulation();
        obj.announceTopics(iceP_topics, iceP_initialize, request.current);
        return java.util.concurrent.CompletableFuture.completedFuture(request.current.createEmptyOutgoingResponse());
    }

    /** @hidden */
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutgoingResponse> _iceD_attachTopic(Session obj, com.zeroc.Ice.IncomingRequest request)
    {
        com.zeroc.Ice.Object._iceCheckMode(null, request.current.mode);
        com.zeroc.Ice.InputStream istr = request.inputStream;
        istr.startEncapsulation();
        TopicSpec iceP_topic;
        iceP_topic = TopicSpec.ice_read(istr);
        istr.endEncapsulation();
        obj.attachTopic(iceP_topic, request.current);
        return java.util.concurrent.CompletableFuture.completedFuture(request.current.createEmptyOutgoingResponse());
    }

    /** @hidden */
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutgoingResponse> _iceD_detachTopic(Session obj, com.zeroc.Ice.IncomingRequest request)
    {
        com.zeroc.Ice.Object._iceCheckMode(null, request.current.mode);
        com.zeroc.Ice.InputStream istr = request.inputStream;
        istr.startEncapsulation();
        long iceP_topicId;
        iceP_topicId = istr.readLong();
        istr.endEncapsulation();
        obj.detachTopic(iceP_topicId, request.current);
        return java.util.concurrent.CompletableFuture.completedFuture(request.current.createEmptyOutgoingResponse());
    }

    /** @hidden */
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutgoingResponse> _iceD_attachTags(Session obj, com.zeroc.Ice.IncomingRequest request)
    {
        com.zeroc.Ice.Object._iceCheckMode(null, request.current.mode);
        com.zeroc.Ice.InputStream istr = request.inputStream;
        istr.startEncapsulation();
        long iceP_topicId;
        ElementInfo[] iceP_tags;
        boolean iceP_initialize;
        iceP_topicId = istr.readLong();
        iceP_tags = ElementInfoSeqHelper.read(istr);
        iceP_initialize = istr.readBool();
        istr.endEncapsulation();
        obj.attachTags(iceP_topicId, iceP_tags, iceP_initialize, request.current);
        return java.util.concurrent.CompletableFuture.completedFuture(request.current.createEmptyOutgoingResponse());
    }

    /** @hidden */
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutgoingResponse> _iceD_detachTags(Session obj, com.zeroc.Ice.IncomingRequest request)
    {
        com.zeroc.Ice.Object._iceCheckMode(null, request.current.mode);
        com.zeroc.Ice.InputStream istr = request.inputStream;
        istr.startEncapsulation();
        long iceP_topicId;
        long[] iceP_tags;
        iceP_topicId = istr.readLong();
        iceP_tags = istr.readLongSeq();
        istr.endEncapsulation();
        obj.detachTags(iceP_topicId, iceP_tags, request.current);
        return java.util.concurrent.CompletableFuture.completedFuture(request.current.createEmptyOutgoingResponse());
    }

    /** @hidden */
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutgoingResponse> _iceD_announceElements(Session obj, com.zeroc.Ice.IncomingRequest request)
    {
        com.zeroc.Ice.Object._iceCheckMode(null, request.current.mode);
        com.zeroc.Ice.InputStream istr = request.inputStream;
        istr.startEncapsulation();
        long iceP_topicId;
        ElementInfo[] iceP_elements;
        iceP_topicId = istr.readLong();
        iceP_elements = ElementInfoSeqHelper.read(istr);
        istr.endEncapsulation();
        obj.announceElements(iceP_topicId, iceP_elements, request.current);
        return java.util.concurrent.CompletableFuture.completedFuture(request.current.createEmptyOutgoingResponse());
    }

    /** @hidden */
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutgoingResponse> _iceD_attachElements(Session obj, com.zeroc.Ice.IncomingRequest request)
    {
        com.zeroc.Ice.Object._iceCheckMode(null, request.current.mode);
        com.zeroc.Ice.InputStream istr = request.inputStream;
        istr.startEncapsulation();
        long iceP_topicId;
        ElementSpec[] iceP_elements;
        boolean iceP_initialize;
        iceP_topicId = istr.readLong();
        iceP_elements = ElementSpecSeqHelper.read(istr);
        iceP_initialize = istr.readBool();
        istr.readPendingValues();
        istr.endEncapsulation();
        obj.attachElements(iceP_topicId, iceP_elements, iceP_initialize, request.current);
        return java.util.concurrent.CompletableFuture.completedFuture(request.current.createEmptyOutgoingResponse());
    }

    /** @hidden */
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutgoingResponse> _iceD_attachElementsAck(Session obj, com.zeroc.Ice.IncomingRequest request)
    {
        com.zeroc.Ice.Object._iceCheckMode(null, request.current.mode);
        com.zeroc.Ice.InputStream istr = request.inputStream;
        istr.startEncapsulation();
        long iceP_topicId;
        ElementSpecAck[] iceP_elements;
        iceP_topicId = istr.readLong();
        iceP_elements = ElementSpecAckSeqHelper.read(istr);
        istr.readPendingValues();
        istr.endEncapsulation();
        obj.attachElementsAck(iceP_topicId, iceP_elements, request.current);
        return java.util.concurrent.CompletableFuture.completedFuture(request.current.createEmptyOutgoingResponse());
    }

    /** @hidden */
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutgoingResponse> _iceD_detachElements(Session obj, com.zeroc.Ice.IncomingRequest request)
    {
        com.zeroc.Ice.Object._iceCheckMode(null, request.current.mode);
        com.zeroc.Ice.InputStream istr = request.inputStream;
        istr.startEncapsulation();
        long iceP_topicId;
        long[] iceP_elements;
        iceP_topicId = istr.readLong();
        iceP_elements = istr.readLongSeq();
        istr.endEncapsulation();
        obj.detachElements(iceP_topicId, iceP_elements, request.current);
        return java.util.concurrent.CompletableFuture.completedFuture(request.current.createEmptyOutgoingResponse());
    }

    /** @hidden */
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutgoingResponse> _iceD_initSamples(Session obj, com.zeroc.Ice.IncomingRequest request)
    {
        com.zeroc.Ice.Object._iceCheckMode(null, request.current.mode);
        com.zeroc.Ice.InputStream istr = request.inputStream;
        istr.startEncapsulation();
        long iceP_topicId;
        DataSamples[] iceP_samples;
        iceP_topicId = istr.readLong();
        iceP_samples = DataSamplesSeqHelper.read(istr);
        istr.endEncapsulation();
        obj.initSamples(iceP_topicId, iceP_samples, request.current);
        return java.util.concurrent.CompletableFuture.completedFuture(request.current.createEmptyOutgoingResponse());
    }

    /** @hidden */
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutgoingResponse> _iceD_disconnected(Session obj, com.zeroc.Ice.IncomingRequest request)
    {
        com.zeroc.Ice.Object._iceCheckMode(null, request.current.mode);
        request.inputStream.skipEmptyEncapsulation();
        obj.disconnected(request.current);
        return java.util.concurrent.CompletableFuture.completedFuture(request.current.createEmptyOutgoingResponse());
    }

    @Override
    default java.util.concurrent.CompletionStage<com.zeroc.Ice.OutgoingResponse> dispatch(com.zeroc.Ice.IncomingRequest request)
        throws com.zeroc.Ice.UserException
    {
        return switch (request.current.operation)
        {
            case "announceTopics" -> Session._iceD_announceTopics(this, request);
            case "attachTopic" -> Session._iceD_attachTopic(this, request);
            case "detachTopic" -> Session._iceD_detachTopic(this, request);
            case "attachTags" -> Session._iceD_attachTags(this, request);
            case "detachTags" -> Session._iceD_detachTags(this, request);
            case "announceElements" -> Session._iceD_announceElements(this, request);
            case "attachElements" -> Session._iceD_attachElements(this, request);
            case "attachElementsAck" -> Session._iceD_attachElementsAck(this, request);
            case "detachElements" -> Session._iceD_detachElements(this, request);
            case "initSamples" -> Session._iceD_initSamples(this, request);
            case "disconnected" -> Session._iceD_disconnected(this, request);
            case "ice_id" -> com.zeroc.Ice.Object._iceD_ice_id(this, request);
            case "ice_ids" -> com.zeroc.Ice.Object._iceD_ice_ids(this, request);
            case "ice_isA" -> com.zeroc.Ice.Object._iceD_ice_isA(this, request);
            case "ice_ping" -> com.zeroc.Ice.Object._iceD_ice_ping(this, request);
            default -> throw new com.zeroc.Ice.OperationNotExistException();
        };
    }
}
