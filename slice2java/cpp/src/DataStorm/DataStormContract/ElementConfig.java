//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Contract.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

package DataStormContract;

/**
 * Represents the configuration of a data reader or data writer, including optional filters and priorities.
 **/
public class ElementConfig extends com.zeroc.Ice.Value
{
    public ElementConfig()
    {
        this.facet = "";
        this.sampleFilter = new FilterInfo();
        this.name = "";
        this.clearHistory = ClearHistoryPolicy.OnAdd;
    }

    public ElementConfig(String facet, FilterInfo sampleFilter, String name, int priority, int sampleCount, int sampleLifetime, ClearHistoryPolicy clearHistory)
    {
        setFacet(facet);
        setSampleFilter(sampleFilter);
        setName(name);
        setPriority(priority);
        setSampleCount(sampleCount);
        setSampleLifetime(sampleLifetime);
        setClearHistory(clearHistory);
    }

    /**
     * A facet that is used to process the samples when sample filtering is enabled.
     **/
    private String facet;
    private boolean _facet;

    /**
     * A facet that is used to process the samples when sample filtering is enabled.
     **/
    public String getFacet()
    {
        if(!_facet)
        {
            throw new java.util.NoSuchElementException("facet is not set");
        }
        return facet;
    }

    /**
     * A facet that is used to process the samples when sample filtering is enabled.
     **/
    public void setFacet(String facet)
    {
        _facet = true;
        this.facet = facet;
    }

    /**
     * A facet that is used to process the samples when sample filtering is enabled.
     **/
    public boolean hasFacet()
    {
        return _facet;
    }

    /**
     * A facet that is used to process the samples when sample filtering is enabled.
     **/
    public void clearFacet()
    {
        _facet = false;
    }

    /**
     * A facet that is used to process the samples when sample filtering is enabled.
     **/
    public void optionalFacet(java.util.Optional<java.lang.String> v)
    {
        if(v == null || !v.isPresent())
        {
            _facet = false;
        }
        else
        {
            _facet = true;
            facet = v.get();
        }
    }

    /**
     * A facet that is used to process the samples when sample filtering is enabled.
     **/
    public java.util.Optional<java.lang.String> optionalFacet()
    {
        if(_facet)
        {
            return java.util.Optional.of(facet);
        }
        else
        {
            return java.util.Optional.empty();
        }
    }

    /**
     * An optional sample filter associated with the reader. Sample filters are specified on the reader side.
     **/
    private FilterInfo sampleFilter;
    private boolean _sampleFilter;

    /**
     * An optional sample filter associated with the reader. Sample filters are specified on the reader side.
     **/
    public FilterInfo getSampleFilter()
    {
        if(!_sampleFilter)
        {
            throw new java.util.NoSuchElementException("sampleFilter is not set");
        }
        return sampleFilter;
    }

    /**
     * An optional sample filter associated with the reader. Sample filters are specified on the reader side.
     **/
    public void setSampleFilter(FilterInfo sampleFilter)
    {
        _sampleFilter = true;
        this.sampleFilter = sampleFilter;
    }

    /**
     * An optional sample filter associated with the reader. Sample filters are specified on the reader side.
     **/
    public boolean hasSampleFilter()
    {
        return _sampleFilter;
    }

    /**
     * An optional sample filter associated with the reader. Sample filters are specified on the reader side.
     **/
    public void clearSampleFilter()
    {
        _sampleFilter = false;
    }

    /**
     * An optional sample filter associated with the reader. Sample filters are specified on the reader side.
     **/
    public void optionalSampleFilter(java.util.Optional<FilterInfo> v)
    {
        if(v == null || !v.isPresent())
        {
            _sampleFilter = false;
        }
        else
        {
            _sampleFilter = true;
            sampleFilter = v.get();
        }
    }

    /**
     * An optional sample filter associated with the reader. Sample filters are specified on the reader side.
     **/
    public java.util.Optional<FilterInfo> optionalSampleFilter()
    {
        if(_sampleFilter)
        {
            return java.util.Optional.of(sampleFilter);
        }
        else
        {
            return java.util.Optional.empty();
        }
    }

    /**
     * An optional name for the reader or writer.
     **/
    private String name;
    private boolean _name;

    /**
     * An optional name for the reader or writer.
     **/
    public String getName()
    {
        if(!_name)
        {
            throw new java.util.NoSuchElementException("name is not set");
        }
        return name;
    }

    /**
     * An optional name for the reader or writer.
     **/
    public void setName(String name)
    {
        _name = true;
        this.name = name;
    }

    /**
     * An optional name for the reader or writer.
     **/
    public boolean hasName()
    {
        return _name;
    }

    /**
     * An optional name for the reader or writer.
     **/
    public void clearName()
    {
        _name = false;
    }

    /**
     * An optional name for the reader or writer.
     **/
    public void optionalName(java.util.Optional<java.lang.String> v)
    {
        if(v == null || !v.isPresent())
        {
            _name = false;
        }
        else
        {
            _name = true;
            name = v.get();
        }
    }

    /**
     * An optional name for the reader or writer.
     **/
    public java.util.Optional<java.lang.String> optionalName()
    {
        if(_name)
        {
            return java.util.Optional.of(name);
        }
        else
        {
            return java.util.Optional.empty();
        }
    }

    /**
     * An optional priority for the writer.
     * See also the `DataStorm.Topic.Priority` property.
     **/
    private int priority;
    private boolean _priority;

    /**
     * An optional priority for the writer.
     * See also the `DataStorm.Topic.Priority` property.
     **/
    public int getPriority()
    {
        if(!_priority)
        {
            throw new java.util.NoSuchElementException("priority is not set");
        }
        return priority;
    }

    /**
     * An optional priority for the writer.
     * See also the `DataStorm.Topic.Priority` property.
     **/
    public void setPriority(int priority)
    {
        _priority = true;
        this.priority = priority;
    }

    /**
     * An optional priority for the writer.
     * See also the `DataStorm.Topic.Priority` property.
     **/
    public boolean hasPriority()
    {
        return _priority;
    }

    /**
     * An optional priority for the writer.
     * See also the `DataStorm.Topic.Priority` property.
     **/
    public void clearPriority()
    {
        _priority = false;
    }

    /**
     * An optional priority for the writer.
     * See also the `DataStorm.Topic.Priority` property.
     **/
    public void optionalPriority(java.util.OptionalInt v)
    {
        if(v == null || !v.isPresent())
        {
            _priority = false;
        }
        else
        {
            _priority = true;
            priority = v.getAsInt();
        }
    }

    /**
     * An optional priority for the writer.
     * See also the `DataStorm.Topic.Priority` property.
     **/
    public java.util.OptionalInt optionalPriority()
    {
        if(_priority)
        {
            return java.util.OptionalInt.of(priority);
        }
        else
        {
            return java.util.OptionalInt.empty();
        }
    }

    /**
     * An optional sample count, specifying the number of samples queued in the writer or reader sample queue.
     * See also the `DataStorm.Topic.SampleCount` property.
     **/
    private int sampleCount;
    private boolean _sampleCount;

    /**
     * An optional sample count, specifying the number of samples queued in the writer or reader sample queue.
     * See also the `DataStorm.Topic.SampleCount` property.
     **/
    public int getSampleCount()
    {
        if(!_sampleCount)
        {
            throw new java.util.NoSuchElementException("sampleCount is not set");
        }
        return sampleCount;
    }

    /**
     * An optional sample count, specifying the number of samples queued in the writer or reader sample queue.
     * See also the `DataStorm.Topic.SampleCount` property.
     **/
    public void setSampleCount(int sampleCount)
    {
        _sampleCount = true;
        this.sampleCount = sampleCount;
    }

    /**
     * An optional sample count, specifying the number of samples queued in the writer or reader sample queue.
     * See also the `DataStorm.Topic.SampleCount` property.
     **/
    public boolean hasSampleCount()
    {
        return _sampleCount;
    }

    /**
     * An optional sample count, specifying the number of samples queued in the writer or reader sample queue.
     * See also the `DataStorm.Topic.SampleCount` property.
     **/
    public void clearSampleCount()
    {
        _sampleCount = false;
    }

    /**
     * An optional sample count, specifying the number of samples queued in the writer or reader sample queue.
     * See also the `DataStorm.Topic.SampleCount` property.
     **/
    public void optionalSampleCount(java.util.OptionalInt v)
    {
        if(v == null || !v.isPresent())
        {
            _sampleCount = false;
        }
        else
        {
            _sampleCount = true;
            sampleCount = v.getAsInt();
        }
    }

    /**
     * An optional sample count, specifying the number of samples queued in the writer or reader sample queue.
     * See also the `DataStorm.Topic.SampleCount` property.
     **/
    public java.util.OptionalInt optionalSampleCount()
    {
        if(_sampleCount)
        {
            return java.util.OptionalInt.of(sampleCount);
        }
        else
        {
            return java.util.OptionalInt.empty();
        }
    }

    /**
     * An optional lifetime, specified in milliseconds, representing the maximum time samples are kept in the
     * writer or reader sample queue. See also the `DataStorm.Topic.SampleLifetime` property.
     **/
    private int sampleLifetime;
    private boolean _sampleLifetime;

    /**
     * An optional lifetime, specified in milliseconds, representing the maximum time samples are kept in the
     * writer or reader sample queue. See also the `DataStorm.Topic.SampleLifetime` property.
     **/
    public int getSampleLifetime()
    {
        if(!_sampleLifetime)
        {
            throw new java.util.NoSuchElementException("sampleLifetime is not set");
        }
        return sampleLifetime;
    }

    /**
     * An optional lifetime, specified in milliseconds, representing the maximum time samples are kept in the
     * writer or reader sample queue. See also the `DataStorm.Topic.SampleLifetime` property.
     **/
    public void setSampleLifetime(int sampleLifetime)
    {
        _sampleLifetime = true;
        this.sampleLifetime = sampleLifetime;
    }

    /**
     * An optional lifetime, specified in milliseconds, representing the maximum time samples are kept in the
     * writer or reader sample queue. See also the `DataStorm.Topic.SampleLifetime` property.
     **/
    public boolean hasSampleLifetime()
    {
        return _sampleLifetime;
    }

    /**
     * An optional lifetime, specified in milliseconds, representing the maximum time samples are kept in the
     * writer or reader sample queue. See also the `DataStorm.Topic.SampleLifetime` property.
     **/
    public void clearSampleLifetime()
    {
        _sampleLifetime = false;
    }

    /**
     * An optional lifetime, specified in milliseconds, representing the maximum time samples are kept in the
     * writer or reader sample queue. See also the `DataStorm.Topic.SampleLifetime` property.
     **/
    public void optionalSampleLifetime(java.util.OptionalInt v)
    {
        if(v == null || !v.isPresent())
        {
            _sampleLifetime = false;
        }
        else
        {
            _sampleLifetime = true;
            sampleLifetime = v.getAsInt();
        }
    }

    /**
     * An optional lifetime, specified in milliseconds, representing the maximum time samples are kept in the
     * writer or reader sample queue. See also the `DataStorm.Topic.SampleLifetime` property.
     **/
    public java.util.OptionalInt optionalSampleLifetime()
    {
        if(_sampleLifetime)
        {
            return java.util.OptionalInt.of(sampleLifetime);
        }
        else
        {
            return java.util.OptionalInt.empty();
        }
    }

    /**
     * An optional clear history policy that determines when the reader or writer sample history is cleared.
     * See also the `DataStorm.Topic.ClearHistory` property.
     **/
    private ClearHistoryPolicy clearHistory;
    private boolean _clearHistory;

    /**
     * An optional clear history policy that determines when the reader or writer sample history is cleared.
     * See also the `DataStorm.Topic.ClearHistory` property.
     **/
    public ClearHistoryPolicy getClearHistory()
    {
        if(!_clearHistory)
        {
            throw new java.util.NoSuchElementException("clearHistory is not set");
        }
        return clearHistory;
    }

    /**
     * An optional clear history policy that determines when the reader or writer sample history is cleared.
     * See also the `DataStorm.Topic.ClearHistory` property.
     **/
    public void setClearHistory(ClearHistoryPolicy clearHistory)
    {
        _clearHistory = true;
        this.clearHistory = clearHistory;
    }

    /**
     * An optional clear history policy that determines when the reader or writer sample history is cleared.
     * See also the `DataStorm.Topic.ClearHistory` property.
     **/
    public boolean hasClearHistory()
    {
        return _clearHistory;
    }

    /**
     * An optional clear history policy that determines when the reader or writer sample history is cleared.
     * See also the `DataStorm.Topic.ClearHistory` property.
     **/
    public void clearClearHistory()
    {
        _clearHistory = false;
    }

    /**
     * An optional clear history policy that determines when the reader or writer sample history is cleared.
     * See also the `DataStorm.Topic.ClearHistory` property.
     **/
    public void optionalClearHistory(java.util.Optional<ClearHistoryPolicy> v)
    {
        if(v == null || !v.isPresent())
        {
            _clearHistory = false;
        }
        else
        {
            _clearHistory = true;
            clearHistory = v.get();
        }
    }

    /**
     * An optional clear history policy that determines when the reader or writer sample history is cleared.
     * See also the `DataStorm.Topic.ClearHistory` property.
     **/
    public java.util.Optional<ClearHistoryPolicy> optionalClearHistory()
    {
        if(_clearHistory)
        {
            return java.util.Optional.of(clearHistory);
        }
        else
        {
            return java.util.Optional.empty();
        }
    }

    public ElementConfig clone()
    {
        return (ElementConfig)super.clone();
    }

    public static String ice_staticId()
    {
        return "::DataStormContract::ElementConfig";
    }

    @Override
    public String ice_id()
    {
        return ice_staticId();
    }

    /** @hidden */
    private static final long serialVersionUID = -3153481067224491617L;

    /** @hidden */
    @Override
    protected void _iceWriteImpl(com.zeroc.Ice.OutputStream ostr_)
    {
        ostr_.startSlice(ice_staticId(), 1, true);
        if(_facet)
        {
            ostr_.writeString(1, facet);
        }
        if(_sampleFilter)
        {
            FilterInfo.ice_write(ostr_, 2, sampleFilter);
        }
        if(_name)
        {
            ostr_.writeString(3, name);
        }
        if(_priority)
        {
            ostr_.writeInt(4, priority);
        }
        if(_sampleCount)
        {
            ostr_.writeInt(10, sampleCount);
        }
        if(_sampleLifetime)
        {
            ostr_.writeInt(11, sampleLifetime);
        }
        if(_clearHistory)
        {
            ClearHistoryPolicy.ice_write(ostr_, 12, clearHistory);
        }
        ostr_.endSlice();
    }

    /** @hidden */
    @Override
    protected void _iceReadImpl(com.zeroc.Ice.InputStream istr_)
    {
        istr_.startSlice();
        if(_facet = istr_.readOptional(1, com.zeroc.Ice.OptionalFormat.VSize))
        {
            facet = istr_.readString();
        }
        if(_sampleFilter = istr_.readOptional(2, com.zeroc.Ice.OptionalFormat.FSize))
        {
            istr_.skip(4);
            sampleFilter = FilterInfo.ice_read(istr_);
        }
        if(_name = istr_.readOptional(3, com.zeroc.Ice.OptionalFormat.VSize))
        {
            name = istr_.readString();
        }
        if(_priority = istr_.readOptional(4, com.zeroc.Ice.OptionalFormat.F4))
        {
            priority = istr_.readInt();
        }
        if(_sampleCount = istr_.readOptional(10, com.zeroc.Ice.OptionalFormat.F4))
        {
            sampleCount = istr_.readInt();
        }
        if(_sampleLifetime = istr_.readOptional(11, com.zeroc.Ice.OptionalFormat.F4))
        {
            sampleLifetime = istr_.readInt();
        }
        if(_clearHistory = istr_.readOptional(12, com.zeroc.Ice.OptionalFormat.Size))
        {
            clearHistory = ClearHistoryPolicy.ice_read(istr_);
        }
        istr_.endSlice();
    }
}
