//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Admin.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

package com.zeroc.IceGrid;

/**
 * Used by administrative clients to view, update, and receive observer updates from the IceGrid registry. Admin
 * sessions are created either via the {@link Registry} object or via the registry admin
 * <code>SessionManager</code> object.
 *
 * @see Registry
 **/
public interface AdminSession extends com.zeroc.Glacier2.Session
{
    /**
     * Keep the session alive. Clients should call this operation regularly to prevent the server from reaping the
     * session.
     * @param current The Current object for the invocation.
     *
     * @see Registry#getSessionTimeout
     **/
    void keepAlive(com.zeroc.Ice.Current current);

    /**
     * Get the admin interface. The admin object returned by this operation can only be accessed by the session.
     * @param current The Current object for the invocation.
     * @return The admin interface proxy. The returned proxy is never null.
     **/
    AdminPrx getAdmin(com.zeroc.Ice.Current current);

    /**
     * Get a "template" proxy for admin callback objects. An Admin client uses this proxy to set the category of
     * its callback objects, and the published endpoints of the object adapter hosting the admin callback objects.
     * @param current The Current object for the invocation.
     * @return A template proxy. The returned proxy is null when the Admin session was established using Glacier2.
     **/
    com.zeroc.Ice.ObjectPrx getAdminCallbackTemplate(com.zeroc.Ice.Current current);

    /**
     * Set the observer proxies that receive notifications when the state of the registry or nodes changes.
     * @param registryObs The registry observer.
     * @param nodeObs The node observer.
     * @param appObs The application observer.
     * @param adptObs The adapter observer.
     * @param objObs The object observer.
     * @param current The Current object for the invocation.
     * @throws ObserverAlreadyRegisteredException Raised if an observer is already registered with this registry.
     **/
    void setObservers(RegistryObserverPrx registryObs, NodeObserverPrx nodeObs, ApplicationObserverPrx appObs, AdapterObserverPrx adptObs, ObjectObserverPrx objObs, com.zeroc.Ice.Current current)
        throws ObserverAlreadyRegisteredException;

    /**
     * Set the observer identities that receive notifications the state of the registry or nodes changes. This
     * operation should be used by clients that are using a bidirectional connection to communicate with the
     * session.
     * @param registryObs The registry observer identity.
     * @param nodeObs The node observer identity.
     * @param appObs The application observer.
     * @param adptObs The adapter observer.
     * @param objObs The object observer.
     * @param current The Current object for the invocation.
     * @throws ObserverAlreadyRegisteredException Raised if an observer is already registered with this registry.
     **/
    void setObserversByIdentity(com.zeroc.Ice.Identity registryObs, com.zeroc.Ice.Identity nodeObs, com.zeroc.Ice.Identity appObs, com.zeroc.Ice.Identity adptObs, com.zeroc.Ice.Identity objObs, com.zeroc.Ice.Current current)
        throws ObserverAlreadyRegisteredException;

    /**
     * Acquires an exclusive lock to start updating the registry applications.
     * @param current The Current object for the invocation.
     * @return The current serial.
     * @throws AccessDeniedException Raised if the exclusive lock can't be acquired. This might happen if the lock
     * is currently acquired by another session.
     **/
    int startUpdate(com.zeroc.Ice.Current current)
        throws AccessDeniedException;

    /**
     * Finish updating the registry and release the exclusive lock.
     * @param current The Current object for the invocation.
     * @throws AccessDeniedException Raised if the session doesn't hold the exclusive lock.
     **/
    void finishUpdate(com.zeroc.Ice.Current current)
        throws AccessDeniedException;

    /**
     * Get the name of the registry replica hosting this session.
     * @param current The Current object for the invocation.
     * @return The replica name of the registry.
     **/
    String getReplicaName(com.zeroc.Ice.Current current);

    /**
     * Open the given server log file for reading. The file can be read with the returned file iterator.
     * @param id The server id.
     * @param path The path of the log file. A log file can be opened only if it's declared in the server or
     * service deployment descriptor.
     * @param count Specifies where to start reading the file. If negative, the file is read from the begining. If
     * 0 or positive, the file is read from the last <code>count</code> lines.
     * @param current The Current object for the invocation.
     * @return An iterator to read the file. The returned proxy is never null.
     * @throws DeploymentException Raised if the server couldn't be deployed on the node.
     * @throws FileNotAvailableException Raised if the file can't be read.
     * @throws NodeUnreachableException Raised if the node could not be reached.
     * @throws ServerNotExistException Raised if the server doesn't exist.
     **/
    FileIteratorPrx openServerLog(String id, String path, int count, com.zeroc.Ice.Current current)
        throws ServerNotExistException,
               DeploymentException,
               NodeUnreachableException,
               FileNotAvailableException;

    /**
     * Open the given server stderr file for reading. The file can be read with the returned file iterator.
     * @param id The server id.
     * @param count Specifies where to start reading the file. If negative, the file is read from the begining. If
     * 0 or positive, the file is read from the last <code>count</code> lines.
     * @param current The Current object for the invocation.
     * @return An iterator to read the file. The returned proxy is never null.
     * @throws DeploymentException Raised if the server couldn't be deployed on the node.
     * @throws FileNotAvailableException Raised if the file can't be read.
     * @throws NodeUnreachableException Raised if the node could not be reached.
     * @throws ServerNotExistException Raised if the server doesn't exist.
     **/
    FileIteratorPrx openServerStdErr(String id, int count, com.zeroc.Ice.Current current)
        throws ServerNotExistException,
               DeploymentException,
               NodeUnreachableException,
               FileNotAvailableException;

    /**
     * Open the given server stdout file for reading. The file can be read with the returned file iterator.
     * @param id The server id.
     * @param count Specifies where to start reading the file. If negative, the file is read from the begining.
     * If 0 or positive, the file is read from the last <code>count</code> lines.
     * @param current The Current object for the invocation.
     * @return An iterator to read the file. The returned proxy is never null.
     * @throws DeploymentException Raised if the server couldn't be deployed on the node.
     * @throws FileNotAvailableException Raised if the file can't be read.
     * @throws NodeUnreachableException Raised if the node could not be reached.
     * @throws ServerNotExistException Raised if the server doesn't exist.
     **/
    FileIteratorPrx openServerStdOut(String id, int count, com.zeroc.Ice.Current current)
        throws ServerNotExistException,
               DeploymentException,
               NodeUnreachableException,
               FileNotAvailableException;

    /**
     * Open the given node stderr file for reading. The file can be read with the returned file iterator.
     * @param name The node name.
     * @param count Specifies where to start reading the file. If negative, the file is read from the begining. If
     * 0 or positive, the file is read from the last <code>count</code> lines.
     * @param current The Current object for the invocation.
     * @return An iterator to read the file. The returned proxy is never null.
     * @throws FileNotAvailableException Raised if the file can't be read.
     * @throws NodeNotExistException Raised if the node doesn't exist.
     * @throws NodeUnreachableException Raised if the node could not be reached.
     **/
    FileIteratorPrx openNodeStdErr(String name, int count, com.zeroc.Ice.Current current)
        throws NodeNotExistException,
               NodeUnreachableException,
               FileNotAvailableException;

    /**
     * Open the given node stdout file for reading. The file can be read with the returned file iterator.
     * @param name The node name.
     * @param count Specifies where to start reading the file. If negative, the file is read from the begining. If
     * 0 or positive, the file is read from the last <code>count</code> lines.
     * @param current The Current object for the invocation.
     * @return An iterator to read the file. The returned proxy is never null.
     * @throws FileNotAvailableException Raised if the file can't be read.
     * @throws NodeNotExistException Raised if the node doesn't exist.
     * @throws NodeUnreachableException Raised if the node could not be reached.
     **/
    FileIteratorPrx openNodeStdOut(String name, int count, com.zeroc.Ice.Current current)
        throws NodeNotExistException,
               NodeUnreachableException,
               FileNotAvailableException;

    /**
     * Open the given registry stderr file for reading. The file can be read with the returned file iterator.
     * @param name The registry name.
     * @param count Specifies where to start reading the file. If negative, the file is read from the begining. If
     * 0 or positive, the file is read from the last <code>count</code> lines.
     * @param current The Current object for the invocation.
     * @return An iterator to read the file. The returned proxy is never null.
     * @throws FileNotAvailableException Raised if the file can't be read.
     * @throws RegistryNotExistException Raised if the registry doesn't exist.
     * @throws RegistryUnreachableException Raised if the registry could not be reached.
     **/
    FileIteratorPrx openRegistryStdErr(String name, int count, com.zeroc.Ice.Current current)
        throws RegistryNotExistException,
               RegistryUnreachableException,
               FileNotAvailableException;

    /**
     * Open the given registry stdout file for reading. The file can be read with the returned file iterator.
     * @param name The registry name.
     * @param count Specifies where to start reading the file. If negative, the file is read from the begining. If
     * 0 or positive, the file is read from the last <code>count</code> lines.
     * @param current The Current object for the invocation.
     * @return An iterator to read the file. The returned proxy is never null.
     * @throws FileNotAvailableException Raised if the file can't be read.
     * @throws RegistryNotExistException Raised if the registry doesn't exist.
     * @throws RegistryUnreachableException Raised if the registry could not be reached.
     **/
    FileIteratorPrx openRegistryStdOut(String name, int count, com.zeroc.Ice.Current current)
        throws RegistryNotExistException,
               RegistryUnreachableException,
               FileNotAvailableException;

    /** @hidden */
    static final String[] _iceIds =
    {
        "::Glacier2::Session",
        "::Ice::Object",
        "::IceGrid::AdminSession"
    };

    @Override
    default String[] ice_ids(com.zeroc.Ice.Current current)
    {
        return _iceIds;
    }

    @Override
    default String ice_id(com.zeroc.Ice.Current current)
    {
        return ice_staticId();
    }

    static String ice_staticId()
    {
        return "::IceGrid::AdminSession";
    }

    /** @hidden */
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutgoingResponse> _iceD_keepAlive(AdminSession obj, com.zeroc.Ice.IncomingRequest request)
    {
        com.zeroc.Ice.Object._iceCheckMode(com.zeroc.Ice.OperationMode.Idempotent, request.current.mode);
        request.inputStream.skipEmptyEncapsulation();
        obj.keepAlive(request.current);
        return java.util.concurrent.CompletableFuture.completedFuture(request.current.createEmptyOutgoingResponse());
    }

    /** @hidden */
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutgoingResponse> _iceD_getAdmin(AdminSession obj, com.zeroc.Ice.IncomingRequest request)
    {
        com.zeroc.Ice.Object._iceCheckMode(com.zeroc.Ice.OperationMode.Idempotent, request.current.mode);
        request.inputStream.skipEmptyEncapsulation();
        AdminPrx ret = obj.getAdmin(request.current);
        var ostr = request.current.startReplyStream();
        ostr.startEncapsulation(request.current.encoding, null);
        ostr.writeProxy(ret);
        ostr.endEncapsulation();
        return java.util.concurrent.CompletableFuture.completedFuture(new com.zeroc.Ice.OutgoingResponse(ostr));
    }

    /** @hidden */
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutgoingResponse> _iceD_getAdminCallbackTemplate(AdminSession obj, com.zeroc.Ice.IncomingRequest request)
    {
        com.zeroc.Ice.Object._iceCheckMode(com.zeroc.Ice.OperationMode.Idempotent, request.current.mode);
        request.inputStream.skipEmptyEncapsulation();
        com.zeroc.Ice.ObjectPrx ret = obj.getAdminCallbackTemplate(request.current);
        var ostr = request.current.startReplyStream();
        ostr.startEncapsulation(request.current.encoding, null);
        ostr.writeProxy(ret);
        ostr.endEncapsulation();
        return java.util.concurrent.CompletableFuture.completedFuture(new com.zeroc.Ice.OutgoingResponse(ostr));
    }

    /** @hidden */
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutgoingResponse> _iceD_setObservers(AdminSession obj, com.zeroc.Ice.IncomingRequest request)
        throws com.zeroc.Ice.UserException
    {
        com.zeroc.Ice.Object._iceCheckMode(com.zeroc.Ice.OperationMode.Idempotent, request.current.mode);
        com.zeroc.Ice.InputStream istr = request.inputStream;
        istr.startEncapsulation();
        RegistryObserverPrx iceP_registryObs;
        NodeObserverPrx iceP_nodeObs;
        ApplicationObserverPrx iceP_appObs;
        AdapterObserverPrx iceP_adptObs;
        ObjectObserverPrx iceP_objObs;
        iceP_registryObs = RegistryObserverPrx.uncheckedCast(istr.readProxy());
        iceP_nodeObs = NodeObserverPrx.uncheckedCast(istr.readProxy());
        iceP_appObs = ApplicationObserverPrx.uncheckedCast(istr.readProxy());
        iceP_adptObs = AdapterObserverPrx.uncheckedCast(istr.readProxy());
        iceP_objObs = ObjectObserverPrx.uncheckedCast(istr.readProxy());
        istr.endEncapsulation();
        obj.setObservers(iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs, request.current);
        return java.util.concurrent.CompletableFuture.completedFuture(request.current.createEmptyOutgoingResponse());
    }

    /** @hidden */
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutgoingResponse> _iceD_setObserversByIdentity(AdminSession obj, com.zeroc.Ice.IncomingRequest request)
        throws com.zeroc.Ice.UserException
    {
        com.zeroc.Ice.Object._iceCheckMode(com.zeroc.Ice.OperationMode.Idempotent, request.current.mode);
        com.zeroc.Ice.InputStream istr = request.inputStream;
        istr.startEncapsulation();
        com.zeroc.Ice.Identity iceP_registryObs;
        com.zeroc.Ice.Identity iceP_nodeObs;
        com.zeroc.Ice.Identity iceP_appObs;
        com.zeroc.Ice.Identity iceP_adptObs;
        com.zeroc.Ice.Identity iceP_objObs;
        iceP_registryObs = com.zeroc.Ice.Identity.ice_read(istr);
        iceP_nodeObs = com.zeroc.Ice.Identity.ice_read(istr);
        iceP_appObs = com.zeroc.Ice.Identity.ice_read(istr);
        iceP_adptObs = com.zeroc.Ice.Identity.ice_read(istr);
        iceP_objObs = com.zeroc.Ice.Identity.ice_read(istr);
        istr.endEncapsulation();
        obj.setObserversByIdentity(iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs, request.current);
        return java.util.concurrent.CompletableFuture.completedFuture(request.current.createEmptyOutgoingResponse());
    }

    /** @hidden */
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutgoingResponse> _iceD_startUpdate(AdminSession obj, com.zeroc.Ice.IncomingRequest request)
        throws com.zeroc.Ice.UserException
    {
        com.zeroc.Ice.Object._iceCheckMode(null, request.current.mode);
        request.inputStream.skipEmptyEncapsulation();
        int ret = obj.startUpdate(request.current);
        var ostr = request.current.startReplyStream();
        ostr.startEncapsulation(request.current.encoding, null);
        ostr.writeInt(ret);
        ostr.endEncapsulation();
        return java.util.concurrent.CompletableFuture.completedFuture(new com.zeroc.Ice.OutgoingResponse(ostr));
    }

    /** @hidden */
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutgoingResponse> _iceD_finishUpdate(AdminSession obj, com.zeroc.Ice.IncomingRequest request)
        throws com.zeroc.Ice.UserException
    {
        com.zeroc.Ice.Object._iceCheckMode(null, request.current.mode);
        request.inputStream.skipEmptyEncapsulation();
        obj.finishUpdate(request.current);
        return java.util.concurrent.CompletableFuture.completedFuture(request.current.createEmptyOutgoingResponse());
    }

    /** @hidden */
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutgoingResponse> _iceD_getReplicaName(AdminSession obj, com.zeroc.Ice.IncomingRequest request)
    {
        com.zeroc.Ice.Object._iceCheckMode(com.zeroc.Ice.OperationMode.Idempotent, request.current.mode);
        request.inputStream.skipEmptyEncapsulation();
        String ret = obj.getReplicaName(request.current);
        var ostr = request.current.startReplyStream();
        ostr.startEncapsulation(request.current.encoding, null);
        ostr.writeString(ret);
        ostr.endEncapsulation();
        return java.util.concurrent.CompletableFuture.completedFuture(new com.zeroc.Ice.OutgoingResponse(ostr));
    }

    /** @hidden */
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutgoingResponse> _iceD_openServerLog(AdminSession obj, com.zeroc.Ice.IncomingRequest request)
        throws com.zeroc.Ice.UserException
    {
        com.zeroc.Ice.Object._iceCheckMode(null, request.current.mode);
        com.zeroc.Ice.InputStream istr = request.inputStream;
        istr.startEncapsulation();
        String iceP_id;
        String iceP_path;
        int iceP_count;
        iceP_id = istr.readString();
        iceP_path = istr.readString();
        iceP_count = istr.readInt();
        istr.endEncapsulation();
        FileIteratorPrx ret = obj.openServerLog(iceP_id, iceP_path, iceP_count, request.current);
        var ostr = request.current.startReplyStream();
        ostr.startEncapsulation(request.current.encoding, null);
        ostr.writeProxy(ret);
        ostr.endEncapsulation();
        return java.util.concurrent.CompletableFuture.completedFuture(new com.zeroc.Ice.OutgoingResponse(ostr));
    }

    /** @hidden */
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutgoingResponse> _iceD_openServerStdErr(AdminSession obj, com.zeroc.Ice.IncomingRequest request)
        throws com.zeroc.Ice.UserException
    {
        com.zeroc.Ice.Object._iceCheckMode(null, request.current.mode);
        com.zeroc.Ice.InputStream istr = request.inputStream;
        istr.startEncapsulation();
        String iceP_id;
        int iceP_count;
        iceP_id = istr.readString();
        iceP_count = istr.readInt();
        istr.endEncapsulation();
        FileIteratorPrx ret = obj.openServerStdErr(iceP_id, iceP_count, request.current);
        var ostr = request.current.startReplyStream();
        ostr.startEncapsulation(request.current.encoding, null);
        ostr.writeProxy(ret);
        ostr.endEncapsulation();
        return java.util.concurrent.CompletableFuture.completedFuture(new com.zeroc.Ice.OutgoingResponse(ostr));
    }

    /** @hidden */
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutgoingResponse> _iceD_openServerStdOut(AdminSession obj, com.zeroc.Ice.IncomingRequest request)
        throws com.zeroc.Ice.UserException
    {
        com.zeroc.Ice.Object._iceCheckMode(null, request.current.mode);
        com.zeroc.Ice.InputStream istr = request.inputStream;
        istr.startEncapsulation();
        String iceP_id;
        int iceP_count;
        iceP_id = istr.readString();
        iceP_count = istr.readInt();
        istr.endEncapsulation();
        FileIteratorPrx ret = obj.openServerStdOut(iceP_id, iceP_count, request.current);
        var ostr = request.current.startReplyStream();
        ostr.startEncapsulation(request.current.encoding, null);
        ostr.writeProxy(ret);
        ostr.endEncapsulation();
        return java.util.concurrent.CompletableFuture.completedFuture(new com.zeroc.Ice.OutgoingResponse(ostr));
    }

    /** @hidden */
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutgoingResponse> _iceD_openNodeStdErr(AdminSession obj, com.zeroc.Ice.IncomingRequest request)
        throws com.zeroc.Ice.UserException
    {
        com.zeroc.Ice.Object._iceCheckMode(null, request.current.mode);
        com.zeroc.Ice.InputStream istr = request.inputStream;
        istr.startEncapsulation();
        String iceP_name;
        int iceP_count;
        iceP_name = istr.readString();
        iceP_count = istr.readInt();
        istr.endEncapsulation();
        FileIteratorPrx ret = obj.openNodeStdErr(iceP_name, iceP_count, request.current);
        var ostr = request.current.startReplyStream();
        ostr.startEncapsulation(request.current.encoding, null);
        ostr.writeProxy(ret);
        ostr.endEncapsulation();
        return java.util.concurrent.CompletableFuture.completedFuture(new com.zeroc.Ice.OutgoingResponse(ostr));
    }

    /** @hidden */
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutgoingResponse> _iceD_openNodeStdOut(AdminSession obj, com.zeroc.Ice.IncomingRequest request)
        throws com.zeroc.Ice.UserException
    {
        com.zeroc.Ice.Object._iceCheckMode(null, request.current.mode);
        com.zeroc.Ice.InputStream istr = request.inputStream;
        istr.startEncapsulation();
        String iceP_name;
        int iceP_count;
        iceP_name = istr.readString();
        iceP_count = istr.readInt();
        istr.endEncapsulation();
        FileIteratorPrx ret = obj.openNodeStdOut(iceP_name, iceP_count, request.current);
        var ostr = request.current.startReplyStream();
        ostr.startEncapsulation(request.current.encoding, null);
        ostr.writeProxy(ret);
        ostr.endEncapsulation();
        return java.util.concurrent.CompletableFuture.completedFuture(new com.zeroc.Ice.OutgoingResponse(ostr));
    }

    /** @hidden */
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutgoingResponse> _iceD_openRegistryStdErr(AdminSession obj, com.zeroc.Ice.IncomingRequest request)
        throws com.zeroc.Ice.UserException
    {
        com.zeroc.Ice.Object._iceCheckMode(null, request.current.mode);
        com.zeroc.Ice.InputStream istr = request.inputStream;
        istr.startEncapsulation();
        String iceP_name;
        int iceP_count;
        iceP_name = istr.readString();
        iceP_count = istr.readInt();
        istr.endEncapsulation();
        FileIteratorPrx ret = obj.openRegistryStdErr(iceP_name, iceP_count, request.current);
        var ostr = request.current.startReplyStream();
        ostr.startEncapsulation(request.current.encoding, null);
        ostr.writeProxy(ret);
        ostr.endEncapsulation();
        return java.util.concurrent.CompletableFuture.completedFuture(new com.zeroc.Ice.OutgoingResponse(ostr));
    }

    /** @hidden */
    static java.util.concurrent.CompletionStage<com.zeroc.Ice.OutgoingResponse> _iceD_openRegistryStdOut(AdminSession obj, com.zeroc.Ice.IncomingRequest request)
        throws com.zeroc.Ice.UserException
    {
        com.zeroc.Ice.Object._iceCheckMode(null, request.current.mode);
        com.zeroc.Ice.InputStream istr = request.inputStream;
        istr.startEncapsulation();
        String iceP_name;
        int iceP_count;
        iceP_name = istr.readString();
        iceP_count = istr.readInt();
        istr.endEncapsulation();
        FileIteratorPrx ret = obj.openRegistryStdOut(iceP_name, iceP_count, request.current);
        var ostr = request.current.startReplyStream();
        ostr.startEncapsulation(request.current.encoding, null);
        ostr.writeProxy(ret);
        ostr.endEncapsulation();
        return java.util.concurrent.CompletableFuture.completedFuture(new com.zeroc.Ice.OutgoingResponse(ostr));
    }

    @Override
    default java.util.concurrent.CompletionStage<com.zeroc.Ice.OutgoingResponse> dispatch(com.zeroc.Ice.IncomingRequest request)
        throws com.zeroc.Ice.UserException
    {
        return switch (request.current.operation)
        {
            case "destroy" -> com.zeroc.Glacier2.Session._iceD_destroy(this, request);
            case "keepAlive" -> AdminSession._iceD_keepAlive(this, request);
            case "getAdmin" -> AdminSession._iceD_getAdmin(this, request);
            case "getAdminCallbackTemplate" -> AdminSession._iceD_getAdminCallbackTemplate(this, request);
            case "setObservers" -> AdminSession._iceD_setObservers(this, request);
            case "setObserversByIdentity" -> AdminSession._iceD_setObserversByIdentity(this, request);
            case "startUpdate" -> AdminSession._iceD_startUpdate(this, request);
            case "finishUpdate" -> AdminSession._iceD_finishUpdate(this, request);
            case "getReplicaName" -> AdminSession._iceD_getReplicaName(this, request);
            case "openServerLog" -> AdminSession._iceD_openServerLog(this, request);
            case "openServerStdErr" -> AdminSession._iceD_openServerStdErr(this, request);
            case "openServerStdOut" -> AdminSession._iceD_openServerStdOut(this, request);
            case "openNodeStdErr" -> AdminSession._iceD_openNodeStdErr(this, request);
            case "openNodeStdOut" -> AdminSession._iceD_openNodeStdOut(this, request);
            case "openRegistryStdErr" -> AdminSession._iceD_openRegistryStdErr(this, request);
            case "openRegistryStdOut" -> AdminSession._iceD_openRegistryStdOut(this, request);
            case "ice_id" -> com.zeroc.Ice.Object._iceD_ice_id(this, request);
            case "ice_ids" -> com.zeroc.Ice.Object._iceD_ice_ids(this, request);
            case "ice_isA" -> com.zeroc.Ice.Object._iceD_ice_isA(this, request);
            case "ice_ping" -> com.zeroc.Ice.Object._iceD_ice_ping(this, request);
            default -> throw new com.zeroc.Ice.OperationNotExistException();
        };
    }
}
