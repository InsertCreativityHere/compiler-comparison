// Copyright (c) ZeroC, Inc.
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file 'Election.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>

#nullable enable

[assembly:Ice.Slice("Election.ice")]

#pragma warning disable CS1591 // Missing XML Comment
#pragma warning disable CS1573 // Parameter has no matching param tag in the XML comment
#pragma warning disable CS0612 // Type or member is obsolete
#pragma warning disable CS0618 // Type or member is obsolete
#pragma warning disable CS0619 // Type or member is obsolete

namespace IceStormElection
{
    public sealed partial record class TopicContent
    {
        public global::Ice.Identity id;

        public global::IceStorm.SubscriberRecord[] records;

        partial void ice_initialize();

        public TopicContent(global::Ice.Identity id, global::IceStorm.SubscriberRecord[] records)
        {
            global::System.ArgumentNullException.ThrowIfNull(id);
            this.id = id;
            global::System.ArgumentNullException.ThrowIfNull(records);
            this.records = records;
            ice_initialize();
        }

        public TopicContent(Ice.InputStream istr)
        {
            this.id = new global::Ice.Identity(istr);
            this.records = global::IceStorm.SubscriberRecordSeqHelper.read(istr);
            ice_initialize();
        }

        public void ice_writeMembers(Ice.OutputStream ostr)
        {
            global::Ice.Identity.ice_write(ostr, this.id);
            global::IceStorm.SubscriberRecordSeqHelper.write(ostr, this.records);
        }

        public static void ice_write(Ice.OutputStream ostr, TopicContent v)
        {
            v.ice_writeMembers(ostr);
        }

        public static TopicContent ice_read(Ice.InputStream istr) => new(istr);
    }

    /// <summary>
    /// Thrown if an observer detects an inconsistency.
    /// </summary>
    [Ice.SliceTypeId("::IceStormElection::ObserverInconsistencyException")]
    public partial class ObserverInconsistencyException : Ice.UserException
    {
        public string reason = "";

        public ObserverInconsistencyException(string reason)
        {
            global::System.ArgumentNullException.ThrowIfNull(reason);
            this.reason = reason;
        }

        public ObserverInconsistencyException()
        {
        }

        public override string ice_id() => "::IceStormElection::ObserverInconsistencyException";

        protected override void iceWriteImpl(Ice.OutputStream ostr_)
        {
            ostr_.startSlice("::IceStormElection::ObserverInconsistencyException", -1, true);
            ostr_.writeString(reason);
            ostr_.endSlice();
        }

        protected override void iceReadImpl(Ice.InputStream istr_)
        {
            istr_.startSlice();
            reason = istr_.readString();
            istr_.endSlice();
        }
    }

    [Ice.SliceTypeId("::IceStormElection::ReplicaObserver")]
    public partial interface ReplicaObserver : Ice.Object
    {
        /// <summary>
        /// Initialize the observer.
        /// </summary>
        /// <param name="llu">
        /// The last log update seen by the master.
        /// </param>
        /// <param name="content">
        /// The topic content.
        /// </param>
        /// <param name="current">The Current object for the dispatch.</param>
        /// <exception cref="IceStormElection.ObserverInconsistencyException">
        /// Raised if an
        /// inconsisency was detected.
        /// </exception>
        void init(LogUpdate llu, TopicContent[] content, Ice.Current current);

        /// <summary>
        /// Create the topic with the given name.
        /// </summary>
        /// <param name="llu">
        /// The log update token.
        /// </param>
        /// <param name="name">
        /// The topic name.
        /// </param>
        /// <param name="current">The Current object for the dispatch.</param>
        /// <exception cref="IceStormElection.ObserverInconsistencyException">
        /// Raised if an
        /// inconsisency was detected.
        /// </exception>
        void createTopic(LogUpdate llu, string name, Ice.Current current);

        /// <summary>
        /// Destroy the topic with the given name.
        /// </summary>
        /// <param name="llu">
        /// The log update token.
        /// </param>
        /// <param name="name">
        /// The topic name.
        /// </param>
        /// <param name="current">The Current object for the dispatch.</param>
        /// <exception cref="IceStormElection.ObserverInconsistencyException">
        /// Raised if an
        /// inconsisency was detected.
        /// </exception>
        void destroyTopic(LogUpdate llu, string name, Ice.Current current);

        /// <summary>
        /// Add a subscriber to a topic.
        /// </summary>
        /// <param name="llu">
        /// The log update token.
        /// </param>
        /// <param name="topic">
        /// The topic name to which to add the subscriber.
        /// </param>
        /// <param name="record">
        /// The subscriber information.
        /// </param>
        /// <param name="current">The Current object for the dispatch.</param>
        /// <exception cref="IceStormElection.ObserverInconsistencyException">
        /// Raised if an
        /// inconsisency was detected.
        /// </exception>
        void addSubscriber(LogUpdate llu, string topic, global::IceStorm.SubscriberRecord record, Ice.Current current);

        /// <summary>
        /// Remove a subscriber from a topic.
        /// </summary>
        /// <param name="llu">
        /// The log update token.
        /// </param>
        /// <param name="subscribers">
        /// The identities of the subscribers to remove.
        /// </param>
        /// <param name="current">The Current object for the dispatch.</param>
        /// <exception cref="IceStormElection.ObserverInconsistencyException">
        /// Raised if an inconsisency was detected.
        /// </exception>
        void removeSubscriber(LogUpdate llu, string topic, global::Ice.Identity[] subscribers, Ice.Current current);
    }

    [Ice.SliceTypeId("::IceStormElection::TopicManagerSync")]
    public partial interface TopicManagerSync : Ice.Object
    {
        /// <summary>
        /// Retrieve the topic content.
        /// </summary>
        /// <param name="llu">
        /// The last log update token.
        /// </param>
        /// <param name="content">
        /// The topic content.
        /// </param>
        /// <param name="current">The Current object for the dispatch.</param>
        void getContent(out LogUpdate llu, out TopicContent[] content, Ice.Current current);
    }

    /// <summary>
    /// The node state.
    /// </summary>
    public enum NodeState
    {
        /// <summary>
        /// The node is inactive and awaiting an election.
        /// </summary>
        NodeStateInactive,
        /// <summary>
        /// The node is electing a leader.
        /// </summary>
        NodeStateElection,
        /// <summary>
        /// The replica group is reorganizing.
        /// </summary>
        NodeStateReorganization,
        /// <summary>
        /// The replica group is active &amp; replicating.
        /// </summary>
        NodeStateNormal
    }

    public sealed class NodeStateHelper
    {
        public static void write(Ice.OutputStream ostr, NodeState v)
        {
            ostr.writeEnum((int)v, 3);
        }

        public static NodeState read(Ice.InputStream istr)
        {
            NodeState v;
            v = (NodeState)istr.readEnum(3);
            return v;
        }
    }

    public sealed partial record class NodeInfo
    {
        public int id;

        public NodePrx? n;

        partial void ice_initialize();

        public NodeInfo()
        {
            ice_initialize();
        }

        public NodeInfo(int id, NodePrx? n)
        {
            this.id = id;
            this.n = n;
            ice_initialize();
        }

        public NodeInfo(Ice.InputStream istr)
        {
            this.id = istr.readInt();
            this.n = NodePrxHelper.read(istr);
            ice_initialize();
        }

        public void ice_writeMembers(Ice.OutputStream ostr)
        {
            ostr.writeInt(this.id);
            NodePrxHelper.write(ostr, this.n);
        }

        public static void ice_write(Ice.OutputStream ostr, NodeInfo v)
        {
            v.ice_writeMembers(ostr);
        }

        public static NodeInfo ice_read(Ice.InputStream istr) => new(istr);
    }

    public partial record struct GroupInfo
    {
        public int id;

        public LogUpdate llu;

        partial void ice_initialize();

        public GroupInfo(int id, LogUpdate llu)
        {
            this.id = id;
            this.llu = llu;
            ice_initialize();
        }

        public GroupInfo(Ice.InputStream istr)
        {
            this.id = istr.readInt();
            this.llu = new LogUpdate(istr);
            ice_initialize();
        }

        public void ice_writeMembers(Ice.OutputStream ostr)
        {
            ostr.writeInt(this.id);
            this.llu.ice_writeMembers(ostr);
        }

        public static void ice_write(Ice.OutputStream ostr, GroupInfo v)
        {
            v.ice_writeMembers(ostr);
        }

        public static GroupInfo ice_read(Ice.InputStream istr) => new(istr);
    }

    public sealed partial record class QueryInfo
    {
        public int id;

        public int coord;

        public string group = "";

        public Ice.ObjectPrx? replica;

        public NodeState state;

        public GroupInfo[] up;

        public int max;

        partial void ice_initialize();

        public QueryInfo(GroupInfo[] up)
        {
            global::System.ArgumentNullException.ThrowIfNull(up);
            this.up = up;
            ice_initialize();
        }

        public QueryInfo(int id, int coord, string group, Ice.ObjectPrx? replica, NodeState state, GroupInfo[] up, int max)
        {
            this.id = id;
            this.coord = coord;
            global::System.ArgumentNullException.ThrowIfNull(group);
            this.group = group;
            this.replica = replica;
            this.state = state;
            global::System.ArgumentNullException.ThrowIfNull(up);
            this.up = up;
            this.max = max;
            ice_initialize();
        }

        public QueryInfo(Ice.InputStream istr)
        {
            this.id = istr.readInt();
            this.coord = istr.readInt();
            this.group = istr.readString();
            this.replica = istr.readProxy();
            this.state = (NodeState)istr.readEnum(3);
            this.up = GroupInfoSeqHelper.read(istr);
            this.max = istr.readInt();
            ice_initialize();
        }

        public void ice_writeMembers(Ice.OutputStream ostr)
        {
            ostr.writeInt(this.id);
            ostr.writeInt(this.coord);
            ostr.writeString(this.group);
            ostr.writeProxy(this.replica);
            ostr.writeEnum((int)this.state, 3);
            GroupInfoSeqHelper.write(ostr, this.up);
            ostr.writeInt(this.max);
        }

        public static void ice_write(Ice.OutputStream ostr, QueryInfo v)
        {
            v.ice_writeMembers(ostr);
        }

        public static QueryInfo ice_read(Ice.InputStream istr) => new(istr);
    }

    [Ice.SliceTypeId("::IceStormElection::Node")]
    public partial interface Node : Ice.Object
    {
        /// <summary>
        /// Invite the node into a group with the given coordinator and group name.
        /// </summary>
        /// <param name="j">
        /// The group coordinator.
        /// </param>
        /// <param name="gn">
        /// The group name.
        /// </param>
        /// <param name="current">The Current object for the dispatch.</param>
        void invitation(int j, string gn, Ice.Current current);

        /// <summary>
        /// Call from the group coordinator to a node to inform the node that the replica group is active.
        /// </summary>
        /// <param name="j">
        /// The group coordinator.
        /// </param>
        /// <param name="gn">
        /// The group name.
        /// </param>
        /// <param name="coordinator">
        /// The proxy to the coordinator.
        /// </param>
        /// <param name="max">
        /// The highest priority node seen by this replica group.
        /// </param>
        /// <param name="generation">
        /// The current generation count.
        /// </param>
        /// <param name="current">The Current object for the dispatch.</param>
        void ready(int j, string gn, Ice.ObjectPrx? coordinator, int max, long generation, Ice.Current current);

        /// <summary>
        /// Called to accept an invitation into the given group.
        /// </summary>
        /// <param name="j">
        /// The id of the node accepting the invitation.
        /// </param>
        /// <param name="gn">
        /// The group name.
        /// </param>
        /// <param name="forwardedInvites">
        /// The ids of the nodes to which invitations were forwarded.
        /// </param>
        /// <param name="observer">
        /// The observer.
        /// </param>
        /// <param name="llu">
        /// The last log update for the given node.
        /// </param>
        /// <param name="max">
        /// The highest priority node seen by this replica group.
        /// </param>
        /// <param name="current">The Current object for the dispatch.</param>
        void accept(int j, string gn, int[] forwardedInvites, Ice.ObjectPrx? observer, LogUpdate llu, int max, Ice.Current current);

        /// <summary>
        /// Determine if this node is a coordinator.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>
        /// <returns>
        /// True if the node is a coordinator, false otherwise.
        /// </returns>
        bool areYouCoordinator(Ice.Current current);

        /// <summary>
        /// Determine if the node is a member of the given group with the given coordinator.
        /// </summary>
        /// <param name="gn">
        /// The group name.
        /// </param>
        /// <param name="j">
        /// The group coordinator.
        /// </param>
        /// <param name="current">The Current object for the dispatch.</param>
        /// <returns>
        /// True if the node is a member, false otherwise.
        /// </returns>
        bool areYouThere(string gn, int j, Ice.Current current);

        /// <summary>
        /// Get the sync object for the replica hosted by this node.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>
        /// <returns>
        /// The sync object.
        /// </returns>
        Ice.ObjectPrx? sync(Ice.Current current);

        /// <summary>
        /// Get the replication group information.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>
        /// <returns>
        /// The set of configured nodes and the associated priority.
        /// </returns>
        NodeInfo[] nodes(Ice.Current current);

        /// <summary>
        /// Get the query information for the given node.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>
        /// <returns>
        /// The query information.
        /// </returns>
        QueryInfo query(Ice.Current current);
    }
}

namespace IceStormElection
{
    public record struct TopicManagerSync_GetContentResult(LogUpdate llu, TopicContent[] content);
}

namespace IceStormElection
{
    /// <summary>
    /// The replica observer.
    /// </summary>
    public interface ReplicaObserverPrx : Ice.ObjectPrx
    {
        /// <summary>
        /// Initialize the observer.
        /// </summary>
        /// <param name="llu">
        /// The last log update seen by the master.
        /// </param>
        /// <param name="content">
        /// The topic content.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <exception cref="IceStormElection.ObserverInconsistencyException">
        /// Raised if an
        /// inconsisency was detected.
        /// </exception>
        void init(LogUpdate llu, TopicContent[] content, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Initialize the observer.
        /// </summary>
        /// <param name="llu">
        /// The last log update seen by the master.
        /// </param>
        /// <param name="content">
        /// The topic content.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
        /// <exception cref="IceStormElection.ObserverInconsistencyException">
        /// Raised if an
        /// inconsisency was detected.
        /// </exception>
        global::System.Threading.Tasks.Task initAsync(LogUpdate llu, TopicContent[] content, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Create the topic with the given name.
        /// </summary>
        /// <param name="llu">
        /// The log update token.
        /// </param>
        /// <param name="name">
        /// The topic name.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <exception cref="IceStormElection.ObserverInconsistencyException">
        /// Raised if an
        /// inconsisency was detected.
        /// </exception>
        void createTopic(LogUpdate llu, string name, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Create the topic with the given name.
        /// </summary>
        /// <param name="llu">
        /// The log update token.
        /// </param>
        /// <param name="name">
        /// The topic name.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
        /// <exception cref="IceStormElection.ObserverInconsistencyException">
        /// Raised if an
        /// inconsisency was detected.
        /// </exception>
        global::System.Threading.Tasks.Task createTopicAsync(LogUpdate llu, string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Destroy the topic with the given name.
        /// </summary>
        /// <param name="llu">
        /// The log update token.
        /// </param>
        /// <param name="name">
        /// The topic name.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <exception cref="IceStormElection.ObserverInconsistencyException">
        /// Raised if an
        /// inconsisency was detected.
        /// </exception>
        void destroyTopic(LogUpdate llu, string name, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Destroy the topic with the given name.
        /// </summary>
        /// <param name="llu">
        /// The log update token.
        /// </param>
        /// <param name="name">
        /// The topic name.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
        /// <exception cref="IceStormElection.ObserverInconsistencyException">
        /// Raised if an
        /// inconsisency was detected.
        /// </exception>
        global::System.Threading.Tasks.Task destroyTopicAsync(LogUpdate llu, string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Add a subscriber to a topic.
        /// </summary>
        /// <param name="llu">
        /// The log update token.
        /// </param>
        /// <param name="topic">
        /// The topic name to which to add the subscriber.
        /// </param>
        /// <param name="record">
        /// The subscriber information.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <exception cref="IceStormElection.ObserverInconsistencyException">
        /// Raised if an
        /// inconsisency was detected.
        /// </exception>
        void addSubscriber(LogUpdate llu, string topic, global::IceStorm.SubscriberRecord record, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Add a subscriber to a topic.
        /// </summary>
        /// <param name="llu">
        /// The log update token.
        /// </param>
        /// <param name="topic">
        /// The topic name to which to add the subscriber.
        /// </param>
        /// <param name="record">
        /// The subscriber information.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
        /// <exception cref="IceStormElection.ObserverInconsistencyException">
        /// Raised if an
        /// inconsisency was detected.
        /// </exception>
        global::System.Threading.Tasks.Task addSubscriberAsync(LogUpdate llu, string topic, global::IceStorm.SubscriberRecord record, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Remove a subscriber from a topic.
        /// </summary>
        /// <param name="llu">
        /// The log update token.
        /// </param>
        /// <param name="subscribers">
        /// The identities of the subscribers to remove.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <exception cref="IceStormElection.ObserverInconsistencyException">
        /// Raised if an inconsisency was detected.
        /// </exception>
        void removeSubscriber(LogUpdate llu, string topic, global::Ice.Identity[] subscribers, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Remove a subscriber from a topic.
        /// </summary>
        /// <param name="llu">
        /// The log update token.
        /// </param>
        /// <param name="subscribers">
        /// The identities of the subscribers to remove.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
        /// <exception cref="IceStormElection.ObserverInconsistencyException">
        /// Raised if an inconsisency was detected.
        /// </exception>
        global::System.Threading.Tasks.Task removeSubscriberAsync(LogUpdate llu, string topic, global::Ice.Identity[] subscribers, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }

    /// <summary>
    /// Interface used to sync topics.
    /// </summary>
    public interface TopicManagerSyncPrx : Ice.ObjectPrx
    {
        /// <summary>
        /// Retrieve the topic content.
        /// </summary>
        /// <param name="llu">
        /// The last log update token.
        /// </param>
        /// <param name="content">
        /// The topic content.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        void getContent(out LogUpdate llu, out TopicContent[] content, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Retrieve the topic content.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<TopicManagerSync_GetContentResult> getContentAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }

    /// <summary>
    /// A replica node.
    /// </summary>
    public interface NodePrx : Ice.ObjectPrx
    {
        /// <summary>
        /// Invite the node into a group with the given coordinator and group name.
        /// </summary>
        /// <param name="j">
        /// The group coordinator.
        /// </param>
        /// <param name="gn">
        /// The group name.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        void invitation(int j, string gn, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Invite the node into a group with the given coordinator and group name.
        /// </summary>
        /// <param name="j">
        /// The group coordinator.
        /// </param>
        /// <param name="gn">
        /// The group name.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task invitationAsync(int j, string gn, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Call from the group coordinator to a node to inform the node that the replica group is active.
        /// </summary>
        /// <param name="j">
        /// The group coordinator.
        /// </param>
        /// <param name="gn">
        /// The group name.
        /// </param>
        /// <param name="coordinator">
        /// The proxy to the coordinator.
        /// </param>
        /// <param name="max">
        /// The highest priority node seen by this replica group.
        /// </param>
        /// <param name="generation">
        /// The current generation count.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        void ready(int j, string gn, Ice.ObjectPrx? coordinator, int max, long generation, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Call from the group coordinator to a node to inform the node that the replica group is active.
        /// </summary>
        /// <param name="j">
        /// The group coordinator.
        /// </param>
        /// <param name="gn">
        /// The group name.
        /// </param>
        /// <param name="coordinator">
        /// The proxy to the coordinator.
        /// </param>
        /// <param name="max">
        /// The highest priority node seen by this replica group.
        /// </param>
        /// <param name="generation">
        /// The current generation count.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task readyAsync(int j, string gn, Ice.ObjectPrx? coordinator, int max, long generation, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Called to accept an invitation into the given group.
        /// </summary>
        /// <param name="j">
        /// The id of the node accepting the invitation.
        /// </param>
        /// <param name="gn">
        /// The group name.
        /// </param>
        /// <param name="forwardedInvites">
        /// The ids of the nodes to which invitations were forwarded.
        /// </param>
        /// <param name="observer">
        /// The observer.
        /// </param>
        /// <param name="llu">
        /// The last log update for the given node.
        /// </param>
        /// <param name="max">
        /// The highest priority node seen by this replica group.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        void accept(int j, string gn, int[] forwardedInvites, Ice.ObjectPrx? observer, LogUpdate llu, int max, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Called to accept an invitation into the given group.
        /// </summary>
        /// <param name="j">
        /// The id of the node accepting the invitation.
        /// </param>
        /// <param name="gn">
        /// The group name.
        /// </param>
        /// <param name="forwardedInvites">
        /// The ids of the nodes to which invitations were forwarded.
        /// </param>
        /// <param name="observer">
        /// The observer.
        /// </param>
        /// <param name="llu">
        /// The last log update for the given node.
        /// </param>
        /// <param name="max">
        /// The highest priority node seen by this replica group.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task acceptAsync(int j, string gn, int[] forwardedInvites, Ice.ObjectPrx? observer, LogUpdate llu, int max, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Determine if this node is a coordinator.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>
        /// True if the node is a coordinator, false otherwise.
        /// </returns>
        bool areYouCoordinator(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Determine if this node is a coordinator.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<bool> areYouCoordinatorAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Determine if the node is a member of the given group with the given coordinator.
        /// </summary>
        /// <param name="gn">
        /// The group name.
        /// </param>
        /// <param name="j">
        /// The group coordinator.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>
        /// True if the node is a member, false otherwise.
        /// </returns>
        bool areYouThere(string gn, int j, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Determine if the node is a member of the given group with the given coordinator.
        /// </summary>
        /// <param name="gn">
        /// The group name.
        /// </param>
        /// <param name="j">
        /// The group coordinator.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<bool> areYouThereAsync(string gn, int j, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get the sync object for the replica hosted by this node.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>
        /// The sync object.
        /// </returns>
        Ice.ObjectPrx? sync(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get the sync object for the replica hosted by this node.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<Ice.ObjectPrx?> syncAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get the replication group information.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>
        /// The set of configured nodes and the associated priority.
        /// </returns>
        NodeInfo[] nodes(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get the replication group information.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<NodeInfo[]> nodesAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get the query information for the given node.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>
        /// The query information.
        /// </returns>
        QueryInfo query(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get the query information for the given node.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<QueryInfo> queryAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }
}

namespace IceStormElection
{
    public sealed class TopicContentSeqHelper
    {
        public static void write(Ice.OutputStream ostr, TopicContent[] v)
        {
            if (v is null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    v[ix].ice_writeMembers(ostr);
                }
            }
        }

        public static TopicContent[] read(Ice.InputStream istr)
        {
            TopicContent[] v;
            {
                int szx = istr.readAndCheckSeqSize(3);
                v = new TopicContent[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new TopicContent(istr);
                }
            }
            return v;
        }
    }

    public sealed class ReplicaObserverPrxHelper : Ice.ObjectPrxHelperBase, ReplicaObserverPrx
    {
        public void init(LogUpdate llu, TopicContent[] content, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_initAsync(llu, content, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void createTopic(LogUpdate llu, string name, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_createTopicAsync(llu, name, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void destroyTopic(LogUpdate llu, string name, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_destroyTopicAsync(llu, name, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void addSubscriber(LogUpdate llu, string topic, global::IceStorm.SubscriberRecord record, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_addSubscriberAsync(llu, topic, record, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void removeSubscriber(LogUpdate llu, string topic, global::Ice.Identity[] subscribers, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_removeSubscriberAsync(llu, topic, subscribers, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task initAsync(LogUpdate llu, TopicContent[] content, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_initAsync(llu, content, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_initAsync(LogUpdate iceP_llu, TopicContent[] iceP_content, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_init_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_init(iceP_llu, iceP_content, context, synchronous, completed);
            return completed.Task;
        }

        private const string _init_name = "init";

        private void _iceI_init(LogUpdate iceP_llu, TopicContent[] iceP_content, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _init_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    iceP_llu.ice_writeMembers(ostr);
                    TopicContentSeqHelper.write(ostr, iceP_content);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ObserverInconsistencyException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task createTopicAsync(LogUpdate llu, string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_createTopicAsync(llu, name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_createTopicAsync(LogUpdate iceP_llu, string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_createTopic_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_createTopic(iceP_llu, iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _createTopic_name = "createTopic";

        private void _iceI_createTopic(LogUpdate iceP_llu, string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _createTopic_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    iceP_llu.ice_writeMembers(ostr);
                    ostr.writeString(iceP_name);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ObserverInconsistencyException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task destroyTopicAsync(LogUpdate llu, string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_destroyTopicAsync(llu, name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_destroyTopicAsync(LogUpdate iceP_llu, string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_destroyTopic_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_destroyTopic(iceP_llu, iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _destroyTopic_name = "destroyTopic";

        private void _iceI_destroyTopic(LogUpdate iceP_llu, string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _destroyTopic_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    iceP_llu.ice_writeMembers(ostr);
                    ostr.writeString(iceP_name);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ObserverInconsistencyException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task addSubscriberAsync(LogUpdate llu, string topic, global::IceStorm.SubscriberRecord record, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_addSubscriberAsync(llu, topic, record, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_addSubscriberAsync(LogUpdate iceP_llu, string iceP_topic, global::IceStorm.SubscriberRecord iceP_record, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_addSubscriber_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_addSubscriber(iceP_llu, iceP_topic, iceP_record, context, synchronous, completed);
            return completed.Task;
        }

        private const string _addSubscriber_name = "addSubscriber";

        private void _iceI_addSubscriber(LogUpdate iceP_llu, string iceP_topic, global::IceStorm.SubscriberRecord iceP_record, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _addSubscriber_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    iceP_llu.ice_writeMembers(ostr);
                    ostr.writeString(iceP_topic);
                    global::IceStorm.SubscriberRecord.ice_write(ostr, iceP_record);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ObserverInconsistencyException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task removeSubscriberAsync(LogUpdate llu, string topic, global::Ice.Identity[] subscribers, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_removeSubscriberAsync(llu, topic, subscribers, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_removeSubscriberAsync(LogUpdate iceP_llu, string iceP_topic, global::Ice.Identity[] iceP_subscribers, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_removeSubscriber_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_removeSubscriber(iceP_llu, iceP_topic, iceP_subscribers, context, synchronous, completed);
            return completed.Task;
        }

        private const string _removeSubscriber_name = "removeSubscriber";

        private void _iceI_removeSubscriber(LogUpdate iceP_llu, string iceP_topic, global::Ice.Identity[] iceP_subscribers, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _removeSubscriber_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    iceP_llu.ice_writeMembers(ostr);
                    ostr.writeString(iceP_topic);
                    global::Ice.IdentitySeqHelper.write(ostr, iceP_subscribers);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ObserverInconsistencyException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public static ReplicaObserverPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new ReplicaObserverPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static ReplicaObserverPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new ReplicaObserverPrxHelper(b) : null;

        public static ReplicaObserverPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static ReplicaObserverPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new ReplicaObserverPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static ReplicaObserverPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceStormElection::ReplicaObserver"
        };

        public static string ice_staticId() => "::IceStormElection::ReplicaObserver";

        public static void write(Ice.OutputStream ostr, ReplicaObserverPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static ReplicaObserverPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new ReplicaObserverPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new ReplicaObserverPrxHelper(reference);

        private ReplicaObserverPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private ReplicaObserverPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }

    public sealed class TopicManagerSyncPrxHelper : Ice.ObjectPrxHelperBase, TopicManagerSyncPrx
    {
        public void getContent(out LogUpdate llu, out TopicContent[] content, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                var result_ = _iceI_getContentAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
                llu = result_.llu;
                content = result_.content;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task<TopicManagerSync_GetContentResult> getContentAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getContentAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<TopicManagerSync_GetContentResult> _iceI_getContentAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getContent_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<TopicManagerSync_GetContentResult>(progress, cancel);
            _iceI_getContent(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getContent_name = "getContent";

        private void _iceI_getContent(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<TopicManagerSync_GetContentResult>(completed);
            outAsync.invoke(
                _getContent_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    var ret = new TopicManagerSync_GetContentResult();
                    ret.llu = new LogUpdate(istr);
                    ret.content = TopicContentSeqHelper.read(istr);
                    return ret;
                });
        }

        public static TopicManagerSyncPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new TopicManagerSyncPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static TopicManagerSyncPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new TopicManagerSyncPrxHelper(b) : null;

        public static TopicManagerSyncPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static TopicManagerSyncPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new TopicManagerSyncPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static TopicManagerSyncPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceStormElection::TopicManagerSync"
        };

        public static string ice_staticId() => "::IceStormElection::TopicManagerSync";

        public static void write(Ice.OutputStream ostr, TopicManagerSyncPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static TopicManagerSyncPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new TopicManagerSyncPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new TopicManagerSyncPrxHelper(reference);

        private TopicManagerSyncPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private TopicManagerSyncPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }

    public sealed class NodeInfoSeqHelper
    {
        public static void write(Ice.OutputStream ostr, NodeInfo[] v)
        {
            if (v is null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    v[ix].ice_writeMembers(ostr);
                }
            }
        }

        public static NodeInfo[] read(Ice.InputStream istr)
        {
            NodeInfo[] v;
            {
                int szx = istr.readAndCheckSeqSize(6);
                v = new NodeInfo[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new NodeInfo(istr);
                }
            }
            return v;
        }
    }

    public sealed class GroupInfoSeqHelper
    {
        public static void write(Ice.OutputStream ostr, GroupInfo[] v)
        {
            if (v is null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    v[ix].ice_writeMembers(ostr);
                }
            }
        }

        public static GroupInfo[] read(Ice.InputStream istr)
        {
            GroupInfo[] v;
            {
                int szx = istr.readAndCheckSeqSize(20);
                v = new GroupInfo[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new GroupInfo(istr);
                }
            }
            return v;
        }
    }

    public sealed class NodePrxHelper : Ice.ObjectPrxHelperBase, NodePrx
    {
        public void invitation(int j, string gn, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_invitationAsync(j, gn, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void ready(int j, string gn, Ice.ObjectPrx? coordinator, int max, long generation, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_readyAsync(j, gn, coordinator, max, generation, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void accept(int j, string gn, int[] forwardedInvites, Ice.ObjectPrx? observer, LogUpdate llu, int max, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_acceptAsync(j, gn, forwardedInvites, observer, llu, max, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public bool areYouCoordinator(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_areYouCoordinatorAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public bool areYouThere(string gn, int j, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_areYouThereAsync(gn, j, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public Ice.ObjectPrx? sync(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_syncAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public NodeInfo[] nodes(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_nodesAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public QueryInfo query(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_queryAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task invitationAsync(int j, string gn, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_invitationAsync(j, gn, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_invitationAsync(int iceP_j, string iceP_gn, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_invitation(iceP_j, iceP_gn, context, synchronous, completed);
            return completed.Task;
        }

        private const string _invitation_name = "invitation";

        private void _iceI_invitation(int iceP_j, string iceP_gn, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _invitation_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_j);
                    ostr.writeString(iceP_gn);
                });
        }

        public global::System.Threading.Tasks.Task readyAsync(int j, string gn, Ice.ObjectPrx? coordinator, int max, long generation, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_readyAsync(j, gn, coordinator, max, generation, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_readyAsync(int iceP_j, string iceP_gn, Ice.ObjectPrx? iceP_coordinator, int iceP_max, long iceP_generation, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_ready(iceP_j, iceP_gn, iceP_coordinator, iceP_max, iceP_generation, context, synchronous, completed);
            return completed.Task;
        }

        private const string _ready_name = "ready";

        private void _iceI_ready(int iceP_j, string iceP_gn, Ice.ObjectPrx? iceP_coordinator, int iceP_max, long iceP_generation, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _ready_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_j);
                    ostr.writeString(iceP_gn);
                    ostr.writeProxy(iceP_coordinator);
                    ostr.writeInt(iceP_max);
                    ostr.writeLong(iceP_generation);
                });
        }

        public global::System.Threading.Tasks.Task acceptAsync(int j, string gn, int[] forwardedInvites, Ice.ObjectPrx? observer, LogUpdate llu, int max, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_acceptAsync(j, gn, forwardedInvites, observer, llu, max, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_acceptAsync(int iceP_j, string iceP_gn, int[] iceP_forwardedInvites, Ice.ObjectPrx? iceP_observer, LogUpdate iceP_llu, int iceP_max, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_accept(iceP_j, iceP_gn, iceP_forwardedInvites, iceP_observer, iceP_llu, iceP_max, context, synchronous, completed);
            return completed.Task;
        }

        private const string _accept_name = "accept";

        private void _iceI_accept(int iceP_j, string iceP_gn, int[] iceP_forwardedInvites, Ice.ObjectPrx? iceP_observer, LogUpdate iceP_llu, int iceP_max, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _accept_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_j);
                    ostr.writeString(iceP_gn);
                    global::Ice.IntSeqHelper.write(ostr, iceP_forwardedInvites);
                    ostr.writeProxy(iceP_observer);
                    iceP_llu.ice_writeMembers(ostr);
                    ostr.writeInt(iceP_max);
                });
        }

        public global::System.Threading.Tasks.Task<bool> areYouCoordinatorAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_areYouCoordinatorAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<bool> _iceI_areYouCoordinatorAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_areYouCoordinator_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<bool>(progress, cancel);
            _iceI_areYouCoordinator(context, synchronous, completed);
            return completed.Task;
        }

        private const string _areYouCoordinator_name = "areYouCoordinator";

        private void _iceI_areYouCoordinator(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<bool>(completed);
            outAsync.invoke(
                _areYouCoordinator_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    bool ret;
                    ret = istr.readBool();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<bool> areYouThereAsync(string gn, int j, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_areYouThereAsync(gn, j, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<bool> _iceI_areYouThereAsync(string iceP_gn, int iceP_j, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_areYouThere_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<bool>(progress, cancel);
            _iceI_areYouThere(iceP_gn, iceP_j, context, synchronous, completed);
            return completed.Task;
        }

        private const string _areYouThere_name = "areYouThere";

        private void _iceI_areYouThere(string iceP_gn, int iceP_j, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<bool>(completed);
            outAsync.invoke(
                _areYouThere_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_gn);
                    ostr.writeInt(iceP_j);
                },
                read: (Ice.InputStream istr) =>
                {
                    bool ret;
                    ret = istr.readBool();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<Ice.ObjectPrx?> syncAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_syncAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<Ice.ObjectPrx?> _iceI_syncAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_sync_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<Ice.ObjectPrx?>(progress, cancel);
            _iceI_sync(context, synchronous, completed);
            return completed.Task;
        }

        private const string _sync_name = "sync";

        private void _iceI_sync(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<Ice.ObjectPrx?>(completed);
            outAsync.invoke(
                _sync_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    Ice.ObjectPrx? ret;
                    ret = istr.readProxy();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<NodeInfo[]> nodesAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_nodesAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<NodeInfo[]> _iceI_nodesAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_nodes_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<NodeInfo[]>(progress, cancel);
            _iceI_nodes(context, synchronous, completed);
            return completed.Task;
        }

        private const string _nodes_name = "nodes";

        private void _iceI_nodes(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<NodeInfo[]>(completed);
            outAsync.invoke(
                _nodes_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    NodeInfo[] ret;
                    ret = NodeInfoSeqHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<QueryInfo> queryAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_queryAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<QueryInfo> _iceI_queryAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_query_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<QueryInfo>(progress, cancel);
            _iceI_query(context, synchronous, completed);
            return completed.Task;
        }

        private const string _query_name = "query";

        private void _iceI_query(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<QueryInfo>(completed);
            outAsync.invoke(
                _query_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    QueryInfo ret;
                    ret = new QueryInfo(istr);
                    return ret;
                });
        }

        public static NodePrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new NodePrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static NodePrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new NodePrxHelper(b) : null;

        public static NodePrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static NodePrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new NodePrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static NodePrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceStormElection::Node"
        };

        public static string ice_staticId() => "::IceStormElection::Node";

        public static void write(Ice.OutputStream ostr, NodePrx? v)
        {
            ostr.writeProxy(v);
        }

        public static NodePrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new NodePrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new NodePrxHelper(reference);

        private NodePrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private NodePrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }
}

namespace IceStormElection
{
    public abstract class ReplicaObserverDisp_ : Ice.ObjectImpl, ReplicaObserver
    {
        public abstract void init(LogUpdate llu, TopicContent[] content, Ice.Current current);

        public abstract void createTopic(LogUpdate llu, string name, Ice.Current current);

        public abstract void destroyTopic(LogUpdate llu, string name, Ice.Current current);

        public abstract void addSubscriber(LogUpdate llu, string topic, global::IceStorm.SubscriberRecord record, Ice.Current current);

        public abstract void removeSubscriber(LogUpdate llu, string topic, global::Ice.Identity[] subscribers, Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::IceStormElection::ReplicaObserver";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "init" => ReplicaObserver.iceD_initAsync(this, request),
                "createTopic" => ReplicaObserver.iceD_createTopicAsync(this, request),
                "destroyTopic" => ReplicaObserver.iceD_destroyTopicAsync(this, request),
                "addSubscriber" => ReplicaObserver.iceD_addSubscriberAsync(this, request),
                "removeSubscriber" => ReplicaObserver.iceD_removeSubscriberAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }

    public abstract class TopicManagerSyncDisp_ : Ice.ObjectImpl, TopicManagerSync
    {
        public abstract void getContent(out LogUpdate llu, out TopicContent[] content, Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::IceStormElection::TopicManagerSync";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "getContent" => TopicManagerSync.iceD_getContentAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }

    public abstract class NodeDisp_ : Ice.ObjectImpl, Node
    {
        public abstract void invitation(int j, string gn, Ice.Current current);

        public abstract void ready(int j, string gn, Ice.ObjectPrx? coordinator, int max, long generation, Ice.Current current);

        public abstract void accept(int j, string gn, int[] forwardedInvites, Ice.ObjectPrx? observer, LogUpdate llu, int max, Ice.Current current);

        public abstract bool areYouCoordinator(Ice.Current current);

        public abstract bool areYouThere(string gn, int j, Ice.Current current);

        public abstract Ice.ObjectPrx? sync(Ice.Current current);

        public abstract NodeInfo[] nodes(Ice.Current current);

        public abstract QueryInfo query(Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::IceStormElection::Node";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "invitation" => Node.iceD_invitationAsync(this, request),
                "ready" => Node.iceD_readyAsync(this, request),
                "accept" => Node.iceD_acceptAsync(this, request),
                "areYouCoordinator" => Node.iceD_areYouCoordinatorAsync(this, request),
                "areYouThere" => Node.iceD_areYouThereAsync(this, request),
                "sync" => Node.iceD_syncAsync(this, request),
                "nodes" => Node.iceD_nodesAsync(this, request),
                "query" => Node.iceD_queryAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }
}

namespace IceStormElection
{
    public partial interface ReplicaObserver
    {
        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_initAsync(
            ReplicaObserver obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            LogUpdate iceP_llu;
            TopicContent[] iceP_content;
            iceP_llu = new LogUpdate(istr);
            iceP_content = TopicContentSeqHelper.read(istr);
            istr.endEncapsulation();
            obj.init(iceP_llu, iceP_content, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_createTopicAsync(
            ReplicaObserver obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            LogUpdate iceP_llu;
            string iceP_name;
            iceP_llu = new LogUpdate(istr);
            iceP_name = istr.readString();
            istr.endEncapsulation();
            obj.createTopic(iceP_llu, iceP_name, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_destroyTopicAsync(
            ReplicaObserver obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            LogUpdate iceP_llu;
            string iceP_name;
            iceP_llu = new LogUpdate(istr);
            iceP_name = istr.readString();
            istr.endEncapsulation();
            obj.destroyTopic(iceP_llu, iceP_name, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_addSubscriberAsync(
            ReplicaObserver obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            LogUpdate iceP_llu;
            string iceP_topic;
            global::IceStorm.SubscriberRecord iceP_record;
            iceP_llu = new LogUpdate(istr);
            iceP_topic = istr.readString();
            iceP_record = new global::IceStorm.SubscriberRecord(istr);
            istr.endEncapsulation();
            obj.addSubscriber(iceP_llu, iceP_topic, iceP_record, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_removeSubscriberAsync(
            ReplicaObserver obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            LogUpdate iceP_llu;
            string iceP_topic;
            global::Ice.Identity[] iceP_subscribers;
            iceP_llu = new LogUpdate(istr);
            iceP_topic = istr.readString();
            iceP_subscribers = global::Ice.IdentitySeqHelper.read(istr);
            istr.endEncapsulation();
            obj.removeSubscriber(iceP_llu, iceP_topic, iceP_subscribers, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }
    }

    public partial interface TopicManagerSync
    {
        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getContentAsync(
            TopicManagerSync obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            LogUpdate iceP_llu;
            TopicContent[] iceP_content;
            obj.getContent(out iceP_llu, out iceP_content, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            iceP_llu.ice_writeMembers(ostr);
            TopicContentSeqHelper.write(ostr, iceP_content);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }
    }

    public partial interface Node
    {
        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_invitationAsync(
            Node obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            int iceP_j;
            string iceP_gn;
            iceP_j = istr.readInt();
            iceP_gn = istr.readString();
            istr.endEncapsulation();
            obj.invitation(iceP_j, iceP_gn, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_readyAsync(
            Node obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            int iceP_j;
            string iceP_gn;
            Ice.ObjectPrx? iceP_coordinator;
            int iceP_max;
            long iceP_generation;
            iceP_j = istr.readInt();
            iceP_gn = istr.readString();
            iceP_coordinator = istr.readProxy();
            iceP_max = istr.readInt();
            iceP_generation = istr.readLong();
            istr.endEncapsulation();
            obj.ready(iceP_j, iceP_gn, iceP_coordinator, iceP_max, iceP_generation, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_acceptAsync(
            Node obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            int iceP_j;
            string iceP_gn;
            int[] iceP_forwardedInvites;
            Ice.ObjectPrx? iceP_observer;
            LogUpdate iceP_llu;
            int iceP_max;
            iceP_j = istr.readInt();
            iceP_gn = istr.readString();
            iceP_forwardedInvites = global::Ice.IntSeqHelper.read(istr);
            iceP_observer = istr.readProxy();
            iceP_llu = new LogUpdate(istr);
            iceP_max = istr.readInt();
            istr.endEncapsulation();
            obj.accept(iceP_j, iceP_gn, iceP_forwardedInvites, iceP_observer, iceP_llu, iceP_max, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_areYouCoordinatorAsync(
            Node obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.areYouCoordinator(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeBool(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_areYouThereAsync(
            Node obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_gn;
            int iceP_j;
            iceP_gn = istr.readString();
            iceP_j = istr.readInt();
            istr.endEncapsulation();
            var ret = obj.areYouThere(iceP_gn, iceP_j, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeBool(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_syncAsync(
            Node obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.sync(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeProxy(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_nodesAsync(
            Node obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.nodes(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            NodeInfoSeqHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_queryAsync(
            Node obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.query(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            QueryInfo.ice_write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }
    }
}
