//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Internal.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#nullable enable

[assembly:Ice.Slice("Internal.ice")]

#pragma warning disable CS1591 // Missing XML Comment
#pragma warning disable CS1573 // Parameter has no matching param tag in the XML comment
#pragma warning disable CS0612 // Type or member is obsolete
#pragma warning disable CS0618 // Type or member is obsolete
#pragma warning disable CS0619 // Type or member is obsolete

namespace IceGrid
{
    [Ice.SliceTypeId("::IceGrid::InternalDbEnvDescriptor")]
    public partial class InternalDbEnvDescriptor : Ice.Value
    {
        public string name = "";

        public PropertyDescriptor[] properties;

        partial void ice_initialize();

        public InternalDbEnvDescriptor(string name, PropertyDescriptor[] properties)
        {
            global::System.ArgumentNullException.ThrowIfNull(name);
            this.name = name;
            global::System.ArgumentNullException.ThrowIfNull(properties);
            this.properties = properties;
            ice_initialize();
        }

        public InternalDbEnvDescriptor(PropertyDescriptor[] properties)
        {
            global::System.ArgumentNullException.ThrowIfNull(properties);
            this.properties = properties;
            ice_initialize();
        }

        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public InternalDbEnvDescriptor()
        {
            this.properties = null!;
            ice_initialize();
        }

        public static new string ice_staticId() => "::IceGrid::InternalDbEnvDescriptor";
        public override string ice_id() => ice_staticId();

        protected override void iceWriteImpl(Ice.OutputStream ostr_)
        {
            ostr_.startSlice(ice_staticId(), -1, true);
            ostr_.writeString(name);
            PropertyDescriptorSeqHelper.write(ostr_, properties);
            ostr_.endSlice();
        }

        protected override void iceReadImpl(Ice.InputStream istr_)
        {
            istr_.startSlice();
            name = istr_.readString();
            properties = PropertyDescriptorSeqHelper.read(istr_);
            istr_.endSlice();
        }
    }

    [Ice.SliceTypeId("::IceGrid::InternalAdapterDescriptor")]
    public partial class InternalAdapterDescriptor : Ice.Value
    {
        public string id = "";

        public bool serverLifetime;

        partial void ice_initialize();

        public InternalAdapterDescriptor(string id, bool serverLifetime)
        {
            global::System.ArgumentNullException.ThrowIfNull(id);
            this.id = id;
            this.serverLifetime = serverLifetime;
            ice_initialize();
        }

        public InternalAdapterDescriptor()
        {
            ice_initialize();
        }

        public static new string ice_staticId() => "::IceGrid::InternalAdapterDescriptor";
        public override string ice_id() => ice_staticId();

        protected override void iceWriteImpl(Ice.OutputStream ostr_)
        {
            ostr_.startSlice(ice_staticId(), -1, true);
            ostr_.writeString(id);
            ostr_.writeBool(serverLifetime);
            ostr_.endSlice();
        }

        protected override void iceReadImpl(Ice.InputStream istr_)
        {
            istr_.startSlice();
            id = istr_.readString();
            serverLifetime = istr_.readBool();
            istr_.endSlice();
        }
    }

    [Ice.SliceTypeId("::IceGrid::InternalServerDescriptor")]
    public partial class InternalServerDescriptor : Ice.Value
    {
        public string id = "";

        public string application = "";

        public string uuid = "";

        public int revision;

        public string sessionId = "";

        public string exe = "";

        public string pwd = "";

        public string user = "";

        public string activation = "";

        public string activationTimeout = "";

        public string deactivationTimeout = "";

        public bool processRegistered;

        public string[] options;

        public string[] envs;

        public string[] logs;

        public InternalAdapterDescriptor?[] adapters;

        public InternalDbEnvDescriptor?[] dbEnvs;

        public global::System.Collections.Generic.Dictionary<string, PropertyDescriptor[]> properties;

        public string[]? services;

        partial void ice_initialize();

        public InternalServerDescriptor(string id, string application, string uuid, int revision, string sessionId, string exe, string pwd, string user, string activation, string activationTimeout, string deactivationTimeout, bool processRegistered, string[] options, string[] envs, string[] logs, InternalAdapterDescriptor?[] adapters, InternalDbEnvDescriptor?[] dbEnvs, global::System.Collections.Generic.Dictionary<string, PropertyDescriptor[]> properties, string[]? services)
        {
            global::System.ArgumentNullException.ThrowIfNull(id);
            this.id = id;
            global::System.ArgumentNullException.ThrowIfNull(application);
            this.application = application;
            global::System.ArgumentNullException.ThrowIfNull(uuid);
            this.uuid = uuid;
            this.revision = revision;
            global::System.ArgumentNullException.ThrowIfNull(sessionId);
            this.sessionId = sessionId;
            global::System.ArgumentNullException.ThrowIfNull(exe);
            this.exe = exe;
            global::System.ArgumentNullException.ThrowIfNull(pwd);
            this.pwd = pwd;
            global::System.ArgumentNullException.ThrowIfNull(user);
            this.user = user;
            global::System.ArgumentNullException.ThrowIfNull(activation);
            this.activation = activation;
            global::System.ArgumentNullException.ThrowIfNull(activationTimeout);
            this.activationTimeout = activationTimeout;
            global::System.ArgumentNullException.ThrowIfNull(deactivationTimeout);
            this.deactivationTimeout = deactivationTimeout;
            this.processRegistered = processRegistered;
            global::System.ArgumentNullException.ThrowIfNull(options);
            this.options = options;
            global::System.ArgumentNullException.ThrowIfNull(envs);
            this.envs = envs;
            global::System.ArgumentNullException.ThrowIfNull(logs);
            this.logs = logs;
            global::System.ArgumentNullException.ThrowIfNull(adapters);
            this.adapters = adapters;
            global::System.ArgumentNullException.ThrowIfNull(dbEnvs);
            this.dbEnvs = dbEnvs;
            global::System.ArgumentNullException.ThrowIfNull(properties);
            this.properties = properties;
            this.services = services;
            ice_initialize();
        }

        public InternalServerDescriptor(string[] options, string[] envs, string[] logs, InternalAdapterDescriptor?[] adapters, InternalDbEnvDescriptor?[] dbEnvs, global::System.Collections.Generic.Dictionary<string, PropertyDescriptor[]> properties)
        {
            global::System.ArgumentNullException.ThrowIfNull(options);
            this.options = options;
            global::System.ArgumentNullException.ThrowIfNull(envs);
            this.envs = envs;
            global::System.ArgumentNullException.ThrowIfNull(logs);
            this.logs = logs;
            global::System.ArgumentNullException.ThrowIfNull(adapters);
            this.adapters = adapters;
            global::System.ArgumentNullException.ThrowIfNull(dbEnvs);
            this.dbEnvs = dbEnvs;
            global::System.ArgumentNullException.ThrowIfNull(properties);
            this.properties = properties;
            ice_initialize();
        }

        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public InternalServerDescriptor()
        {
            this.options = null!;
            this.envs = null!;
            this.logs = null!;
            this.adapters = null!;
            this.dbEnvs = null!;
            this.properties = null!;
            ice_initialize();
        }

        public static new string ice_staticId() => "::IceGrid::InternalServerDescriptor";
        public override string ice_id() => ice_staticId();

        protected override void iceWriteImpl(Ice.OutputStream ostr_)
        {
            ostr_.startSlice(ice_staticId(), -1, true);
            ostr_.writeString(id);
            ostr_.writeString(application);
            ostr_.writeString(uuid);
            ostr_.writeInt(revision);
            ostr_.writeString(sessionId);
            ostr_.writeString(exe);
            ostr_.writeString(pwd);
            ostr_.writeString(user);
            ostr_.writeString(activation);
            ostr_.writeString(activationTimeout);
            ostr_.writeString(deactivationTimeout);
            ostr_.writeBool(processRegistered);
            global::Ice.StringSeqHelper.write(ostr_, options);
            global::Ice.StringSeqHelper.write(ostr_, envs);
            global::Ice.StringSeqHelper.write(ostr_, logs);
            InternalAdapterDescriptorSeqHelper.write(ostr_, adapters);
            InternalDbEnvDescriptorSeqHelper.write(ostr_, dbEnvs);
            PropertyDescriptorSeqDictHelper.write(ostr_, properties);
            ostr_.writeStringSeq(1, services);
            ostr_.endSlice();
        }

        protected override void iceReadImpl(Ice.InputStream istr_)
        {
            istr_.startSlice();
            id = istr_.readString();
            application = istr_.readString();
            uuid = istr_.readString();
            revision = istr_.readInt();
            sessionId = istr_.readString();
            exe = istr_.readString();
            pwd = istr_.readString();
            user = istr_.readString();
            activation = istr_.readString();
            activationTimeout = istr_.readString();
            deactivationTimeout = istr_.readString();
            processRegistered = istr_.readBool();
            options = global::Ice.StringSeqHelper.read(istr_);
            envs = global::Ice.StringSeqHelper.read(istr_);
            logs = global::Ice.StringSeqHelper.read(istr_);
            adapters = InternalAdapterDescriptorSeqHelper.read(istr_);
            dbEnvs = InternalDbEnvDescriptorSeqHelper.read(istr_);
            properties = PropertyDescriptorSeqDictHelper.read(istr_);
            if (istr_.readOptional(1, Ice.OptionalFormat.FSize))
            {
                istr_.skip(4);
                string[] tmpVal;
                tmpVal = global::Ice.StringSeqHelper.read(istr_);
                services = tmpVal;
            }
            else
            {
                services = null;
            }
            istr_.endSlice();
        }
    }

    /// <summary>
    /// This exception is raised if an adapter is active.
    /// </summary>

    [Ice.SliceTypeId("::IceGrid::AdapterActiveException")]
    public partial class AdapterActiveException : Ice.UserException
    {
        public override string ice_id() => "::IceGrid::AdapterActiveException";

        protected override void iceWriteImpl(Ice.OutputStream ostr_)
        {
            ostr_.startSlice("::IceGrid::AdapterActiveException", -1, true);
            ostr_.endSlice();
        }

        protected override void iceReadImpl(Ice.InputStream istr_)
        {
            istr_.startSlice();
            istr_.endSlice();
        }
    }

    [Ice.SliceTypeId("::IceGrid::AdapterNotActiveException")]
    public partial class AdapterNotActiveException : Ice.UserException
    {
        public bool activatable;

        public AdapterNotActiveException(bool activatable)
        {
            this.activatable = activatable;
        }

        public AdapterNotActiveException()
        {
        }

        public override string ice_id() => "::IceGrid::AdapterNotActiveException";

        protected override void iceWriteImpl(Ice.OutputStream ostr_)
        {
            ostr_.startSlice("::IceGrid::AdapterNotActiveException", -1, true);
            ostr_.writeBool(activatable);
            ostr_.endSlice();
        }

        protected override void iceReadImpl(Ice.InputStream istr_)
        {
            istr_.startSlice();
            activatable = istr_.readBool();
            istr_.endSlice();
        }
    }

    [Ice.SliceTypeId("::IceGrid::Adapter")]
    public partial interface Adapter : Ice.Object
    {
        /// <summary>
        /// Activate this adapter.
        /// If this adapter can be activated, this will activate the adapter and return the direct
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<global::Ice.ObjectPrx?> activateAsync(Ice.Current current);

        /// <summary>
        /// Get the adapter direct proxy.
        /// The adapter direct proxy is a proxy created with the object adapter. The proxy
        ///  contains the last known adapter endpoints.
        /// </summary>
        ///  <returns>A direct proxy containing the last known adapter endpoints if the adapter is already active.</returns>
        /// <param name="current">The Current object for the dispatch.</param>

        global::Ice.ObjectPrx? getDirectProxy(Ice.Current current);

        /// <summary>
        /// Set the direct proxy for this adapter.
        /// </summary>
        /// <param name="The">direct proxy. The direct proxy should be created with the object adapter and should contain the
        ///  object adapter endpoints.
        ///  </param>
        /// <exception name="AdapterActiveException">The adapter is already active. It's not possible to override the direct proxy of
        ///  an active adapter.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        void setDirectProxy(global::Ice.ObjectPrx? proxy, Ice.Current current);
    }

    /// <summary>
    /// This exception is raised if an adapter with the same name already exists.
    /// </summary>

    [Ice.SliceTypeId("::IceGrid::AdapterExistsException")]
    public partial class AdapterExistsException : Ice.UserException
    {
        public string id = "";

        public AdapterExistsException(string id)
        {
            global::System.ArgumentNullException.ThrowIfNull(id);
            this.id = id;
        }

        public AdapterExistsException()
        {
        }

        public override string ice_id() => "::IceGrid::AdapterExistsException";

        protected override void iceWriteImpl(Ice.OutputStream ostr_)
        {
            ostr_.startSlice("::IceGrid::AdapterExistsException", -1, true);
            ostr_.writeString(id);
            ostr_.endSlice();
        }

        protected override void iceReadImpl(Ice.InputStream istr_)
        {
            istr_.startSlice();
            id = istr_.readString();
            istr_.endSlice();
        }
    }

    [Ice.SliceTypeId("::IceGrid::FileReader")]
    public partial interface FileReader : Ice.Object
    {
        /// <summary>
        /// Count the number of given lines from the end of the file and return the file offset.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        long getOffsetFromEnd(string filename, int lines, Ice.Current current);

        /// <summary>
        /// Read lines (or size bytes) at the specified position from the given file.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        bool read(string filename, long pos, int size, out long newPos, out string[] lines, Ice.Current current);
    }

    [Ice.SliceTypeId("::IceGrid::Server")]
    public partial interface Server : FileReader
    {
        /// <summary>
        /// Start the server.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task startAsync(Ice.Current current);

        /// <summary>
        /// Stop the server.
        /// This methods returns only when the server is deactivated. If the server doesn't stop after a
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task stopAsync(Ice.Current current);

        /// <summary>
        /// Check if the given server can be loaded on this node.
        /// </summary>
        /// <returns>True if the server is inactive.
        ///  </returns>
        /// <exception name="DeploymentException">Raised if the server can't be updated.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        bool checkUpdate(InternalServerDescriptor? svr, bool noRestart, Ice.Current current);

        /// <summary>
        /// Enable or disable the server.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        void setEnabled(bool enable, Ice.Current current);

        /// <summary>
        /// Check if the server is enabled.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        bool isEnabled(Ice.Current current);

        /// <summary>
        /// Send signal to the server
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        void sendSignal(string signal, Ice.Current current);

        /// <summary>
        /// Write message on servers' stdout or stderr.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        void writeMessage(string message, int fd, Ice.Current current);

        /// <summary>
        /// Return the server state.
        /// </summary>
        /// <returns>The server state.
        ///  </returns>
        /// <param name="current">The Current object for the dispatch.</param>

        ServerState getState(Ice.Current current);

        /// <summary>
        /// Get the server pid.
        /// Note that the value returned by this method is system dependant. On Unix operating systems,
        ///  it's the pid value returned by the fork() system call and converted to an integer.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        int getPid(Ice.Current current);

        /// <summary>
        /// Set the process proxy.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task setProcessAsync(global::Ice.ProcessPrx? proc, Ice.Current current);
    }

    [Ice.SliceTypeId("::IceGrid::ReplicaObserver")]
    public partial interface ReplicaObserver : Ice.Object
    {
        /// <summary>
        /// Initialization of the replica observer.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        void replicaInit(InternalRegistryPrx?[] replicas, Ice.Current current);

        /// <summary>
        /// Notification that a replica has been added.
        /// The node should establish a session with this new replica.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        void replicaAdded(InternalRegistryPrx? replica, Ice.Current current);

        /// <summary>
        /// Notification that a replica has been removed.
        /// The node should destroy the session to this replica.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        void replicaRemoved(InternalRegistryPrx? replica, Ice.Current current);
    }

    [Ice.SliceTypeId("::IceGrid::Node")]
    public partial interface Node : FileReader, ReplicaObserver
    {
        /// <summary>
        /// Load the given server.
        /// If the server resources weren't already created (database environment directories,
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<Node_LoadServerResult> loadServerAsync(InternalServerDescriptor? svr, string replicaName, Ice.Current current);

        /// <summary>
        /// Load the given server and ensure the server won't be restarted.
        /// If the server resources weren't already created
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<Node_LoadServerWithoutRestartResult> loadServerWithoutRestartAsync(InternalServerDescriptor? svr, string replicaName, Ice.Current current);

        /// <summary>
        /// Destroy the given server.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task destroyServerAsync(string name, string uuid, int revision, string replicaName, Ice.Current current);

        /// <summary>
        /// Destroy the server if it's not active.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task destroyServerWithoutRestartAsync(string name, string uuid, int revision, string replicaName, Ice.Current current);

        /// <summary>
        /// Establish a session to the given replica, this method only returns once the registration was attempted (unlike
        ///  replicaAdded below).
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        void registerWithReplica(InternalRegistryPrx? replica, Ice.Current current);

        /// <summary>
        /// Get the node name.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        string getName(Ice.Current current);

        /// <summary>
        /// Get the node hostname.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        string getHostname(Ice.Current current);

        /// <summary>
        /// Get the node load.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        LoadInfo getLoad(Ice.Current current);

        /// <summary>
        /// Get the number of processor sockets for the machine where this node is running.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        int getProcessorSocketCount(Ice.Current current);

        /// <summary>
        /// Shutdown the node.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        void shutdown(Ice.Current current);
    }

    /// <summary>
    /// This exception is raised if a node is already registered and active.
    /// </summary>

    [Ice.SliceTypeId("::IceGrid::NodeActiveException")]
    public partial class NodeActiveException : Ice.UserException
    {
        public override string ice_id() => "::IceGrid::NodeActiveException";

        protected override void iceWriteImpl(Ice.OutputStream ostr_)
        {
            ostr_.startSlice("::IceGrid::NodeActiveException", -1, true);
            ostr_.endSlice();
        }

        protected override void iceReadImpl(Ice.InputStream istr_)
        {
            istr_.startSlice();
            istr_.endSlice();
        }
    }

    [Ice.SliceTypeId("::IceGrid::NodeSession")]
    public partial interface NodeSession : Ice.Object
    {
        /// <summary>
        /// The node call this method to keep the session alive.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        void keepAlive(LoadInfo load, Ice.Current current);

        /// <summary>
        /// Set the replica observer.
        /// The node calls this method when it's ready to receive notifications for the replicas.
        ///  It only calls this for the session with the master.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        void setReplicaObserver(ReplicaObserverPrx? observer, Ice.Current current);

        /// <summary>
        /// Return the node session timeout.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        int getTimeout(Ice.Current current);

        /// <summary>
        /// Return the node observer.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        NodeObserverPrx? getObserver(Ice.Current current);

        /// <summary>
        /// Ask the registry to load the servers on the node.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task loadServersAsync(Ice.Current current);

        /// <summary>
        /// Get the name of the servers deployed on the node.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        string[] getServers(Ice.Current current);

        /// <summary>
        /// Wait for the application update to complete (the application is completely updated once all the registry
        ///  replicas have been updated).
        /// This is used by the node to ensure that before to start a server all the
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task waitForApplicationUpdateAsync(string application, int revision, Ice.Current current);

        /// <summary>
        /// Destroy the session.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        void destroy(Ice.Current current);
    }

    /// <summary>
    /// This exception is raised if a replica is already registered and active.
    /// </summary>

    [Ice.SliceTypeId("::IceGrid::ReplicaActiveException")]
    public partial class ReplicaActiveException : Ice.UserException
    {
        public override string ice_id() => "::IceGrid::ReplicaActiveException";

        protected override void iceWriteImpl(Ice.OutputStream ostr_)
        {
            ostr_.startSlice("::IceGrid::ReplicaActiveException", -1, true);
            ostr_.endSlice();
        }

        protected override void iceReadImpl(Ice.InputStream istr_)
        {
            istr_.startSlice();
            istr_.endSlice();
        }
    }

    public enum TopicName
    {
        RegistryObserver,
        NodeObserver,
        ApplicationObserver,
        AdapterObserver,
        ObjectObserver
    }

    public sealed class TopicNameHelper
    {
        public static void write(Ice.OutputStream ostr, TopicName v)
        {
            ostr.writeEnum((int)v, 4);
        }

        public static TopicName read(Ice.InputStream istr)
        {
            TopicName v;
            v = (TopicName)istr.readEnum(4);
            return v;
        }
    }

    [Ice.SliceTypeId("::IceGrid::DatabaseObserver")]
    public partial interface DatabaseObserver : ApplicationObserver, ObjectObserver, AdapterObserver
    {
    }

    [Ice.SliceTypeId("::IceGrid::ReplicaSession")]
    public partial interface ReplicaSession : Ice.Object
    {
        /// <summary>
        /// The replica call this method to keep the session alive.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        void keepAlive(Ice.Current current);

        /// <summary>
        /// Return the replica session timeout.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        int getTimeout(Ice.Current current);

        /// <summary>
        /// Set the database observer.
        /// Once the observer is subscribed, it will receive the database and database updates.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        void setDatabaseObserver(DatabaseObserverPrx? dbObs, global::System.Collections.Generic.Dictionary<string, long>? serials, Ice.Current current);

        /// <summary>
        /// This method sets the endpoints of the replica.
        /// This allows the master to create proxies with multiple endpoints
        ///  for replicated objects (e.g.: IceGrid::Query object).
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        void setEndpoints(global::System.Collections.Generic.Dictionary<string, global::Ice.ObjectPrx?> endpoints, Ice.Current current);

        /// <summary>
        /// Registers the replica well-known objects with the master.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        void registerWellKnownObjects(ObjectInfo[] objects, Ice.Current current);

        /// <summary>
        /// Set the adapter direct proxy of the given adapter in the master.
        /// This is used to support dynamic registration
        ///  with the locator registry interface.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        void setAdapterDirectProxy(string adapterId, string replicaGroupId, global::Ice.ObjectPrx? proxy, Ice.Current current);

        /// <summary>
        /// Notify the master that an update was received.
        /// The master might wait for replication updates to be received by
        ///  all the replicas before to continue.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        void receivedUpdate(TopicName name, int serial, string failure, Ice.Current current);

        /// <summary>
        /// Destroy the session.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        void destroy(Ice.Current current);
    }

    [Ice.SliceTypeId("::IceGrid::InternalNodeInfo")]
    public partial class InternalNodeInfo : Ice.Value
    {
        public string name = "";

        public string os = "";

        public string hostname = "";

        public string release = "";

        public string version = "";

        public string machine = "";

        public int nProcessors;

        public string dataDir = "";

        partial void ice_initialize();

        public InternalNodeInfo(string name, string os, string hostname, string release, string version, string machine, int nProcessors, string dataDir)
        {
            global::System.ArgumentNullException.ThrowIfNull(name);
            this.name = name;
            global::System.ArgumentNullException.ThrowIfNull(os);
            this.os = os;
            global::System.ArgumentNullException.ThrowIfNull(hostname);
            this.hostname = hostname;
            global::System.ArgumentNullException.ThrowIfNull(release);
            this.release = release;
            global::System.ArgumentNullException.ThrowIfNull(version);
            this.version = version;
            global::System.ArgumentNullException.ThrowIfNull(machine);
            this.machine = machine;
            this.nProcessors = nProcessors;
            global::System.ArgumentNullException.ThrowIfNull(dataDir);
            this.dataDir = dataDir;
            ice_initialize();
        }

        public InternalNodeInfo()
        {
            ice_initialize();
        }

        public static new string ice_staticId() => "::IceGrid::InternalNodeInfo";
        public override string ice_id() => ice_staticId();

        protected override void iceWriteImpl(Ice.OutputStream ostr_)
        {
            ostr_.startSlice(ice_staticId(), -1, true);
            ostr_.writeString(name);
            ostr_.writeString(os);
            ostr_.writeString(hostname);
            ostr_.writeString(release);
            ostr_.writeString(version);
            ostr_.writeString(machine);
            ostr_.writeInt(nProcessors);
            ostr_.writeString(dataDir);
            ostr_.endSlice();
        }

        protected override void iceReadImpl(Ice.InputStream istr_)
        {
            istr_.startSlice();
            name = istr_.readString();
            os = istr_.readString();
            hostname = istr_.readString();
            release = istr_.readString();
            version = istr_.readString();
            machine = istr_.readString();
            nProcessors = istr_.readInt();
            dataDir = istr_.readString();
            istr_.endSlice();
        }
    }

    [Ice.SliceTypeId("::IceGrid::InternalReplicaInfo")]
    public partial class InternalReplicaInfo : Ice.Value
    {
        public string name = "";

        public string hostname = "";

        partial void ice_initialize();

        public InternalReplicaInfo(string name, string hostname)
        {
            global::System.ArgumentNullException.ThrowIfNull(name);
            this.name = name;
            global::System.ArgumentNullException.ThrowIfNull(hostname);
            this.hostname = hostname;
            ice_initialize();
        }

        public InternalReplicaInfo()
        {
            ice_initialize();
        }

        public static new string ice_staticId() => "::IceGrid::InternalReplicaInfo";
        public override string ice_id() => ice_staticId();

        protected override void iceWriteImpl(Ice.OutputStream ostr_)
        {
            ostr_.startSlice(ice_staticId(), -1, true);
            ostr_.writeString(name);
            ostr_.writeString(hostname);
            ostr_.endSlice();
        }

        protected override void iceReadImpl(Ice.InputStream istr_)
        {
            istr_.startSlice();
            name = istr_.readString();
            hostname = istr_.readString();
            istr_.endSlice();
        }
    }

    [Ice.SliceTypeId("::IceGrid::InternalRegistry")]
    public partial interface InternalRegistry : FileReader
    {
        /// <summary>
        /// Register a node with the registry.
        /// If a node with the same name is already registered,
        ///  registerNode overrides the existing registration only when the previously
        ///  registered node is not active.
        /// </summary>
        ///  <param name="info">Some information on the node.
        ///  </param>
        /// <param name="prx">The proxy of the node.
        ///  </param>
        /// <param name="loadInf">The load information of the node.
        ///  </param>
        /// <returns>The node session proxy.
        ///  </returns>
        /// <exception name="NodeActiveException">Raised if the node is already registered and currently active.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        NodeSessionPrx? registerNode(InternalNodeInfo? info, NodePrx? prx, LoadInfo loadInf, Ice.Current current);

        /// <summary>
        /// Register a replica with the registry.
        /// If a replica with the same name is already registered,
        ///  registerReplica overrides the existing registration only when the previously
        ///  registered node is not active.
        /// </summary>
        ///  <param name="info">Some information on the replica.
        ///  </param>
        /// <param name="prx">The proxy of the replica.
        ///  </param>
        /// <returns>The replica session proxy.
        ///  </returns>
        /// <exception name="ReplicaActiveException">Raised if the replica is already registered and currently active.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        ReplicaSessionPrx? registerReplica(InternalReplicaInfo? info, InternalRegistryPrx? prx, Ice.Current current);

        /// <summary>
        /// Create a session with the given registry replica.
        /// This method returns only once the session creation has been
        ///  attempted.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        void registerWithReplica(InternalRegistryPrx? prx, Ice.Current current);

        /// <summary>
        /// Return the proxies of all the nodes known by this registry.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        NodePrx?[] getNodes(Ice.Current current);

        /// <summary>
        /// Return the proxies of all the registry replicas known by this registry.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        InternalRegistryPrx?[] getReplicas(Ice.Current current);

        /// <summary>
        /// Return applications, adapters, objects from this replica.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        ApplicationInfo[] getApplications(out long serial, Ice.Current current);

        AdapterInfo[] getAdapters(out long serial, Ice.Current current);

        ObjectInfo[] getObjects(out long serial, Ice.Current current);

        /// <summary>
        /// Shutdown this registry.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        void shutdown(Ice.Current current);
    }
}

namespace IceGrid
{
    public record struct FileReader_ReadResult(bool returnValue, long newPos, string[] lines);

    public record struct Node_LoadServerResult(ServerPrx? returnValue, global::System.Collections.Generic.Dictionary<string, AdapterPrx?> adapters, int activateTimeout, int deactivateTimeout);

    public record struct Node_LoadServerWithoutRestartResult(ServerPrx? returnValue, global::System.Collections.Generic.Dictionary<string, AdapterPrx?> adapters, int activateTimeout, int deactivateTimeout);

    public record struct InternalRegistry_GetApplicationsResult(ApplicationInfo[] returnValue, long serial);

    public record struct InternalRegistry_GetAdaptersResult(AdapterInfo[] returnValue, long serial);

    public record struct InternalRegistry_GetObjectsResult(ObjectInfo[] returnValue, long serial);
}

namespace IceGrid
{
    public interface AdapterPrx : Ice.ObjectPrx
    {
        /// <summary>
        /// Activate this adapter.
        /// If this adapter can be activated, this will activate the adapter and return the direct
        ///  proxy of the adapter once it's active. If this adapter can be activated on demand, this will return 0 if the
        ///  adapter is inactive or the adapter direct proxy it's active.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        global::Ice.ObjectPrx? activate(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Activate this adapter.
        /// If this adapter can be activated, this will activate the adapter and return the direct
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<global::Ice.ObjectPrx?> activateAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get the adapter direct proxy.
        /// The adapter direct proxy is a proxy created with the object adapter. The proxy
        ///  contains the last known adapter endpoints.
        /// </summary>
        ///  <returns>A direct proxy containing the last known adapter endpoints if the adapter is already active.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        global::Ice.ObjectPrx? getDirectProxy(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get the adapter direct proxy.
        /// The adapter direct proxy is a proxy created with the object adapter. The proxy
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<global::Ice.ObjectPrx?> getDirectProxyAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Set the direct proxy for this adapter.
        /// </summary>
        /// <param name="The">direct proxy. The direct proxy should be created with the object adapter and should contain the
        ///  object adapter endpoints.
        ///  </param>
        /// <exception name="AdapterActiveException">The adapter is already active. It's not possible to override the direct proxy of
        ///  an active adapter.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void setDirectProxy(global::Ice.ObjectPrx? proxy, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Set the direct proxy for this adapter.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task setDirectProxyAsync(global::Ice.ObjectPrx? proxy, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }

    public interface FileReaderPrx : Ice.ObjectPrx
    {
        /// <summary>
        /// Count the number of given lines from the end of the file and return the file offset.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        long getOffsetFromEnd(string filename, int lines, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Count the number of given lines from the end of the file and return the file offset.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<long> getOffsetFromEndAsync(string filename, int lines, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Read lines (or size bytes) at the specified position from the given file.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        bool read(string filename, long pos, int size, out long newPos, out string[] lines, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Read lines (or size bytes) at the specified position from the given file.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<FileReader_ReadResult> readAsync(string filename, long pos, int size, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }

    public interface ServerPrx : FileReaderPrx
    {
        /// <summary>
        /// Start the server.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void start(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Start the server.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task startAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Stop the server.
        /// This methods returns only when the server is deactivated. If the server doesn't stop after a
        ///  configurable amount of time, it will be killed.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void stop(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Stop the server.
        /// This methods returns only when the server is deactivated. If the server doesn't stop after a
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task stopAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Check if the given server can be loaded on this node.
        /// </summary>
        /// <returns>True if the server is inactive.
        ///  </returns>
        /// <exception name="DeploymentException">Raised if the server can't be updated.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        bool checkUpdate(InternalServerDescriptor? svr, bool noRestart, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Check if the given server can be loaded on this node.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<bool> checkUpdateAsync(InternalServerDescriptor? svr, bool noRestart, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Enable or disable the server.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void setEnabled(bool enable, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Enable or disable the server.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task setEnabledAsync(bool enable, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Check if the server is enabled.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        bool isEnabled(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Check if the server is enabled.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<bool> isEnabledAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Send signal to the server
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void sendSignal(string signal, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Send signal to the server
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task sendSignalAsync(string signal, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Write message on servers' stdout or stderr.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void writeMessage(string message, int fd, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Write message on servers' stdout or stderr.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task writeMessageAsync(string message, int fd, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Return the server state.
        /// </summary>
        /// <returns>The server state.
        ///  </returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        ServerState getState(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Return the server state.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<ServerState> getStateAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get the server pid.
        /// Note that the value returned by this method is system dependant. On Unix operating systems,
        ///  it's the pid value returned by the fork() system call and converted to an integer.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        int getPid(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get the server pid.
        /// Note that the value returned by this method is system dependant. On Unix operating systems,
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<int> getPidAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Set the process proxy.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void setProcess(global::Ice.ProcessPrx? proc, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Set the process proxy.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task setProcessAsync(global::Ice.ProcessPrx? proc, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }

    public interface ReplicaObserverPrx : Ice.ObjectPrx
    {
        /// <summary>
        /// Initialization of the replica observer.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void replicaInit(InternalRegistryPrx?[] replicas, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Initialization of the replica observer.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task replicaInitAsync(InternalRegistryPrx?[] replicas, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Notification that a replica has been added.
        /// The node should establish a session with this new replica.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void replicaAdded(InternalRegistryPrx? replica, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Notification that a replica has been added.
        /// The node should establish a session with this new replica.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task replicaAddedAsync(InternalRegistryPrx? replica, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Notification that a replica has been removed.
        /// The node should destroy the session to this replica.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void replicaRemoved(InternalRegistryPrx? replica, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Notification that a replica has been removed.
        /// The node should destroy the session to this replica.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task replicaRemovedAsync(InternalRegistryPrx? replica, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }

    public interface NodePrx : FileReaderPrx, ReplicaObserverPrx
    {
        /// <summary>
        /// Load the given server.
        /// If the server resources weren't already created (database environment directories,
        ///  property files, etc), they will be created. The returned proxy is never null.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        ServerPrx? loadServer(InternalServerDescriptor? svr, string replicaName, out global::System.Collections.Generic.Dictionary<string, AdapterPrx?> adapters, out int activateTimeout, out int deactivateTimeout, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Load the given server.
        /// If the server resources weren't already created (database environment directories,
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<Node_LoadServerResult> loadServerAsync(InternalServerDescriptor? svr, string replicaName, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Load the given server and ensure the server won't be restarted.
        /// If the server resources weren't already created
        ///  (database environment directories, property files, etc), they will be created. If the server can't be updated
        ///  without a restart, a DeploymentException is raised. The returned proxy is never null.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        ServerPrx? loadServerWithoutRestart(InternalServerDescriptor? svr, string replicaName, out global::System.Collections.Generic.Dictionary<string, AdapterPrx?> adapters, out int activateTimeout, out int deactivateTimeout, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Load the given server and ensure the server won't be restarted.
        /// If the server resources weren't already created
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<Node_LoadServerWithoutRestartResult> loadServerWithoutRestartAsync(InternalServerDescriptor? svr, string replicaName, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Destroy the given server.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void destroyServer(string name, string uuid, int revision, string replicaName, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Destroy the given server.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task destroyServerAsync(string name, string uuid, int revision, string replicaName, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Destroy the server if it's not active.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void destroyServerWithoutRestart(string name, string uuid, int revision, string replicaName, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Destroy the server if it's not active.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task destroyServerWithoutRestartAsync(string name, string uuid, int revision, string replicaName, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Establish a session to the given replica, this method only returns once the registration was attempted (unlike
        ///  replicaAdded below).
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void registerWithReplica(InternalRegistryPrx? replica, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Establish a session to the given replica, this method only returns once the registration was attempted (unlike
        ///  replicaAdded below).
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task registerWithReplicaAsync(InternalRegistryPrx? replica, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get the node name.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        string getName(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get the node name.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<string> getNameAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get the node hostname.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        string getHostname(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get the node hostname.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<string> getHostnameAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get the node load.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        LoadInfo getLoad(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get the node load.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<LoadInfo> getLoadAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get the number of processor sockets for the machine where this node is running.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        int getProcessorSocketCount(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get the number of processor sockets for the machine where this node is running.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<int> getProcessorSocketCountAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Shutdown the node.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void shutdown(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Shutdown the node.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task shutdownAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }

    public interface NodeSessionPrx : Ice.ObjectPrx
    {
        /// <summary>
        /// The node call this method to keep the session alive.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void keepAlive(LoadInfo load, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// The node call this method to keep the session alive.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task keepAliveAsync(LoadInfo load, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Set the replica observer.
        /// The node calls this method when it's ready to receive notifications for the replicas.
        ///  It only calls this for the session with the master.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void setReplicaObserver(ReplicaObserverPrx? observer, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Set the replica observer.
        /// The node calls this method when it's ready to receive notifications for the replicas.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task setReplicaObserverAsync(ReplicaObserverPrx? observer, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Return the node session timeout.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        int getTimeout(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Return the node session timeout.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<int> getTimeoutAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Return the node observer.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        NodeObserverPrx? getObserver(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Return the node observer.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<NodeObserverPrx?> getObserverAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Ask the registry to load the servers on the node.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void loadServers(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Ask the registry to load the servers on the node.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task loadServersAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get the name of the servers deployed on the node.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        string[] getServers(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get the name of the servers deployed on the node.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<string[]> getServersAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Wait for the application update to complete (the application is completely updated once all the registry
        ///  replicas have been updated).
        /// This is used by the node to ensure that before to start a server all the
        ///  replicas have the up-to-date descriptor of the server.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void waitForApplicationUpdate(string application, int revision, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Wait for the application update to complete (the application is completely updated once all the registry
        ///  replicas have been updated).
        /// This is used by the node to ensure that before to start a server all the
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task waitForApplicationUpdateAsync(string application, int revision, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Destroy the session.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void destroy(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Destroy the session.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task destroyAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }

    public interface DatabaseObserverPrx : ApplicationObserverPrx, ObjectObserverPrx, AdapterObserverPrx
    {
    }

    public interface ReplicaSessionPrx : Ice.ObjectPrx
    {
        /// <summary>
        /// The replica call this method to keep the session alive.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void keepAlive(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// The replica call this method to keep the session alive.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task keepAliveAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Return the replica session timeout.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        int getTimeout(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Return the replica session timeout.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<int> getTimeoutAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Set the database observer.
        /// Once the observer is subscribed, it will receive the database and database updates.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void setDatabaseObserver(DatabaseObserverPrx? dbObs, global::System.Collections.Generic.Dictionary<string, long>? serials, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Set the database observer.
        /// Once the observer is subscribed, it will receive the database and database updates.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task setDatabaseObserverAsync(DatabaseObserverPrx? dbObs, global::System.Collections.Generic.Dictionary<string, long>? serials, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// This method sets the endpoints of the replica.
        /// This allows the master to create proxies with multiple endpoints
        ///  for replicated objects (e.g.: IceGrid::Query object).
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void setEndpoints(global::System.Collections.Generic.Dictionary<string, global::Ice.ObjectPrx?> endpoints, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// This method sets the endpoints of the replica.
        /// This allows the master to create proxies with multiple endpoints
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task setEndpointsAsync(global::System.Collections.Generic.Dictionary<string, global::Ice.ObjectPrx?> endpoints, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Registers the replica well-known objects with the master.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void registerWellKnownObjects(ObjectInfo[] objects, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Registers the replica well-known objects with the master.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task registerWellKnownObjectsAsync(ObjectInfo[] objects, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Set the adapter direct proxy of the given adapter in the master.
        /// This is used to support dynamic registration
        ///  with the locator registry interface.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void setAdapterDirectProxy(string adapterId, string replicaGroupId, global::Ice.ObjectPrx? proxy, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Set the adapter direct proxy of the given adapter in the master.
        /// This is used to support dynamic registration
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task setAdapterDirectProxyAsync(string adapterId, string replicaGroupId, global::Ice.ObjectPrx? proxy, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Notify the master that an update was received.
        /// The master might wait for replication updates to be received by
        ///  all the replicas before to continue.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void receivedUpdate(TopicName name, int serial, string failure, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Notify the master that an update was received.
        /// The master might wait for replication updates to be received by
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task receivedUpdateAsync(TopicName name, int serial, string failure, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Destroy the session.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void destroy(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Destroy the session.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task destroyAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }

    public interface InternalRegistryPrx : FileReaderPrx
    {
        /// <summary>
        /// Register a node with the registry.
        /// If a node with the same name is already registered,
        ///  registerNode overrides the existing registration only when the previously
        ///  registered node is not active.
        /// </summary>
        ///  <param name="info">Some information on the node.
        ///  </param>
        /// <param name="prx">The proxy of the node.
        ///  </param>
        /// <param name="loadInf">The load information of the node.
        ///  </param>
        /// <returns>The node session proxy.
        ///  </returns>
        /// <exception name="NodeActiveException">Raised if the node is already registered and currently active.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        NodeSessionPrx? registerNode(InternalNodeInfo? info, NodePrx? prx, LoadInfo loadInf, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Register a node with the registry.
        /// If a node with the same name is already registered,
        /// </summary>
        ///  <param name="info">Some information on the node.
        ///  </param>
        /// <param name="prx">The proxy of the node.
        ///  </param>
        /// <param name="loadInf">The load information of the node.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<NodeSessionPrx?> registerNodeAsync(InternalNodeInfo? info, NodePrx? prx, LoadInfo loadInf, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Register a replica with the registry.
        /// If a replica with the same name is already registered,
        ///  registerReplica overrides the existing registration only when the previously
        ///  registered node is not active.
        /// </summary>
        ///  <param name="info">Some information on the replica.
        ///  </param>
        /// <param name="prx">The proxy of the replica.
        ///  </param>
        /// <returns>The replica session proxy.
        ///  </returns>
        /// <exception name="ReplicaActiveException">Raised if the replica is already registered and currently active.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        ReplicaSessionPrx? registerReplica(InternalReplicaInfo? info, InternalRegistryPrx? prx, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Register a replica with the registry.
        /// If a replica with the same name is already registered,
        /// </summary>
        ///  <param name="info">Some information on the replica.
        ///  </param>
        /// <param name="prx">The proxy of the replica.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<ReplicaSessionPrx?> registerReplicaAsync(InternalReplicaInfo? info, InternalRegistryPrx? prx, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Create a session with the given registry replica.
        /// This method returns only once the session creation has been
        ///  attempted.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void registerWithReplica(InternalRegistryPrx? prx, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Create a session with the given registry replica.
        /// This method returns only once the session creation has been
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task registerWithReplicaAsync(InternalRegistryPrx? prx, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Return the proxies of all the nodes known by this registry.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        NodePrx?[] getNodes(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Return the proxies of all the nodes known by this registry.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<NodePrx?[]> getNodesAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Return the proxies of all the registry replicas known by this registry.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        InternalRegistryPrx?[] getReplicas(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Return the proxies of all the registry replicas known by this registry.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<InternalRegistryPrx?[]> getReplicasAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Return applications, adapters, objects from this replica.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        ApplicationInfo[] getApplications(out long serial, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Return applications, adapters, objects from this replica.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<InternalRegistry_GetApplicationsResult> getApplicationsAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        AdapterInfo[] getAdapters(out long serial, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        global::System.Threading.Tasks.Task<InternalRegistry_GetAdaptersResult> getAdaptersAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        ObjectInfo[] getObjects(out long serial, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        global::System.Threading.Tasks.Task<InternalRegistry_GetObjectsResult> getObjectsAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Shutdown this registry.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void shutdown(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Shutdown this registry.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task shutdownAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }
}

namespace IceGrid
{
    public sealed class InternalDbEnvDescriptorSeqHelper
    {
        public static void write(Ice.OutputStream ostr, InternalDbEnvDescriptor?[] v)
        {
            if (v is null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    ostr.writeValue(v[ix]);
                }
            }
        }

        public static InternalDbEnvDescriptor?[] read(Ice.InputStream istr)
        {
            InternalDbEnvDescriptor?[] v;
            {
                int szx = istr.readAndCheckSeqSize(1);
                v = new InternalDbEnvDescriptor?[szx];
                for (int ix = 0; ix < szx; ++ix)
                {
                    istr.readValue(Ice.Internal.Patcher.arrayReadValue<InternalDbEnvDescriptor>(v, ix));
                }
            }
            return v;
        }
    }

    public sealed class InternalAdapterDescriptorSeqHelper
    {
        public static void write(Ice.OutputStream ostr, InternalAdapterDescriptor?[] v)
        {
            if (v is null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    ostr.writeValue(v[ix]);
                }
            }
        }

        public static InternalAdapterDescriptor?[] read(Ice.InputStream istr)
        {
            InternalAdapterDescriptor?[] v;
            {
                int szx = istr.readAndCheckSeqSize(1);
                v = new InternalAdapterDescriptor?[szx];
                for (int ix = 0; ix < szx; ++ix)
                {
                    istr.readValue(Ice.Internal.Patcher.arrayReadValue<InternalAdapterDescriptor>(v, ix));
                }
            }
            return v;
        }
    }

    public sealed class PropertyDescriptorSeqDictHelper
    {
        public static void write(Ice.OutputStream ostr,
                                 global::System.Collections.Generic.Dictionary<string, PropertyDescriptor[]> v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Count);
                foreach(global::System.Collections.Generic.KeyValuePair<string, PropertyDescriptor[]> e in v)
                {
                    ostr.writeString(e.Key);
                    PropertyDescriptorSeqHelper.write(ostr, e.Value);
                }
            }
        }

        public static global::System.Collections.Generic.Dictionary<string, PropertyDescriptor[]> read(Ice.InputStream istr)
        {
            int sz = istr.readSize();
            global::System.Collections.Generic.Dictionary<string, PropertyDescriptor[]> r = new global::System.Collections.Generic.Dictionary<string, PropertyDescriptor[]>();
            for(int i = 0; i < sz; ++i)
            {
                string k;
                k = istr.readString();
                PropertyDescriptor[] v;
                v = PropertyDescriptorSeqHelper.read(istr);
                r[k] = v;
            }
            return r;
        }
    }

    public sealed class AdapterPrxHelper : Ice.ObjectPrxHelperBase, AdapterPrx
    {
        public global::Ice.ObjectPrx? activate(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_activateAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::Ice.ObjectPrx? getDirectProxy(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getDirectProxyAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void setDirectProxy(global::Ice.ObjectPrx? proxy, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_setDirectProxyAsync(proxy, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task<global::Ice.ObjectPrx?> activateAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_activateAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<global::Ice.ObjectPrx?> _iceI_activateAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_activate_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<global::Ice.ObjectPrx?>(progress, cancel);
            _iceI_activate(context, synchronous, completed);
            return completed.Task;
        }

        private const string _activate_name = "activate";

        private void _iceI_activate(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<global::Ice.ObjectPrx?>(completed);
            outAsync.invoke(
                _activate_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    global::Ice.ObjectPrx? ret;
                    ret = istr.readProxy();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<global::Ice.ObjectPrx?> getDirectProxyAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getDirectProxyAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<global::Ice.ObjectPrx?> _iceI_getDirectProxyAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getDirectProxy_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<global::Ice.ObjectPrx?>(progress, cancel);
            _iceI_getDirectProxy(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getDirectProxy_name = "getDirectProxy";

        private void _iceI_getDirectProxy(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<global::Ice.ObjectPrx?>(completed);
            outAsync.invoke(
                _getDirectProxy_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(AdapterNotActiveException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    global::Ice.ObjectPrx? ret;
                    ret = istr.readProxy();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task setDirectProxyAsync(global::Ice.ObjectPrx? proxy, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_setDirectProxyAsync(proxy, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_setDirectProxyAsync(global::Ice.ObjectPrx? iceP_proxy, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_setDirectProxy_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_setDirectProxy(iceP_proxy, context, synchronous, completed);
            return completed.Task;
        }

        private const string _setDirectProxy_name = "setDirectProxy";

        private void _iceI_setDirectProxy(global::Ice.ObjectPrx? iceP_proxy, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _setDirectProxy_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeProxy(iceP_proxy);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(AdapterActiveException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public static AdapterPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new AdapterPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static AdapterPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new AdapterPrxHelper(b) : null;

        public static AdapterPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static AdapterPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new AdapterPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static AdapterPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::Adapter"
        };

        public static string ice_staticId() => "::IceGrid::Adapter";

        public static void write(Ice.OutputStream ostr, AdapterPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static AdapterPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new AdapterPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new AdapterPrxHelper(reference);

        private AdapterPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private AdapterPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }

    public sealed class AdapterPrxDictHelper
    {
        public static void write(Ice.OutputStream ostr,
                                 global::System.Collections.Generic.Dictionary<string, AdapterPrx?> v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Count);
                foreach(global::System.Collections.Generic.KeyValuePair<string, AdapterPrx?> e in v)
                {
                    ostr.writeString(e.Key);
                    AdapterPrxHelper.write(ostr, e.Value);
                }
            }
        }

        public static global::System.Collections.Generic.Dictionary<string, AdapterPrx?> read(Ice.InputStream istr)
        {
            int sz = istr.readSize();
            global::System.Collections.Generic.Dictionary<string, AdapterPrx?> r = new global::System.Collections.Generic.Dictionary<string, AdapterPrx?>();
            for(int i = 0; i < sz; ++i)
            {
                string k;
                k = istr.readString();
                AdapterPrx? v;
                v = AdapterPrxHelper.read(istr);
                r[k] = v;
            }
            return r;
        }
    }

    public sealed class FileReaderPrxHelper : Ice.ObjectPrxHelperBase, FileReaderPrx
    {
        public long getOffsetFromEnd(string filename, int lines, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getOffsetFromEndAsync(filename, lines, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public bool read(string filename, long pos, int size, out long newPos, out string[] lines, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                var result_ = _iceI_readAsync(filename, pos, size, context, null, global::System.Threading.CancellationToken.None, true).Result;
                newPos = result_.newPos;
                lines = result_.lines;
                return result_.returnValue;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task<long> getOffsetFromEndAsync(string filename, int lines, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getOffsetFromEndAsync(filename, lines, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<long> _iceI_getOffsetFromEndAsync(string iceP_filename, int iceP_lines, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getOffsetFromEnd_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<long>(progress, cancel);
            _iceI_getOffsetFromEnd(iceP_filename, iceP_lines, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getOffsetFromEnd_name = "getOffsetFromEnd";

        private void _iceI_getOffsetFromEnd(string iceP_filename, int iceP_lines, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<long>(completed);
            outAsync.invoke(
                _getOffsetFromEnd_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_filename);
                    ostr.writeInt(iceP_lines);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(FileNotAvailableException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    long ret;
                    ret = istr.readLong();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<FileReader_ReadResult> readAsync(string filename, long pos, int size, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_readAsync(filename, pos, size, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<FileReader_ReadResult> _iceI_readAsync(string iceP_filename, long iceP_pos, int iceP_size, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_read_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<FileReader_ReadResult>(progress, cancel);
            _iceI_read(iceP_filename, iceP_pos, iceP_size, context, synchronous, completed);
            return completed.Task;
        }

        private const string _read_name = "read";

        private void _iceI_read(string iceP_filename, long iceP_pos, int iceP_size, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<FileReader_ReadResult>(completed);
            outAsync.invoke(
                _read_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_filename);
                    ostr.writeLong(iceP_pos);
                    ostr.writeInt(iceP_size);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(FileNotAvailableException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    var ret = new FileReader_ReadResult();
                    ret.newPos = istr.readLong();
                    ret.lines = global::Ice.StringSeqHelper.read(istr);
                    ret.returnValue = istr.readBool();
                    return ret;
                });
        }

        public static FileReaderPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new FileReaderPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static FileReaderPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new FileReaderPrxHelper(b) : null;

        public static FileReaderPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static FileReaderPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new FileReaderPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static FileReaderPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::FileReader"
        };

        public static string ice_staticId() => "::IceGrid::FileReader";

        public static void write(Ice.OutputStream ostr, FileReaderPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static FileReaderPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new FileReaderPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new FileReaderPrxHelper(reference);

        private FileReaderPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private FileReaderPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }

    public sealed class ServerPrxHelper : Ice.ObjectPrxHelperBase, ServerPrx
    {
        public long getOffsetFromEnd(string filename, int lines, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getOffsetFromEndAsync(filename, lines, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public bool read(string filename, long pos, int size, out long newPos, out string[] lines, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                var result_ = _iceI_readAsync(filename, pos, size, context, null, global::System.Threading.CancellationToken.None, true).Result;
                newPos = result_.newPos;
                lines = result_.lines;
                return result_.returnValue;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void start(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_startAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void stop(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_stopAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public bool checkUpdate(InternalServerDescriptor? svr, bool noRestart, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_checkUpdateAsync(svr, noRestart, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void setEnabled(bool enable, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_setEnabledAsync(enable, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public bool isEnabled(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_isEnabledAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void sendSignal(string signal, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_sendSignalAsync(signal, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void writeMessage(string message, int fd, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_writeMessageAsync(message, fd, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public ServerState getState(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getStateAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public int getPid(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getPidAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void setProcess(global::Ice.ProcessPrx? proc, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_setProcessAsync(proc, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task<long> getOffsetFromEndAsync(string filename, int lines, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getOffsetFromEndAsync(filename, lines, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<long> _iceI_getOffsetFromEndAsync(string iceP_filename, int iceP_lines, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getOffsetFromEnd_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<long>(progress, cancel);
            _iceI_getOffsetFromEnd(iceP_filename, iceP_lines, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getOffsetFromEnd_name = "getOffsetFromEnd";

        private void _iceI_getOffsetFromEnd(string iceP_filename, int iceP_lines, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<long>(completed);
            outAsync.invoke(
                _getOffsetFromEnd_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_filename);
                    ostr.writeInt(iceP_lines);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(FileNotAvailableException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    long ret;
                    ret = istr.readLong();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<FileReader_ReadResult> readAsync(string filename, long pos, int size, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_readAsync(filename, pos, size, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<FileReader_ReadResult> _iceI_readAsync(string iceP_filename, long iceP_pos, int iceP_size, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_read_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<FileReader_ReadResult>(progress, cancel);
            _iceI_read(iceP_filename, iceP_pos, iceP_size, context, synchronous, completed);
            return completed.Task;
        }

        private const string _read_name = "read";

        private void _iceI_read(string iceP_filename, long iceP_pos, int iceP_size, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<FileReader_ReadResult>(completed);
            outAsync.invoke(
                _read_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_filename);
                    ostr.writeLong(iceP_pos);
                    ostr.writeInt(iceP_size);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(FileNotAvailableException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    var ret = new FileReader_ReadResult();
                    ret.newPos = istr.readLong();
                    ret.lines = global::Ice.StringSeqHelper.read(istr);
                    ret.returnValue = istr.readBool();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task startAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_startAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_startAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_start_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_start(context, synchronous, completed);
            return completed.Task;
        }

        private const string _start_name = "start";

        private void _iceI_start(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _start_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ServerStartException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task stopAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_stopAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_stopAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_stop_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_stop(context, synchronous, completed);
            return completed.Task;
        }

        private const string _stop_name = "stop";

        private void _iceI_stop(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _stop_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ServerStopException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<bool> checkUpdateAsync(InternalServerDescriptor? svr, bool noRestart, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_checkUpdateAsync(svr, noRestart, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<bool> _iceI_checkUpdateAsync(InternalServerDescriptor? iceP_svr, bool iceP_noRestart, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_checkUpdate_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<bool>(progress, cancel);
            _iceI_checkUpdate(iceP_svr, iceP_noRestart, context, synchronous, completed);
            return completed.Task;
        }

        private const string _checkUpdate_name = "checkUpdate";

        private void _iceI_checkUpdate(InternalServerDescriptor? iceP_svr, bool iceP_noRestart, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<bool>(completed);
            outAsync.invoke(
                _checkUpdate_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeValue(iceP_svr);
                    ostr.writeBool(iceP_noRestart);
                    ostr.writePendingValues();
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    bool ret;
                    ret = istr.readBool();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task setEnabledAsync(bool enable, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_setEnabledAsync(enable, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_setEnabledAsync(bool iceP_enable, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_setEnabled(iceP_enable, context, synchronous, completed);
            return completed.Task;
        }

        private const string _setEnabled_name = "setEnabled";

        private void _iceI_setEnabled(bool iceP_enable, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _setEnabled_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeBool(iceP_enable);
                });
        }

        public global::System.Threading.Tasks.Task<bool> isEnabledAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_isEnabledAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<bool> _iceI_isEnabledAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_isEnabled_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<bool>(progress, cancel);
            _iceI_isEnabled(context, synchronous, completed);
            return completed.Task;
        }

        private const string _isEnabled_name = "isEnabled";

        private void _iceI_isEnabled(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<bool>(completed);
            outAsync.invoke(
                _isEnabled_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    bool ret;
                    ret = istr.readBool();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task sendSignalAsync(string signal, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_sendSignalAsync(signal, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_sendSignalAsync(string iceP_signal, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_sendSignal_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_sendSignal(iceP_signal, context, synchronous, completed);
            return completed.Task;
        }

        private const string _sendSignal_name = "sendSignal";

        private void _iceI_sendSignal(string iceP_signal, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _sendSignal_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_signal);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(BadSignalException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task writeMessageAsync(string message, int fd, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_writeMessageAsync(message, fd, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_writeMessageAsync(string iceP_message, int iceP_fd, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_writeMessage(iceP_message, iceP_fd, context, synchronous, completed);
            return completed.Task;
        }

        private const string _writeMessage_name = "writeMessage";

        private void _iceI_writeMessage(string iceP_message, int iceP_fd, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _writeMessage_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_message);
                    ostr.writeInt(iceP_fd);
                });
        }

        public global::System.Threading.Tasks.Task<ServerState> getStateAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getStateAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<ServerState> _iceI_getStateAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getState_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<ServerState>(progress, cancel);
            _iceI_getState(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getState_name = "getState";

        private void _iceI_getState(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<ServerState>(completed);
            outAsync.invoke(
                _getState_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    ServerState ret;
                    ret = (ServerState)istr.readEnum(6);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<int> getPidAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getPidAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<int> _iceI_getPidAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getPid_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<int>(progress, cancel);
            _iceI_getPid(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getPid_name = "getPid";

        private void _iceI_getPid(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<int>(completed);
            outAsync.invoke(
                _getPid_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    int ret;
                    ret = istr.readInt();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task setProcessAsync(global::Ice.ProcessPrx? proc, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_setProcessAsync(proc, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_setProcessAsync(global::Ice.ProcessPrx? iceP_proc, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_setProcess(iceP_proc, context, synchronous, completed);
            return completed.Task;
        }

        private const string _setProcess_name = "setProcess";

        private void _iceI_setProcess(global::Ice.ProcessPrx? iceP_proc, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _setProcess_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    global::Ice.ProcessPrxHelper.write(ostr, iceP_proc);
                });
        }

        public static ServerPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new ServerPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static ServerPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new ServerPrxHelper(b) : null;

        public static ServerPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static ServerPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new ServerPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static ServerPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::FileReader",
            "::IceGrid::Server"
        };

        public static string ice_staticId() => "::IceGrid::Server";

        public static void write(Ice.OutputStream ostr, ServerPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static ServerPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new ServerPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new ServerPrxHelper(reference);

        private ServerPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private ServerPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }

    public sealed class InternalRegistryPrxSeqHelper
    {
        public static void write(Ice.OutputStream ostr, InternalRegistryPrx?[] v)
        {
            if (v is null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    InternalRegistryPrxHelper.write(ostr, v[ix]);
                }
            }
        }

        public static InternalRegistryPrx?[] read(Ice.InputStream istr)
        {
            InternalRegistryPrx?[] v;
            {
                int szx = istr.readAndCheckSeqSize(2);
                v = new InternalRegistryPrx?[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = InternalRegistryPrxHelper.read(istr);
                }
            }
            return v;
        }
    }

    public sealed class ReplicaObserverPrxHelper : Ice.ObjectPrxHelperBase, ReplicaObserverPrx
    {
        public void replicaInit(InternalRegistryPrx?[] replicas, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_replicaInitAsync(replicas, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void replicaAdded(InternalRegistryPrx? replica, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_replicaAddedAsync(replica, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void replicaRemoved(InternalRegistryPrx? replica, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_replicaRemovedAsync(replica, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task replicaInitAsync(InternalRegistryPrx?[] replicas, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_replicaInitAsync(replicas, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_replicaInitAsync(InternalRegistryPrx?[] iceP_replicas, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_replicaInit(iceP_replicas, context, synchronous, completed);
            return completed.Task;
        }

        private const string _replicaInit_name = "replicaInit";

        private void _iceI_replicaInit(InternalRegistryPrx?[] iceP_replicas, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _replicaInit_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    InternalRegistryPrxSeqHelper.write(ostr, iceP_replicas);
                });
        }

        public global::System.Threading.Tasks.Task replicaAddedAsync(InternalRegistryPrx? replica, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_replicaAddedAsync(replica, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_replicaAddedAsync(InternalRegistryPrx? iceP_replica, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_replicaAdded(iceP_replica, context, synchronous, completed);
            return completed.Task;
        }

        private const string _replicaAdded_name = "replicaAdded";

        private void _iceI_replicaAdded(InternalRegistryPrx? iceP_replica, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _replicaAdded_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    InternalRegistryPrxHelper.write(ostr, iceP_replica);
                });
        }

        public global::System.Threading.Tasks.Task replicaRemovedAsync(InternalRegistryPrx? replica, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_replicaRemovedAsync(replica, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_replicaRemovedAsync(InternalRegistryPrx? iceP_replica, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_replicaRemoved(iceP_replica, context, synchronous, completed);
            return completed.Task;
        }

        private const string _replicaRemoved_name = "replicaRemoved";

        private void _iceI_replicaRemoved(InternalRegistryPrx? iceP_replica, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _replicaRemoved_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    InternalRegistryPrxHelper.write(ostr, iceP_replica);
                });
        }

        public static ReplicaObserverPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new ReplicaObserverPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static ReplicaObserverPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new ReplicaObserverPrxHelper(b) : null;

        public static ReplicaObserverPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static ReplicaObserverPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new ReplicaObserverPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static ReplicaObserverPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::ReplicaObserver"
        };

        public static string ice_staticId() => "::IceGrid::ReplicaObserver";

        public static void write(Ice.OutputStream ostr, ReplicaObserverPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static ReplicaObserverPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new ReplicaObserverPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new ReplicaObserverPrxHelper(reference);

        private ReplicaObserverPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private ReplicaObserverPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }

    public sealed class NodePrxHelper : Ice.ObjectPrxHelperBase, NodePrx
    {
        public long getOffsetFromEnd(string filename, int lines, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getOffsetFromEndAsync(filename, lines, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public bool read(string filename, long pos, int size, out long newPos, out string[] lines, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                var result_ = _iceI_readAsync(filename, pos, size, context, null, global::System.Threading.CancellationToken.None, true).Result;
                newPos = result_.newPos;
                lines = result_.lines;
                return result_.returnValue;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void replicaInit(InternalRegistryPrx?[] replicas, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_replicaInitAsync(replicas, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void replicaAdded(InternalRegistryPrx? replica, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_replicaAddedAsync(replica, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void replicaRemoved(InternalRegistryPrx? replica, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_replicaRemovedAsync(replica, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public ServerPrx? loadServer(InternalServerDescriptor? svr, string replicaName, out global::System.Collections.Generic.Dictionary<string, AdapterPrx?> adapters, out int activateTimeout, out int deactivateTimeout, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                var result_ = _iceI_loadServerAsync(svr, replicaName, context, null, global::System.Threading.CancellationToken.None, true).Result;
                adapters = result_.adapters;
                activateTimeout = result_.activateTimeout;
                deactivateTimeout = result_.deactivateTimeout;
                return result_.returnValue;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public ServerPrx? loadServerWithoutRestart(InternalServerDescriptor? svr, string replicaName, out global::System.Collections.Generic.Dictionary<string, AdapterPrx?> adapters, out int activateTimeout, out int deactivateTimeout, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                var result_ = _iceI_loadServerWithoutRestartAsync(svr, replicaName, context, null, global::System.Threading.CancellationToken.None, true).Result;
                adapters = result_.adapters;
                activateTimeout = result_.activateTimeout;
                deactivateTimeout = result_.deactivateTimeout;
                return result_.returnValue;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void destroyServer(string name, string uuid, int revision, string replicaName, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_destroyServerAsync(name, uuid, revision, replicaName, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void destroyServerWithoutRestart(string name, string uuid, int revision, string replicaName, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_destroyServerWithoutRestartAsync(name, uuid, revision, replicaName, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void registerWithReplica(InternalRegistryPrx? replica, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_registerWithReplicaAsync(replica, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public string getName(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getNameAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public string getHostname(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getHostnameAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public LoadInfo getLoad(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getLoadAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public int getProcessorSocketCount(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getProcessorSocketCountAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void shutdown(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_shutdownAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task<long> getOffsetFromEndAsync(string filename, int lines, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getOffsetFromEndAsync(filename, lines, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<long> _iceI_getOffsetFromEndAsync(string iceP_filename, int iceP_lines, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getOffsetFromEnd_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<long>(progress, cancel);
            _iceI_getOffsetFromEnd(iceP_filename, iceP_lines, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getOffsetFromEnd_name = "getOffsetFromEnd";

        private void _iceI_getOffsetFromEnd(string iceP_filename, int iceP_lines, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<long>(completed);
            outAsync.invoke(
                _getOffsetFromEnd_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_filename);
                    ostr.writeInt(iceP_lines);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(FileNotAvailableException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    long ret;
                    ret = istr.readLong();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<FileReader_ReadResult> readAsync(string filename, long pos, int size, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_readAsync(filename, pos, size, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<FileReader_ReadResult> _iceI_readAsync(string iceP_filename, long iceP_pos, int iceP_size, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_read_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<FileReader_ReadResult>(progress, cancel);
            _iceI_read(iceP_filename, iceP_pos, iceP_size, context, synchronous, completed);
            return completed.Task;
        }

        private const string _read_name = "read";

        private void _iceI_read(string iceP_filename, long iceP_pos, int iceP_size, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<FileReader_ReadResult>(completed);
            outAsync.invoke(
                _read_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_filename);
                    ostr.writeLong(iceP_pos);
                    ostr.writeInt(iceP_size);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(FileNotAvailableException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    var ret = new FileReader_ReadResult();
                    ret.newPos = istr.readLong();
                    ret.lines = global::Ice.StringSeqHelper.read(istr);
                    ret.returnValue = istr.readBool();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task replicaInitAsync(InternalRegistryPrx?[] replicas, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_replicaInitAsync(replicas, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_replicaInitAsync(InternalRegistryPrx?[] iceP_replicas, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_replicaInit(iceP_replicas, context, synchronous, completed);
            return completed.Task;
        }

        private const string _replicaInit_name = "replicaInit";

        private void _iceI_replicaInit(InternalRegistryPrx?[] iceP_replicas, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _replicaInit_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    InternalRegistryPrxSeqHelper.write(ostr, iceP_replicas);
                });
        }

        public global::System.Threading.Tasks.Task replicaAddedAsync(InternalRegistryPrx? replica, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_replicaAddedAsync(replica, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_replicaAddedAsync(InternalRegistryPrx? iceP_replica, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_replicaAdded(iceP_replica, context, synchronous, completed);
            return completed.Task;
        }

        private const string _replicaAdded_name = "replicaAdded";

        private void _iceI_replicaAdded(InternalRegistryPrx? iceP_replica, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _replicaAdded_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    InternalRegistryPrxHelper.write(ostr, iceP_replica);
                });
        }

        public global::System.Threading.Tasks.Task replicaRemovedAsync(InternalRegistryPrx? replica, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_replicaRemovedAsync(replica, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_replicaRemovedAsync(InternalRegistryPrx? iceP_replica, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_replicaRemoved(iceP_replica, context, synchronous, completed);
            return completed.Task;
        }

        private const string _replicaRemoved_name = "replicaRemoved";

        private void _iceI_replicaRemoved(InternalRegistryPrx? iceP_replica, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _replicaRemoved_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    InternalRegistryPrxHelper.write(ostr, iceP_replica);
                });
        }

        public global::System.Threading.Tasks.Task<Node_LoadServerResult> loadServerAsync(InternalServerDescriptor? svr, string replicaName, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_loadServerAsync(svr, replicaName, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<Node_LoadServerResult> _iceI_loadServerAsync(InternalServerDescriptor? iceP_svr, string iceP_replicaName, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_loadServer_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<Node_LoadServerResult>(progress, cancel);
            _iceI_loadServer(iceP_svr, iceP_replicaName, context, synchronous, completed);
            return completed.Task;
        }

        private const string _loadServer_name = "loadServer";

        private void _iceI_loadServer(InternalServerDescriptor? iceP_svr, string iceP_replicaName, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<Node_LoadServerResult>(completed);
            outAsync.invoke(
                _loadServer_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeValue(iceP_svr);
                    ostr.writeString(iceP_replicaName);
                    ostr.writePendingValues();
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    var ret = new Node_LoadServerResult();
                    ret.adapters = AdapterPrxDictHelper.read(istr);
                    ret.activateTimeout = istr.readInt();
                    ret.deactivateTimeout = istr.readInt();
                    ret.returnValue = ServerPrxHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<Node_LoadServerWithoutRestartResult> loadServerWithoutRestartAsync(InternalServerDescriptor? svr, string replicaName, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_loadServerWithoutRestartAsync(svr, replicaName, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<Node_LoadServerWithoutRestartResult> _iceI_loadServerWithoutRestartAsync(InternalServerDescriptor? iceP_svr, string iceP_replicaName, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_loadServerWithoutRestart_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<Node_LoadServerWithoutRestartResult>(progress, cancel);
            _iceI_loadServerWithoutRestart(iceP_svr, iceP_replicaName, context, synchronous, completed);
            return completed.Task;
        }

        private const string _loadServerWithoutRestart_name = "loadServerWithoutRestart";

        private void _iceI_loadServerWithoutRestart(InternalServerDescriptor? iceP_svr, string iceP_replicaName, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<Node_LoadServerWithoutRestartResult>(completed);
            outAsync.invoke(
                _loadServerWithoutRestart_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeValue(iceP_svr);
                    ostr.writeString(iceP_replicaName);
                    ostr.writePendingValues();
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    var ret = new Node_LoadServerWithoutRestartResult();
                    ret.adapters = AdapterPrxDictHelper.read(istr);
                    ret.activateTimeout = istr.readInt();
                    ret.deactivateTimeout = istr.readInt();
                    ret.returnValue = ServerPrxHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task destroyServerAsync(string name, string uuid, int revision, string replicaName, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_destroyServerAsync(name, uuid, revision, replicaName, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_destroyServerAsync(string iceP_name, string iceP_uuid, int iceP_revision, string iceP_replicaName, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_destroyServer_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_destroyServer(iceP_name, iceP_uuid, iceP_revision, iceP_replicaName, context, synchronous, completed);
            return completed.Task;
        }

        private const string _destroyServer_name = "destroyServer";

        private void _iceI_destroyServer(string iceP_name, string iceP_uuid, int iceP_revision, string iceP_replicaName, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _destroyServer_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                    ostr.writeString(iceP_uuid);
                    ostr.writeInt(iceP_revision);
                    ostr.writeString(iceP_replicaName);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task destroyServerWithoutRestartAsync(string name, string uuid, int revision, string replicaName, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_destroyServerWithoutRestartAsync(name, uuid, revision, replicaName, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_destroyServerWithoutRestartAsync(string iceP_name, string iceP_uuid, int iceP_revision, string iceP_replicaName, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_destroyServerWithoutRestart_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_destroyServerWithoutRestart(iceP_name, iceP_uuid, iceP_revision, iceP_replicaName, context, synchronous, completed);
            return completed.Task;
        }

        private const string _destroyServerWithoutRestart_name = "destroyServerWithoutRestart";

        private void _iceI_destroyServerWithoutRestart(string iceP_name, string iceP_uuid, int iceP_revision, string iceP_replicaName, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _destroyServerWithoutRestart_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                    ostr.writeString(iceP_uuid);
                    ostr.writeInt(iceP_revision);
                    ostr.writeString(iceP_replicaName);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task registerWithReplicaAsync(InternalRegistryPrx? replica, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_registerWithReplicaAsync(replica, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_registerWithReplicaAsync(InternalRegistryPrx? iceP_replica, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_registerWithReplica(iceP_replica, context, synchronous, completed);
            return completed.Task;
        }

        private const string _registerWithReplica_name = "registerWithReplica";

        private void _iceI_registerWithReplica(InternalRegistryPrx? iceP_replica, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _registerWithReplica_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    InternalRegistryPrxHelper.write(ostr, iceP_replica);
                });
        }

        public global::System.Threading.Tasks.Task<string> getNameAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getNameAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<string> _iceI_getNameAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getName_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<string>(progress, cancel);
            _iceI_getName(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getName_name = "getName";

        private void _iceI_getName(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<string>(completed);
            outAsync.invoke(
                _getName_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    string ret;
                    ret = istr.readString();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<string> getHostnameAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getHostnameAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<string> _iceI_getHostnameAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getHostname_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<string>(progress, cancel);
            _iceI_getHostname(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getHostname_name = "getHostname";

        private void _iceI_getHostname(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<string>(completed);
            outAsync.invoke(
                _getHostname_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    string ret;
                    ret = istr.readString();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<LoadInfo> getLoadAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getLoadAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<LoadInfo> _iceI_getLoadAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getLoad_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<LoadInfo>(progress, cancel);
            _iceI_getLoad(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getLoad_name = "getLoad";

        private void _iceI_getLoad(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<LoadInfo>(completed);
            outAsync.invoke(
                _getLoad_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    LoadInfo ret;
                    ret = new LoadInfo(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<int> getProcessorSocketCountAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getProcessorSocketCountAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<int> _iceI_getProcessorSocketCountAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getProcessorSocketCount_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<int>(progress, cancel);
            _iceI_getProcessorSocketCount(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getProcessorSocketCount_name = "getProcessorSocketCount";

        private void _iceI_getProcessorSocketCount(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<int>(completed);
            outAsync.invoke(
                _getProcessorSocketCount_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    int ret;
                    ret = istr.readInt();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task shutdownAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_shutdownAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_shutdownAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_shutdown(context, synchronous, completed);
            return completed.Task;
        }

        private const string _shutdown_name = "shutdown";

        private void _iceI_shutdown(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _shutdown_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous);
        }

        public static NodePrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new NodePrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static NodePrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new NodePrxHelper(b) : null;

        public static NodePrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static NodePrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new NodePrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static NodePrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::FileReader",
            "::IceGrid::Node",
            "::IceGrid::ReplicaObserver"
        };

        public static string ice_staticId() => "::IceGrid::Node";

        public static void write(Ice.OutputStream ostr, NodePrx? v)
        {
            ostr.writeProxy(v);
        }

        public static NodePrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new NodePrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new NodePrxHelper(reference);

        private NodePrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private NodePrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }

    public sealed class NodePrxSeqHelper
    {
        public static void write(Ice.OutputStream ostr, NodePrx?[] v)
        {
            if (v is null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    NodePrxHelper.write(ostr, v[ix]);
                }
            }
        }

        public static NodePrx?[] read(Ice.InputStream istr)
        {
            NodePrx?[] v;
            {
                int szx = istr.readAndCheckSeqSize(2);
                v = new NodePrx?[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = NodePrxHelper.read(istr);
                }
            }
            return v;
        }
    }

    public sealed class NodeSessionPrxHelper : Ice.ObjectPrxHelperBase, NodeSessionPrx
    {
        public void keepAlive(LoadInfo load, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_keepAliveAsync(load, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void setReplicaObserver(ReplicaObserverPrx? observer, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_setReplicaObserverAsync(observer, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public int getTimeout(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getTimeoutAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public NodeObserverPrx? getObserver(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getObserverAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void loadServers(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_loadServersAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public string[] getServers(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getServersAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void waitForApplicationUpdate(string application, int revision, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_waitForApplicationUpdateAsync(application, revision, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void destroy(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_destroyAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task keepAliveAsync(LoadInfo load, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_keepAliveAsync(load, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_keepAliveAsync(LoadInfo iceP_load, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_keepAlive(iceP_load, context, synchronous, completed);
            return completed.Task;
        }

        private const string _keepAlive_name = "keepAlive";

        private void _iceI_keepAlive(LoadInfo iceP_load, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _keepAlive_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    iceP_load.ice_writeMembers(ostr);
                });
        }

        public global::System.Threading.Tasks.Task setReplicaObserverAsync(ReplicaObserverPrx? observer, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_setReplicaObserverAsync(observer, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_setReplicaObserverAsync(ReplicaObserverPrx? iceP_observer, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_setReplicaObserver(iceP_observer, context, synchronous, completed);
            return completed.Task;
        }

        private const string _setReplicaObserver_name = "setReplicaObserver";

        private void _iceI_setReplicaObserver(ReplicaObserverPrx? iceP_observer, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _setReplicaObserver_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ReplicaObserverPrxHelper.write(ostr, iceP_observer);
                });
        }

        public global::System.Threading.Tasks.Task<int> getTimeoutAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getTimeoutAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<int> _iceI_getTimeoutAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getTimeout_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<int>(progress, cancel);
            _iceI_getTimeout(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getTimeout_name = "getTimeout";

        private void _iceI_getTimeout(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<int>(completed);
            outAsync.invoke(
                _getTimeout_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    int ret;
                    ret = istr.readInt();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<NodeObserverPrx?> getObserverAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getObserverAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<NodeObserverPrx?> _iceI_getObserverAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getObserver_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<NodeObserverPrx?>(progress, cancel);
            _iceI_getObserver(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getObserver_name = "getObserver";

        private void _iceI_getObserver(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<NodeObserverPrx?>(completed);
            outAsync.invoke(
                _getObserver_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    NodeObserverPrx? ret;
                    ret = NodeObserverPrxHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task loadServersAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_loadServersAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_loadServersAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_loadServers(context, synchronous, completed);
            return completed.Task;
        }

        private const string _loadServers_name = "loadServers";

        private void _iceI_loadServers(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _loadServers_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous);
        }

        public global::System.Threading.Tasks.Task<string[]> getServersAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getServersAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<string[]> _iceI_getServersAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getServers_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<string[]>(progress, cancel);
            _iceI_getServers(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getServers_name = "getServers";

        private void _iceI_getServers(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<string[]>(completed);
            outAsync.invoke(
                _getServers_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    string[] ret;
                    ret = global::Ice.StringSeqHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task waitForApplicationUpdateAsync(string application, int revision, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_waitForApplicationUpdateAsync(application, revision, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_waitForApplicationUpdateAsync(string iceP_application, int iceP_revision, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_waitForApplicationUpdate(iceP_application, iceP_revision, context, synchronous, completed);
            return completed.Task;
        }

        private const string _waitForApplicationUpdate_name = "waitForApplicationUpdate";

        private void _iceI_waitForApplicationUpdate(string iceP_application, int iceP_revision, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _waitForApplicationUpdate_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_application);
                    ostr.writeInt(iceP_revision);
                });
        }

        public global::System.Threading.Tasks.Task destroyAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_destroyAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_destroyAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_destroy(context, synchronous, completed);
            return completed.Task;
        }

        private const string _destroy_name = "destroy";

        private void _iceI_destroy(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _destroy_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous);
        }

        public static NodeSessionPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new NodeSessionPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static NodeSessionPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new NodeSessionPrxHelper(b) : null;

        public static NodeSessionPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static NodeSessionPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new NodeSessionPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static NodeSessionPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::NodeSession"
        };

        public static string ice_staticId() => "::IceGrid::NodeSession";

        public static void write(Ice.OutputStream ostr, NodeSessionPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static NodeSessionPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new NodeSessionPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new NodeSessionPrxHelper(reference);

        private NodeSessionPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private NodeSessionPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }

    public sealed class DatabaseObserverPrxHelper : Ice.ObjectPrxHelperBase, DatabaseObserverPrx
    {
        public void applicationInit(int serial, ApplicationInfo[] applications, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_applicationInitAsync(serial, applications, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void applicationAdded(int serial, ApplicationInfo desc, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_applicationAddedAsync(serial, desc, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void applicationRemoved(int serial, string name, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_applicationRemovedAsync(serial, name, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void applicationUpdated(int serial, ApplicationUpdateInfo desc, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_applicationUpdatedAsync(serial, desc, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void objectInit(ObjectInfo[] objects, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_objectInitAsync(objects, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void objectAdded(ObjectInfo info, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_objectAddedAsync(info, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void objectUpdated(ObjectInfo info, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_objectUpdatedAsync(info, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void objectRemoved(global::Ice.Identity id, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_objectRemovedAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void adapterInit(AdapterInfo[] adpts, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_adapterInitAsync(adpts, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void adapterAdded(AdapterInfo info, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_adapterAddedAsync(info, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void adapterUpdated(AdapterInfo info, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_adapterUpdatedAsync(info, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void adapterRemoved(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_adapterRemovedAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task applicationInitAsync(int serial, ApplicationInfo[] applications, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_applicationInitAsync(serial, applications, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_applicationInitAsync(int iceP_serial, ApplicationInfo[] iceP_applications, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_applicationInit(iceP_serial, iceP_applications, context, synchronous, completed);
            return completed.Task;
        }

        private const string _applicationInit_name = "applicationInit";

        private void _iceI_applicationInit(int iceP_serial, ApplicationInfo[] iceP_applications, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _applicationInit_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_serial);
                    ApplicationInfoSeqHelper.write(ostr, iceP_applications);
                    ostr.writePendingValues();
                });
        }

        public global::System.Threading.Tasks.Task applicationAddedAsync(int serial, ApplicationInfo desc, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_applicationAddedAsync(serial, desc, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_applicationAddedAsync(int iceP_serial, ApplicationInfo iceP_desc, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_applicationAdded(iceP_serial, iceP_desc, context, synchronous, completed);
            return completed.Task;
        }

        private const string _applicationAdded_name = "applicationAdded";

        private void _iceI_applicationAdded(int iceP_serial, ApplicationInfo iceP_desc, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _applicationAdded_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_serial);
                    ApplicationInfo.ice_write(ostr, iceP_desc);
                    ostr.writePendingValues();
                });
        }

        public global::System.Threading.Tasks.Task applicationRemovedAsync(int serial, string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_applicationRemovedAsync(serial, name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_applicationRemovedAsync(int iceP_serial, string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_applicationRemoved(iceP_serial, iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _applicationRemoved_name = "applicationRemoved";

        private void _iceI_applicationRemoved(int iceP_serial, string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _applicationRemoved_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_serial);
                    ostr.writeString(iceP_name);
                });
        }

        public global::System.Threading.Tasks.Task applicationUpdatedAsync(int serial, ApplicationUpdateInfo desc, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_applicationUpdatedAsync(serial, desc, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_applicationUpdatedAsync(int iceP_serial, ApplicationUpdateInfo iceP_desc, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_applicationUpdated(iceP_serial, iceP_desc, context, synchronous, completed);
            return completed.Task;
        }

        private const string _applicationUpdated_name = "applicationUpdated";

        private void _iceI_applicationUpdated(int iceP_serial, ApplicationUpdateInfo iceP_desc, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _applicationUpdated_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_serial);
                    ApplicationUpdateInfo.ice_write(ostr, iceP_desc);
                    ostr.writePendingValues();
                });
        }

        public global::System.Threading.Tasks.Task objectInitAsync(ObjectInfo[] objects, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_objectInitAsync(objects, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_objectInitAsync(ObjectInfo[] iceP_objects, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_objectInit(iceP_objects, context, synchronous, completed);
            return completed.Task;
        }

        private const string _objectInit_name = "objectInit";

        private void _iceI_objectInit(ObjectInfo[] iceP_objects, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _objectInit_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ObjectInfoSeqHelper.write(ostr, iceP_objects);
                });
        }

        public global::System.Threading.Tasks.Task objectAddedAsync(ObjectInfo info, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_objectAddedAsync(info, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_objectAddedAsync(ObjectInfo iceP_info, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_objectAdded(iceP_info, context, synchronous, completed);
            return completed.Task;
        }

        private const string _objectAdded_name = "objectAdded";

        private void _iceI_objectAdded(ObjectInfo iceP_info, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _objectAdded_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ObjectInfo.ice_write(ostr, iceP_info);
                });
        }

        public global::System.Threading.Tasks.Task objectUpdatedAsync(ObjectInfo info, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_objectUpdatedAsync(info, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_objectUpdatedAsync(ObjectInfo iceP_info, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_objectUpdated(iceP_info, context, synchronous, completed);
            return completed.Task;
        }

        private const string _objectUpdated_name = "objectUpdated";

        private void _iceI_objectUpdated(ObjectInfo iceP_info, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _objectUpdated_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ObjectInfo.ice_write(ostr, iceP_info);
                });
        }

        public global::System.Threading.Tasks.Task objectRemovedAsync(global::Ice.Identity id, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_objectRemovedAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_objectRemovedAsync(global::Ice.Identity iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_objectRemoved(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _objectRemoved_name = "objectRemoved";

        private void _iceI_objectRemoved(global::Ice.Identity iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _objectRemoved_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    global::Ice.Identity.ice_write(ostr, iceP_id);
                });
        }

        public global::System.Threading.Tasks.Task adapterInitAsync(AdapterInfo[] adpts, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_adapterInitAsync(adpts, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_adapterInitAsync(AdapterInfo[] iceP_adpts, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_adapterInit(iceP_adpts, context, synchronous, completed);
            return completed.Task;
        }

        private const string _adapterInit_name = "adapterInit";

        private void _iceI_adapterInit(AdapterInfo[] iceP_adpts, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _adapterInit_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    AdapterInfoSeqHelper.write(ostr, iceP_adpts);
                });
        }

        public global::System.Threading.Tasks.Task adapterAddedAsync(AdapterInfo info, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_adapterAddedAsync(info, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_adapterAddedAsync(AdapterInfo iceP_info, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_adapterAdded(iceP_info, context, synchronous, completed);
            return completed.Task;
        }

        private const string _adapterAdded_name = "adapterAdded";

        private void _iceI_adapterAdded(AdapterInfo iceP_info, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _adapterAdded_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    AdapterInfo.ice_write(ostr, iceP_info);
                });
        }

        public global::System.Threading.Tasks.Task adapterUpdatedAsync(AdapterInfo info, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_adapterUpdatedAsync(info, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_adapterUpdatedAsync(AdapterInfo iceP_info, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_adapterUpdated(iceP_info, context, synchronous, completed);
            return completed.Task;
        }

        private const string _adapterUpdated_name = "adapterUpdated";

        private void _iceI_adapterUpdated(AdapterInfo iceP_info, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _adapterUpdated_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    AdapterInfo.ice_write(ostr, iceP_info);
                });
        }

        public global::System.Threading.Tasks.Task adapterRemovedAsync(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_adapterRemovedAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_adapterRemovedAsync(string iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_adapterRemoved(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _adapterRemoved_name = "adapterRemoved";

        private void _iceI_adapterRemoved(string iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _adapterRemoved_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                });
        }

        public static DatabaseObserverPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new DatabaseObserverPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static DatabaseObserverPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new DatabaseObserverPrxHelper(b) : null;

        public static DatabaseObserverPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static DatabaseObserverPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new DatabaseObserverPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static DatabaseObserverPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::AdapterObserver",
            "::IceGrid::ApplicationObserver",
            "::IceGrid::DatabaseObserver",
            "::IceGrid::ObjectObserver"
        };

        public static string ice_staticId() => "::IceGrid::DatabaseObserver";

        public static void write(Ice.OutputStream ostr, DatabaseObserverPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static DatabaseObserverPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new DatabaseObserverPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new DatabaseObserverPrxHelper(reference);

        private DatabaseObserverPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private DatabaseObserverPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }

    public sealed class StringLongDictHelper
    {
        public static void write(Ice.OutputStream ostr,
                                 global::System.Collections.Generic.Dictionary<string, long> v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Count);
                foreach(global::System.Collections.Generic.KeyValuePair<string, long> e in v)
                {
                    ostr.writeString(e.Key);
                    ostr.writeLong(e.Value);
                }
            }
        }

        public static global::System.Collections.Generic.Dictionary<string, long> read(Ice.InputStream istr)
        {
            int sz = istr.readSize();
            global::System.Collections.Generic.Dictionary<string, long> r = new global::System.Collections.Generic.Dictionary<string, long>();
            for(int i = 0; i < sz; ++i)
            {
                string k;
                k = istr.readString();
                long v;
                v = istr.readLong();
                r[k] = v;
            }
            return r;
        }
    }

    public sealed class ReplicaSessionPrxHelper : Ice.ObjectPrxHelperBase, ReplicaSessionPrx
    {
        public void keepAlive(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_keepAliveAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public int getTimeout(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getTimeoutAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void setDatabaseObserver(DatabaseObserverPrx? dbObs, global::System.Collections.Generic.Dictionary<string, long>? serials, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_setDatabaseObserverAsync(dbObs, serials, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void setEndpoints(global::System.Collections.Generic.Dictionary<string, global::Ice.ObjectPrx?> endpoints, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_setEndpointsAsync(endpoints, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void registerWellKnownObjects(ObjectInfo[] objects, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_registerWellKnownObjectsAsync(objects, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void setAdapterDirectProxy(string adapterId, string replicaGroupId, global::Ice.ObjectPrx? proxy, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_setAdapterDirectProxyAsync(adapterId, replicaGroupId, proxy, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void receivedUpdate(TopicName name, int serial, string failure, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_receivedUpdateAsync(name, serial, failure, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void destroy(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_destroyAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task keepAliveAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_keepAliveAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_keepAliveAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_keepAlive(context, synchronous, completed);
            return completed.Task;
        }

        private const string _keepAlive_name = "keepAlive";

        private void _iceI_keepAlive(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _keepAlive_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous);
        }

        public global::System.Threading.Tasks.Task<int> getTimeoutAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getTimeoutAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<int> _iceI_getTimeoutAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getTimeout_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<int>(progress, cancel);
            _iceI_getTimeout(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getTimeout_name = "getTimeout";

        private void _iceI_getTimeout(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<int>(completed);
            outAsync.invoke(
                _getTimeout_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    int ret;
                    ret = istr.readInt();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task setDatabaseObserverAsync(DatabaseObserverPrx? dbObs, global::System.Collections.Generic.Dictionary<string, long>? serials, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_setDatabaseObserverAsync(dbObs, serials, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_setDatabaseObserverAsync(DatabaseObserverPrx? iceP_dbObs, global::System.Collections.Generic.Dictionary<string, long>? iceP_serials, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_setDatabaseObserver_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_setDatabaseObserver(iceP_dbObs, iceP_serials, context, synchronous, completed);
            return completed.Task;
        }

        private const string _setDatabaseObserver_name = "setDatabaseObserver";

        private void _iceI_setDatabaseObserver(DatabaseObserverPrx? iceP_dbObs, global::System.Collections.Generic.Dictionary<string, long>? iceP_serials, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _setDatabaseObserver_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    DatabaseObserverPrxHelper.write(ostr, iceP_dbObs);
                    if (iceP_serials is not null && ostr.writeOptional(1, Ice.OptionalFormat.FSize))
                    {
                        int pos = ostr.startSize();
                        StringLongDictHelper.write(ostr, iceP_serials);
                        ostr.endSize(pos);
                    }
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(ObserverAlreadyRegisteredException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task setEndpointsAsync(global::System.Collections.Generic.Dictionary<string, global::Ice.ObjectPrx?> endpoints, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_setEndpointsAsync(endpoints, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_setEndpointsAsync(global::System.Collections.Generic.Dictionary<string, global::Ice.ObjectPrx?> iceP_endpoints, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_setEndpoints(iceP_endpoints, context, synchronous, completed);
            return completed.Task;
        }

        private const string _setEndpoints_name = "setEndpoints";

        private void _iceI_setEndpoints(global::System.Collections.Generic.Dictionary<string, global::Ice.ObjectPrx?> iceP_endpoints, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _setEndpoints_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    StringObjectProxyDictHelper.write(ostr, iceP_endpoints);
                });
        }

        public global::System.Threading.Tasks.Task registerWellKnownObjectsAsync(ObjectInfo[] objects, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_registerWellKnownObjectsAsync(objects, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_registerWellKnownObjectsAsync(ObjectInfo[] iceP_objects, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_registerWellKnownObjects(iceP_objects, context, synchronous, completed);
            return completed.Task;
        }

        private const string _registerWellKnownObjects_name = "registerWellKnownObjects";

        private void _iceI_registerWellKnownObjects(ObjectInfo[] iceP_objects, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _registerWellKnownObjects_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ObjectInfoSeqHelper.write(ostr, iceP_objects);
                });
        }

        public global::System.Threading.Tasks.Task setAdapterDirectProxyAsync(string adapterId, string replicaGroupId, global::Ice.ObjectPrx? proxy, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_setAdapterDirectProxyAsync(adapterId, replicaGroupId, proxy, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_setAdapterDirectProxyAsync(string iceP_adapterId, string iceP_replicaGroupId, global::Ice.ObjectPrx? iceP_proxy, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_setAdapterDirectProxy_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_setAdapterDirectProxy(iceP_adapterId, iceP_replicaGroupId, iceP_proxy, context, synchronous, completed);
            return completed.Task;
        }

        private const string _setAdapterDirectProxy_name = "setAdapterDirectProxy";

        private void _iceI_setAdapterDirectProxy(string iceP_adapterId, string iceP_replicaGroupId, global::Ice.ObjectPrx? iceP_proxy, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _setAdapterDirectProxy_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_adapterId);
                    ostr.writeString(iceP_replicaGroupId);
                    ostr.writeProxy(iceP_proxy);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(AdapterNotExistException)
                    {
                        throw;
                    }
                    catch(AdapterExistsException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task receivedUpdateAsync(TopicName name, int serial, string failure, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_receivedUpdateAsync(name, serial, failure, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_receivedUpdateAsync(TopicName iceP_name, int iceP_serial, string iceP_failure, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_receivedUpdate(iceP_name, iceP_serial, iceP_failure, context, synchronous, completed);
            return completed.Task;
        }

        private const string _receivedUpdate_name = "receivedUpdate";

        private void _iceI_receivedUpdate(TopicName iceP_name, int iceP_serial, string iceP_failure, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _receivedUpdate_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeEnum((int)iceP_name, 4);
                    ostr.writeInt(iceP_serial);
                    ostr.writeString(iceP_failure);
                });
        }

        public global::System.Threading.Tasks.Task destroyAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_destroyAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_destroyAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_destroy(context, synchronous, completed);
            return completed.Task;
        }

        private const string _destroy_name = "destroy";

        private void _iceI_destroy(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _destroy_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous);
        }

        public static ReplicaSessionPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new ReplicaSessionPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static ReplicaSessionPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new ReplicaSessionPrxHelper(b) : null;

        public static ReplicaSessionPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static ReplicaSessionPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new ReplicaSessionPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static ReplicaSessionPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::ReplicaSession"
        };

        public static string ice_staticId() => "::IceGrid::ReplicaSession";

        public static void write(Ice.OutputStream ostr, ReplicaSessionPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static ReplicaSessionPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new ReplicaSessionPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new ReplicaSessionPrxHelper(reference);

        private ReplicaSessionPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private ReplicaSessionPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }

    public sealed class InternalRegistryPrxHelper : Ice.ObjectPrxHelperBase, InternalRegistryPrx
    {
        public long getOffsetFromEnd(string filename, int lines, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getOffsetFromEndAsync(filename, lines, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public bool read(string filename, long pos, int size, out long newPos, out string[] lines, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                var result_ = _iceI_readAsync(filename, pos, size, context, null, global::System.Threading.CancellationToken.None, true).Result;
                newPos = result_.newPos;
                lines = result_.lines;
                return result_.returnValue;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public NodeSessionPrx? registerNode(InternalNodeInfo? info, NodePrx? prx, LoadInfo loadInf, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_registerNodeAsync(info, prx, loadInf, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public ReplicaSessionPrx? registerReplica(InternalReplicaInfo? info, InternalRegistryPrx? prx, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_registerReplicaAsync(info, prx, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void registerWithReplica(InternalRegistryPrx? prx, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_registerWithReplicaAsync(prx, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public NodePrx?[] getNodes(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getNodesAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public InternalRegistryPrx?[] getReplicas(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getReplicasAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public ApplicationInfo[] getApplications(out long serial, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                var result_ = _iceI_getApplicationsAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
                serial = result_.serial;
                return result_.returnValue;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public AdapterInfo[] getAdapters(out long serial, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                var result_ = _iceI_getAdaptersAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
                serial = result_.serial;
                return result_.returnValue;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public ObjectInfo[] getObjects(out long serial, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                var result_ = _iceI_getObjectsAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
                serial = result_.serial;
                return result_.returnValue;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void shutdown(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_shutdownAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task<long> getOffsetFromEndAsync(string filename, int lines, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getOffsetFromEndAsync(filename, lines, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<long> _iceI_getOffsetFromEndAsync(string iceP_filename, int iceP_lines, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getOffsetFromEnd_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<long>(progress, cancel);
            _iceI_getOffsetFromEnd(iceP_filename, iceP_lines, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getOffsetFromEnd_name = "getOffsetFromEnd";

        private void _iceI_getOffsetFromEnd(string iceP_filename, int iceP_lines, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<long>(completed);
            outAsync.invoke(
                _getOffsetFromEnd_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_filename);
                    ostr.writeInt(iceP_lines);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(FileNotAvailableException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    long ret;
                    ret = istr.readLong();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<FileReader_ReadResult> readAsync(string filename, long pos, int size, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_readAsync(filename, pos, size, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<FileReader_ReadResult> _iceI_readAsync(string iceP_filename, long iceP_pos, int iceP_size, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_read_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<FileReader_ReadResult>(progress, cancel);
            _iceI_read(iceP_filename, iceP_pos, iceP_size, context, synchronous, completed);
            return completed.Task;
        }

        private const string _read_name = "read";

        private void _iceI_read(string iceP_filename, long iceP_pos, int iceP_size, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<FileReader_ReadResult>(completed);
            outAsync.invoke(
                _read_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_filename);
                    ostr.writeLong(iceP_pos);
                    ostr.writeInt(iceP_size);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(FileNotAvailableException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    var ret = new FileReader_ReadResult();
                    ret.newPos = istr.readLong();
                    ret.lines = global::Ice.StringSeqHelper.read(istr);
                    ret.returnValue = istr.readBool();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<NodeSessionPrx?> registerNodeAsync(InternalNodeInfo? info, NodePrx? prx, LoadInfo loadInf, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_registerNodeAsync(info, prx, loadInf, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<NodeSessionPrx?> _iceI_registerNodeAsync(InternalNodeInfo? iceP_info, NodePrx? iceP_prx, LoadInfo iceP_loadInf, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_registerNode_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<NodeSessionPrx?>(progress, cancel);
            _iceI_registerNode(iceP_info, iceP_prx, iceP_loadInf, context, synchronous, completed);
            return completed.Task;
        }

        private const string _registerNode_name = "registerNode";

        private void _iceI_registerNode(InternalNodeInfo? iceP_info, NodePrx? iceP_prx, LoadInfo iceP_loadInf, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<NodeSessionPrx?>(completed);
            outAsync.invoke(
                _registerNode_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeValue(iceP_info);
                    NodePrxHelper.write(ostr, iceP_prx);
                    iceP_loadInf.ice_writeMembers(ostr);
                    ostr.writePendingValues();
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(PermissionDeniedException)
                    {
                        throw;
                    }
                    catch(NodeActiveException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    NodeSessionPrx? ret;
                    ret = NodeSessionPrxHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<ReplicaSessionPrx?> registerReplicaAsync(InternalReplicaInfo? info, InternalRegistryPrx? prx, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_registerReplicaAsync(info, prx, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<ReplicaSessionPrx?> _iceI_registerReplicaAsync(InternalReplicaInfo? iceP_info, InternalRegistryPrx? iceP_prx, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_registerReplica_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<ReplicaSessionPrx?>(progress, cancel);
            _iceI_registerReplica(iceP_info, iceP_prx, context, synchronous, completed);
            return completed.Task;
        }

        private const string _registerReplica_name = "registerReplica";

        private void _iceI_registerReplica(InternalReplicaInfo? iceP_info, InternalRegistryPrx? iceP_prx, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<ReplicaSessionPrx?>(completed);
            outAsync.invoke(
                _registerReplica_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeValue(iceP_info);
                    InternalRegistryPrxHelper.write(ostr, iceP_prx);
                    ostr.writePendingValues();
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(PermissionDeniedException)
                    {
                        throw;
                    }
                    catch(ReplicaActiveException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    ReplicaSessionPrx? ret;
                    ret = ReplicaSessionPrxHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task registerWithReplicaAsync(InternalRegistryPrx? prx, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_registerWithReplicaAsync(prx, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_registerWithReplicaAsync(InternalRegistryPrx? iceP_prx, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_registerWithReplica(iceP_prx, context, synchronous, completed);
            return completed.Task;
        }

        private const string _registerWithReplica_name = "registerWithReplica";

        private void _iceI_registerWithReplica(InternalRegistryPrx? iceP_prx, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _registerWithReplica_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    InternalRegistryPrxHelper.write(ostr, iceP_prx);
                });
        }

        public global::System.Threading.Tasks.Task<NodePrx?[]> getNodesAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getNodesAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<NodePrx?[]> _iceI_getNodesAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getNodes_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<NodePrx?[]>(progress, cancel);
            _iceI_getNodes(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getNodes_name = "getNodes";

        private void _iceI_getNodes(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<NodePrx?[]>(completed);
            outAsync.invoke(
                _getNodes_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    NodePrx?[] ret;
                    ret = NodePrxSeqHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<InternalRegistryPrx?[]> getReplicasAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getReplicasAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<InternalRegistryPrx?[]> _iceI_getReplicasAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getReplicas_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<InternalRegistryPrx?[]>(progress, cancel);
            _iceI_getReplicas(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getReplicas_name = "getReplicas";

        private void _iceI_getReplicas(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<InternalRegistryPrx?[]>(completed);
            outAsync.invoke(
                _getReplicas_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    InternalRegistryPrx?[] ret;
                    ret = InternalRegistryPrxSeqHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<InternalRegistry_GetApplicationsResult> getApplicationsAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getApplicationsAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<InternalRegistry_GetApplicationsResult> _iceI_getApplicationsAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getApplications_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<InternalRegistry_GetApplicationsResult>(progress, cancel);
            _iceI_getApplications(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getApplications_name = "getApplications";

        private void _iceI_getApplications(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<InternalRegistry_GetApplicationsResult>(completed);
            outAsync.invoke(
                _getApplications_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    var ret = new InternalRegistry_GetApplicationsResult();
                    ret.serial = istr.readLong();
                    ret.returnValue = ApplicationInfoSeqHelper.read(istr);
                    istr.readPendingValues();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<InternalRegistry_GetAdaptersResult> getAdaptersAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getAdaptersAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<InternalRegistry_GetAdaptersResult> _iceI_getAdaptersAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getAdapters_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<InternalRegistry_GetAdaptersResult>(progress, cancel);
            _iceI_getAdapters(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getAdapters_name = "getAdapters";

        private void _iceI_getAdapters(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<InternalRegistry_GetAdaptersResult>(completed);
            outAsync.invoke(
                _getAdapters_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    var ret = new InternalRegistry_GetAdaptersResult();
                    ret.serial = istr.readLong();
                    ret.returnValue = AdapterInfoSeqHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<InternalRegistry_GetObjectsResult> getObjectsAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getObjectsAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<InternalRegistry_GetObjectsResult> _iceI_getObjectsAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getObjects_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<InternalRegistry_GetObjectsResult>(progress, cancel);
            _iceI_getObjects(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getObjects_name = "getObjects";

        private void _iceI_getObjects(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<InternalRegistry_GetObjectsResult>(completed);
            outAsync.invoke(
                _getObjects_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    var ret = new InternalRegistry_GetObjectsResult();
                    ret.serial = istr.readLong();
                    ret.returnValue = ObjectInfoSeqHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task shutdownAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_shutdownAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_shutdownAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_shutdown(context, synchronous, completed);
            return completed.Task;
        }

        private const string _shutdown_name = "shutdown";

        private void _iceI_shutdown(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _shutdown_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous);
        }

        public static InternalRegistryPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new InternalRegistryPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static InternalRegistryPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new InternalRegistryPrxHelper(b) : null;

        public static InternalRegistryPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static InternalRegistryPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new InternalRegistryPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static InternalRegistryPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::FileReader",
            "::IceGrid::InternalRegistry"
        };

        public static string ice_staticId() => "::IceGrid::InternalRegistry";

        public static void write(Ice.OutputStream ostr, InternalRegistryPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static InternalRegistryPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new InternalRegistryPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new InternalRegistryPrxHelper(reference);

        private InternalRegistryPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private InternalRegistryPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }
}

namespace IceGrid
{
    public abstract class AdapterDisp_ : Ice.ObjectImpl, Adapter
    {
        public abstract global::System.Threading.Tasks.Task<global::Ice.ObjectPrx?> activateAsync(Ice.Current current);

        public abstract global::Ice.ObjectPrx? getDirectProxy(Ice.Current current);

        public abstract void setDirectProxy(global::Ice.ObjectPrx? proxy, Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::IceGrid::Adapter";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "activate" => Adapter.iceD_activateAsync(this, request),
                "getDirectProxy" => Adapter.iceD_getDirectProxyAsync(this, request),
                "setDirectProxy" => Adapter.iceD_setDirectProxyAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }

    public abstract class FileReaderDisp_ : Ice.ObjectImpl, FileReader
    {
        public abstract long getOffsetFromEnd(string filename, int lines, Ice.Current current);

        public abstract bool read(string filename, long pos, int size, out long newPos, out string[] lines, Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::IceGrid::FileReader";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "getOffsetFromEnd" => FileReader.iceD_getOffsetFromEndAsync(this, request),
                "read" => FileReader.iceD_readAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }

    public abstract class ServerDisp_ : Ice.ObjectImpl, Server
    {
        public abstract global::System.Threading.Tasks.Task startAsync(Ice.Current current);

        public abstract global::System.Threading.Tasks.Task stopAsync(Ice.Current current);

        public abstract bool checkUpdate(InternalServerDescriptor? svr, bool noRestart, Ice.Current current);

        public abstract void setEnabled(bool enable, Ice.Current current);

        public abstract bool isEnabled(Ice.Current current);

        public abstract void sendSignal(string signal, Ice.Current current);

        public abstract void writeMessage(string message, int fd, Ice.Current current);

        public abstract ServerState getState(Ice.Current current);

        public abstract int getPid(Ice.Current current);

        public abstract global::System.Threading.Tasks.Task setProcessAsync(global::Ice.ProcessPrx? proc, Ice.Current current);

        public abstract long getOffsetFromEnd(string filename, int lines, Ice.Current current);

        public abstract bool read(string filename, long pos, int size, out long newPos, out string[] lines, Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::IceGrid::Server";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "getOffsetFromEnd" => FileReader.iceD_getOffsetFromEndAsync(this, request),
                "read" => FileReader.iceD_readAsync(this, request),
                "start" => Server.iceD_startAsync(this, request),
                "stop" => Server.iceD_stopAsync(this, request),
                "checkUpdate" => Server.iceD_checkUpdateAsync(this, request),
                "setEnabled" => Server.iceD_setEnabledAsync(this, request),
                "isEnabled" => Server.iceD_isEnabledAsync(this, request),
                "sendSignal" => Server.iceD_sendSignalAsync(this, request),
                "writeMessage" => Server.iceD_writeMessageAsync(this, request),
                "getState" => Server.iceD_getStateAsync(this, request),
                "getPid" => Server.iceD_getPidAsync(this, request),
                "setProcess" => Server.iceD_setProcessAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }

    public abstract class ReplicaObserverDisp_ : Ice.ObjectImpl, ReplicaObserver
    {
        public abstract void replicaInit(InternalRegistryPrx?[] replicas, Ice.Current current);

        public abstract void replicaAdded(InternalRegistryPrx? replica, Ice.Current current);

        public abstract void replicaRemoved(InternalRegistryPrx? replica, Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::IceGrid::ReplicaObserver";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "replicaInit" => ReplicaObserver.iceD_replicaInitAsync(this, request),
                "replicaAdded" => ReplicaObserver.iceD_replicaAddedAsync(this, request),
                "replicaRemoved" => ReplicaObserver.iceD_replicaRemovedAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }

    public abstract class NodeDisp_ : Ice.ObjectImpl, Node
    {
        public abstract global::System.Threading.Tasks.Task<Node_LoadServerResult> loadServerAsync(InternalServerDescriptor? svr, string replicaName, Ice.Current current);

        public abstract global::System.Threading.Tasks.Task<Node_LoadServerWithoutRestartResult> loadServerWithoutRestartAsync(InternalServerDescriptor? svr, string replicaName, Ice.Current current);

        public abstract global::System.Threading.Tasks.Task destroyServerAsync(string name, string uuid, int revision, string replicaName, Ice.Current current);

        public abstract global::System.Threading.Tasks.Task destroyServerWithoutRestartAsync(string name, string uuid, int revision, string replicaName, Ice.Current current);

        public abstract void registerWithReplica(InternalRegistryPrx? replica, Ice.Current current);

        public abstract string getName(Ice.Current current);

        public abstract string getHostname(Ice.Current current);

        public abstract LoadInfo getLoad(Ice.Current current);

        public abstract int getProcessorSocketCount(Ice.Current current);

        public abstract void shutdown(Ice.Current current);

        public abstract void replicaInit(InternalRegistryPrx?[] replicas, Ice.Current current);

        public abstract void replicaAdded(InternalRegistryPrx? replica, Ice.Current current);

        public abstract void replicaRemoved(InternalRegistryPrx? replica, Ice.Current current);

        public abstract long getOffsetFromEnd(string filename, int lines, Ice.Current current);

        public abstract bool read(string filename, long pos, int size, out long newPos, out string[] lines, Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::IceGrid::Node";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "getOffsetFromEnd" => FileReader.iceD_getOffsetFromEndAsync(this, request),
                "read" => FileReader.iceD_readAsync(this, request),
                "replicaInit" => ReplicaObserver.iceD_replicaInitAsync(this, request),
                "replicaAdded" => ReplicaObserver.iceD_replicaAddedAsync(this, request),
                "replicaRemoved" => ReplicaObserver.iceD_replicaRemovedAsync(this, request),
                "loadServer" => Node.iceD_loadServerAsync(this, request),
                "loadServerWithoutRestart" => Node.iceD_loadServerWithoutRestartAsync(this, request),
                "destroyServer" => Node.iceD_destroyServerAsync(this, request),
                "destroyServerWithoutRestart" => Node.iceD_destroyServerWithoutRestartAsync(this, request),
                "registerWithReplica" => Node.iceD_registerWithReplicaAsync(this, request),
                "getName" => Node.iceD_getNameAsync(this, request),
                "getHostname" => Node.iceD_getHostnameAsync(this, request),
                "getLoad" => Node.iceD_getLoadAsync(this, request),
                "getProcessorSocketCount" => Node.iceD_getProcessorSocketCountAsync(this, request),
                "shutdown" => Node.iceD_shutdownAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }

    public abstract class NodeSessionDisp_ : Ice.ObjectImpl, NodeSession
    {
        public abstract void keepAlive(LoadInfo load, Ice.Current current);

        public abstract void setReplicaObserver(ReplicaObserverPrx? observer, Ice.Current current);

        public abstract int getTimeout(Ice.Current current);

        public abstract NodeObserverPrx? getObserver(Ice.Current current);

        public abstract global::System.Threading.Tasks.Task loadServersAsync(Ice.Current current);

        public abstract string[] getServers(Ice.Current current);

        public abstract global::System.Threading.Tasks.Task waitForApplicationUpdateAsync(string application, int revision, Ice.Current current);

        public abstract void destroy(Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::IceGrid::NodeSession";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "keepAlive" => NodeSession.iceD_keepAliveAsync(this, request),
                "setReplicaObserver" => NodeSession.iceD_setReplicaObserverAsync(this, request),
                "getTimeout" => NodeSession.iceD_getTimeoutAsync(this, request),
                "getObserver" => NodeSession.iceD_getObserverAsync(this, request),
                "loadServers" => NodeSession.iceD_loadServersAsync(this, request),
                "getServers" => NodeSession.iceD_getServersAsync(this, request),
                "waitForApplicationUpdate" => NodeSession.iceD_waitForApplicationUpdateAsync(this, request),
                "destroy" => NodeSession.iceD_destroyAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }

    public abstract class DatabaseObserverDisp_ : Ice.ObjectImpl, DatabaseObserver
    {
        public abstract void applicationInit(int serial, ApplicationInfo[] applications, Ice.Current current);

        public abstract void applicationAdded(int serial, ApplicationInfo desc, Ice.Current current);

        public abstract void applicationRemoved(int serial, string name, Ice.Current current);

        public abstract void applicationUpdated(int serial, ApplicationUpdateInfo desc, Ice.Current current);

        public abstract void adapterInit(AdapterInfo[] adpts, Ice.Current current);

        public abstract void adapterAdded(AdapterInfo info, Ice.Current current);

        public abstract void adapterUpdated(AdapterInfo info, Ice.Current current);

        public abstract void adapterRemoved(string id, Ice.Current current);

        public abstract void objectInit(ObjectInfo[] objects, Ice.Current current);

        public abstract void objectAdded(ObjectInfo info, Ice.Current current);

        public abstract void objectUpdated(ObjectInfo info, Ice.Current current);

        public abstract void objectRemoved(global::Ice.Identity id, Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::IceGrid::DatabaseObserver";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "applicationInit" => ApplicationObserver.iceD_applicationInitAsync(this, request),
                "applicationAdded" => ApplicationObserver.iceD_applicationAddedAsync(this, request),
                "applicationRemoved" => ApplicationObserver.iceD_applicationRemovedAsync(this, request),
                "applicationUpdated" => ApplicationObserver.iceD_applicationUpdatedAsync(this, request),
                "objectInit" => ObjectObserver.iceD_objectInitAsync(this, request),
                "objectAdded" => ObjectObserver.iceD_objectAddedAsync(this, request),
                "objectUpdated" => ObjectObserver.iceD_objectUpdatedAsync(this, request),
                "objectRemoved" => ObjectObserver.iceD_objectRemovedAsync(this, request),
                "adapterInit" => AdapterObserver.iceD_adapterInitAsync(this, request),
                "adapterAdded" => AdapterObserver.iceD_adapterAddedAsync(this, request),
                "adapterUpdated" => AdapterObserver.iceD_adapterUpdatedAsync(this, request),
                "adapterRemoved" => AdapterObserver.iceD_adapterRemovedAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }

    public abstract class ReplicaSessionDisp_ : Ice.ObjectImpl, ReplicaSession
    {
        public abstract void keepAlive(Ice.Current current);

        public abstract int getTimeout(Ice.Current current);

        public abstract void setDatabaseObserver(DatabaseObserverPrx? dbObs, global::System.Collections.Generic.Dictionary<string, long>? serials, Ice.Current current);

        public abstract void setEndpoints(global::System.Collections.Generic.Dictionary<string, global::Ice.ObjectPrx?> endpoints, Ice.Current current);

        public abstract void registerWellKnownObjects(ObjectInfo[] objects, Ice.Current current);

        public abstract void setAdapterDirectProxy(string adapterId, string replicaGroupId, global::Ice.ObjectPrx? proxy, Ice.Current current);

        public abstract void receivedUpdate(TopicName name, int serial, string failure, Ice.Current current);

        public abstract void destroy(Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::IceGrid::ReplicaSession";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "keepAlive" => ReplicaSession.iceD_keepAliveAsync(this, request),
                "getTimeout" => ReplicaSession.iceD_getTimeoutAsync(this, request),
                "setDatabaseObserver" => ReplicaSession.iceD_setDatabaseObserverAsync(this, request),
                "setEndpoints" => ReplicaSession.iceD_setEndpointsAsync(this, request),
                "registerWellKnownObjects" => ReplicaSession.iceD_registerWellKnownObjectsAsync(this, request),
                "setAdapterDirectProxy" => ReplicaSession.iceD_setAdapterDirectProxyAsync(this, request),
                "receivedUpdate" => ReplicaSession.iceD_receivedUpdateAsync(this, request),
                "destroy" => ReplicaSession.iceD_destroyAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }

    public abstract class InternalRegistryDisp_ : Ice.ObjectImpl, InternalRegistry
    {
        public abstract NodeSessionPrx? registerNode(InternalNodeInfo? info, NodePrx? prx, LoadInfo loadInf, Ice.Current current);

        public abstract ReplicaSessionPrx? registerReplica(InternalReplicaInfo? info, InternalRegistryPrx? prx, Ice.Current current);

        public abstract void registerWithReplica(InternalRegistryPrx? prx, Ice.Current current);

        public abstract NodePrx?[] getNodes(Ice.Current current);

        public abstract InternalRegistryPrx?[] getReplicas(Ice.Current current);

        public abstract ApplicationInfo[] getApplications(out long serial, Ice.Current current);

        public abstract AdapterInfo[] getAdapters(out long serial, Ice.Current current);

        public abstract ObjectInfo[] getObjects(out long serial, Ice.Current current);

        public abstract void shutdown(Ice.Current current);

        public abstract long getOffsetFromEnd(string filename, int lines, Ice.Current current);

        public abstract bool read(string filename, long pos, int size, out long newPos, out string[] lines, Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::IceGrid::InternalRegistry";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "getOffsetFromEnd" => FileReader.iceD_getOffsetFromEndAsync(this, request),
                "read" => FileReader.iceD_readAsync(this, request),
                "registerNode" => InternalRegistry.iceD_registerNodeAsync(this, request),
                "registerReplica" => InternalRegistry.iceD_registerReplicaAsync(this, request),
                "registerWithReplica" => InternalRegistry.iceD_registerWithReplicaAsync(this, request),
                "getNodes" => InternalRegistry.iceD_getNodesAsync(this, request),
                "getReplicas" => InternalRegistry.iceD_getReplicasAsync(this, request),
                "getApplications" => InternalRegistry.iceD_getApplicationsAsync(this, request),
                "getAdapters" => InternalRegistry.iceD_getAdaptersAsync(this, request),
                "getObjects" => InternalRegistry.iceD_getObjectsAsync(this, request),
                "shutdown" => InternalRegistry.iceD_shutdownAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }
}

namespace IceGrid
{
    public partial interface Adapter
    {
        protected static async global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_activateAsync(
            Adapter obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var result = await obj.activateAsync(request.current).ConfigureAwait(false);
            return Ice.CurrentExtensions.createOutgoingResponse(
                request.current,
                result,
                static (ostr, ret) =>
                {
                    ostr.writeProxy(ret);
                });
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getDirectProxyAsync(
            Adapter obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.getDirectProxy(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeProxy(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_setDirectProxyAsync(
            Adapter obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            global::Ice.ObjectPrx? iceP_proxy;
            iceP_proxy = istr.readProxy();
            istr.endEncapsulation();
            obj.setDirectProxy(iceP_proxy, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }
    }

    public partial interface FileReader
    {
        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getOffsetFromEndAsync(
            FileReader obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_filename;
            int iceP_lines;
            iceP_filename = istr.readString();
            iceP_lines = istr.readInt();
            istr.endEncapsulation();
            var ret = obj.getOffsetFromEnd(iceP_filename, iceP_lines, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeLong(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_readAsync(
            FileReader obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_filename;
            long iceP_pos;
            int iceP_size;
            iceP_filename = istr.readString();
            iceP_pos = istr.readLong();
            iceP_size = istr.readInt();
            istr.endEncapsulation();
            long iceP_newPos;
            string[] iceP_lines;
            var ret = obj.read(iceP_filename, iceP_pos, iceP_size, out iceP_newPos, out iceP_lines, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeLong(iceP_newPos);
            global::Ice.StringSeqHelper.write(ostr, iceP_lines);
            ostr.writeBool(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }
    }

    public partial interface Server
    {
        protected static async global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_startAsync(
            Server obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            await obj.startAsync(request.current).ConfigureAwait(false);
            return Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current);
        }

        protected static async global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_stopAsync(
            Server obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            await obj.stopAsync(request.current).ConfigureAwait(false);
            return Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current);
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_checkUpdateAsync(
            Server obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            InternalServerDescriptor? iceP_svr = null;
            bool iceP_noRestart;
            istr.readValue((InternalServerDescriptor? v) => { iceP_svr = v; });
            iceP_noRestart = istr.readBool();
            istr.readPendingValues();
            istr.endEncapsulation();
            var ret = obj.checkUpdate(iceP_svr, iceP_noRestart, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeBool(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_setEnabledAsync(
            Server obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            bool iceP_enable;
            iceP_enable = istr.readBool();
            istr.endEncapsulation();
            obj.setEnabled(iceP_enable, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_isEnabledAsync(
            Server obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.isEnabled(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeBool(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_sendSignalAsync(
            Server obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_signal;
            iceP_signal = istr.readString();
            istr.endEncapsulation();
            obj.sendSignal(iceP_signal, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_writeMessageAsync(
            Server obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_message;
            int iceP_fd;
            iceP_message = istr.readString();
            iceP_fd = istr.readInt();
            istr.endEncapsulation();
            obj.writeMessage(iceP_message, iceP_fd, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getStateAsync(
            Server obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.getState(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeEnum((int)ret, 6);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getPidAsync(
            Server obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.getPid(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeInt(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static async global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_setProcessAsync(
            Server obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            global::Ice.ProcessPrx? iceP_proc;
            iceP_proc = global::Ice.ProcessPrxHelper.read(istr);
            istr.endEncapsulation();
            await obj.setProcessAsync(iceP_proc, request.current).ConfigureAwait(false);
            return Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current);
        }
    }

    public partial interface ReplicaObserver
    {
        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_replicaInitAsync(
            ReplicaObserver obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            InternalRegistryPrx?[] iceP_replicas;
            iceP_replicas = InternalRegistryPrxSeqHelper.read(istr);
            istr.endEncapsulation();
            obj.replicaInit(iceP_replicas, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_replicaAddedAsync(
            ReplicaObserver obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            InternalRegistryPrx? iceP_replica;
            iceP_replica = InternalRegistryPrxHelper.read(istr);
            istr.endEncapsulation();
            obj.replicaAdded(iceP_replica, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_replicaRemovedAsync(
            ReplicaObserver obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            InternalRegistryPrx? iceP_replica;
            iceP_replica = InternalRegistryPrxHelper.read(istr);
            istr.endEncapsulation();
            obj.replicaRemoved(iceP_replica, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }
    }

    public partial interface Node
    {
        protected static async global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_loadServerAsync(
            Node obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            InternalServerDescriptor? iceP_svr = null;
            string iceP_replicaName;
            istr.readValue((InternalServerDescriptor? v) => { iceP_svr = v; });
            iceP_replicaName = istr.readString();
            istr.readPendingValues();
            istr.endEncapsulation();
            var result = await obj.loadServerAsync(iceP_svr, iceP_replicaName, request.current).ConfigureAwait(false);
            return Ice.CurrentExtensions.createOutgoingResponse(
                request.current,
                result,
                static (ostr, ret) =>
                {
                    AdapterPrxDictHelper.write(ostr, ret.adapters);
                    ostr.writeInt(ret.activateTimeout);
                    ostr.writeInt(ret.deactivateTimeout);
                    ServerPrxHelper.write(ostr, ret.returnValue);
                });
        }

        protected static async global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_loadServerWithoutRestartAsync(
            Node obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            InternalServerDescriptor? iceP_svr = null;
            string iceP_replicaName;
            istr.readValue((InternalServerDescriptor? v) => { iceP_svr = v; });
            iceP_replicaName = istr.readString();
            istr.readPendingValues();
            istr.endEncapsulation();
            var result = await obj.loadServerWithoutRestartAsync(iceP_svr, iceP_replicaName, request.current).ConfigureAwait(false);
            return Ice.CurrentExtensions.createOutgoingResponse(
                request.current,
                result,
                static (ostr, ret) =>
                {
                    AdapterPrxDictHelper.write(ostr, ret.adapters);
                    ostr.writeInt(ret.activateTimeout);
                    ostr.writeInt(ret.deactivateTimeout);
                    ServerPrxHelper.write(ostr, ret.returnValue);
                });
        }

        protected static async global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_destroyServerAsync(
            Node obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_name;
            string iceP_uuid;
            int iceP_revision;
            string iceP_replicaName;
            iceP_name = istr.readString();
            iceP_uuid = istr.readString();
            iceP_revision = istr.readInt();
            iceP_replicaName = istr.readString();
            istr.endEncapsulation();
            await obj.destroyServerAsync(iceP_name, iceP_uuid, iceP_revision, iceP_replicaName, request.current).ConfigureAwait(false);
            return Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current);
        }

        protected static async global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_destroyServerWithoutRestartAsync(
            Node obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_name;
            string iceP_uuid;
            int iceP_revision;
            string iceP_replicaName;
            iceP_name = istr.readString();
            iceP_uuid = istr.readString();
            iceP_revision = istr.readInt();
            iceP_replicaName = istr.readString();
            istr.endEncapsulation();
            await obj.destroyServerWithoutRestartAsync(iceP_name, iceP_uuid, iceP_revision, iceP_replicaName, request.current).ConfigureAwait(false);
            return Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current);
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_registerWithReplicaAsync(
            Node obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            InternalRegistryPrx? iceP_replica;
            iceP_replica = InternalRegistryPrxHelper.read(istr);
            istr.endEncapsulation();
            obj.registerWithReplica(iceP_replica, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getNameAsync(
            Node obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.getName(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeString(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getHostnameAsync(
            Node obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.getHostname(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeString(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getLoadAsync(
            Node obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.getLoad(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ret.ice_writeMembers(ostr);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getProcessorSocketCountAsync(
            Node obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.getProcessorSocketCount(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeInt(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_shutdownAsync(
            Node obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            obj.shutdown(request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }
    }

    public partial interface NodeSession
    {
        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_keepAliveAsync(
            NodeSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            LoadInfo iceP_load;
            iceP_load = new LoadInfo(istr);
            istr.endEncapsulation();
            obj.keepAlive(iceP_load, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_setReplicaObserverAsync(
            NodeSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            ReplicaObserverPrx? iceP_observer;
            iceP_observer = ReplicaObserverPrxHelper.read(istr);
            istr.endEncapsulation();
            obj.setReplicaObserver(iceP_observer, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getTimeoutAsync(
            NodeSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.getTimeout(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeInt(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getObserverAsync(
            NodeSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.getObserver(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            NodeObserverPrxHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static async global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_loadServersAsync(
            NodeSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            await obj.loadServersAsync(request.current).ConfigureAwait(false);
            return Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current);
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getServersAsync(
            NodeSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.getServers(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            global::Ice.StringSeqHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static async global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_waitForApplicationUpdateAsync(
            NodeSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_application;
            int iceP_revision;
            iceP_application = istr.readString();
            iceP_revision = istr.readInt();
            istr.endEncapsulation();
            await obj.waitForApplicationUpdateAsync(iceP_application, iceP_revision, request.current).ConfigureAwait(false);
            return Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current);
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_destroyAsync(
            NodeSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            obj.destroy(request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }
    }

    public partial interface DatabaseObserver
    {
    }

    public partial interface ReplicaSession
    {
        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_keepAliveAsync(
            ReplicaSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            obj.keepAlive(request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getTimeoutAsync(
            ReplicaSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.getTimeout(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeInt(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_setDatabaseObserverAsync(
            ReplicaSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            DatabaseObserverPrx? iceP_dbObs;
            global::System.Collections.Generic.Dictionary<string, long>? iceP_serials;
            iceP_dbObs = DatabaseObserverPrxHelper.read(istr);
            if (istr.readOptional(1, Ice.OptionalFormat.FSize))
            {
                istr.skip(4);
                global::System.Collections.Generic.Dictionary<string, long> tmpVal = new global::System.Collections.Generic.Dictionary<string, long>();
                tmpVal = StringLongDictHelper.read(istr);
                iceP_serials = tmpVal;
            }
            else
            {
                iceP_serials = null;
            }
            istr.endEncapsulation();
            obj.setDatabaseObserver(iceP_dbObs, iceP_serials, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_setEndpointsAsync(
            ReplicaSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            global::System.Collections.Generic.Dictionary<string, global::Ice.ObjectPrx?> iceP_endpoints;
            iceP_endpoints = StringObjectProxyDictHelper.read(istr);
            istr.endEncapsulation();
            obj.setEndpoints(iceP_endpoints, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_registerWellKnownObjectsAsync(
            ReplicaSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            ObjectInfo[] iceP_objects;
            iceP_objects = ObjectInfoSeqHelper.read(istr);
            istr.endEncapsulation();
            obj.registerWellKnownObjects(iceP_objects, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_setAdapterDirectProxyAsync(
            ReplicaSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_adapterId;
            string iceP_replicaGroupId;
            global::Ice.ObjectPrx? iceP_proxy;
            iceP_adapterId = istr.readString();
            iceP_replicaGroupId = istr.readString();
            iceP_proxy = istr.readProxy();
            istr.endEncapsulation();
            obj.setAdapterDirectProxy(iceP_adapterId, iceP_replicaGroupId, iceP_proxy, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_receivedUpdateAsync(
            ReplicaSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            TopicName iceP_name;
            int iceP_serial;
            string iceP_failure;
            iceP_name = (TopicName)istr.readEnum(4);
            iceP_serial = istr.readInt();
            iceP_failure = istr.readString();
            istr.endEncapsulation();
            obj.receivedUpdate(iceP_name, iceP_serial, iceP_failure, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_destroyAsync(
            ReplicaSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            obj.destroy(request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }
    }

    public partial interface InternalRegistry
    {
        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_registerNodeAsync(
            InternalRegistry obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            InternalNodeInfo? iceP_info = null;
            NodePrx? iceP_prx;
            LoadInfo iceP_loadInf;
            istr.readValue((InternalNodeInfo? v) => { iceP_info = v; });
            iceP_prx = NodePrxHelper.read(istr);
            iceP_loadInf = new LoadInfo(istr);
            istr.readPendingValues();
            istr.endEncapsulation();
            var ret = obj.registerNode(iceP_info, iceP_prx, iceP_loadInf, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            NodeSessionPrxHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_registerReplicaAsync(
            InternalRegistry obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            InternalReplicaInfo? iceP_info = null;
            InternalRegistryPrx? iceP_prx;
            istr.readValue((InternalReplicaInfo? v) => { iceP_info = v; });
            iceP_prx = InternalRegistryPrxHelper.read(istr);
            istr.readPendingValues();
            istr.endEncapsulation();
            var ret = obj.registerReplica(iceP_info, iceP_prx, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ReplicaSessionPrxHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_registerWithReplicaAsync(
            InternalRegistry obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            InternalRegistryPrx? iceP_prx;
            iceP_prx = InternalRegistryPrxHelper.read(istr);
            istr.endEncapsulation();
            obj.registerWithReplica(iceP_prx, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getNodesAsync(
            InternalRegistry obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.getNodes(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            NodePrxSeqHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getReplicasAsync(
            InternalRegistry obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.getReplicas(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            InternalRegistryPrxSeqHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getApplicationsAsync(
            InternalRegistry obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            long iceP_serial;
            var ret = obj.getApplications(out iceP_serial, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeLong(iceP_serial);
            ApplicationInfoSeqHelper.write(ostr, ret);
            ostr.writePendingValues();
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getAdaptersAsync(
            InternalRegistry obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            long iceP_serial;
            var ret = obj.getAdapters(out iceP_serial, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeLong(iceP_serial);
            AdapterInfoSeqHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getObjectsAsync(
            InternalRegistry obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            long iceP_serial;
            var ret = obj.getObjects(out iceP_serial, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeLong(iceP_serial);
            ObjectInfoSeqHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_shutdownAsync(
            InternalRegistry obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            obj.shutdown(request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }
    }
}
