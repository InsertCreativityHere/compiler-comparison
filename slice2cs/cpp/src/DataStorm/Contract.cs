//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Contract.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#nullable enable

[assembly:Ice.Slice("Contract.ice")]

#pragma warning disable CS1591 // Missing XML Comment
#pragma warning disable CS1573 // Parameter has no matching param tag in the XML comment
#pragma warning disable CS0612 // Type or member is obsolete
#pragma warning disable CS0618 // Type or member is obsolete
#pragma warning disable CS0619 // Type or member is obsolete

namespace DataStormContract
{
    /// <summary>
    /// The ClearHistoryPolicy enumeration defines the policy that determines when a reader clears its
    ///  DataSample history in response to various events.
    /// </summary>

    public enum ClearHistoryPolicy
    {
        /// <summary>
        /// The reader clears its history when a new DataSample is added.
        /// </summary>

        OnAdd,
        /// <summary>
        /// The reader clears its history when a DataSample is removed.
        /// </summary>

        OnRemove,
        /// <summary>
        /// The reader clears its history when any DataSample event occurs.
        /// </summary>

        OnAll,
        /// <summary>
        /// The reader clears its history when any DataSample event occurs, except for PartialUpdate events.
        /// </summary>

        OnAllExceptPartialUpdate,
        /// <summary>
        /// The reader never clears its history.
        /// </summary>

        Never
    }

    public sealed class ClearHistoryPolicyHelper
    {
        public static void write(Ice.OutputStream ostr, ClearHistoryPolicy v)
        {
            ostr.writeEnum((int)v, 4);
        }

        public static ClearHistoryPolicy read(Ice.InputStream istr)
        {
            ClearHistoryPolicy v;
            v = (ClearHistoryPolicy)istr.readEnum(4);
            return v;
        }
    }

    public sealed partial record class DataSample
    {
        public long id;

        public long keyId;

        public byte[] keyValue;

        public long timestamp;

        public long tag;

        public global::DataStorm.SampleEvent @event;

        public byte[] value;

        partial void ice_initialize();

        public DataSample(byte[] keyValue, byte[] value)
        {
            global::System.ArgumentNullException.ThrowIfNull(keyValue);
            this.keyValue = keyValue;
            global::System.ArgumentNullException.ThrowIfNull(value);
            this.value = value;
            ice_initialize();
        }

        public DataSample(long id, long keyId, byte[] keyValue, long timestamp, long tag, global::DataStorm.SampleEvent @event, byte[] value)
        {
            this.id = id;
            this.keyId = keyId;
            global::System.ArgumentNullException.ThrowIfNull(keyValue);
            this.keyValue = keyValue;
            this.timestamp = timestamp;
            this.tag = tag;
            this.@event = @event;
            global::System.ArgumentNullException.ThrowIfNull(value);
            this.value = value;
            ice_initialize();
        }

        public DataSample(Ice.InputStream istr)
        {
            this.id = istr.readLong();
            this.keyId = istr.readLong();
            this.keyValue = global::Ice.ByteSeqHelper.read(istr);
            this.timestamp = istr.readLong();
            this.tag = istr.readLong();
            this.@event = (global::DataStorm.SampleEvent)istr.readEnum(3);
            this.value = global::Ice.ByteSeqHelper.read(istr);
            ice_initialize();
        }

        public void ice_writeMembers(Ice.OutputStream ostr)
        {
            ostr.writeLong(this.id);
            ostr.writeLong(this.keyId);
            global::Ice.ByteSeqHelper.write(ostr, this.keyValue);
            ostr.writeLong(this.timestamp);
            ostr.writeLong(this.tag);
            ostr.writeEnum((int)this.@event, 3);
            global::Ice.ByteSeqHelper.write(ostr, this.value);
        }

        public static void ice_write(Ice.OutputStream ostr, DataSample v)
        {
            v.ice_writeMembers(ostr);
        }

        public static DataSample ice_read(Ice.InputStream istr) => new(istr);
    }

    public sealed partial record class DataSamples
    {
        public long id;

        public DataSample[] samples;

        partial void ice_initialize();

        public DataSamples(DataSample[] samples)
        {
            global::System.ArgumentNullException.ThrowIfNull(samples);
            this.samples = samples;
            ice_initialize();
        }

        public DataSamples(long id, DataSample[] samples)
        {
            this.id = id;
            global::System.ArgumentNullException.ThrowIfNull(samples);
            this.samples = samples;
            ice_initialize();
        }

        public DataSamples(Ice.InputStream istr)
        {
            this.id = istr.readLong();
            this.samples = DataSampleSeqHelper.read(istr);
            ice_initialize();
        }

        public void ice_writeMembers(Ice.OutputStream ostr)
        {
            ostr.writeLong(this.id);
            DataSampleSeqHelper.write(ostr, this.samples);
        }

        public static void ice_write(Ice.OutputStream ostr, DataSamples v)
        {
            v.ice_writeMembers(ostr);
        }

        public static DataSamples ice_read(Ice.InputStream istr) => new(istr);
    }

    public sealed partial record class ElementInfo
    {
        public long id;

        public string name = "";

        public byte[] value;

        partial void ice_initialize();

        public ElementInfo(byte[] value)
        {
            global::System.ArgumentNullException.ThrowIfNull(value);
            this.value = value;
            ice_initialize();
        }

        public ElementInfo(long id, string name, byte[] value)
        {
            this.id = id;
            global::System.ArgumentNullException.ThrowIfNull(name);
            this.name = name;
            global::System.ArgumentNullException.ThrowIfNull(value);
            this.value = value;
            ice_initialize();
        }

        public ElementInfo(Ice.InputStream istr)
        {
            this.id = istr.readLong();
            this.name = istr.readString();
            this.value = global::Ice.ByteSeqHelper.read(istr);
            ice_initialize();
        }

        public void ice_writeMembers(Ice.OutputStream ostr)
        {
            ostr.writeLong(this.id);
            ostr.writeString(this.name);
            global::Ice.ByteSeqHelper.write(ostr, this.value);
        }

        public static void ice_write(Ice.OutputStream ostr, ElementInfo v)
        {
            v.ice_writeMembers(ostr);
        }

        public static ElementInfo ice_read(Ice.InputStream istr) => new(istr);
    }

    public sealed partial record class TopicInfo
    {
        public string name = "";

        public long[] ids;

        partial void ice_initialize();

        public TopicInfo(long[] ids)
        {
            global::System.ArgumentNullException.ThrowIfNull(ids);
            this.ids = ids;
            ice_initialize();
        }

        public TopicInfo(string name, long[] ids)
        {
            global::System.ArgumentNullException.ThrowIfNull(name);
            this.name = name;
            global::System.ArgumentNullException.ThrowIfNull(ids);
            this.ids = ids;
            ice_initialize();
        }

        public TopicInfo(Ice.InputStream istr)
        {
            this.name = istr.readString();
            this.ids = global::Ice.LongSeqHelper.read(istr);
            ice_initialize();
        }

        public void ice_writeMembers(Ice.OutputStream ostr)
        {
            ostr.writeString(this.name);
            global::Ice.LongSeqHelper.write(ostr, this.ids);
        }

        public static void ice_write(Ice.OutputStream ostr, TopicInfo v)
        {
            v.ice_writeMembers(ostr);
        }

        public static TopicInfo ice_read(Ice.InputStream istr) => new(istr);
    }

    public sealed partial record class TopicSpec
    {
        public long id;

        public string name = "";

        public ElementInfo[] elements;

        public ElementInfo[] tags;

        partial void ice_initialize();

        public TopicSpec(ElementInfo[] elements, ElementInfo[] tags)
        {
            global::System.ArgumentNullException.ThrowIfNull(elements);
            this.elements = elements;
            global::System.ArgumentNullException.ThrowIfNull(tags);
            this.tags = tags;
            ice_initialize();
        }

        public TopicSpec(long id, string name, ElementInfo[] elements, ElementInfo[] tags)
        {
            this.id = id;
            global::System.ArgumentNullException.ThrowIfNull(name);
            this.name = name;
            global::System.ArgumentNullException.ThrowIfNull(elements);
            this.elements = elements;
            global::System.ArgumentNullException.ThrowIfNull(tags);
            this.tags = tags;
            ice_initialize();
        }

        public TopicSpec(Ice.InputStream istr)
        {
            this.id = istr.readLong();
            this.name = istr.readString();
            this.elements = ElementInfoSeqHelper.read(istr);
            this.tags = ElementInfoSeqHelper.read(istr);
            ice_initialize();
        }

        public void ice_writeMembers(Ice.OutputStream ostr)
        {
            ostr.writeLong(this.id);
            ostr.writeString(this.name);
            ElementInfoSeqHelper.write(ostr, this.elements);
            ElementInfoSeqHelper.write(ostr, this.tags);
        }

        public static void ice_write(Ice.OutputStream ostr, TopicSpec v)
        {
            v.ice_writeMembers(ostr);
        }

        public static TopicSpec ice_read(Ice.InputStream istr) => new(istr);
    }

    public sealed partial record class FilterInfo
    {
        public string name = "";

        public byte[] criteria;

        partial void ice_initialize();

        public FilterInfo(byte[] criteria)
        {
            global::System.ArgumentNullException.ThrowIfNull(criteria);
            this.criteria = criteria;
            ice_initialize();
        }

        public FilterInfo(string name, byte[] criteria)
        {
            global::System.ArgumentNullException.ThrowIfNull(name);
            this.name = name;
            global::System.ArgumentNullException.ThrowIfNull(criteria);
            this.criteria = criteria;
            ice_initialize();
        }

        public FilterInfo(Ice.InputStream istr)
        {
            this.name = istr.readString();
            this.criteria = global::Ice.ByteSeqHelper.read(istr);
            ice_initialize();
        }

        public void ice_writeMembers(Ice.OutputStream ostr)
        {
            ostr.writeString(this.name);
            global::Ice.ByteSeqHelper.write(ostr, this.criteria);
        }

        public static void ice_write(Ice.OutputStream ostr, FilterInfo v)
        {
            v.ice_writeMembers(ostr);
        }

        public static FilterInfo ice_read(Ice.InputStream istr) => new(istr);
    }

    [Ice.SliceTypeId("::DataStormContract::ElementConfig")]
    [Ice.CompactSliceTypeId(1)]
    public partial class ElementConfig : Ice.Value
    {
        public string? facet;

        public FilterInfo? sampleFilter;

        public string? name;

        public int? priority;

        public int? sampleCount;

        public int? sampleLifetime;

        public ClearHistoryPolicy? clearHistory;

        partial void ice_initialize();

        public ElementConfig(string? facet, FilterInfo? sampleFilter, string? name, int? priority, int? sampleCount, int? sampleLifetime, ClearHistoryPolicy? clearHistory)
        {
            this.facet = facet;
            this.sampleFilter = sampleFilter;
            this.name = name;
            this.priority = priority;
            this.sampleCount = sampleCount;
            this.sampleLifetime = sampleLifetime;
            this.clearHistory = clearHistory;
            ice_initialize();
        }

        public ElementConfig()
        {
            ice_initialize();
        }

        public static new string ice_staticId() => "::DataStormContract::ElementConfig";
        public override string ice_id() => ice_staticId();

        protected override void iceWriteImpl(Ice.OutputStream ostr_)
        {
            ostr_.startSlice(ice_staticId(), 1, true);
            ostr_.writeString(1, facet);
            if (sampleFilter is not null && ostr_.writeOptional(2, Ice.OptionalFormat.FSize))
            {
                int pos = ostr_.startSize();
                FilterInfo.ice_write(ostr_, sampleFilter);
                ostr_.endSize(pos);
            }
            ostr_.writeString(3, name);
            ostr_.writeInt(4, priority);
            ostr_.writeInt(10, sampleCount);
            ostr_.writeInt(11, sampleLifetime);
            if (clearHistory is not null)
            {
                ostr_.writeEnum(12, (int)clearHistory.Value, 5);
            }
            ostr_.endSlice();
        }

        protected override void iceReadImpl(Ice.InputStream istr_)
        {
            istr_.startSlice();
            facet = istr_.readString(1);
            if (istr_.readOptional(2, Ice.OptionalFormat.FSize))
            {
                istr_.skip(4);
                FilterInfo tmpVal;
                tmpVal = new FilterInfo(istr_);
                sampleFilter = tmpVal;
            }
            else
            {
                sampleFilter = null;
            }
            name = istr_.readString(3);
            priority = istr_.readInt(4);
            sampleCount = istr_.readInt(10);
            sampleLifetime = istr_.readInt(11);
            if (istr_.readOptional(12, Ice.OptionalFormat.Size))
            {
                ClearHistoryPolicy tmpVal;
                tmpVal = (ClearHistoryPolicy)istr_.readEnum(4);
                clearHistory = tmpVal;
            }
            else
            {
                clearHistory = null;
            }
            istr_.endSlice();
        }
    }

    public sealed partial record class ElementData
    {
        public long id;

        public ElementConfig? config;

        public global::System.Collections.Generic.Dictionary<long, long> lastIds;

        partial void ice_initialize();

        public ElementData(global::System.Collections.Generic.Dictionary<long, long> lastIds)
        {
            global::System.ArgumentNullException.ThrowIfNull(lastIds);
            this.lastIds = lastIds;
            ice_initialize();
        }

        public ElementData(long id, ElementConfig? config, global::System.Collections.Generic.Dictionary<long, long> lastIds)
        {
            this.id = id;
            this.config = config;
            global::System.ArgumentNullException.ThrowIfNull(lastIds);
            this.lastIds = lastIds;
            ice_initialize();
        }

        public ElementData(Ice.InputStream istr)
        {
            this.id = istr.readLong();
            istr.readValue((ElementConfig? v) => { this.config = v; });
            this.lastIds = LongLongDictHelper.read(istr);
            ice_initialize();
        }

        public void ice_writeMembers(Ice.OutputStream ostr)
        {
            ostr.writeLong(this.id);
            ostr.writeValue(this.config);
            LongLongDictHelper.write(ostr, this.lastIds);
        }

        public static void ice_write(Ice.OutputStream ostr, ElementData v)
        {
            v.ice_writeMembers(ostr);
        }

        public static ElementData ice_read(Ice.InputStream istr) => new(istr);
    }

    public sealed partial record class ElementSpec
    {
        public ElementData[] elements;

        public long id;

        public string name = "";

        public byte[] value;

        public long peerId;

        public string peerName = "";

        partial void ice_initialize();

        public ElementSpec(ElementData[] elements, byte[] value)
        {
            global::System.ArgumentNullException.ThrowIfNull(elements);
            this.elements = elements;
            global::System.ArgumentNullException.ThrowIfNull(value);
            this.value = value;
            ice_initialize();
        }

        public ElementSpec(ElementData[] elements, long id, string name, byte[] value, long peerId, string peerName)
        {
            global::System.ArgumentNullException.ThrowIfNull(elements);
            this.elements = elements;
            this.id = id;
            global::System.ArgumentNullException.ThrowIfNull(name);
            this.name = name;
            global::System.ArgumentNullException.ThrowIfNull(value);
            this.value = value;
            this.peerId = peerId;
            global::System.ArgumentNullException.ThrowIfNull(peerName);
            this.peerName = peerName;
            ice_initialize();
        }

        public ElementSpec(Ice.InputStream istr)
        {
            this.elements = ElementDataSeqHelper.read(istr);
            this.id = istr.readLong();
            this.name = istr.readString();
            this.value = global::Ice.ByteSeqHelper.read(istr);
            this.peerId = istr.readLong();
            this.peerName = istr.readString();
            ice_initialize();
        }

        public void ice_writeMembers(Ice.OutputStream ostr)
        {
            ElementDataSeqHelper.write(ostr, this.elements);
            ostr.writeLong(this.id);
            ostr.writeString(this.name);
            global::Ice.ByteSeqHelper.write(ostr, this.value);
            ostr.writeLong(this.peerId);
            ostr.writeString(this.peerName);
        }

        public static void ice_write(Ice.OutputStream ostr, ElementSpec v)
        {
            v.ice_writeMembers(ostr);
        }

        public static ElementSpec ice_read(Ice.InputStream istr) => new(istr);
    }

    public sealed partial record class ElementDataAck
    {
        public long id;

        public ElementConfig? config;

        public global::System.Collections.Generic.Dictionary<long, long> lastIds;

        public DataSample[] samples;

        public long peerId;

        partial void ice_initialize();

        public ElementDataAck(global::System.Collections.Generic.Dictionary<long, long> lastIds, DataSample[] samples)
        {
            global::System.ArgumentNullException.ThrowIfNull(lastIds);
            this.lastIds = lastIds;
            global::System.ArgumentNullException.ThrowIfNull(samples);
            this.samples = samples;
            ice_initialize();
        }

        public ElementDataAck(long id, ElementConfig? config, global::System.Collections.Generic.Dictionary<long, long> lastIds, DataSample[] samples, long peerId)
        {
            this.id = id;
            this.config = config;
            global::System.ArgumentNullException.ThrowIfNull(lastIds);
            this.lastIds = lastIds;
            global::System.ArgumentNullException.ThrowIfNull(samples);
            this.samples = samples;
            this.peerId = peerId;
            ice_initialize();
        }

        public ElementDataAck(Ice.InputStream istr)
        {
            this.id = istr.readLong();
            istr.readValue((ElementConfig? v) => { this.config = v; });
            this.lastIds = LongLongDictHelper.read(istr);
            this.samples = DataSampleSeqHelper.read(istr);
            this.peerId = istr.readLong();
            ice_initialize();
        }

        public void ice_writeMembers(Ice.OutputStream ostr)
        {
            ostr.writeLong(this.id);
            ostr.writeValue(this.config);
            LongLongDictHelper.write(ostr, this.lastIds);
            DataSampleSeqHelper.write(ostr, this.samples);
            ostr.writeLong(this.peerId);
        }

        public static void ice_write(Ice.OutputStream ostr, ElementDataAck v)
        {
            v.ice_writeMembers(ostr);
        }

        public static ElementDataAck ice_read(Ice.InputStream istr) => new(istr);
    }

    public sealed partial record class ElementSpecAck
    {
        public ElementDataAck[] elements;

        public long id;

        public string name = "";

        public byte[] value;

        public long peerId;

        public string peerName = "";

        partial void ice_initialize();

        public ElementSpecAck(ElementDataAck[] elements, byte[] value)
        {
            global::System.ArgumentNullException.ThrowIfNull(elements);
            this.elements = elements;
            global::System.ArgumentNullException.ThrowIfNull(value);
            this.value = value;
            ice_initialize();
        }

        public ElementSpecAck(ElementDataAck[] elements, long id, string name, byte[] value, long peerId, string peerName)
        {
            global::System.ArgumentNullException.ThrowIfNull(elements);
            this.elements = elements;
            this.id = id;
            global::System.ArgumentNullException.ThrowIfNull(name);
            this.name = name;
            global::System.ArgumentNullException.ThrowIfNull(value);
            this.value = value;
            this.peerId = peerId;
            global::System.ArgumentNullException.ThrowIfNull(peerName);
            this.peerName = peerName;
            ice_initialize();
        }

        public ElementSpecAck(Ice.InputStream istr)
        {
            this.elements = ElementDataAckSeqHelper.read(istr);
            this.id = istr.readLong();
            this.name = istr.readString();
            this.value = global::Ice.ByteSeqHelper.read(istr);
            this.peerId = istr.readLong();
            this.peerName = istr.readString();
            ice_initialize();
        }

        public void ice_writeMembers(Ice.OutputStream ostr)
        {
            ElementDataAckSeqHelper.write(ostr, this.elements);
            ostr.writeLong(this.id);
            ostr.writeString(this.name);
            global::Ice.ByteSeqHelper.write(ostr, this.value);
            ostr.writeLong(this.peerId);
            ostr.writeString(this.peerName);
        }

        public static void ice_write(Ice.OutputStream ostr, ElementSpecAck v)
        {
            v.ice_writeMembers(ostr);
        }

        public static ElementSpecAck ice_read(Ice.InputStream istr) => new(istr);
    }

    [Ice.SliceTypeId("::DataStormContract::Session")]
    public partial interface Session : Ice.Object
    {
        /// <summary>
        /// Announces existing topics to the peer during session establishment.
        /// A publisher session announces the topics it writes, while a subscriber session announces the topics it reads.
        ///
        ///  The peer receiving the announcement will invoke `attachTopic` for the topics it is interested in.
        ///
        /// </summary>
        ///  <param name="topics">The sequence of topics to announce.
        ///  </param>
        /// <param name="initialize">Currently unused.
        ///  </param>
        /// <param name="current">The Current object for the dispatch.</param>

        void announceTopics(TopicInfo[] topics, bool initialize, Ice.Current current);

        /// <summary>
        /// Attaches a local topic to a remote topic when a session receives a topic announcement from a peer.
        /// This method is called if the session is interested in the announced topic, which occurs when:
        ///  - The session has a reader for a topic that the peer has a writer for, or
        ///  - The session has a writer for a topic that the peer has a reader for.
        ///
        /// </summary>
        ///  <param name="topic">The TopicSpec object describing the topic being attached to the remote topic.</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void attachTopic(TopicSpec topic, Ice.Current current);

        void detachTopic(long topic, Ice.Current current);

        void attachTags(long topic, ElementInfo[] tags, bool initialize, Ice.Current current);

        void detachTags(long topic, long[] tags, Ice.Current current);

        /// <summary>
        /// Announces new elements to the peer.
        /// The peer will invoke `attachElements` for the elements it is interested in. The announced elements include
        ///  key readers, key writers, and filter readers associated with the specified topic.
        ///
        /// </summary>
        ///  <param name="topic">The ID of the topic associated with the elements.
        ///  </param>
        /// <param name="elements">The sequence of elements to announce.
        ///  </param>
        /// <param name="current">The Current object for the dispatch.</param>

        void announceElements(long topic, ElementInfo[] elements, Ice.Current current);

        void attachElements(long topic, ElementSpec[] elements, bool initialize, Ice.Current current);

        void attachElementsAck(long topic, ElementSpecAck[] elements, Ice.Current current);

        void detachElements(long topic, long[] keys, Ice.Current current);

        void initSamples(long topic, DataSamples[] samples, Ice.Current current);

        void disconnected(Ice.Current current);
    }

    [Ice.SliceTypeId("::DataStormContract::PublisherSession")]
    public partial interface PublisherSession : Session
    {
    }

    [Ice.SliceTypeId("::DataStormContract::SubscriberSession")]
    public partial interface SubscriberSession : Session
    {
        void s(long topicId, long elementId, DataSample sample, Ice.Current current);
    }

    [Ice.SliceTypeId("::DataStormContract::Node")]
    public partial interface Node : Ice.Object
    {
        /// <summary>
        /// Initiate the creation of a publisher session with a node, after the target node has announced a topic
        ///  reader for which this node has a corresponding topic writer.
        /// </summary>
        /// <param name="publisher">The publisher node initiating the session. The proxy is never null.
        ///  </param>
        /// <param name="current">The Current object for the dispatch.</param>

        void initiateCreateSession(NodePrx? publisher, Ice.Current current);

        /// <summary>
        /// Initiate the creation of a subscriber session with a node, after the target node has announced a topic
        ///  writer for which this node has a corresponding topic reader, or after the node has called
        ///  Node::initiateCreateSession.
        /// </summary>
        /// <param name="subscriber">The subscriber node initiating the session. The proxy is never null.
        ///  </param>
        /// <param name="session">The subscriber session being created. The proxy is never null.
        ///  </param>
        /// <param name="fromRelay">Indicates if the session is being created from a relay node.</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void createSession(NodePrx? subscriber, SubscriberSessionPrx? session, bool fromRelay, Ice.Current current);

        /// <summary>
        /// Confirm the creation of a publisher session with a node.
        /// </summary>
        /// <param name="publisher">The publisher node confirming the session. The proxy is never null.
        ///  </param>
        /// <param name="session">The publisher session being confirmed. The proxy is never null.</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void confirmCreateSession(NodePrx? publisher, PublisherSessionPrx? session, Ice.Current current);
    }

    [Ice.SliceTypeId("::DataStormContract::Lookup")]
    public partial interface Lookup : Ice.Object
    {
        /// <summary>
        /// Announce a topic reader.
        /// </summary>
        /// <param name="topic">The name of the topic.
        ///  </param>
        /// <param name="subscriber">The node reading the topic. The subscriber proxy is never null.</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void announceTopicReader(string topic, NodePrx? subscriber, Ice.Current current);

        /// <summary>
        /// Announce a topic writer.
        /// </summary>
        /// <param name="topic">The name of the topic.
        ///  </param>
        /// <param name="node">The node writing the topic. The proxy is never null.</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void announceTopicWriter(string topic, NodePrx? node, Ice.Current current);

        /// <summary>
        /// Announce a set of topic readers and writers.
        /// </summary>
        /// <param name="readers">A sequence of topic names for readers.
        ///  </param>
        /// <param name="writers">A sequence of topic names for writers.
        ///  </param>
        /// <param name="node">The node reading or writing the topics. The proxy is never null.</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void announceTopics(string[] readers, string[] writers, NodePrx? node, Ice.Current current);

        /// <summary>
        /// Establish a connection between this node and another node.
        /// </summary>
        /// <param name="node">The node initiating the connection. The proxy is never null.
        ///  </param>
        /// <returns>A proxy to this node. The proxy is never null.</returns>
        /// <param name="current">The Current object for the dispatch.</param>

        NodePrx? createSession(NodePrx? node, Ice.Current current);
    }
}

namespace DataStormContract
{
    public interface SessionPrx : Ice.ObjectPrx
    {
        /// <summary>
        /// Announces existing topics to the peer during session establishment.
        /// A publisher session announces the topics it writes, while a subscriber session announces the topics it reads.
        ///
        ///  The peer receiving the announcement will invoke `attachTopic` for the topics it is interested in.
        ///
        /// </summary>
        ///  <param name="topics">The sequence of topics to announce.
        ///  </param>
        /// <param name="initialize">Currently unused.
        ///  </param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void announceTopics(TopicInfo[] topics, bool initialize, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Announces existing topics to the peer during session establishment.
        /// A publisher session announces the topics it writes, while a subscriber session announces the topics it reads.
        /// </summary>
        ///  <param name="topics">The sequence of topics to announce.
        ///  </param>
        /// <param name="initialize">Currently unused.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task announceTopicsAsync(TopicInfo[] topics, bool initialize, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Attaches a local topic to a remote topic when a session receives a topic announcement from a peer.
        /// This method is called if the session is interested in the announced topic, which occurs when:
        ///  - The session has a reader for a topic that the peer has a writer for, or
        ///  - The session has a writer for a topic that the peer has a reader for.
        ///
        /// </summary>
        ///  <param name="topic">The TopicSpec object describing the topic being attached to the remote topic.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void attachTopic(TopicSpec topic, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Attaches a local topic to a remote topic when a session receives a topic announcement from a peer.
        /// This method is called if the session is interested in the announced topic, which occurs when:
        /// </summary>
        ///  <param name="topic">The TopicSpec object describing the topic being attached to the remote topic.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task attachTopicAsync(TopicSpec topic, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        void detachTopic(long topic, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        global::System.Threading.Tasks.Task detachTopicAsync(long topic, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        void attachTags(long topic, ElementInfo[] tags, bool initialize, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        global::System.Threading.Tasks.Task attachTagsAsync(long topic, ElementInfo[] tags, bool initialize, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        void detachTags(long topic, long[] tags, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        global::System.Threading.Tasks.Task detachTagsAsync(long topic, long[] tags, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Announces new elements to the peer.
        /// The peer will invoke `attachElements` for the elements it is interested in. The announced elements include
        ///  key readers, key writers, and filter readers associated with the specified topic.
        ///
        /// </summary>
        ///  <param name="topic">The ID of the topic associated with the elements.
        ///  </param>
        /// <param name="elements">The sequence of elements to announce.
        ///  </param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void announceElements(long topic, ElementInfo[] elements, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Announces new elements to the peer.
        /// The peer will invoke `attachElements` for the elements it is interested in. The announced elements include
        /// </summary>
        ///  <param name="topic">The ID of the topic associated with the elements.
        ///  </param>
        /// <param name="elements">The sequence of elements to announce.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task announceElementsAsync(long topic, ElementInfo[] elements, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        void attachElements(long topic, ElementSpec[] elements, bool initialize, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        global::System.Threading.Tasks.Task attachElementsAsync(long topic, ElementSpec[] elements, bool initialize, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        void attachElementsAck(long topic, ElementSpecAck[] elements, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        global::System.Threading.Tasks.Task attachElementsAckAsync(long topic, ElementSpecAck[] elements, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        void detachElements(long topic, long[] keys, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        global::System.Threading.Tasks.Task detachElementsAsync(long topic, long[] keys, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        void initSamples(long topic, DataSamples[] samples, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        global::System.Threading.Tasks.Task initSamplesAsync(long topic, DataSamples[] samples, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        void disconnected(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        global::System.Threading.Tasks.Task disconnectedAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }

    public interface PublisherSessionPrx : SessionPrx
    {
    }

    public interface SubscriberSessionPrx : SessionPrx
    {
        void s(long topicId, long elementId, DataSample sample, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        global::System.Threading.Tasks.Task sAsync(long topicId, long elementId, DataSample sample, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }

    /// <summary>
    /// The Node interface allows DataStorm nodes to create publisher and subscriber sessions with each other.
    /// When a node has a writer for a topic that another node is reading, the node initiates the creation of a
    ///  publisher session. Likewise, when a node has a reader for a topic that another node is writing, the node
    ///  initiates the creation of a subscriber session.
    ///
    ///  The publisher node hosts the publisher session servant, which is accessed by the subscriber node through a
    ///  PublisherSession proxy. The subscriber node hosts the subscriber session servant, which is accessed by the
    ///  publisher node through a SubscriberSession proxy.
    /// </summary>

    public interface NodePrx : Ice.ObjectPrx
    {
        /// <summary>
        /// Initiate the creation of a publisher session with a node, after the target node has announced a topic
        ///  reader for which this node has a corresponding topic writer.
        /// </summary>
        /// <param name="publisher">The publisher node initiating the session. The proxy is never null.
        ///  </param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void initiateCreateSession(NodePrx? publisher, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Initiate the creation of a publisher session with a node, after the target node has announced a topic
        ///  reader for which this node has a corresponding topic writer.
        /// </summary>
        /// <param name="publisher">The publisher node initiating the session. The proxy is never null.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task initiateCreateSessionAsync(NodePrx? publisher, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Initiate the creation of a subscriber session with a node, after the target node has announced a topic
        ///  writer for which this node has a corresponding topic reader, or after the node has called
        ///  Node::initiateCreateSession.
        /// </summary>
        /// <param name="subscriber">The subscriber node initiating the session. The proxy is never null.
        ///  </param>
        /// <param name="session">The subscriber session being created. The proxy is never null.
        ///  </param>
        /// <param name="fromRelay">Indicates if the session is being created from a relay node.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void createSession(NodePrx? subscriber, SubscriberSessionPrx? session, bool fromRelay, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Initiate the creation of a subscriber session with a node, after the target node has announced a topic
        ///  writer for which this node has a corresponding topic reader, or after the node has called
        ///  Node::initiateCreateSession.
        /// </summary>
        /// <param name="subscriber">The subscriber node initiating the session. The proxy is never null.
        ///  </param>
        /// <param name="session">The subscriber session being created. The proxy is never null.
        ///  </param>
        /// <param name="fromRelay">Indicates if the session is being created from a relay node.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task createSessionAsync(NodePrx? subscriber, SubscriberSessionPrx? session, bool fromRelay, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Confirm the creation of a publisher session with a node.
        /// </summary>
        /// <param name="publisher">The publisher node confirming the session. The proxy is never null.
        ///  </param>
        /// <param name="session">The publisher session being confirmed. The proxy is never null.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void confirmCreateSession(NodePrx? publisher, PublisherSessionPrx? session, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Confirm the creation of a publisher session with a node.
        /// </summary>
        /// <param name="publisher">The publisher node confirming the session. The proxy is never null.
        ///  </param>
        /// <param name="session">The publisher session being confirmed. The proxy is never null.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task confirmCreateSessionAsync(NodePrx? publisher, PublisherSessionPrx? session, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }

    /// <summary>
    /// The lookup interface is used by DataStorm nodes to announce their topic readers and writers to other connected
    ///  nodes.
    /// When multicast is enabled, the lookup interface also broadcasts these announcements.
    ///  Each DataStorm node hosts a lookup servant with the identity "DataStorm/Lookup".
    /// </summary>

    public interface LookupPrx : Ice.ObjectPrx
    {
        /// <summary>
        /// Announce a topic reader.
        /// </summary>
        /// <param name="topic">The name of the topic.
        ///  </param>
        /// <param name="subscriber">The node reading the topic. The subscriber proxy is never null.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void announceTopicReader(string topic, NodePrx? subscriber, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Announce a topic reader.
        /// </summary>
        /// <param name="topic">The name of the topic.
        ///  </param>
        /// <param name="subscriber">The node reading the topic. The subscriber proxy is never null.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task announceTopicReaderAsync(string topic, NodePrx? subscriber, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Announce a topic writer.
        /// </summary>
        /// <param name="topic">The name of the topic.
        ///  </param>
        /// <param name="node">The node writing the topic. The proxy is never null.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void announceTopicWriter(string topic, NodePrx? node, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Announce a topic writer.
        /// </summary>
        /// <param name="topic">The name of the topic.
        ///  </param>
        /// <param name="node">The node writing the topic. The proxy is never null.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task announceTopicWriterAsync(string topic, NodePrx? node, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Announce a set of topic readers and writers.
        /// </summary>
        /// <param name="readers">A sequence of topic names for readers.
        ///  </param>
        /// <param name="writers">A sequence of topic names for writers.
        ///  </param>
        /// <param name="node">The node reading or writing the topics. The proxy is never null.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void announceTopics(string[] readers, string[] writers, NodePrx? node, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Announce a set of topic readers and writers.
        /// </summary>
        /// <param name="readers">A sequence of topic names for readers.
        ///  </param>
        /// <param name="writers">A sequence of topic names for writers.
        ///  </param>
        /// <param name="node">The node reading or writing the topics. The proxy is never null.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task announceTopicsAsync(string[] readers, string[] writers, NodePrx? node, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Establish a connection between this node and another node.
        /// </summary>
        /// <param name="node">The node initiating the connection. The proxy is never null.
        ///  </param>
        /// <returns>A proxy to this node. The proxy is never null.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        NodePrx? createSession(NodePrx? node, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Establish a connection between this node and another node.
        /// </summary>
        /// <param name="node">The node initiating the connection. The proxy is never null.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<NodePrx?> createSessionAsync(NodePrx? node, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }
}

namespace DataStormContract
{
    public sealed class LongLongDictHelper
    {
        public static void write(Ice.OutputStream ostr,
                                 global::System.Collections.Generic.Dictionary<long, long> v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Count);
                foreach(global::System.Collections.Generic.KeyValuePair<long, long> e in v)
                {
                    ostr.writeLong(e.Key);
                    ostr.writeLong(e.Value);
                }
            }
        }

        public static global::System.Collections.Generic.Dictionary<long, long> read(Ice.InputStream istr)
        {
            int sz = istr.readSize();
            global::System.Collections.Generic.Dictionary<long, long> r = new global::System.Collections.Generic.Dictionary<long, long>();
            for(int i = 0; i < sz; ++i)
            {
                long k;
                k = istr.readLong();
                long v;
                v = istr.readLong();
                r[k] = v;
            }
            return r;
        }
    }

    public sealed class DataSampleSeqHelper
    {
        public static void write(Ice.OutputStream ostr, DataSample[] v)
        {
            if (v is null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    v[ix].ice_writeMembers(ostr);
                }
            }
        }

        public static DataSample[] read(Ice.InputStream istr)
        {
            DataSample[] v;
            {
                int szx = istr.readAndCheckSeqSize(35);
                v = new DataSample[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new DataSample(istr);
                }
            }
            return v;
        }
    }

    public sealed class DataSamplesSeqHelper
    {
        public static void write(Ice.OutputStream ostr, DataSamples[] v)
        {
            if (v is null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    v[ix].ice_writeMembers(ostr);
                }
            }
        }

        public static DataSamples[] read(Ice.InputStream istr)
        {
            DataSamples[] v;
            {
                int szx = istr.readAndCheckSeqSize(9);
                v = new DataSamples[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new DataSamples(istr);
                }
            }
            return v;
        }
    }

    public sealed class ElementInfoSeqHelper
    {
        public static void write(Ice.OutputStream ostr, ElementInfo[] v)
        {
            if (v is null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    v[ix].ice_writeMembers(ostr);
                }
            }
        }

        public static ElementInfo[] read(Ice.InputStream istr)
        {
            ElementInfo[] v;
            {
                int szx = istr.readAndCheckSeqSize(10);
                v = new ElementInfo[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new ElementInfo(istr);
                }
            }
            return v;
        }
    }

    public sealed class TopicInfoSeqHelper
    {
        public static void write(Ice.OutputStream ostr, TopicInfo[] v)
        {
            if (v is null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    v[ix].ice_writeMembers(ostr);
                }
            }
        }

        public static TopicInfo[] read(Ice.InputStream istr)
        {
            TopicInfo[] v;
            {
                int szx = istr.readAndCheckSeqSize(2);
                v = new TopicInfo[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new TopicInfo(istr);
                }
            }
            return v;
        }
    }

    public sealed class ElementDataSeqHelper
    {
        public static void write(Ice.OutputStream ostr, ElementData[] v)
        {
            if (v is null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    v[ix].ice_writeMembers(ostr);
                }
            }
        }

        public static ElementData[] read(Ice.InputStream istr)
        {
            ElementData[] v;
            {
                int szx = istr.readAndCheckSeqSize(10);
                v = new ElementData[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new ElementData(istr);
                }
            }
            return v;
        }
    }

    public sealed class ElementSpecSeqHelper
    {
        public static void write(Ice.OutputStream ostr, ElementSpec[] v)
        {
            if (v is null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    v[ix].ice_writeMembers(ostr);
                }
            }
        }

        public static ElementSpec[] read(Ice.InputStream istr)
        {
            ElementSpec[] v;
            {
                int szx = istr.readAndCheckSeqSize(20);
                v = new ElementSpec[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new ElementSpec(istr);
                }
            }
            return v;
        }
    }

    public sealed class ElementDataAckSeqHelper
    {
        public static void write(Ice.OutputStream ostr, ElementDataAck[] v)
        {
            if (v is null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    v[ix].ice_writeMembers(ostr);
                }
            }
        }

        public static ElementDataAck[] read(Ice.InputStream istr)
        {
            ElementDataAck[] v;
            {
                int szx = istr.readAndCheckSeqSize(19);
                v = new ElementDataAck[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new ElementDataAck(istr);
                }
            }
            return v;
        }
    }

    public sealed class ElementSpecAckSeqHelper
    {
        public static void write(Ice.OutputStream ostr, ElementSpecAck[] v)
        {
            if (v is null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    v[ix].ice_writeMembers(ostr);
                }
            }
        }

        public static ElementSpecAck[] read(Ice.InputStream istr)
        {
            ElementSpecAck[] v;
            {
                int szx = istr.readAndCheckSeqSize(20);
                v = new ElementSpecAck[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new ElementSpecAck(istr);
                }
            }
            return v;
        }
    }

    public sealed class SessionPrxHelper : Ice.ObjectPrxHelperBase, SessionPrx
    {
        public void announceTopics(TopicInfo[] topics, bool initialize, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_announceTopicsAsync(topics, initialize, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void attachTopic(TopicSpec topic, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_attachTopicAsync(topic, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void detachTopic(long topic, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_detachTopicAsync(topic, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void attachTags(long topic, ElementInfo[] tags, bool initialize, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_attachTagsAsync(topic, tags, initialize, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void detachTags(long topic, long[] tags, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_detachTagsAsync(topic, tags, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void announceElements(long topic, ElementInfo[] elements, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_announceElementsAsync(topic, elements, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void attachElements(long topic, ElementSpec[] elements, bool initialize, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_attachElementsAsync(topic, elements, initialize, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void attachElementsAck(long topic, ElementSpecAck[] elements, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_attachElementsAckAsync(topic, elements, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void detachElements(long topic, long[] keys, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_detachElementsAsync(topic, keys, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void initSamples(long topic, DataSamples[] samples, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_initSamplesAsync(topic, samples, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void disconnected(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_disconnectedAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task announceTopicsAsync(TopicInfo[] topics, bool initialize, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_announceTopicsAsync(topics, initialize, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_announceTopicsAsync(TopicInfo[] iceP_topics, bool iceP_initialize, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_announceTopics(iceP_topics, iceP_initialize, context, synchronous, completed);
            return completed.Task;
        }

        private const string _announceTopics_name = "announceTopics";

        private void _iceI_announceTopics(TopicInfo[] iceP_topics, bool iceP_initialize, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _announceTopics_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    TopicInfoSeqHelper.write(ostr, iceP_topics);
                    ostr.writeBool(iceP_initialize);
                });
        }

        public global::System.Threading.Tasks.Task attachTopicAsync(TopicSpec topic, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_attachTopicAsync(topic, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_attachTopicAsync(TopicSpec iceP_topic, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_attachTopic(iceP_topic, context, synchronous, completed);
            return completed.Task;
        }

        private const string _attachTopic_name = "attachTopic";

        private void _iceI_attachTopic(TopicSpec iceP_topic, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _attachTopic_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    TopicSpec.ice_write(ostr, iceP_topic);
                });
        }

        public global::System.Threading.Tasks.Task detachTopicAsync(long topic, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_detachTopicAsync(topic, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_detachTopicAsync(long iceP_topic, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_detachTopic(iceP_topic, context, synchronous, completed);
            return completed.Task;
        }

        private const string _detachTopic_name = "detachTopic";

        private void _iceI_detachTopic(long iceP_topic, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _detachTopic_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeLong(iceP_topic);
                });
        }

        public global::System.Threading.Tasks.Task attachTagsAsync(long topic, ElementInfo[] tags, bool initialize, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_attachTagsAsync(topic, tags, initialize, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_attachTagsAsync(long iceP_topic, ElementInfo[] iceP_tags, bool iceP_initialize, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_attachTags(iceP_topic, iceP_tags, iceP_initialize, context, synchronous, completed);
            return completed.Task;
        }

        private const string _attachTags_name = "attachTags";

        private void _iceI_attachTags(long iceP_topic, ElementInfo[] iceP_tags, bool iceP_initialize, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _attachTags_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeLong(iceP_topic);
                    ElementInfoSeqHelper.write(ostr, iceP_tags);
                    ostr.writeBool(iceP_initialize);
                });
        }

        public global::System.Threading.Tasks.Task detachTagsAsync(long topic, long[] tags, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_detachTagsAsync(topic, tags, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_detachTagsAsync(long iceP_topic, long[] iceP_tags, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_detachTags(iceP_topic, iceP_tags, context, synchronous, completed);
            return completed.Task;
        }

        private const string _detachTags_name = "detachTags";

        private void _iceI_detachTags(long iceP_topic, long[] iceP_tags, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _detachTags_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeLong(iceP_topic);
                    global::Ice.LongSeqHelper.write(ostr, iceP_tags);
                });
        }

        public global::System.Threading.Tasks.Task announceElementsAsync(long topic, ElementInfo[] elements, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_announceElementsAsync(topic, elements, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_announceElementsAsync(long iceP_topic, ElementInfo[] iceP_elements, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_announceElements(iceP_topic, iceP_elements, context, synchronous, completed);
            return completed.Task;
        }

        private const string _announceElements_name = "announceElements";

        private void _iceI_announceElements(long iceP_topic, ElementInfo[] iceP_elements, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _announceElements_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeLong(iceP_topic);
                    ElementInfoSeqHelper.write(ostr, iceP_elements);
                });
        }

        public global::System.Threading.Tasks.Task attachElementsAsync(long topic, ElementSpec[] elements, bool initialize, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_attachElementsAsync(topic, elements, initialize, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_attachElementsAsync(long iceP_topic, ElementSpec[] iceP_elements, bool iceP_initialize, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_attachElements(iceP_topic, iceP_elements, iceP_initialize, context, synchronous, completed);
            return completed.Task;
        }

        private const string _attachElements_name = "attachElements";

        private void _iceI_attachElements(long iceP_topic, ElementSpec[] iceP_elements, bool iceP_initialize, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _attachElements_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeLong(iceP_topic);
                    ElementSpecSeqHelper.write(ostr, iceP_elements);
                    ostr.writeBool(iceP_initialize);
                    ostr.writePendingValues();
                });
        }

        public global::System.Threading.Tasks.Task attachElementsAckAsync(long topic, ElementSpecAck[] elements, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_attachElementsAckAsync(topic, elements, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_attachElementsAckAsync(long iceP_topic, ElementSpecAck[] iceP_elements, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_attachElementsAck(iceP_topic, iceP_elements, context, synchronous, completed);
            return completed.Task;
        }

        private const string _attachElementsAck_name = "attachElementsAck";

        private void _iceI_attachElementsAck(long iceP_topic, ElementSpecAck[] iceP_elements, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _attachElementsAck_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeLong(iceP_topic);
                    ElementSpecAckSeqHelper.write(ostr, iceP_elements);
                    ostr.writePendingValues();
                });
        }

        public global::System.Threading.Tasks.Task detachElementsAsync(long topic, long[] keys, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_detachElementsAsync(topic, keys, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_detachElementsAsync(long iceP_topic, long[] iceP_keys, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_detachElements(iceP_topic, iceP_keys, context, synchronous, completed);
            return completed.Task;
        }

        private const string _detachElements_name = "detachElements";

        private void _iceI_detachElements(long iceP_topic, long[] iceP_keys, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _detachElements_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeLong(iceP_topic);
                    global::Ice.LongSeqHelper.write(ostr, iceP_keys);
                });
        }

        public global::System.Threading.Tasks.Task initSamplesAsync(long topic, DataSamples[] samples, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_initSamplesAsync(topic, samples, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_initSamplesAsync(long iceP_topic, DataSamples[] iceP_samples, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_initSamples(iceP_topic, iceP_samples, context, synchronous, completed);
            return completed.Task;
        }

        private const string _initSamples_name = "initSamples";

        private void _iceI_initSamples(long iceP_topic, DataSamples[] iceP_samples, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _initSamples_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeLong(iceP_topic);
                    DataSamplesSeqHelper.write(ostr, iceP_samples);
                });
        }

        public global::System.Threading.Tasks.Task disconnectedAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_disconnectedAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_disconnectedAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_disconnected(context, synchronous, completed);
            return completed.Task;
        }

        private const string _disconnected_name = "disconnected";

        private void _iceI_disconnected(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _disconnected_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous);
        }

        public static SessionPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new SessionPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static SessionPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new SessionPrxHelper(b) : null;

        public static SessionPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static SessionPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new SessionPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static SessionPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::DataStormContract::Session",
            "::Ice::Object"
        };

        public static string ice_staticId() => "::DataStormContract::Session";

        public static void write(Ice.OutputStream ostr, SessionPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static SessionPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new SessionPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new SessionPrxHelper(reference);

        private SessionPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private SessionPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }

    public sealed class PublisherSessionPrxHelper : Ice.ObjectPrxHelperBase, PublisherSessionPrx
    {
        public void announceTopics(TopicInfo[] topics, bool initialize, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_announceTopicsAsync(topics, initialize, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void attachTopic(TopicSpec topic, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_attachTopicAsync(topic, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void detachTopic(long topic, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_detachTopicAsync(topic, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void attachTags(long topic, ElementInfo[] tags, bool initialize, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_attachTagsAsync(topic, tags, initialize, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void detachTags(long topic, long[] tags, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_detachTagsAsync(topic, tags, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void announceElements(long topic, ElementInfo[] elements, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_announceElementsAsync(topic, elements, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void attachElements(long topic, ElementSpec[] elements, bool initialize, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_attachElementsAsync(topic, elements, initialize, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void attachElementsAck(long topic, ElementSpecAck[] elements, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_attachElementsAckAsync(topic, elements, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void detachElements(long topic, long[] keys, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_detachElementsAsync(topic, keys, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void initSamples(long topic, DataSamples[] samples, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_initSamplesAsync(topic, samples, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void disconnected(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_disconnectedAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task announceTopicsAsync(TopicInfo[] topics, bool initialize, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_announceTopicsAsync(topics, initialize, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_announceTopicsAsync(TopicInfo[] iceP_topics, bool iceP_initialize, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_announceTopics(iceP_topics, iceP_initialize, context, synchronous, completed);
            return completed.Task;
        }

        private const string _announceTopics_name = "announceTopics";

        private void _iceI_announceTopics(TopicInfo[] iceP_topics, bool iceP_initialize, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _announceTopics_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    TopicInfoSeqHelper.write(ostr, iceP_topics);
                    ostr.writeBool(iceP_initialize);
                });
        }

        public global::System.Threading.Tasks.Task attachTopicAsync(TopicSpec topic, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_attachTopicAsync(topic, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_attachTopicAsync(TopicSpec iceP_topic, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_attachTopic(iceP_topic, context, synchronous, completed);
            return completed.Task;
        }

        private const string _attachTopic_name = "attachTopic";

        private void _iceI_attachTopic(TopicSpec iceP_topic, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _attachTopic_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    TopicSpec.ice_write(ostr, iceP_topic);
                });
        }

        public global::System.Threading.Tasks.Task detachTopicAsync(long topic, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_detachTopicAsync(topic, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_detachTopicAsync(long iceP_topic, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_detachTopic(iceP_topic, context, synchronous, completed);
            return completed.Task;
        }

        private const string _detachTopic_name = "detachTopic";

        private void _iceI_detachTopic(long iceP_topic, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _detachTopic_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeLong(iceP_topic);
                });
        }

        public global::System.Threading.Tasks.Task attachTagsAsync(long topic, ElementInfo[] tags, bool initialize, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_attachTagsAsync(topic, tags, initialize, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_attachTagsAsync(long iceP_topic, ElementInfo[] iceP_tags, bool iceP_initialize, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_attachTags(iceP_topic, iceP_tags, iceP_initialize, context, synchronous, completed);
            return completed.Task;
        }

        private const string _attachTags_name = "attachTags";

        private void _iceI_attachTags(long iceP_topic, ElementInfo[] iceP_tags, bool iceP_initialize, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _attachTags_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeLong(iceP_topic);
                    ElementInfoSeqHelper.write(ostr, iceP_tags);
                    ostr.writeBool(iceP_initialize);
                });
        }

        public global::System.Threading.Tasks.Task detachTagsAsync(long topic, long[] tags, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_detachTagsAsync(topic, tags, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_detachTagsAsync(long iceP_topic, long[] iceP_tags, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_detachTags(iceP_topic, iceP_tags, context, synchronous, completed);
            return completed.Task;
        }

        private const string _detachTags_name = "detachTags";

        private void _iceI_detachTags(long iceP_topic, long[] iceP_tags, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _detachTags_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeLong(iceP_topic);
                    global::Ice.LongSeqHelper.write(ostr, iceP_tags);
                });
        }

        public global::System.Threading.Tasks.Task announceElementsAsync(long topic, ElementInfo[] elements, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_announceElementsAsync(topic, elements, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_announceElementsAsync(long iceP_topic, ElementInfo[] iceP_elements, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_announceElements(iceP_topic, iceP_elements, context, synchronous, completed);
            return completed.Task;
        }

        private const string _announceElements_name = "announceElements";

        private void _iceI_announceElements(long iceP_topic, ElementInfo[] iceP_elements, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _announceElements_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeLong(iceP_topic);
                    ElementInfoSeqHelper.write(ostr, iceP_elements);
                });
        }

        public global::System.Threading.Tasks.Task attachElementsAsync(long topic, ElementSpec[] elements, bool initialize, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_attachElementsAsync(topic, elements, initialize, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_attachElementsAsync(long iceP_topic, ElementSpec[] iceP_elements, bool iceP_initialize, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_attachElements(iceP_topic, iceP_elements, iceP_initialize, context, synchronous, completed);
            return completed.Task;
        }

        private const string _attachElements_name = "attachElements";

        private void _iceI_attachElements(long iceP_topic, ElementSpec[] iceP_elements, bool iceP_initialize, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _attachElements_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeLong(iceP_topic);
                    ElementSpecSeqHelper.write(ostr, iceP_elements);
                    ostr.writeBool(iceP_initialize);
                    ostr.writePendingValues();
                });
        }

        public global::System.Threading.Tasks.Task attachElementsAckAsync(long topic, ElementSpecAck[] elements, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_attachElementsAckAsync(topic, elements, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_attachElementsAckAsync(long iceP_topic, ElementSpecAck[] iceP_elements, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_attachElementsAck(iceP_topic, iceP_elements, context, synchronous, completed);
            return completed.Task;
        }

        private const string _attachElementsAck_name = "attachElementsAck";

        private void _iceI_attachElementsAck(long iceP_topic, ElementSpecAck[] iceP_elements, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _attachElementsAck_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeLong(iceP_topic);
                    ElementSpecAckSeqHelper.write(ostr, iceP_elements);
                    ostr.writePendingValues();
                });
        }

        public global::System.Threading.Tasks.Task detachElementsAsync(long topic, long[] keys, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_detachElementsAsync(topic, keys, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_detachElementsAsync(long iceP_topic, long[] iceP_keys, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_detachElements(iceP_topic, iceP_keys, context, synchronous, completed);
            return completed.Task;
        }

        private const string _detachElements_name = "detachElements";

        private void _iceI_detachElements(long iceP_topic, long[] iceP_keys, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _detachElements_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeLong(iceP_topic);
                    global::Ice.LongSeqHelper.write(ostr, iceP_keys);
                });
        }

        public global::System.Threading.Tasks.Task initSamplesAsync(long topic, DataSamples[] samples, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_initSamplesAsync(topic, samples, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_initSamplesAsync(long iceP_topic, DataSamples[] iceP_samples, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_initSamples(iceP_topic, iceP_samples, context, synchronous, completed);
            return completed.Task;
        }

        private const string _initSamples_name = "initSamples";

        private void _iceI_initSamples(long iceP_topic, DataSamples[] iceP_samples, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _initSamples_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeLong(iceP_topic);
                    DataSamplesSeqHelper.write(ostr, iceP_samples);
                });
        }

        public global::System.Threading.Tasks.Task disconnectedAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_disconnectedAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_disconnectedAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_disconnected(context, synchronous, completed);
            return completed.Task;
        }

        private const string _disconnected_name = "disconnected";

        private void _iceI_disconnected(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _disconnected_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous);
        }

        public static PublisherSessionPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new PublisherSessionPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static PublisherSessionPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new PublisherSessionPrxHelper(b) : null;

        public static PublisherSessionPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static PublisherSessionPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new PublisherSessionPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static PublisherSessionPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::DataStormContract::PublisherSession",
            "::DataStormContract::Session",
            "::Ice::Object"
        };

        public static string ice_staticId() => "::DataStormContract::PublisherSession";

        public static void write(Ice.OutputStream ostr, PublisherSessionPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static PublisherSessionPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new PublisherSessionPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new PublisherSessionPrxHelper(reference);

        private PublisherSessionPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private PublisherSessionPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }

    public sealed class SubscriberSessionPrxHelper : Ice.ObjectPrxHelperBase, SubscriberSessionPrx
    {
        public void announceTopics(TopicInfo[] topics, bool initialize, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_announceTopicsAsync(topics, initialize, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void attachTopic(TopicSpec topic, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_attachTopicAsync(topic, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void detachTopic(long topic, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_detachTopicAsync(topic, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void attachTags(long topic, ElementInfo[] tags, bool initialize, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_attachTagsAsync(topic, tags, initialize, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void detachTags(long topic, long[] tags, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_detachTagsAsync(topic, tags, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void announceElements(long topic, ElementInfo[] elements, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_announceElementsAsync(topic, elements, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void attachElements(long topic, ElementSpec[] elements, bool initialize, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_attachElementsAsync(topic, elements, initialize, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void attachElementsAck(long topic, ElementSpecAck[] elements, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_attachElementsAckAsync(topic, elements, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void detachElements(long topic, long[] keys, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_detachElementsAsync(topic, keys, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void initSamples(long topic, DataSamples[] samples, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_initSamplesAsync(topic, samples, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void disconnected(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_disconnectedAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void s(long topicId, long elementId, DataSample sample, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_sAsync(topicId, elementId, sample, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task announceTopicsAsync(TopicInfo[] topics, bool initialize, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_announceTopicsAsync(topics, initialize, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_announceTopicsAsync(TopicInfo[] iceP_topics, bool iceP_initialize, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_announceTopics(iceP_topics, iceP_initialize, context, synchronous, completed);
            return completed.Task;
        }

        private const string _announceTopics_name = "announceTopics";

        private void _iceI_announceTopics(TopicInfo[] iceP_topics, bool iceP_initialize, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _announceTopics_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    TopicInfoSeqHelper.write(ostr, iceP_topics);
                    ostr.writeBool(iceP_initialize);
                });
        }

        public global::System.Threading.Tasks.Task attachTopicAsync(TopicSpec topic, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_attachTopicAsync(topic, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_attachTopicAsync(TopicSpec iceP_topic, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_attachTopic(iceP_topic, context, synchronous, completed);
            return completed.Task;
        }

        private const string _attachTopic_name = "attachTopic";

        private void _iceI_attachTopic(TopicSpec iceP_topic, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _attachTopic_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    TopicSpec.ice_write(ostr, iceP_topic);
                });
        }

        public global::System.Threading.Tasks.Task detachTopicAsync(long topic, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_detachTopicAsync(topic, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_detachTopicAsync(long iceP_topic, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_detachTopic(iceP_topic, context, synchronous, completed);
            return completed.Task;
        }

        private const string _detachTopic_name = "detachTopic";

        private void _iceI_detachTopic(long iceP_topic, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _detachTopic_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeLong(iceP_topic);
                });
        }

        public global::System.Threading.Tasks.Task attachTagsAsync(long topic, ElementInfo[] tags, bool initialize, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_attachTagsAsync(topic, tags, initialize, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_attachTagsAsync(long iceP_topic, ElementInfo[] iceP_tags, bool iceP_initialize, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_attachTags(iceP_topic, iceP_tags, iceP_initialize, context, synchronous, completed);
            return completed.Task;
        }

        private const string _attachTags_name = "attachTags";

        private void _iceI_attachTags(long iceP_topic, ElementInfo[] iceP_tags, bool iceP_initialize, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _attachTags_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeLong(iceP_topic);
                    ElementInfoSeqHelper.write(ostr, iceP_tags);
                    ostr.writeBool(iceP_initialize);
                });
        }

        public global::System.Threading.Tasks.Task detachTagsAsync(long topic, long[] tags, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_detachTagsAsync(topic, tags, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_detachTagsAsync(long iceP_topic, long[] iceP_tags, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_detachTags(iceP_topic, iceP_tags, context, synchronous, completed);
            return completed.Task;
        }

        private const string _detachTags_name = "detachTags";

        private void _iceI_detachTags(long iceP_topic, long[] iceP_tags, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _detachTags_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeLong(iceP_topic);
                    global::Ice.LongSeqHelper.write(ostr, iceP_tags);
                });
        }

        public global::System.Threading.Tasks.Task announceElementsAsync(long topic, ElementInfo[] elements, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_announceElementsAsync(topic, elements, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_announceElementsAsync(long iceP_topic, ElementInfo[] iceP_elements, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_announceElements(iceP_topic, iceP_elements, context, synchronous, completed);
            return completed.Task;
        }

        private const string _announceElements_name = "announceElements";

        private void _iceI_announceElements(long iceP_topic, ElementInfo[] iceP_elements, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _announceElements_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeLong(iceP_topic);
                    ElementInfoSeqHelper.write(ostr, iceP_elements);
                });
        }

        public global::System.Threading.Tasks.Task attachElementsAsync(long topic, ElementSpec[] elements, bool initialize, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_attachElementsAsync(topic, elements, initialize, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_attachElementsAsync(long iceP_topic, ElementSpec[] iceP_elements, bool iceP_initialize, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_attachElements(iceP_topic, iceP_elements, iceP_initialize, context, synchronous, completed);
            return completed.Task;
        }

        private const string _attachElements_name = "attachElements";

        private void _iceI_attachElements(long iceP_topic, ElementSpec[] iceP_elements, bool iceP_initialize, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _attachElements_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeLong(iceP_topic);
                    ElementSpecSeqHelper.write(ostr, iceP_elements);
                    ostr.writeBool(iceP_initialize);
                    ostr.writePendingValues();
                });
        }

        public global::System.Threading.Tasks.Task attachElementsAckAsync(long topic, ElementSpecAck[] elements, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_attachElementsAckAsync(topic, elements, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_attachElementsAckAsync(long iceP_topic, ElementSpecAck[] iceP_elements, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_attachElementsAck(iceP_topic, iceP_elements, context, synchronous, completed);
            return completed.Task;
        }

        private const string _attachElementsAck_name = "attachElementsAck";

        private void _iceI_attachElementsAck(long iceP_topic, ElementSpecAck[] iceP_elements, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _attachElementsAck_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeLong(iceP_topic);
                    ElementSpecAckSeqHelper.write(ostr, iceP_elements);
                    ostr.writePendingValues();
                });
        }

        public global::System.Threading.Tasks.Task detachElementsAsync(long topic, long[] keys, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_detachElementsAsync(topic, keys, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_detachElementsAsync(long iceP_topic, long[] iceP_keys, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_detachElements(iceP_topic, iceP_keys, context, synchronous, completed);
            return completed.Task;
        }

        private const string _detachElements_name = "detachElements";

        private void _iceI_detachElements(long iceP_topic, long[] iceP_keys, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _detachElements_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeLong(iceP_topic);
                    global::Ice.LongSeqHelper.write(ostr, iceP_keys);
                });
        }

        public global::System.Threading.Tasks.Task initSamplesAsync(long topic, DataSamples[] samples, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_initSamplesAsync(topic, samples, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_initSamplesAsync(long iceP_topic, DataSamples[] iceP_samples, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_initSamples(iceP_topic, iceP_samples, context, synchronous, completed);
            return completed.Task;
        }

        private const string _initSamples_name = "initSamples";

        private void _iceI_initSamples(long iceP_topic, DataSamples[] iceP_samples, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _initSamples_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeLong(iceP_topic);
                    DataSamplesSeqHelper.write(ostr, iceP_samples);
                });
        }

        public global::System.Threading.Tasks.Task disconnectedAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_disconnectedAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_disconnectedAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_disconnected(context, synchronous, completed);
            return completed.Task;
        }

        private const string _disconnected_name = "disconnected";

        private void _iceI_disconnected(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _disconnected_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous);
        }

        public global::System.Threading.Tasks.Task sAsync(long topicId, long elementId, DataSample sample, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_sAsync(topicId, elementId, sample, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_sAsync(long iceP_topicId, long iceP_elementId, DataSample iceP_sample, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_s(iceP_topicId, iceP_elementId, iceP_sample, context, synchronous, completed);
            return completed.Task;
        }

        private const string _s_name = "s";

        private void _iceI_s(long iceP_topicId, long iceP_elementId, DataSample iceP_sample, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _s_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeLong(iceP_topicId);
                    ostr.writeLong(iceP_elementId);
                    DataSample.ice_write(ostr, iceP_sample);
                });
        }

        public static SubscriberSessionPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new SubscriberSessionPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static SubscriberSessionPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new SubscriberSessionPrxHelper(b) : null;

        public static SubscriberSessionPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static SubscriberSessionPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new SubscriberSessionPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static SubscriberSessionPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::DataStormContract::Session",
            "::DataStormContract::SubscriberSession",
            "::Ice::Object"
        };

        public static string ice_staticId() => "::DataStormContract::SubscriberSession";

        public static void write(Ice.OutputStream ostr, SubscriberSessionPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static SubscriberSessionPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new SubscriberSessionPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new SubscriberSessionPrxHelper(reference);

        private SubscriberSessionPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private SubscriberSessionPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }

    public sealed class NodePrxHelper : Ice.ObjectPrxHelperBase, NodePrx
    {
        public void initiateCreateSession(NodePrx? publisher, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_initiateCreateSessionAsync(publisher, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void createSession(NodePrx? subscriber, SubscriberSessionPrx? session, bool fromRelay, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_createSessionAsync(subscriber, session, fromRelay, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void confirmCreateSession(NodePrx? publisher, PublisherSessionPrx? session, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_confirmCreateSessionAsync(publisher, session, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task initiateCreateSessionAsync(NodePrx? publisher, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_initiateCreateSessionAsync(publisher, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_initiateCreateSessionAsync(NodePrx? iceP_publisher, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_initiateCreateSession(iceP_publisher, context, synchronous, completed);
            return completed.Task;
        }

        private const string _initiateCreateSession_name = "initiateCreateSession";

        private void _iceI_initiateCreateSession(NodePrx? iceP_publisher, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _initiateCreateSession_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    NodePrxHelper.write(ostr, iceP_publisher);
                });
        }

        public global::System.Threading.Tasks.Task createSessionAsync(NodePrx? subscriber, SubscriberSessionPrx? session, bool fromRelay, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_createSessionAsync(subscriber, session, fromRelay, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_createSessionAsync(NodePrx? iceP_subscriber, SubscriberSessionPrx? iceP_session, bool iceP_fromRelay, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_createSession(iceP_subscriber, iceP_session, iceP_fromRelay, context, synchronous, completed);
            return completed.Task;
        }

        private const string _createSession_name = "createSession";

        private void _iceI_createSession(NodePrx? iceP_subscriber, SubscriberSessionPrx? iceP_session, bool iceP_fromRelay, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _createSession_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    NodePrxHelper.write(ostr, iceP_subscriber);
                    SubscriberSessionPrxHelper.write(ostr, iceP_session);
                    ostr.writeBool(iceP_fromRelay);
                });
        }

        public global::System.Threading.Tasks.Task confirmCreateSessionAsync(NodePrx? publisher, PublisherSessionPrx? session, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_confirmCreateSessionAsync(publisher, session, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_confirmCreateSessionAsync(NodePrx? iceP_publisher, PublisherSessionPrx? iceP_session, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_confirmCreateSession(iceP_publisher, iceP_session, context, synchronous, completed);
            return completed.Task;
        }

        private const string _confirmCreateSession_name = "confirmCreateSession";

        private void _iceI_confirmCreateSession(NodePrx? iceP_publisher, PublisherSessionPrx? iceP_session, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _confirmCreateSession_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    NodePrxHelper.write(ostr, iceP_publisher);
                    PublisherSessionPrxHelper.write(ostr, iceP_session);
                });
        }

        public static NodePrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new NodePrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static NodePrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new NodePrxHelper(b) : null;

        public static NodePrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static NodePrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new NodePrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static NodePrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::DataStormContract::Node",
            "::Ice::Object"
        };

        public static string ice_staticId() => "::DataStormContract::Node";

        public static void write(Ice.OutputStream ostr, NodePrx? v)
        {
            ostr.writeProxy(v);
        }

        public static NodePrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new NodePrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new NodePrxHelper(reference);

        private NodePrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private NodePrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }

    public sealed class LookupPrxHelper : Ice.ObjectPrxHelperBase, LookupPrx
    {
        public void announceTopicReader(string topic, NodePrx? subscriber, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_announceTopicReaderAsync(topic, subscriber, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void announceTopicWriter(string topic, NodePrx? node, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_announceTopicWriterAsync(topic, node, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void announceTopics(string[] readers, string[] writers, NodePrx? node, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_announceTopicsAsync(readers, writers, node, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public NodePrx? createSession(NodePrx? node, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_createSessionAsync(node, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task announceTopicReaderAsync(string topic, NodePrx? subscriber, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_announceTopicReaderAsync(topic, subscriber, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_announceTopicReaderAsync(string iceP_topic, NodePrx? iceP_subscriber, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_announceTopicReader(iceP_topic, iceP_subscriber, context, synchronous, completed);
            return completed.Task;
        }

        private const string _announceTopicReader_name = "announceTopicReader";

        private void _iceI_announceTopicReader(string iceP_topic, NodePrx? iceP_subscriber, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _announceTopicReader_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_topic);
                    NodePrxHelper.write(ostr, iceP_subscriber);
                });
        }

        public global::System.Threading.Tasks.Task announceTopicWriterAsync(string topic, NodePrx? node, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_announceTopicWriterAsync(topic, node, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_announceTopicWriterAsync(string iceP_topic, NodePrx? iceP_node, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_announceTopicWriter(iceP_topic, iceP_node, context, synchronous, completed);
            return completed.Task;
        }

        private const string _announceTopicWriter_name = "announceTopicWriter";

        private void _iceI_announceTopicWriter(string iceP_topic, NodePrx? iceP_node, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _announceTopicWriter_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_topic);
                    NodePrxHelper.write(ostr, iceP_node);
                });
        }

        public global::System.Threading.Tasks.Task announceTopicsAsync(string[] readers, string[] writers, NodePrx? node, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_announceTopicsAsync(readers, writers, node, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_announceTopicsAsync(string[] iceP_readers, string[] iceP_writers, NodePrx? iceP_node, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_announceTopics(iceP_readers, iceP_writers, iceP_node, context, synchronous, completed);
            return completed.Task;
        }

        private const string _announceTopics_name = "announceTopics";

        private void _iceI_announceTopics(string[] iceP_readers, string[] iceP_writers, NodePrx? iceP_node, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _announceTopics_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    global::Ice.StringSeqHelper.write(ostr, iceP_readers);
                    global::Ice.StringSeqHelper.write(ostr, iceP_writers);
                    NodePrxHelper.write(ostr, iceP_node);
                });
        }

        public global::System.Threading.Tasks.Task<NodePrx?> createSessionAsync(NodePrx? node, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_createSessionAsync(node, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<NodePrx?> _iceI_createSessionAsync(NodePrx? iceP_node, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_createSession_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<NodePrx?>(progress, cancel);
            _iceI_createSession(iceP_node, context, synchronous, completed);
            return completed.Task;
        }

        private const string _createSession_name = "createSession";

        private void _iceI_createSession(NodePrx? iceP_node, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<NodePrx?>(completed);
            outAsync.invoke(
                _createSession_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    NodePrxHelper.write(ostr, iceP_node);
                },
                read: (Ice.InputStream istr) =>
                {
                    NodePrx? ret;
                    ret = NodePrxHelper.read(istr);
                    return ret;
                });
        }

        public static LookupPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new LookupPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static LookupPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new LookupPrxHelper(b) : null;

        public static LookupPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static LookupPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new LookupPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static LookupPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::DataStormContract::Lookup",
            "::Ice::Object"
        };

        public static string ice_staticId() => "::DataStormContract::Lookup";

        public static void write(Ice.OutputStream ostr, LookupPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static LookupPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new LookupPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new LookupPrxHelper(reference);

        private LookupPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private LookupPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }
}

namespace DataStormContract
{
    public abstract class SessionDisp_ : Ice.ObjectImpl, Session
    {
        public abstract void announceTopics(TopicInfo[] topics, bool initialize, Ice.Current current);

        public abstract void attachTopic(TopicSpec topic, Ice.Current current);

        public abstract void detachTopic(long topic, Ice.Current current);

        public abstract void attachTags(long topic, ElementInfo[] tags, bool initialize, Ice.Current current);

        public abstract void detachTags(long topic, long[] tags, Ice.Current current);

        public abstract void announceElements(long topic, ElementInfo[] elements, Ice.Current current);

        public abstract void attachElements(long topic, ElementSpec[] elements, bool initialize, Ice.Current current);

        public abstract void attachElementsAck(long topic, ElementSpecAck[] elements, Ice.Current current);

        public abstract void detachElements(long topic, long[] keys, Ice.Current current);

        public abstract void initSamples(long topic, DataSamples[] samples, Ice.Current current);

        public abstract void disconnected(Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::DataStormContract::Session";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "announceTopics" => Session.iceD_announceTopicsAsync(this, request),
                "attachTopic" => Session.iceD_attachTopicAsync(this, request),
                "detachTopic" => Session.iceD_detachTopicAsync(this, request),
                "attachTags" => Session.iceD_attachTagsAsync(this, request),
                "detachTags" => Session.iceD_detachTagsAsync(this, request),
                "announceElements" => Session.iceD_announceElementsAsync(this, request),
                "attachElements" => Session.iceD_attachElementsAsync(this, request),
                "attachElementsAck" => Session.iceD_attachElementsAckAsync(this, request),
                "detachElements" => Session.iceD_detachElementsAsync(this, request),
                "initSamples" => Session.iceD_initSamplesAsync(this, request),
                "disconnected" => Session.iceD_disconnectedAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }

    public abstract class PublisherSessionDisp_ : Ice.ObjectImpl, PublisherSession
    {
        public abstract void detachElements(long topic, long[] keys, Ice.Current current);

        public abstract void initSamples(long topic, DataSamples[] samples, Ice.Current current);

        public abstract void disconnected(Ice.Current current);

        public abstract void announceTopics(TopicInfo[] topics, bool initialize, Ice.Current current);

        public abstract void attachTopic(TopicSpec topic, Ice.Current current);

        public abstract void detachTopic(long topic, Ice.Current current);

        public abstract void attachTags(long topic, ElementInfo[] tags, bool initialize, Ice.Current current);

        public abstract void detachTags(long topic, long[] tags, Ice.Current current);

        public abstract void announceElements(long topic, ElementInfo[] elements, Ice.Current current);

        public abstract void attachElements(long topic, ElementSpec[] elements, bool initialize, Ice.Current current);

        public abstract void attachElementsAck(long topic, ElementSpecAck[] elements, Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::DataStormContract::PublisherSession";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "announceTopics" => Session.iceD_announceTopicsAsync(this, request),
                "attachTopic" => Session.iceD_attachTopicAsync(this, request),
                "detachTopic" => Session.iceD_detachTopicAsync(this, request),
                "attachTags" => Session.iceD_attachTagsAsync(this, request),
                "detachTags" => Session.iceD_detachTagsAsync(this, request),
                "announceElements" => Session.iceD_announceElementsAsync(this, request),
                "attachElements" => Session.iceD_attachElementsAsync(this, request),
                "attachElementsAck" => Session.iceD_attachElementsAckAsync(this, request),
                "detachElements" => Session.iceD_detachElementsAsync(this, request),
                "initSamples" => Session.iceD_initSamplesAsync(this, request),
                "disconnected" => Session.iceD_disconnectedAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }

    public abstract class SubscriberSessionDisp_ : Ice.ObjectImpl, SubscriberSession
    {
        public abstract void s(long topicId, long elementId, DataSample sample, Ice.Current current);

        public abstract void detachElements(long topic, long[] keys, Ice.Current current);

        public abstract void initSamples(long topic, DataSamples[] samples, Ice.Current current);

        public abstract void disconnected(Ice.Current current);

        public abstract void announceTopics(TopicInfo[] topics, bool initialize, Ice.Current current);

        public abstract void attachTopic(TopicSpec topic, Ice.Current current);

        public abstract void detachTopic(long topic, Ice.Current current);

        public abstract void attachTags(long topic, ElementInfo[] tags, bool initialize, Ice.Current current);

        public abstract void detachTags(long topic, long[] tags, Ice.Current current);

        public abstract void announceElements(long topic, ElementInfo[] elements, Ice.Current current);

        public abstract void attachElements(long topic, ElementSpec[] elements, bool initialize, Ice.Current current);

        public abstract void attachElementsAck(long topic, ElementSpecAck[] elements, Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::DataStormContract::SubscriberSession";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "announceTopics" => Session.iceD_announceTopicsAsync(this, request),
                "attachTopic" => Session.iceD_attachTopicAsync(this, request),
                "detachTopic" => Session.iceD_detachTopicAsync(this, request),
                "attachTags" => Session.iceD_attachTagsAsync(this, request),
                "detachTags" => Session.iceD_detachTagsAsync(this, request),
                "announceElements" => Session.iceD_announceElementsAsync(this, request),
                "attachElements" => Session.iceD_attachElementsAsync(this, request),
                "attachElementsAck" => Session.iceD_attachElementsAckAsync(this, request),
                "detachElements" => Session.iceD_detachElementsAsync(this, request),
                "initSamples" => Session.iceD_initSamplesAsync(this, request),
                "disconnected" => Session.iceD_disconnectedAsync(this, request),
                "s" => SubscriberSession.iceD_sAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }

    public abstract class NodeDisp_ : Ice.ObjectImpl, Node
    {
        public abstract void initiateCreateSession(NodePrx? publisher, Ice.Current current);

        public abstract void createSession(NodePrx? subscriber, SubscriberSessionPrx? session, bool fromRelay, Ice.Current current);

        public abstract void confirmCreateSession(NodePrx? publisher, PublisherSessionPrx? session, Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::DataStormContract::Node";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "initiateCreateSession" => Node.iceD_initiateCreateSessionAsync(this, request),
                "createSession" => Node.iceD_createSessionAsync(this, request),
                "confirmCreateSession" => Node.iceD_confirmCreateSessionAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }

    public abstract class LookupDisp_ : Ice.ObjectImpl, Lookup
    {
        public abstract void announceTopicReader(string topic, NodePrx? subscriber, Ice.Current current);

        public abstract void announceTopicWriter(string topic, NodePrx? node, Ice.Current current);

        public abstract void announceTopics(string[] readers, string[] writers, NodePrx? node, Ice.Current current);

        public abstract NodePrx? createSession(NodePrx? node, Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::DataStormContract::Lookup";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "announceTopicReader" => Lookup.iceD_announceTopicReaderAsync(this, request),
                "announceTopicWriter" => Lookup.iceD_announceTopicWriterAsync(this, request),
                "announceTopics" => Lookup.iceD_announceTopicsAsync(this, request),
                "createSession" => Lookup.iceD_createSessionAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }
}

namespace DataStormContract
{
    public partial interface Session
    {
        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_announceTopicsAsync(
            Session obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            TopicInfo[] iceP_topics;
            bool iceP_initialize;
            iceP_topics = TopicInfoSeqHelper.read(istr);
            iceP_initialize = istr.readBool();
            istr.endEncapsulation();
            obj.announceTopics(iceP_topics, iceP_initialize, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_attachTopicAsync(
            Session obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            TopicSpec iceP_topic;
            iceP_topic = new TopicSpec(istr);
            istr.endEncapsulation();
            obj.attachTopic(iceP_topic, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_detachTopicAsync(
            Session obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            long iceP_topic;
            iceP_topic = istr.readLong();
            istr.endEncapsulation();
            obj.detachTopic(iceP_topic, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_attachTagsAsync(
            Session obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            long iceP_topic;
            ElementInfo[] iceP_tags;
            bool iceP_initialize;
            iceP_topic = istr.readLong();
            iceP_tags = ElementInfoSeqHelper.read(istr);
            iceP_initialize = istr.readBool();
            istr.endEncapsulation();
            obj.attachTags(iceP_topic, iceP_tags, iceP_initialize, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_detachTagsAsync(
            Session obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            long iceP_topic;
            long[] iceP_tags;
            iceP_topic = istr.readLong();
            iceP_tags = global::Ice.LongSeqHelper.read(istr);
            istr.endEncapsulation();
            obj.detachTags(iceP_topic, iceP_tags, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_announceElementsAsync(
            Session obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            long iceP_topic;
            ElementInfo[] iceP_elements;
            iceP_topic = istr.readLong();
            iceP_elements = ElementInfoSeqHelper.read(istr);
            istr.endEncapsulation();
            obj.announceElements(iceP_topic, iceP_elements, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_attachElementsAsync(
            Session obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            long iceP_topic;
            ElementSpec[] iceP_elements;
            bool iceP_initialize;
            iceP_topic = istr.readLong();
            iceP_elements = ElementSpecSeqHelper.read(istr);
            iceP_initialize = istr.readBool();
            istr.readPendingValues();
            istr.endEncapsulation();
            obj.attachElements(iceP_topic, iceP_elements, iceP_initialize, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_attachElementsAckAsync(
            Session obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            long iceP_topic;
            ElementSpecAck[] iceP_elements;
            iceP_topic = istr.readLong();
            iceP_elements = ElementSpecAckSeqHelper.read(istr);
            istr.readPendingValues();
            istr.endEncapsulation();
            obj.attachElementsAck(iceP_topic, iceP_elements, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_detachElementsAsync(
            Session obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            long iceP_topic;
            long[] iceP_keys;
            iceP_topic = istr.readLong();
            iceP_keys = global::Ice.LongSeqHelper.read(istr);
            istr.endEncapsulation();
            obj.detachElements(iceP_topic, iceP_keys, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_initSamplesAsync(
            Session obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            long iceP_topic;
            DataSamples[] iceP_samples;
            iceP_topic = istr.readLong();
            iceP_samples = DataSamplesSeqHelper.read(istr);
            istr.endEncapsulation();
            obj.initSamples(iceP_topic, iceP_samples, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_disconnectedAsync(
            Session obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            obj.disconnected(request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }
    }

    public partial interface PublisherSession
    {
    }

    public partial interface SubscriberSession
    {
        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_sAsync(
            SubscriberSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            long iceP_topicId;
            long iceP_elementId;
            DataSample iceP_sample;
            iceP_topicId = istr.readLong();
            iceP_elementId = istr.readLong();
            iceP_sample = new DataSample(istr);
            istr.endEncapsulation();
            obj.s(iceP_topicId, iceP_elementId, iceP_sample, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }
    }

    public partial interface Node
    {
        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_initiateCreateSessionAsync(
            Node obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            NodePrx? iceP_publisher;
            iceP_publisher = NodePrxHelper.read(istr);
            istr.endEncapsulation();
            obj.initiateCreateSession(iceP_publisher, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_createSessionAsync(
            Node obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            NodePrx? iceP_subscriber;
            SubscriberSessionPrx? iceP_session;
            bool iceP_fromRelay;
            iceP_subscriber = NodePrxHelper.read(istr);
            iceP_session = SubscriberSessionPrxHelper.read(istr);
            iceP_fromRelay = istr.readBool();
            istr.endEncapsulation();
            obj.createSession(iceP_subscriber, iceP_session, iceP_fromRelay, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_confirmCreateSessionAsync(
            Node obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            NodePrx? iceP_publisher;
            PublisherSessionPrx? iceP_session;
            iceP_publisher = NodePrxHelper.read(istr);
            iceP_session = PublisherSessionPrxHelper.read(istr);
            istr.endEncapsulation();
            obj.confirmCreateSession(iceP_publisher, iceP_session, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }
    }

    public partial interface Lookup
    {
        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_announceTopicReaderAsync(
            Lookup obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_topic;
            NodePrx? iceP_subscriber;
            iceP_topic = istr.readString();
            iceP_subscriber = NodePrxHelper.read(istr);
            istr.endEncapsulation();
            obj.announceTopicReader(iceP_topic, iceP_subscriber, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_announceTopicWriterAsync(
            Lookup obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_topic;
            NodePrx? iceP_node;
            iceP_topic = istr.readString();
            iceP_node = NodePrxHelper.read(istr);
            istr.endEncapsulation();
            obj.announceTopicWriter(iceP_topic, iceP_node, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_announceTopicsAsync(
            Lookup obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string[] iceP_readers;
            string[] iceP_writers;
            NodePrx? iceP_node;
            iceP_readers = global::Ice.StringSeqHelper.read(istr);
            iceP_writers = global::Ice.StringSeqHelper.read(istr);
            iceP_node = NodePrxHelper.read(istr);
            istr.endEncapsulation();
            obj.announceTopics(iceP_readers, iceP_writers, iceP_node, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_createSessionAsync(
            Lookup obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            NodePrx? iceP_node;
            iceP_node = NodePrxHelper.read(istr);
            istr.endEncapsulation();
            var ret = obj.createSession(iceP_node, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            NodePrxHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }
    }
}
