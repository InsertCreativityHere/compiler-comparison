//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Key.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#nullable enable

[assembly:Ice.Slice("Key.ice")]

#pragma warning disable CS1591 // Missing XML Comment
#pragma warning disable CS1573 // Parameter has no matching param tag in the XML comment
#pragma warning disable CS0612 // Type or member is obsolete
#pragma warning disable CS0618 // Type or member is obsolete
#pragma warning disable CS0619 // Type or member is obsolete

namespace and
{
    public enum @continue
    {
        let,
        @var
    }

    public sealed class continueHelper
    {
        public static void write(Ice.OutputStream ostr, @continue v)
        {
            ostr.writeEnum((int)v, 1);
        }

        public static @continue read(Ice.InputStream istr)
        {
            @continue v;
            v = (@continue)istr.readEnum(1);
            return v;
        }
    }

    public partial record struct guard
    {
        public int @default;

        partial void ice_initialize();

        public guard(int @default)
        {
            this.@default = @default;
            ice_initialize();
        }

        public guard(Ice.InputStream istr)
        {
            this.@default = istr.readInt();
            ice_initialize();
        }

        public void ice_writeMembers(Ice.OutputStream ostr)
        {
            ostr.writeInt(this.@default);
        }

        public static void ice_write(Ice.OutputStream ostr, guard v)
        {
            v.ice_writeMembers(ostr);
        }

        public static guard ice_read(Ice.InputStream istr) => new(istr);
    }

    public sealed partial record class defer
    {
        public string @else = "";

        partial void ice_initialize();

        public defer()
        {
            ice_initialize();
        }

        public defer(string @else)
        {
            global::System.ArgumentNullException.ThrowIfNull(@else);
            this.@else = @else;
            ice_initialize();
        }

        public defer(Ice.InputStream istr)
        {
            this.@else = istr.readString();
            ice_initialize();
        }

        public void ice_writeMembers(Ice.OutputStream ostr)
        {
            ostr.writeString(this.@else);
        }

        public static void ice_write(Ice.OutputStream ostr, defer v)
        {
            v.ice_writeMembers(ostr);
        }

        public static defer ice_read(Ice.InputStream istr) => new(istr);
    }

    [Ice.SliceTypeId("::and::break")]
    public partial interface @break : Ice.Object
    {
        global::System.Threading.Tasks.Task<int> caseAsync(int @catch, Ice.Current current);
    }

    [Ice.SliceTypeId("::and::func")]
    public partial interface func : Ice.Object
    {
        void @public(Ice.Current current);
    }

    [Ice.SliceTypeId("::and::switch")]
    public partial class @switch : Ice.Value
    {
        public int @if;

        public funcPrx? export;

        public int @volatile;

        partial void ice_initialize();

        public @switch(int @if, funcPrx? export, int @volatile)
        {
            this.@if = @if;
            this.export = export;
            this.@volatile = @volatile;
            ice_initialize();
        }

        public @switch()
        {
            ice_initialize();
        }

        public static new string ice_staticId() => "::and::switch";
        public override string ice_id() => ice_staticId();

        protected override void iceWriteImpl(Ice.OutputStream ostr_)
        {
            ostr_.startSlice(ice_staticId(), -1, true);
            ostr_.writeInt(@if);
            funcPrxHelper.write(ostr_, export);
            ostr_.writeInt(@volatile);
            ostr_.endSlice();
        }

        protected override void iceReadImpl(Ice.InputStream istr_)
        {
            istr_.startSlice();
            @if = istr_.readInt();
            export = funcPrxHelper.read(istr_);
            @volatile = istr_.readInt();
            istr_.endSlice();
        }
    }

    [Ice.SliceTypeId("::and::do")]
    public partial interface @do : func, @break
    {
    }

    [Ice.SliceTypeId("::and::return")]
    public partial class @return : Ice.UserException
    {
        public int Int32;

        public @return(int Int32)
        {
            this.Int32 = Int32;
        }

        public @return()
        {
        }

        public override string ice_id() => "::and::return";

        protected override void iceWriteImpl(Ice.OutputStream ostr_)
        {
            ostr_.startSlice("::and::return", -1, true);
            ostr_.writeInt(Int32);
            ostr_.endSlice();
        }

        protected override void iceReadImpl(Ice.InputStream istr_)
        {
            istr_.startSlice();
            Int32 = istr_.readInt();
            istr_.endSlice();
        }
    }

    [Ice.SliceTypeId("::and::as")]
    public partial class @as : @return
    {
        public int @static;

        public int @switch;

        public @as(int Int32, int @static, int @switch) : base(Int32)
        {
            this.@static = @static;
            this.@switch = @switch;
        }

        public @as()
        {
        }

        public override string ice_id() => "::and::as";

        protected override void iceWriteImpl(Ice.OutputStream ostr_)
        {
            ostr_.startSlice("::and::as", -1, false);
            ostr_.writeInt(@static);
            ostr_.writeInt(@switch);
            ostr_.endSlice();
            base.iceWriteImpl(ostr_);
        }

        protected override void iceReadImpl(Ice.InputStream istr_)
        {
            istr_.startSlice();
            @static = istr_.readInt();
            @switch = istr_.readInt();
            istr_.endSlice();
            base.iceReadImpl(istr_);
        }
    }

    public abstract class @is
    {
        public const int value = 0;
    }

    public abstract class self
    {
        public const int value = 0;
    }

    public abstract class @throw
    {
        public const int value = 0;
    }

    public abstract class typealias
    {
        public const int value = 0;
    }

    public abstract class @internal
    {
        public const int value = 0;
    }

    public abstract class @while
    {
        public const int value = 0;
    }

    public abstract class import
    {
        public const int value = 0;
    }
}

namespace and
{
    public interface breakPrx : Ice.ObjectPrx
    {
        void @case(int @catch, out int @try, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        global::System.Threading.Tasks.Task<int> caseAsync(int @catch, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }

    public interface funcPrx : Ice.ObjectPrx
    {
        void @public(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        global::System.Threading.Tasks.Task publicAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }

    public interface doPrx : funcPrx, breakPrx
    {
    }
}

namespace and
{
    public sealed class breakPrxHelper : Ice.ObjectPrxHelperBase, breakPrx
    {
        public void @case(int @catch, out int @try, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                @try = _iceI_caseAsync(@catch, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task<int> caseAsync(int @catch, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_caseAsync(@catch, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<int> _iceI_caseAsync(int iceP_catch, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_case_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<int>(progress, cancel);
            _iceI_case(iceP_catch, context, synchronous, completed);
            return completed.Task;
        }

        private const string _case_name = "case";

        private void _iceI_case(int iceP_catch, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<int>(completed);
            outAsync.invoke(
                _case_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_catch);
                },
                read: (Ice.InputStream istr) =>
                {
                    int iceP_try;
                    iceP_try = istr.readInt();
                    return iceP_try;
                });
        }

        public static breakPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new breakPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static breakPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new breakPrxHelper(b) : null;

        public static breakPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static breakPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new breakPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static breakPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::and::break"
        };

        public static string ice_staticId() => "::and::break";

        public static void write(Ice.OutputStream ostr, breakPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static breakPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new breakPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new breakPrxHelper(reference);

        private breakPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private breakPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }

    public sealed class funcPrxHelper : Ice.ObjectPrxHelperBase, funcPrx
    {
        public void @public(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_publicAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task publicAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_publicAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_publicAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_public(context, synchronous, completed);
            return completed.Task;
        }

        private const string _public_name = "public";

        private void _iceI_public(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _public_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous);
        }

        public static funcPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new funcPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static funcPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new funcPrxHelper(b) : null;

        public static funcPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static funcPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new funcPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static funcPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::and::func"
        };

        public static string ice_staticId() => "::and::func";

        public static void write(Ice.OutputStream ostr, funcPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static funcPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new funcPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new funcPrxHelper(reference);

        private funcPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private funcPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }

    public sealed class doPrxHelper : Ice.ObjectPrxHelperBase, doPrx
    {
        public void @public(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_publicAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void @case(int @catch, out int @try, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                @try = _iceI_caseAsync(@catch, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task publicAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_publicAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_publicAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_public(context, synchronous, completed);
            return completed.Task;
        }

        private const string _public_name = "public";

        private void _iceI_public(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _public_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous);
        }

        public global::System.Threading.Tasks.Task<int> caseAsync(int @catch, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_caseAsync(@catch, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<int> _iceI_caseAsync(int iceP_catch, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_case_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<int>(progress, cancel);
            _iceI_case(iceP_catch, context, synchronous, completed);
            return completed.Task;
        }

        private const string _case_name = "case";

        private void _iceI_case(int iceP_catch, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<int>(completed);
            outAsync.invoke(
                _case_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_catch);
                },
                read: (Ice.InputStream istr) =>
                {
                    int iceP_try;
                    iceP_try = istr.readInt();
                    return iceP_try;
                });
        }

        public static doPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new doPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static doPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new doPrxHelper(b) : null;

        public static doPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static doPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new doPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static doPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::and::break",
            "::and::do",
            "::and::func"
        };

        public static string ice_staticId() => "::and::do";

        public static void write(Ice.OutputStream ostr, doPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static doPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new doPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new doPrxHelper(reference);

        private doPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private doPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }

    public sealed class fileprivateHelper
    {
        public static void write(Ice.OutputStream ostr, guard[] v)
        {
            if (v is null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    v[ix].ice_writeMembers(ostr);
                }
            }
        }

        public static guard[] read(Ice.InputStream istr)
        {
            guard[] v;
            {
                int szx = istr.readAndCheckSeqSize(4);
                v = new guard[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new guard(istr);
                }
            }
            return v;
        }
    }

    public sealed class forHelper
    {
        public static void write(Ice.OutputStream ostr,
                                 global::System.Collections.Generic.Dictionary<string, guard> v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Count);
                foreach(global::System.Collections.Generic.KeyValuePair<string, guard> e in v)
                {
                    ostr.writeString(e.Key);
                    e.Value.ice_writeMembers(ostr);
                }
            }
        }

        public static global::System.Collections.Generic.Dictionary<string, guard> read(Ice.InputStream istr)
        {
            int sz = istr.readSize();
            global::System.Collections.Generic.Dictionary<string, guard> r = new global::System.Collections.Generic.Dictionary<string, guard>();
            for(int i = 0; i < sz; ++i)
            {
                string k;
                k = istr.readString();
                guard v;
                v = new guard(istr);
                r[k] = v;
            }
            return r;
        }
    }
}

namespace and
{
    public abstract class breakDisp_ : Ice.ObjectImpl, @break
    {
        public abstract global::System.Threading.Tasks.Task<int> caseAsync(int @catch, Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::and::break";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "case" => @break.iceD_caseAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }

    public abstract class funcDisp_ : Ice.ObjectImpl, func
    {
        public abstract void @public(Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::and::func";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "public" => func.iceD_publicAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }

    public abstract class doDisp_ : Ice.ObjectImpl, @do
    {
        public abstract global::System.Threading.Tasks.Task<int> caseAsync(int @catch, Ice.Current current);

        public abstract void @public(Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::and::do";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "public" => func.iceD_publicAsync(this, request),
                "case" => @break.iceD_caseAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }
}

namespace and
{
    public partial interface @break
    {
        protected static async global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_caseAsync(
            @break obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            int iceP_catch;
            iceP_catch = istr.readInt();
            istr.endEncapsulation();
            var result = await obj.caseAsync(iceP_catch, request.current).ConfigureAwait(false);
            return Ice.CurrentExtensions.createOutgoingResponse(
                request.current,
                result,
                static (ostr, iceP_try) =>
                {
                    ostr.writeInt(iceP_try);
                });
        }
    }

    public partial interface func
    {
        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_publicAsync(
            func obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            obj.@public(request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }
    }

    public partial interface @do
    {
    }
}
