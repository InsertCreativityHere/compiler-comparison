// Copyright (c) ZeroC, Inc.
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file 'Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>

#nullable enable

[assembly:Ice.Slice("Test.ice")]

#pragma warning disable CS1591 // Missing XML Comment
#pragma warning disable CS1573 // Parameter has no matching param tag in the XML comment
#pragma warning disable CS0612 // Type or member is obsolete
#pragma warning disable CS0618 // Type or member is obsolete
#pragma warning disable CS0619 // Type or member is obsolete

namespace Test
{
    [Ice.SliceTypeId("::Test::Hold")]
    public partial interface Hold : Ice.Object
    {
        /// <summary>
        /// Puts the adapter on hold, and optionally reactivates it.
        /// </summary>
        /// <param name="delay">
        /// When less than 0, puts the adapter on hold indefinitely. When 0, puts the adapter on hold and
        /// immediately reactivates it. When greater than 0, starts a background task that sleeps for delay
        /// milliseconds, puts the adapter on hold and then immediately reactivates it.
        /// </param>
        /// <param name="current">The Current object for the dispatch.</param>
        void putOnHold(int delay, Ice.Current current);

        /// <summary>
        /// Starts a background task that calls waitForHold and activate on the adapter.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>
        void waitForHold(Ice.Current current);

        /// <summary>
        /// Saves value as the last value.
        /// </summary>
        /// <param name="value">
        /// The new value.
        /// </param>
        /// <param name="expected">
        /// The current value as expected by the caller.
        /// </param>
        /// <param name="current">The Current object for the dispatch.</param>
        void setOneway(int value, int expected, Ice.Current current);

        /// <summary>
        /// Saves value as the last value after a delay.
        /// </summary>
        /// <param name="value">
        /// The new value.
        /// </param>
        /// <param name="delay">
        /// The delay in milliseconds.
        /// </param>
        /// <param name="current">The Current object for the dispatch.</param>
        /// <returns>
        /// The previous value.
        /// </returns>
        int set(int value, int delay, Ice.Current current);

        /// <summary>
        /// Shuts down the server.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>
        void shutdown(Ice.Current current);
    }
}

namespace Test
{
    public interface HoldPrx : Ice.ObjectPrx
    {
        /// <summary>
        /// Puts the adapter on hold, and optionally reactivates it.
        /// </summary>
        /// <param name="delay">
        /// When less than 0, puts the adapter on hold indefinitely. When 0, puts the adapter on hold and
        /// immediately reactivates it. When greater than 0, starts a background task that sleeps for delay
        /// milliseconds, puts the adapter on hold and then immediately reactivates it.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        void putOnHold(int delay, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Puts the adapter on hold, and optionally reactivates it.
        /// </summary>
        /// <param name="delay">
        /// When less than 0, puts the adapter on hold indefinitely. When 0, puts the adapter on hold and
        /// immediately reactivates it. When greater than 0, starts a background task that sleeps for delay
        /// milliseconds, puts the adapter on hold and then immediately reactivates it.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task putOnHoldAsync(int delay, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Starts a background task that calls waitForHold and activate on the adapter.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        void waitForHold(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Starts a background task that calls waitForHold and activate on the adapter.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task waitForHoldAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Saves value as the last value.
        /// </summary>
        /// <param name="value">
        /// The new value.
        /// </param>
        /// <param name="expected">
        /// The current value as expected by the caller.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        void setOneway(int value, int expected, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Saves value as the last value.
        /// </summary>
        /// <param name="value">
        /// The new value.
        /// </param>
        /// <param name="expected">
        /// The current value as expected by the caller.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task setOnewayAsync(int value, int expected, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Saves value as the last value after a delay.
        /// </summary>
        /// <param name="value">
        /// The new value.
        /// </param>
        /// <param name="delay">
        /// The delay in milliseconds.
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>
        /// The previous value.
        /// </returns>
        int set(int value, int delay, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Saves value as the last value after a delay.
        /// </summary>
        /// <param name="value">
        /// The new value.
        /// </param>
        /// <param name="delay">
        /// The delay in milliseconds.
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<int> setAsync(int value, int delay, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Shuts down the server.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        void shutdown(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Shuts down the server.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>A task that represents the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task shutdownAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }
}

namespace Test
{
    public sealed class HoldPrxHelper : Ice.ObjectPrxHelperBase, HoldPrx
    {
        public void putOnHold(int delay, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_putOnHoldAsync(delay, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void waitForHold(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_waitForHoldAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void setOneway(int value, int expected, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_setOnewayAsync(value, expected, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public int set(int value, int delay, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_setAsync(value, delay, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void shutdown(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_shutdownAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task putOnHoldAsync(int delay, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_putOnHoldAsync(delay, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_putOnHoldAsync(int iceP_delay, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_putOnHold(iceP_delay, context, synchronous, completed);
            return completed.Task;
        }

        private const string _putOnHold_name = "putOnHold";

        private void _iceI_putOnHold(int iceP_delay, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _putOnHold_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_delay);
                });
        }

        public global::System.Threading.Tasks.Task waitForHoldAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_waitForHoldAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_waitForHoldAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_waitForHold(context, synchronous, completed);
            return completed.Task;
        }

        private const string _waitForHold_name = "waitForHold";

        private void _iceI_waitForHold(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _waitForHold_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous);
        }

        public global::System.Threading.Tasks.Task setOnewayAsync(int value, int expected, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_setOnewayAsync(value, expected, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_setOnewayAsync(int iceP_value, int iceP_expected, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_setOneway(iceP_value, iceP_expected, context, synchronous, completed);
            return completed.Task;
        }

        private const string _setOneway_name = "setOneway";

        private void _iceI_setOneway(int iceP_value, int iceP_expected, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _setOneway_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_value);
                    ostr.writeInt(iceP_expected);
                });
        }

        public global::System.Threading.Tasks.Task<int> setAsync(int value, int delay, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_setAsync(value, delay, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<int> _iceI_setAsync(int iceP_value, int iceP_delay, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_set_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<int>(progress, cancel);
            _iceI_set(iceP_value, iceP_delay, context, synchronous, completed);
            return completed.Task;
        }

        private const string _set_name = "set";

        private void _iceI_set(int iceP_value, int iceP_delay, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<int>(completed);
            outAsync.invoke(
                _set_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_value);
                    ostr.writeInt(iceP_delay);
                },
                read: (Ice.InputStream istr) =>
                {
                    int ret;
                    ret = istr.readInt();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task shutdownAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_shutdownAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_shutdownAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_shutdown(context, synchronous, completed);
            return completed.Task;
        }

        private const string _shutdown_name = "shutdown";

        private void _iceI_shutdown(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _shutdown_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous);
        }

        public static HoldPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new HoldPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static HoldPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new HoldPrxHelper(b) : null;

        public static HoldPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static HoldPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new HoldPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static HoldPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::Test::Hold"
        };

        public static string ice_staticId() => "::Test::Hold";

        public static void write(Ice.OutputStream ostr, HoldPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static HoldPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new HoldPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new HoldPrxHelper(reference);

        private HoldPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private HoldPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }
}

namespace Test
{
    public abstract class HoldDisp_ : Ice.ObjectImpl, Hold
    {
        public abstract void putOnHold(int delay, Ice.Current current);

        public abstract void waitForHold(Ice.Current current);

        public abstract void setOneway(int value, int expected, Ice.Current current);

        public abstract int set(int value, int delay, Ice.Current current);

        public abstract void shutdown(Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::Test::Hold";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "putOnHold" => Hold.iceD_putOnHoldAsync(this, request),
                "waitForHold" => Hold.iceD_waitForHoldAsync(this, request),
                "setOneway" => Hold.iceD_setOnewayAsync(this, request),
                "set" => Hold.iceD_setAsync(this, request),
                "shutdown" => Hold.iceD_shutdownAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }
}

namespace Test
{
    public partial interface Hold
    {
        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_putOnHoldAsync(
            Hold obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            int iceP_delay;
            iceP_delay = istr.readInt();
            istr.endEncapsulation();
            obj.putOnHold(iceP_delay, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_waitForHoldAsync(
            Hold obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            obj.waitForHold(request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_setOnewayAsync(
            Hold obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            int iceP_value;
            int iceP_expected;
            iceP_value = istr.readInt();
            iceP_expected = istr.readInt();
            istr.endEncapsulation();
            obj.setOneway(iceP_value, iceP_expected, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_setAsync(
            Hold obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            int iceP_value;
            int iceP_delay;
            iceP_value = istr.readInt();
            iceP_delay = istr.readInt();
            istr.endEncapsulation();
            var ret = obj.set(iceP_value, iceP_delay, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeInt(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_shutdownAsync(
            Hold obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            obj.shutdown(request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }
    }
}
