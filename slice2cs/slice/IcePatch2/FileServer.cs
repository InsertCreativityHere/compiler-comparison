//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `FileServer.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//


using _System = global::System;

#pragma warning disable 1591

namespace IcePatch2
{
    /// <summary>
    /// A partition argument was not in the range 0-255.
    /// </summary>

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1032")]
    [global::System.Serializable]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial class PartitionOutOfRangeException : global::Ice.UserException
    {
        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public PartitionOutOfRangeException()
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public PartitionOutOfRangeException(global::System.Exception ex) : base(ex)
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public PartitionOutOfRangeException(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : base(info, context)
        {
        }

        #endregion

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override string ice_id()
        {
            return "::IcePatch2::PartitionOutOfRangeException";
        }

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override int GetHashCode()
        {
            int h_ = 5381;
            global::IceInternal.HashUtil.hashAdd(ref h_, "::IcePatch2::PartitionOutOfRangeException");
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override bool Equals(object other)
        {
            if(other == null)
            {
                return false;
            }
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            PartitionOutOfRangeException o = other as PartitionOutOfRangeException;
            if(o == null)
            {
                return false;
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator==(PartitionOutOfRangeException lhs, PartitionOutOfRangeException rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator!=(PartitionOutOfRangeException lhs, PartitionOutOfRangeException rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceWriteImpl(global::Ice.OutputStream ostr_)
        {
            ostr_.startSlice("::IcePatch2::PartitionOutOfRangeException", -1, true);
            ostr_.endSlice();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceReadImpl(global::Ice.InputStream istr_)
        {
            istr_.startSlice();
            istr_.endSlice();
        }

        #endregion
    }

    /// <summary>
    /// This exception is raised if a file's contents cannot be read.
    /// </summary>

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1032")]
    [global::System.Serializable]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial class FileAccessException : global::Ice.UserException
    {
        #region Slice data members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public string reason;

        #endregion

        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        private void _initDM()
        {
            this.reason = "";
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public FileAccessException()
        {
            _initDM();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public FileAccessException(global::System.Exception ex) : base(ex)
        {
            _initDM();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public FileAccessException(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : base(info, context)
        {
            this.reason = info.GetString("reason");
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        private void _initDM(string reason)
        {
            this.reason = reason;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public FileAccessException(string reason)
        {
            _initDM(reason);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public FileAccessException(string reason, global::System.Exception ex) : base(ex)
        {
            _initDM(reason);
        }

        #endregion

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override string ice_id()
        {
            return "::IcePatch2::FileAccessException";
        }

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override int GetHashCode()
        {
            int h_ = 5381;
            global::IceInternal.HashUtil.hashAdd(ref h_, "::IcePatch2::FileAccessException");
            global::IceInternal.HashUtil.hashAdd(ref h_, reason);
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override bool Equals(object other)
        {
            if(other == null)
            {
                return false;
            }
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            FileAccessException o = other as FileAccessException;
            if(o == null)
            {
                return false;
            }
            if(this.reason == null)
            {
                if(o.reason != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.reason.Equals(o.reason))
                {
                    return false;
                }
            }
            return true;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override void GetObjectData(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context)
        {
            info.AddValue("reason", this.reason == null ? "" : this.reason);

            base.GetObjectData(info, context);
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator==(FileAccessException lhs, FileAccessException rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator!=(FileAccessException lhs, FileAccessException rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceWriteImpl(global::Ice.OutputStream ostr_)
        {
            ostr_.startSlice("::IcePatch2::FileAccessException", -1, true);
            ostr_.writeString(reason);
            ostr_.endSlice();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceReadImpl(global::Ice.InputStream istr_)
        {
            istr_.startSlice();
            reason = istr_.readString();
            istr_.endSlice();
        }

        #endregion
    }

    /// <summary>
    /// This exception is raised if an operation tries to use a file whose size is
    /// larger than 2.1 GB.
    /// Use the "large" versions of the operations instead.
    /// </summary>

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1032")]
    [global::System.Serializable]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial class FileSizeRangeException : FileAccessException
    {
        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public FileSizeRangeException()
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public FileSizeRangeException(global::System.Exception ex) : base(ex)
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public FileSizeRangeException(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : base(info, context)
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public FileSizeRangeException(string reason) : base(reason)
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public FileSizeRangeException(string reason, global::System.Exception ex) : base(reason, ex)
        {
        }

        #endregion

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override string ice_id()
        {
            return "::IcePatch2::FileSizeRangeException";
        }

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override int GetHashCode()
        {
            int h_ = base.GetHashCode();
            global::IceInternal.HashUtil.hashAdd(ref h_, "::IcePatch2::FileSizeRangeException");
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public override bool Equals(object other)
        {
            if(other == null)
            {
                return false;
            }
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            FileSizeRangeException o = other as FileSizeRangeException;
            if(o == null)
            {
                return false;
            }
            if(!base.Equals(other))
            {
                return false;
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator==(FileSizeRangeException lhs, FileSizeRangeException rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        public static bool operator!=(FileSizeRangeException lhs, FileSizeRangeException rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceWriteImpl(global::Ice.OutputStream ostr_)
        {
            ostr_.startSlice("::IcePatch2::FileSizeRangeException", -1, false);
            ostr_.endSlice();
            base.iceWriteImpl(ostr_);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        protected override void iceReadImpl(global::Ice.InputStream istr_)
        {
            istr_.startSlice();
            istr_.endSlice();
            base.iceReadImpl(istr_);
        }

        #endregion
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial interface FileServer : global::Ice.Object, FileServerOperations_
    {
    }
}

namespace IcePatch2
{
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_FileServer_getFileInfoSeq(FileInfo[] ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_FileServer_getLargeFileInfoSeq(LargeFileInfo[] ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_FileServer_getChecksumSeq(byte[][] ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_FileServer_getChecksum(byte[] ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_FileServer_getFileCompressed(byte[] ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public delegate void Callback_FileServer_getLargeFileCompressed(byte[] ret);
}

namespace IcePatch2
{
    /// <summary>
    /// The interface that provides access to files.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public interface FileServerPrx : global::Ice.ObjectPrx
    {
        /// <summary>
        /// Return file information for the specified partition.
        ///
        /// <para>getFileInfoSeq() is deprecated, use getLargeFileInfoSeq() instead.</para>
        ///
        /// &lt;p class="Deprecated"&gt; This operation is deprecated and only present for
        /// compatibility with old Ice clients (older than version 3.6).
        ///
        /// </summary>
        /// <param name="partition">The partition number in the range 0-255.
        ///
        /// </param>
        /// <returns>A sequence containing information about the files in the
        /// specified partition.
        ///
        /// </returns>
        /// <exception name="PartitionOutOfRangeException">If the partition number is out of range.
        /// </exception>
        /// <exception name="FileSizeRangeException">If a file is larger than 2.1GB.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        [global::System.Obsolete("getFileInfoSeq() is deprecated, use getLargeFileInfoSeq() instead.")]
        FileInfo[] getFileInfoSeq(int partition, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Return file information for the specified partition.
        /// &lt;p class="Deprecated"&gt; This operation is deprecated and only present for
        /// </summary>
        /// <param name="partition">The partition number in the range 0-255.
        ///
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        /// <para>getFileInfoSeq() is deprecated, use getLargeFileInfoSeq() instead.</para>
        [global::System.Obsolete("getFileInfoSeq() is deprecated, use getLargeFileInfoSeq() instead.")]
        global::System.Threading.Tasks.Task<FileInfo[]> getFileInfoSeqAsync(int partition, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Return file information for the specified partition.
        /// &lt;p class="Deprecated"&gt; This operation is deprecated and only present for
        /// </summary>
        /// <param name="partition">The partition number in the range 0-255.
        ///
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        /// <para>getFileInfoSeq() is deprecated, use getLargeFileInfoSeq() instead.</para>
        [global::System.Obsolete("getFileInfoSeq() is deprecated, use getLargeFileInfoSeq() instead.")]
        global::Ice.AsyncResult<Callback_FileServer_getFileInfoSeq> begin_getFileInfoSeq(int partition, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Return file information for the specified partition.
        /// &lt;p class="Deprecated"&gt; This operation is deprecated and only present for
        /// </summary>
        /// <param name="partition">The partition number in the range 0-255.
        ///
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        /// <para>getFileInfoSeq() is deprecated, use getLargeFileInfoSeq() instead.</para>
        [global::System.Obsolete("getFileInfoSeq() is deprecated, use getLargeFileInfoSeq() instead.")]
        global::Ice.AsyncResult begin_getFileInfoSeq(int partition, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Return file information for the specified partition.
        /// &lt;p class="Deprecated"&gt; This operation is deprecated and only present for
        /// </summary>
        /// <param name="partition">The partition number in the range 0-255.
        ///
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        /// <para>getFileInfoSeq() is deprecated, use getLargeFileInfoSeq() instead.</para>
        [global::System.Obsolete("getFileInfoSeq() is deprecated, use getLargeFileInfoSeq() instead.")]
        global::Ice.AsyncResult begin_getFileInfoSeq(int partition, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Return file information for the specified partition.
        /// &lt;p class="Deprecated"&gt; This operation is deprecated and only present for
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>A sequence containing information about the files in the
        /// specified partition.
        ///
        /// </returns>
        /// <para>getFileInfoSeq() is deprecated, use getLargeFileInfoSeq() instead.</para>
        [global::System.Obsolete("getFileInfoSeq() is deprecated, use getLargeFileInfoSeq() instead.")]
        FileInfo[] end_getFileInfoSeq(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Returns file information for the specified partition.
        /// </summary>
        /// <param name="partition">The partition number in the range 0-255.
        ///
        /// </param>
        /// <returns>A sequence containing information about the files in the
        /// specified partition.
        ///
        /// </returns>
        /// <exception name="PartitionOutOfRangeException">If the partition number is out of range.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        LargeFileInfo[] getLargeFileInfoSeq(int partition, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Returns file information for the specified partition.
        /// </summary>
        /// <param name="partition">The partition number in the range 0-255.
        ///
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<LargeFileInfo[]> getLargeFileInfoSeqAsync(int partition, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Returns file information for the specified partition.
        /// </summary>
        /// <param name="partition">The partition number in the range 0-255.
        ///
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_FileServer_getLargeFileInfoSeq> begin_getLargeFileInfoSeq(int partition, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Returns file information for the specified partition.
        /// </summary>
        /// <param name="partition">The partition number in the range 0-255.
        ///
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getLargeFileInfoSeq(int partition, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Returns file information for the specified partition.
        /// </summary>
        /// <param name="partition">The partition number in the range 0-255.
        ///
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getLargeFileInfoSeq(int partition, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Returns file information for the specified partition.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>A sequence containing information about the files in the
        /// specified partition.
        ///
        /// </returns>
        LargeFileInfo[] end_getLargeFileInfoSeq(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Return the checksums for all partitions.
        /// </summary>
        /// <returns>A sequence containing 256 checksums. Partitions with a
        /// checksum that differs from the previous checksum for the same
        /// partition contain updated files. Partitions with a checksum
        /// that is identical to the previous checksum do not contain
        /// updated files.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        byte[][] getChecksumSeq(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Return the checksums for all partitions.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<byte[][]> getChecksumSeqAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Return the checksums for all partitions.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_FileServer_getChecksumSeq> begin_getChecksumSeq(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Return the checksums for all partitions.
        /// </summary>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getChecksumSeq(global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Return the checksums for all partitions.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getChecksumSeq(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Return the checksums for all partitions.
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>A sequence containing 256 checksums. Partitions with a
        /// checksum that differs from the previous checksum for the same
        /// partition contain updated files. Partitions with a checksum
        /// that is identical to the previous checksum do not contain
        /// updated files.</returns>
        byte[][] end_getChecksumSeq(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Return the master checksum for all partitions.
        /// If this checksum is the same
        /// as for a previous run, the entire file set is up-to-date.
        ///
        /// </summary>
        /// <returns>The master checksum for the file set.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        byte[] getChecksum(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Return the master checksum for all partitions.
        /// If this checksum is the same
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<byte[]> getChecksumAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Return the master checksum for all partitions.
        /// If this checksum is the same
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_FileServer_getChecksum> begin_getChecksum(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Return the master checksum for all partitions.
        /// If this checksum is the same
        /// </summary>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getChecksum(global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Return the master checksum for all partitions.
        /// If this checksum is the same
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getChecksum(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Return the master checksum for all partitions.
        /// If this checksum is the same
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>The master checksum for the file set.</returns>
        byte[] end_getChecksum(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Read the specified file.
        ///
        /// <para>getFileCompressed() is deprecated, use getLargeFileCompressed() instead.</para>
        ///
        /// This operation may only return fewer bytes than requested
        /// in case there was an end-of-file condition.
        ///
        /// &lt;p class="Deprecated"&gt; This operation is deprecated and only present for
        /// compatibility with old Ice clients (older than version 3.6).
        ///
        /// </summary>
        /// <param name="path">The pathname (relative to the data directory) for
        /// the file to be read.
        ///
        /// </param>
        /// <param name="pos">The file offset at which to begin reading.
        ///
        /// </param>
        /// <param name="num">The number of bytes to be read.
        ///
        /// </param>
        /// <returns>A sequence containing the compressed file contents.
        ///
        /// </returns>
        /// <exception name="FileAccessException">If an error occurred while trying to read the file.
        /// </exception>
        /// <exception name="FileSizeRangeException">If a file is larger than 2.1GB.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        [global::System.Obsolete("getFileCompressed() is deprecated, use getLargeFileCompressed() instead.")]
        byte[] getFileCompressed(string path, int pos, int num, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Read the specified file.
        /// This operation may only return fewer bytes than requested
        /// </summary>
        /// <param name="path">The pathname (relative to the data directory) for
        /// the file to be read.
        ///
        /// </param>
        /// <param name="pos">The file offset at which to begin reading.
        ///
        /// </param>
        /// <param name="num">The number of bytes to be read.
        ///
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        /// <para>getFileCompressed() is deprecated, use getLargeFileCompressed() instead.</para>
        [global::System.Obsolete("getFileCompressed() is deprecated, use getLargeFileCompressed() instead.")]
        global::System.Threading.Tasks.Task<byte[]> getFileCompressedAsync(string path, int pos, int num, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Read the specified file.
        /// This operation may only return fewer bytes than requested
        /// </summary>
        /// <param name="path">The pathname (relative to the data directory) for
        /// the file to be read.
        ///
        /// </param>
        /// <param name="pos">The file offset at which to begin reading.
        ///
        /// </param>
        /// <param name="num">The number of bytes to be read.
        ///
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        /// <para>getFileCompressed() is deprecated, use getLargeFileCompressed() instead.</para>
        [global::System.Obsolete("getFileCompressed() is deprecated, use getLargeFileCompressed() instead.")]
        global::Ice.AsyncResult<Callback_FileServer_getFileCompressed> begin_getFileCompressed(string path, int pos, int num, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Read the specified file.
        /// This operation may only return fewer bytes than requested
        /// </summary>
        /// <param name="path">The pathname (relative to the data directory) for
        /// the file to be read.
        ///
        /// </param>
        /// <param name="pos">The file offset at which to begin reading.
        ///
        /// </param>
        /// <param name="num">The number of bytes to be read.
        ///
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        /// <para>getFileCompressed() is deprecated, use getLargeFileCompressed() instead.</para>
        [global::System.Obsolete("getFileCompressed() is deprecated, use getLargeFileCompressed() instead.")]
        global::Ice.AsyncResult begin_getFileCompressed(string path, int pos, int num, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Read the specified file.
        /// This operation may only return fewer bytes than requested
        /// </summary>
        /// <param name="path">The pathname (relative to the data directory) for
        /// the file to be read.
        ///
        /// </param>
        /// <param name="pos">The file offset at which to begin reading.
        ///
        /// </param>
        /// <param name="num">The number of bytes to be read.
        ///
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        /// <para>getFileCompressed() is deprecated, use getLargeFileCompressed() instead.</para>
        [global::System.Obsolete("getFileCompressed() is deprecated, use getLargeFileCompressed() instead.")]
        global::Ice.AsyncResult begin_getFileCompressed(string path, int pos, int num, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Read the specified file.
        /// This operation may only return fewer bytes than requested
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>A sequence containing the compressed file contents.
        ///
        /// </returns>
        /// <para>getFileCompressed() is deprecated, use getLargeFileCompressed() instead.</para>
        [global::System.Obsolete("getFileCompressed() is deprecated, use getLargeFileCompressed() instead.")]
        byte[] end_getFileCompressed(global::Ice.AsyncResult asyncResult);

        /// <summary>
        /// Read the specified file.
        /// This operation may only return fewer bytes than requested
        /// in case there was an end-of-file condition.
        ///
        /// </summary>
        /// <param name="path">The pathname (relative to the data directory) for
        /// the file to be read.
        ///
        /// </param>
        /// <param name="pos">The file offset at which to begin reading.
        ///
        /// </param>
        /// <param name="num">The number of bytes to be read.
        ///
        /// </param>
        /// <returns>A sequence containing the compressed file contents.
        ///
        /// </returns>
        /// <exception name="FileAccessException">If an error occurred while trying to read the file.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        byte[] getLargeFileCompressed(string path, long pos, int num, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Read the specified file.
        /// This operation may only return fewer bytes than requested
        /// </summary>
        /// <param name="path">The pathname (relative to the data directory) for
        /// the file to be read.
        ///
        /// </param>
        /// <param name="pos">The file offset at which to begin reading.
        ///
        /// </param>
        /// <param name="num">The number of bytes to be read.
        ///
        /// </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<byte[]> getLargeFileCompressedAsync(string path, long pos, int num, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Read the specified file.
        /// This operation may only return fewer bytes than requested
        /// </summary>
        /// <param name="path">The pathname (relative to the data directory) for
        /// the file to be read.
        ///
        /// </param>
        /// <param name="pos">The file offset at which to begin reading.
        ///
        /// </param>
        /// <param name="num">The number of bytes to be read.
        ///
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult<Callback_FileServer_getLargeFileCompressed> begin_getLargeFileCompressed(string path, long pos, int num, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Read the specified file.
        /// This operation may only return fewer bytes than requested
        /// </summary>
        /// <param name="path">The pathname (relative to the data directory) for
        /// the file to be read.
        ///
        /// </param>
        /// <param name="pos">The file offset at which to begin reading.
        ///
        /// </param>
        /// <param name="num">The number of bytes to be read.
        ///
        /// </param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getLargeFileCompressed(string path, long pos, int num, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Read the specified file.
        /// This operation may only return fewer bytes than requested
        /// </summary>
        /// <param name="path">The pathname (relative to the data directory) for
        /// the file to be read.
        ///
        /// </param>
        /// <param name="pos">The file offset at which to begin reading.
        ///
        /// </param>
        /// <param name="num">The number of bytes to be read.
        ///
        /// </param>
        /// <param name="context">The Context map to send with the invocation.</param>
        /// <param name="callback">Asynchronous callback invoked when the operation completes.</param>
        /// <param name="cookie">Application data to store in the asynchronous result object.</param>
        /// <returns>An asynchronous result object.</returns>
        global::Ice.AsyncResult begin_getLargeFileCompressed(string path, long pos, int num, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie);

        /// <summary>
        /// Read the specified file.
        /// This operation may only return fewer bytes than requested
        /// </summary>
        /// <param name="asyncResult">The asynchronous result object for the invocation.</param>
        /// <returns>A sequence containing the compressed file contents.
        ///
        /// </returns>
        byte[] end_getLargeFileCompressed(global::Ice.AsyncResult asyncResult);
    }
}

namespace IcePatch2
{
    /// <summary>
    /// The interface that provides access to files.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public interface FileServerOperations_
    {
        /// <summary>
        /// Return file information for the specified partition.
        ///
        /// <para>getFileInfoSeq() is deprecated, use getLargeFileInfoSeq() instead.</para>
        ///
        /// &lt;p class="Deprecated"&gt; This operation is deprecated and only present for
        /// compatibility with old Ice clients (older than version 3.6).
        ///
        /// </summary>
        /// <param name="partition">The partition number in the range 0-255.
        ///
        /// </param>
        /// <returns>A sequence containing information about the files in the
        /// specified partition.
        ///
        /// </returns>
        /// <exception name="PartitionOutOfRangeException">If the partition number is out of range.
        /// </exception>
        /// <exception name="FileSizeRangeException">If a file is larger than 2.1GB.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.Obsolete("getFileInfoSeq() is deprecated, use getLargeFileInfoSeq() instead.")]
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        FileInfo[] getFileInfoSeq(int partition, global::Ice.Current current = null);

        /// <summary>
        /// Returns file information for the specified partition.
        /// </summary>
        /// <param name="partition">The partition number in the range 0-255.
        ///
        /// </param>
        /// <returns>A sequence containing information about the files in the
        /// specified partition.
        ///
        /// </returns>
        /// <exception name="PartitionOutOfRangeException">If the partition number is out of range.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        LargeFileInfo[] getLargeFileInfoSeq(int partition, global::Ice.Current current = null);

        /// <summary>
        /// Return the checksums for all partitions.
        /// </summary>
        /// <returns>A sequence containing 256 checksums. Partitions with a
        /// checksum that differs from the previous checksum for the same
        /// partition contain updated files. Partitions with a checksum
        /// that is identical to the previous checksum do not contain
        /// updated files.</returns>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        byte[][] getChecksumSeq(global::Ice.Current current = null);

        /// <summary>
        /// Return the master checksum for all partitions.
        /// If this checksum is the same
        /// as for a previous run, the entire file set is up-to-date.
        ///
        /// </summary>
        /// <returns>The master checksum for the file set.</returns>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        byte[] getChecksum(global::Ice.Current current = null);

        /// <summary>
        /// Read the specified file.
        /// This operation may only return fewer bytes than requested
        /// </summary>
        /// <param name="path">The pathname (relative to the data directory) for
        /// the file to be read.
        ///
        /// </param>
        /// <param name="pos">The file offset at which to begin reading.
        ///
        /// </param>
        /// <param name="num">The number of bytes to be read.
        ///
        /// </param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        /// <para>getFileCompressed() is deprecated, use getLargeFileCompressed() instead.</para>
        [global::System.Obsolete("getFileCompressed() is deprecated, use getLargeFileCompressed() instead.")]
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<byte[]> getFileCompressedAsync(string path, int pos, int num, global::Ice.Current current = null);

        /// <summary>
        /// Read the specified file.
        /// This operation may only return fewer bytes than requested
        /// </summary>
        /// <param name="path">The pathname (relative to the data directory) for
        /// the file to be read.
        ///
        /// </param>
        /// <param name="pos">The file offset at which to begin reading.
        ///
        /// </param>
        /// <param name="num">The number of bytes to be read.
        ///
        /// </param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
        global::System.Threading.Tasks.Task<byte[]> getLargeFileCompressedAsync(string path, long pos, int num, global::Ice.Current current = null);
    }
}

namespace IcePatch2
{
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public sealed class ByteSeqSeqHelper
    {
        public static void write(global::Ice.OutputStream ostr, byte[][] v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    global::Ice.ByteSeqHelper.write(ostr, v[ix]);
                }
            }
        }

        public static byte[][] read(global::Ice.InputStream istr)
        {
            byte[][] v;
            {
                int szx = istr.readAndCheckSeqSize(1);
                v = new byte[szx][];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = global::Ice.ByteSeqHelper.read(istr);
                }
            }
            return v;
        }
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    [global::System.Serializable]
    public sealed class FileServerPrxHelper : global::Ice.ObjectPrxHelperBase, FileServerPrx
    {
        public FileServerPrxHelper()
        {
        }

        public FileServerPrxHelper(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : base(info, context)
        {
        }

        #region Synchronous operations

        public FileInfo[] getFileInfoSeq(int partition, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getFileInfoSeqAsync(partition, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public LargeFileInfo[] getLargeFileInfoSeq(int partition, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getLargeFileInfoSeqAsync(partition, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public byte[][] getChecksumSeq(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getChecksumSeqAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public byte[] getChecksum(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getChecksumAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public byte[] getFileCompressed(string path, int pos, int num, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getFileCompressedAsync(path, pos, num, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public byte[] getLargeFileCompressed(string path, long pos, int num, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getLargeFileCompressedAsync(path, pos, num, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        #endregion

        #region Async Task operations

        public global::System.Threading.Tasks.Task<FileInfo[]> getFileInfoSeqAsync(int partition, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getFileInfoSeqAsync(partition, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<FileInfo[]> _iceI_getFileInfoSeqAsync(int iceP_partition, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getFileInfoSeq_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<FileInfo[]>(progress, cancel);
            _iceI_getFileInfoSeq(iceP_partition, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getFileInfoSeq_name = "getFileInfoSeq";

        private void _iceI_getFileInfoSeq(int iceP_partition, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<FileInfo[]>(completed);
            outAsync.invoke(
                _getFileInfoSeq_name,
                global::Ice.OperationMode.Nonmutating,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_partition);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(FileSizeRangeException)
                    {
                        throw;
                    }
                    catch(PartitionOutOfRangeException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    FileInfo[] ret;
                    ret = FileInfoSeqHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<LargeFileInfo[]> getLargeFileInfoSeqAsync(int partition, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getLargeFileInfoSeqAsync(partition, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<LargeFileInfo[]> _iceI_getLargeFileInfoSeqAsync(int iceP_partition, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getLargeFileInfoSeq_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<LargeFileInfo[]>(progress, cancel);
            _iceI_getLargeFileInfoSeq(iceP_partition, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getLargeFileInfoSeq_name = "getLargeFileInfoSeq";

        private void _iceI_getLargeFileInfoSeq(int iceP_partition, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<LargeFileInfo[]>(completed);
            outAsync.invoke(
                _getLargeFileInfoSeq_name,
                global::Ice.OperationMode.Nonmutating,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_partition);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(PartitionOutOfRangeException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    LargeFileInfo[] ret;
                    ret = LargeFileInfoSeqHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<byte[][]> getChecksumSeqAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getChecksumSeqAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<byte[][]> _iceI_getChecksumSeqAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getChecksumSeq_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<byte[][]>(progress, cancel);
            _iceI_getChecksumSeq(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getChecksumSeq_name = "getChecksumSeq";

        private void _iceI_getChecksumSeq(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<byte[][]>(completed);
            outAsync.invoke(
                _getChecksumSeq_name,
                global::Ice.OperationMode.Nonmutating,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                read: (global::Ice.InputStream istr) =>
                {
                    byte[][] ret;
                    ret = ByteSeqSeqHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<byte[]> getChecksumAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getChecksumAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<byte[]> _iceI_getChecksumAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getChecksum_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<byte[]>(progress, cancel);
            _iceI_getChecksum(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getChecksum_name = "getChecksum";

        private void _iceI_getChecksum(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<byte[]>(completed);
            outAsync.invoke(
                _getChecksum_name,
                global::Ice.OperationMode.Nonmutating,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                read: (global::Ice.InputStream istr) =>
                {
                    byte[] ret;
                    ret = global::Ice.ByteSeqHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<byte[]> getFileCompressedAsync(string path, int pos, int num, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getFileCompressedAsync(path, pos, num, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<byte[]> _iceI_getFileCompressedAsync(string iceP_path, int iceP_pos, int iceP_num, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getFileCompressed_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<byte[]>(progress, cancel);
            _iceI_getFileCompressed(iceP_path, iceP_pos, iceP_num, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getFileCompressed_name = "getFileCompressed";

        private void _iceI_getFileCompressed(string iceP_path, int iceP_pos, int iceP_num, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<byte[]>(completed);
            outAsync.invoke(
                _getFileCompressed_name,
                global::Ice.OperationMode.Nonmutating,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_path);
                    ostr.writeInt(iceP_pos);
                    ostr.writeInt(iceP_num);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(FileSizeRangeException)
                    {
                        throw;
                    }
                    catch(FileAccessException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    byte[] ret;
                    ret = global::Ice.ByteSeqHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<byte[]> getLargeFileCompressedAsync(string path, long pos, int num, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getLargeFileCompressedAsync(path, pos, num, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<byte[]> _iceI_getLargeFileCompressedAsync(string iceP_path, long iceP_pos, int iceP_num, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getLargeFileCompressed_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<byte[]>(progress, cancel);
            _iceI_getLargeFileCompressed(iceP_path, iceP_pos, iceP_num, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getLargeFileCompressed_name = "getLargeFileCompressed";

        private void _iceI_getLargeFileCompressed(string iceP_path, long iceP_pos, int iceP_num, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<byte[]>(completed);
            outAsync.invoke(
                _getLargeFileCompressed_name,
                global::Ice.OperationMode.Nonmutating,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_path);
                    ostr.writeLong(iceP_pos);
                    ostr.writeInt(iceP_num);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(FileAccessException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    byte[] ret;
                    ret = global::Ice.ByteSeqHelper.read(istr);
                    return ret;
                });
        }

        #endregion

        #region Asynchronous operations

        public global::Ice.AsyncResult<Callback_FileServer_getFileInfoSeq> begin_getFileInfoSeq(int partition, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getFileInfoSeq(partition, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getFileInfoSeq(int partition, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getFileInfoSeq(partition, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getFileInfoSeq(int partition, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getFileInfoSeq(partition, context, callback, cookie, false);
        }

        public FileInfo[] end_getFileInfoSeq(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getFileInfoSeq_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<FileInfo[]>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_FileServer_getFileInfoSeq> begin_getFileInfoSeq(int iceP_partition, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getFileInfoSeq_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_FileServer_getFileInfoSeq, FileInfo[]>(
                (Callback_FileServer_getFileInfoSeq cb, FileInfo[] ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getFileInfoSeq_name, cookie, completedCallback);
            _iceI_getFileInfoSeq(iceP_partition, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_FileServer_getLargeFileInfoSeq> begin_getLargeFileInfoSeq(int partition, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getLargeFileInfoSeq(partition, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getLargeFileInfoSeq(int partition, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getLargeFileInfoSeq(partition, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getLargeFileInfoSeq(int partition, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getLargeFileInfoSeq(partition, context, callback, cookie, false);
        }

        public LargeFileInfo[] end_getLargeFileInfoSeq(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getLargeFileInfoSeq_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<LargeFileInfo[]>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_FileServer_getLargeFileInfoSeq> begin_getLargeFileInfoSeq(int iceP_partition, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getLargeFileInfoSeq_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_FileServer_getLargeFileInfoSeq, LargeFileInfo[]>(
                (Callback_FileServer_getLargeFileInfoSeq cb, LargeFileInfo[] ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getLargeFileInfoSeq_name, cookie, completedCallback);
            _iceI_getLargeFileInfoSeq(iceP_partition, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_FileServer_getChecksumSeq> begin_getChecksumSeq(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getChecksumSeq(context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getChecksumSeq(global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getChecksumSeq(new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getChecksumSeq(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getChecksumSeq(context, callback, cookie, false);
        }

        public byte[][] end_getChecksumSeq(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getChecksumSeq_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<byte[][]>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_FileServer_getChecksumSeq> begin_getChecksumSeq(global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getChecksumSeq_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_FileServer_getChecksumSeq, byte[][]>(
                (Callback_FileServer_getChecksumSeq cb, byte[][] ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getChecksumSeq_name, cookie, completedCallback);
            _iceI_getChecksumSeq(context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_FileServer_getChecksum> begin_getChecksum(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getChecksum(context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getChecksum(global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getChecksum(new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getChecksum(global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getChecksum(context, callback, cookie, false);
        }

        public byte[] end_getChecksum(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getChecksum_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<byte[]>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_FileServer_getChecksum> begin_getChecksum(global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getChecksum_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_FileServer_getChecksum, byte[]>(
                (Callback_FileServer_getChecksum cb, byte[] ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getChecksum_name, cookie, completedCallback);
            _iceI_getChecksum(context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_FileServer_getFileCompressed> begin_getFileCompressed(string path, int pos, int num, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getFileCompressed(path, pos, num, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getFileCompressed(string path, int pos, int num, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getFileCompressed(path, pos, num, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getFileCompressed(string path, int pos, int num, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getFileCompressed(path, pos, num, context, callback, cookie, false);
        }

        public byte[] end_getFileCompressed(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getFileCompressed_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<byte[]>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_FileServer_getFileCompressed> begin_getFileCompressed(string iceP_path, int iceP_pos, int iceP_num, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getFileCompressed_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_FileServer_getFileCompressed, byte[]>(
                (Callback_FileServer_getFileCompressed cb, byte[] ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getFileCompressed_name, cookie, completedCallback);
            _iceI_getFileCompressed(iceP_path, iceP_pos, iceP_num, context, synchronous, completed);
            return completed;
        }

        public global::Ice.AsyncResult<Callback_FileServer_getLargeFileCompressed> begin_getLargeFileCompressed(string path, long pos, int num, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            return begin_getLargeFileCompressed(path, pos, num, context, null, null, false);
        }

        public global::Ice.AsyncResult begin_getLargeFileCompressed(string path, long pos, int num, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getLargeFileCompressed(path, pos, num, new global::Ice.OptionalContext(), callback, cookie, false);
        }

        public global::Ice.AsyncResult begin_getLargeFileCompressed(string path, long pos, int num, global::Ice.OptionalContext context, global::Ice.AsyncCallback callback, object cookie)
        {
            return begin_getLargeFileCompressed(path, pos, num, context, callback, cookie, false);
        }

        public byte[] end_getLargeFileCompressed(global::Ice.AsyncResult asyncResult)
        {
            var resultI_ = global::IceInternal.AsyncResultI.check(asyncResult, this, _getLargeFileCompressed_name);
            var outgoing_ = (global::IceInternal.OutgoingAsyncT<byte[]>)resultI_.OutgoingAsync;
            return outgoing_.getResult(resultI_.wait());
        }

        private global::Ice.AsyncResult<Callback_FileServer_getLargeFileCompressed> begin_getLargeFileCompressed(string iceP_path, long iceP_pos, int iceP_num, global::System.Collections.Generic.Dictionary<string, string> context, global::Ice.AsyncCallback completedCallback, object cookie, bool synchronous)
        {
            iceCheckAsyncTwowayOnly(_getLargeFileCompressed_name);
            var completed = new global::IceInternal.OperationAsyncResultCompletionCallback<Callback_FileServer_getLargeFileCompressed, byte[]>(
                (Callback_FileServer_getLargeFileCompressed cb, byte[] ret) =>
                {
                    if(cb != null)
                    {
                        cb.Invoke(ret);
                    }
                },
                this, _getLargeFileCompressed_name, cookie, completedCallback);
            _iceI_getLargeFileCompressed(iceP_path, iceP_pos, iceP_num, context, synchronous, completed);
            return completed;
        }

        #endregion

        #region Checked and unchecked cast operations

        public static FileServerPrx checkedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            FileServerPrx r = b as FileServerPrx;
            if((r == null) && b.ice_isA(ice_staticId()))
            {
                FileServerPrxHelper h = new FileServerPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static FileServerPrx checkedCast(global::Ice.ObjectPrx b, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            FileServerPrx r = b as FileServerPrx;
            if((r == null) && b.ice_isA(ice_staticId(), ctx))
            {
                FileServerPrxHelper h = new FileServerPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static FileServerPrx checkedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId()))
                {
                    FileServerPrxHelper h = new FileServerPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static FileServerPrx checkedCast(global::Ice.ObjectPrx b, string f, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId(), ctx))
                {
                    FileServerPrxHelper h = new FileServerPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static FileServerPrx uncheckedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            FileServerPrx r = b as FileServerPrx;
            if(r == null)
            {
                FileServerPrxHelper h = new FileServerPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static FileServerPrx uncheckedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            FileServerPrxHelper h = new FileServerPrxHelper();
            h.iceCopyFrom(bb);
            return h;
        }

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IcePatch2::FileServer"
        };

        public static string ice_staticId()
        {
            return _ids[1];
        }

        #endregion

        #region Marshaling support

        public static void write(global::Ice.OutputStream ostr, FileServerPrx v)
        {
            ostr.writeProxy(v);
        }

        public static FileServerPrx read(global::Ice.InputStream istr)
        {
            global::Ice.ObjectPrx proxy = istr.readProxy();
            if(proxy != null)
            {
                FileServerPrxHelper result = new FileServerPrxHelper();
                result.iceCopyFrom(proxy);
                return result;
            }
            return null;
        }

        #endregion
    }
}

namespace IcePatch2
{
    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.7.10")]
    public abstract class FileServerDisp_ : global::Ice.ObjectImpl, FileServer
    {
        #region Slice operations

        public abstract FileInfo[] getFileInfoSeq(int partition, global::Ice.Current current = null);

        public abstract LargeFileInfo[] getLargeFileInfoSeq(int partition, global::Ice.Current current = null);

        public abstract byte[][] getChecksumSeq(global::Ice.Current current = null);

        public abstract byte[] getChecksum(global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<byte[]> getFileCompressedAsync(string path, int pos, int num, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task<byte[]> getLargeFileCompressedAsync(string path, long pos, int num, global::Ice.Current current = null);

        #endregion

        #region Slice type-related members

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IcePatch2::FileServer"
        };

        public override bool ice_isA(string s, global::Ice.Current current = null)
        {
            return global::System.Array.BinarySearch(_ids, s, IceUtilInternal.StringUtil.OrdinalStringComparer) >= 0;
        }

        public override string[] ice_ids(global::Ice.Current current = null)
        {
            return _ids;
        }

        public override string ice_id(global::Ice.Current current = null)
        {
            return _ids[1];
        }

        public static new string ice_staticId()
        {
            return _ids[1];
        }

        #endregion

        #region Operation dispatch

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getFileInfoSeq(FileServer obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            int iceP_partition;
            iceP_partition = istr.readInt();
            inS.endReadParams();
            var ret = obj.getFileInfoSeq(iceP_partition, current);
            var ostr = inS.startWriteParams();
            FileInfoSeqHelper.write(ostr, ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getLargeFileInfoSeq(FileServer obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            int iceP_partition;
            iceP_partition = istr.readInt();
            inS.endReadParams();
            var ret = obj.getLargeFileInfoSeq(iceP_partition, current);
            var ostr = inS.startWriteParams();
            LargeFileInfoSeqHelper.write(ostr, ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getChecksumSeq(FileServer obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            inS.readEmptyParams();
            var ret = obj.getChecksumSeq(current);
            var ostr = inS.startWriteParams();
            ByteSeqSeqHelper.write(ostr, ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getChecksum(FileServer obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            inS.readEmptyParams();
            var ret = obj.getChecksum(current);
            var ostr = inS.startWriteParams();
            global::Ice.ByteSeqHelper.write(ostr, ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getFileCompressed(FileServer obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_path;
            int iceP_pos;
            int iceP_num;
            iceP_path = istr.readString();
            iceP_pos = istr.readInt();
            iceP_num = istr.readInt();
            inS.endReadParams();
            return inS.setResultTask<byte[]>(obj.getFileCompressedAsync(iceP_path, iceP_pos, iceP_num, current),
                (ostr, ret) =>
                {
                    global::Ice.ByteSeqHelper.write(ostr, ret);
                });
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getLargeFileCompressed(FileServer obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_path;
            long iceP_pos;
            int iceP_num;
            iceP_path = istr.readString();
            iceP_pos = istr.readLong();
            iceP_num = istr.readInt();
            inS.endReadParams();
            return inS.setResultTask<byte[]>(obj.getLargeFileCompressedAsync(iceP_path, iceP_pos, iceP_num, current),
                (ostr, ret) =>
                {
                    global::Ice.ByteSeqHelper.write(ostr, ret);
                });
        }

        private static readonly string[] _all =
        {
            "getChecksum",
            "getChecksumSeq",
            "getFileCompressed",
            "getFileInfoSeq",
            "getLargeFileCompressed",
            "getLargeFileInfoSeq",
            "ice_id",
            "ice_ids",
            "ice_isA",
            "ice_ping"
        };

        public override global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceDispatch(global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            int pos = global::System.Array.BinarySearch(_all, current.operation, global::IceUtilInternal.StringUtil.OrdinalStringComparer);
            if(pos < 0)
            {
                throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
            }

            switch(pos)
            {
                case 0:
                {
                    return iceD_getChecksum(this, inS, current);
                }
                case 1:
                {
                    return iceD_getChecksumSeq(this, inS, current);
                }
                case 2:
                {
                    return iceD_getFileCompressed(this, inS, current);
                }
                case 3:
                {
                    return iceD_getFileInfoSeq(this, inS, current);
                }
                case 4:
                {
                    return iceD_getLargeFileCompressed(this, inS, current);
                }
                case 5:
                {
                    return iceD_getLargeFileInfoSeq(this, inS, current);
                }
                case 6:
                {
                    return global::Ice.ObjectImpl.iceD_ice_id(this, inS, current);
                }
                case 7:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ids(this, inS, current);
                }
                case 8:
                {
                    return global::Ice.ObjectImpl.iceD_ice_isA(this, inS, current);
                }
                case 9:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ping(this, inS, current);
                }
            }

            global::System.Diagnostics.Debug.Assert(false);
            throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
        }

        #endregion
    }
}
