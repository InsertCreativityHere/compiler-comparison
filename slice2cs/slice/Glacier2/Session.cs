//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Session.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#nullable enable

[assembly:Ice.Slice("Session.ice")]

#pragma warning disable CS1591 // Missing XML Comment
#pragma warning disable CS1573 // Parameter has no matching param tag in the XML comment
#pragma warning disable CS0612 // Type or member is obsolete
#pragma warning disable CS0618 // Type or member is obsolete
#pragma warning disable CS0619 // Type or member is obsolete

namespace Glacier2
{
    /// <summary>
    /// This exception is raised if an attempt to create a new session failed.
    /// </summary>

    [Ice.SliceTypeId("::Glacier2::CannotCreateSessionException")]
    public partial class CannotCreateSessionException : Ice.UserException
    {
        public string reason = "";

        public CannotCreateSessionException(string reason)
        {
            global::System.ArgumentNullException.ThrowIfNull(reason);
            this.reason = reason;
        }

        public CannotCreateSessionException()
        {
        }

        public override string ice_id() => "::Glacier2::CannotCreateSessionException";

        protected override void iceWriteImpl(Ice.OutputStream ostr_)
        {
            ostr_.startSlice("::Glacier2::CannotCreateSessionException", -1, true);
            ostr_.writeString(reason);
            ostr_.endSlice();
        }

        protected override void iceReadImpl(Ice.InputStream istr_)
        {
            istr_.startSlice();
            reason = istr_.readString();
            istr_.endSlice();
        }
    }

    [Ice.SliceTypeId("::Glacier2::Session")]
    public partial interface Session : Ice.Object
    {
        /// <summary>
        /// Destroy the session.
        /// This is called automatically when the router is destroyed.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        void destroy(Ice.Current current);
    }

    [Ice.SliceTypeId("::Glacier2::StringSet")]
    public partial interface StringSet : Ice.Object
    {
        /// <summary>
        /// Add a sequence of strings to this set of constraints.
        /// Order is not preserved and duplicates are implicitly
        ///  removed.
        /// </summary>
        ///  <param name="additions">The sequence of strings to be added.</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void add(string[] additions, Ice.Current current);

        /// <summary>
        /// Remove a sequence of strings from this set of constraints.
        /// No errors are returned if an entry is not found.
        /// </summary>
        ///  <param name="deletions">The sequence of strings to be removed.</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void remove(string[] deletions, Ice.Current current);

        /// <summary>
        /// Returns a sequence of strings describing the constraints in this set.
        /// </summary>
        /// <returns>The sequence of strings for this set.</returns>
        /// <param name="current">The Current object for the dispatch.</param>

        string[] get(Ice.Current current);
    }

    [Ice.SliceTypeId("::Glacier2::IdentitySet")]
    public partial interface IdentitySet : Ice.Object
    {
        /// <summary>
        /// Add a sequence of Ice identities to this set of constraints.
        /// Order is not preserved and duplicates are
        ///  implicitly removed.
        /// </summary>
        ///  <param name="additions">The sequence of Ice identities to be added.</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void add(global::Ice.Identity[] additions, Ice.Current current);

        /// <summary>
        /// Remove a sequence of identities from this set of constraints.
        /// No errors are returned if an entry is not
        ///  found.
        /// </summary>
        ///  <param name="deletions">The sequence of Ice identities to be removed.</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void remove(global::Ice.Identity[] deletions, Ice.Current current);

        /// <summary>
        /// Returns a sequence of identities describing the constraints in this set.
        /// </summary>
        /// <returns>The sequence of Ice identities for this set.</returns>
        /// <param name="current">The Current object for the dispatch.</param>

        global::Ice.Identity[] get(Ice.Current current);
    }

    [Ice.SliceTypeId("::Glacier2::SessionControl")]
    public partial interface SessionControl : Ice.Object
    {
        /// <summary>
        /// Access the object that manages the allowable categories for object identities for this session.
        /// </summary>
        /// <returns>A StringSet object. The returned proxy is never null.</returns>
        /// <param name="current">The Current object for the dispatch.</param>

        StringSetPrx? categories(Ice.Current current);

        /// <summary>
        /// Access the object that manages the allowable adapter identities for objects for this session.
        /// </summary>
        /// <returns>A StringSet object. The returned proxy is never null.</returns>
        /// <param name="current">The Current object for the dispatch.</param>

        StringSetPrx? adapterIds(Ice.Current current);

        /// <summary>
        /// Access the object that manages the allowable object identities for this session.
        /// </summary>
        /// <returns>An IdentitySet object. The returned proxy is never null.</returns>
        /// <param name="current">The Current object for the dispatch.</param>

        IdentitySetPrx? identities(Ice.Current current);

        /// <summary>
        /// Get the session timeout.
        /// </summary>
        /// <returns>The timeout.</returns>
        /// <param name="current">The Current object for the dispatch.</param>

        int getSessionTimeout(Ice.Current current);

        /// <summary>
        /// Destroy the associated session.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        void destroy(Ice.Current current);
    }

    [Ice.SliceTypeId("::Glacier2::SessionManager")]
    public partial interface SessionManager : Ice.Object
    {
        /// <summary>
        /// Create a new session.
        /// The implementation must return a non-null proxy or raise
        ///  CannotCreateSessionException if the session cannot be created.
        /// </summary>
        ///  <param name="userId">The user id for the session.
        ///  </param>
        /// <param name="control">A proxy to the session control object. The control proxy is null if Glacier2.Server.Endpoints
        ///  are not configured.
        ///  </param>
        /// <returns>A proxy to the newly created session.
        ///  </returns>
        /// <exception name="CannotCreateSessionException">Raised if the session cannot be created.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        SessionPrx? create(string userId, SessionControlPrx? control, Ice.Current current);
    }

    [Ice.SliceTypeId("::Glacier2::SSLSessionManager")]
    public partial interface SSLSessionManager : Ice.Object
    {
        /// <summary>
        /// Create a new session.
        /// </summary>
        /// <param name="info">The SSL info.
        ///  </param>
        /// <param name="control">A proxy to the session control object.
        ///  </param>
        /// <returns>A proxy to the newly created session.
        ///  </returns>
        /// <exception name="CannotCreateSessionException">Raised if the session cannot be created.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        SessionPrx? create(SSLInfo info, SessionControlPrx? control, Ice.Current current);
    }
}

namespace Glacier2
{
    /// <summary>
    /// A client-visible session object, which is tied to the lifecycle of a Router.
    /// </summary>

    public interface SessionPrx : Ice.ObjectPrx
    {
        /// <summary>
        /// Destroy the session.
        /// This is called automatically when the router is destroyed.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void destroy(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Destroy the session.
        /// This is called automatically when the router is destroyed.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task destroyAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }

    /// <summary>
    /// An object for managing the set of identity constraints for specific parts of object identity on a
    ///  Session.
    /// </summary>

    public interface StringSetPrx : Ice.ObjectPrx
    {
        /// <summary>
        /// Add a sequence of strings to this set of constraints.
        /// Order is not preserved and duplicates are implicitly
        ///  removed.
        /// </summary>
        ///  <param name="additions">The sequence of strings to be added.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void add(string[] additions, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Add a sequence of strings to this set of constraints.
        /// Order is not preserved and duplicates are implicitly
        /// </summary>
        ///  <param name="additions">The sequence of strings to be added.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task addAsync(string[] additions, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Remove a sequence of strings from this set of constraints.
        /// No errors are returned if an entry is not found.
        /// </summary>
        ///  <param name="deletions">The sequence of strings to be removed.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void remove(string[] deletions, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Remove a sequence of strings from this set of constraints.
        /// No errors are returned if an entry is not found.
        /// </summary>
        ///  <param name="deletions">The sequence of strings to be removed.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task removeAsync(string[] deletions, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Returns a sequence of strings describing the constraints in this set.
        /// </summary>
        /// <returns>The sequence of strings for this set.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        string[] get(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Returns a sequence of strings describing the constraints in this set.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<string[]> getAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }

    /// <summary>
    /// An object for managing the set of object identity constraints on a Session.
    /// </summary>

    public interface IdentitySetPrx : Ice.ObjectPrx
    {
        /// <summary>
        /// Add a sequence of Ice identities to this set of constraints.
        /// Order is not preserved and duplicates are
        ///  implicitly removed.
        /// </summary>
        ///  <param name="additions">The sequence of Ice identities to be added.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void add(global::Ice.Identity[] additions, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Add a sequence of Ice identities to this set of constraints.
        /// Order is not preserved and duplicates are
        /// </summary>
        ///  <param name="additions">The sequence of Ice identities to be added.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task addAsync(global::Ice.Identity[] additions, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Remove a sequence of identities from this set of constraints.
        /// No errors are returned if an entry is not
        ///  found.
        /// </summary>
        ///  <param name="deletions">The sequence of Ice identities to be removed.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void remove(global::Ice.Identity[] deletions, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Remove a sequence of identities from this set of constraints.
        /// No errors are returned if an entry is not
        /// </summary>
        ///  <param name="deletions">The sequence of Ice identities to be removed.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task removeAsync(global::Ice.Identity[] deletions, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Returns a sequence of identities describing the constraints in this set.
        /// </summary>
        /// <returns>The sequence of Ice identities for this set.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        global::Ice.Identity[] get(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Returns a sequence of identities describing the constraints in this set.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<global::Ice.Identity[]> getAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }

    /// <summary>
    /// An administrative session control object, which is tied to the lifecycle of a Session.
    /// </summary>

    public interface SessionControlPrx : Ice.ObjectPrx
    {
        /// <summary>
        /// Access the object that manages the allowable categories for object identities for this session.
        /// </summary>
        /// <returns>A StringSet object. The returned proxy is never null.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        StringSetPrx? categories(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Access the object that manages the allowable categories for object identities for this session.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<StringSetPrx?> categoriesAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Access the object that manages the allowable adapter identities for objects for this session.
        /// </summary>
        /// <returns>A StringSet object. The returned proxy is never null.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        StringSetPrx? adapterIds(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Access the object that manages the allowable adapter identities for objects for this session.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<StringSetPrx?> adapterIdsAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Access the object that manages the allowable object identities for this session.
        /// </summary>
        /// <returns>An IdentitySet object. The returned proxy is never null.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        IdentitySetPrx? identities(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Access the object that manages the allowable object identities for this session.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<IdentitySetPrx?> identitiesAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get the session timeout.
        /// </summary>
        /// <returns>The timeout.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        int getSessionTimeout(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get the session timeout.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<int> getSessionTimeoutAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Destroy the associated session.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void destroy(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Destroy the associated session.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task destroyAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }

    /// <summary>
    /// The session manager for username/password authenticated users that is responsible for managing Session
    ///  objects.
    /// New session objects are created by the Router object calling on an application-provided
    ///  session manager. If no session manager is provided by the application, no client-visible sessions are passed to
    ///  the client.
    /// </summary>

    public interface SessionManagerPrx : Ice.ObjectPrx
    {
        /// <summary>
        /// Create a new session.
        /// The implementation must return a non-null proxy or raise
        ///  CannotCreateSessionException if the session cannot be created.
        /// </summary>
        ///  <param name="userId">The user id for the session.
        ///  </param>
        /// <param name="control">A proxy to the session control object. The control proxy is null if Glacier2.Server.Endpoints
        ///  are not configured.
        ///  </param>
        /// <returns>A proxy to the newly created session.
        ///  </returns>
        /// <exception name="CannotCreateSessionException">Raised if the session cannot be created.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        SessionPrx? create(string userId, SessionControlPrx? control, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Create a new session.
        /// The implementation must return a non-null proxy or raise
        /// </summary>
        ///  <param name="userId">The user id for the session.
        ///  </param>
        /// <param name="control">A proxy to the session control object. The control proxy is null if Glacier2.Server.Endpoints
        ///  are not configured.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<SessionPrx?> createAsync(string userId, SessionControlPrx? control, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }

    /// <summary>
    /// The session manager for SSL authenticated users that is responsible for managing Session objects.
    /// New
    ///  session objects are created by the Router object calling on an application-provided session manager. If
    ///  no session manager is provided by the application, no client-visible sessions are passed to the client.
    /// </summary>

    public interface SSLSessionManagerPrx : Ice.ObjectPrx
    {
        /// <summary>
        /// Create a new session.
        /// </summary>
        /// <param name="info">The SSL info.
        ///  </param>
        /// <param name="control">A proxy to the session control object.
        ///  </param>
        /// <returns>A proxy to the newly created session.
        ///  </returns>
        /// <exception name="CannotCreateSessionException">Raised if the session cannot be created.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        SessionPrx? create(SSLInfo info, SessionControlPrx? control, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Create a new session.
        /// </summary>
        /// <param name="info">The SSL info.
        ///  </param>
        /// <param name="control">A proxy to the session control object.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<SessionPrx?> createAsync(SSLInfo info, SessionControlPrx? control, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }
}

namespace Glacier2
{
    public sealed class SessionPrxHelper : Ice.ObjectPrxHelperBase, SessionPrx
    {
        public void destroy(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_destroyAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task destroyAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_destroyAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_destroyAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_destroy(context, synchronous, completed);
            return completed.Task;
        }

        private const string _destroy_name = "destroy";

        private void _iceI_destroy(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _destroy_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous);
        }

        public static SessionPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new SessionPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static SessionPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new SessionPrxHelper(b) : null;

        public static SessionPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static SessionPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new SessionPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static SessionPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Glacier2::Session",
            "::Ice::Object"
        };

        public static string ice_staticId() => "::Glacier2::Session";

        public static void write(Ice.OutputStream ostr, SessionPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static SessionPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new SessionPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new SessionPrxHelper(reference);

        private SessionPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private SessionPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }

    public sealed class StringSetPrxHelper : Ice.ObjectPrxHelperBase, StringSetPrx
    {
        public void add(string[] additions, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_addAsync(additions, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void remove(string[] deletions, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_removeAsync(deletions, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public string[] get(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task addAsync(string[] additions, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_addAsync(additions, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_addAsync(string[] iceP_additions, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_add(iceP_additions, context, synchronous, completed);
            return completed.Task;
        }

        private const string _add_name = "add";

        private void _iceI_add(string[] iceP_additions, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _add_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    global::Ice.StringSeqHelper.write(ostr, iceP_additions);
                });
        }

        public global::System.Threading.Tasks.Task removeAsync(string[] deletions, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_removeAsync(deletions, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_removeAsync(string[] iceP_deletions, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_remove(iceP_deletions, context, synchronous, completed);
            return completed.Task;
        }

        private const string _remove_name = "remove";

        private void _iceI_remove(string[] iceP_deletions, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _remove_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    global::Ice.StringSeqHelper.write(ostr, iceP_deletions);
                });
        }

        public global::System.Threading.Tasks.Task<string[]> getAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<string[]> _iceI_getAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_get_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<string[]>(progress, cancel);
            _iceI_get(context, synchronous, completed);
            return completed.Task;
        }

        private const string _get_name = "get";

        private void _iceI_get(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<string[]>(completed);
            outAsync.invoke(
                _get_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    string[] ret;
                    ret = global::Ice.StringSeqHelper.read(istr);
                    return ret;
                });
        }

        public static StringSetPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new StringSetPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static StringSetPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new StringSetPrxHelper(b) : null;

        public static StringSetPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static StringSetPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new StringSetPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static StringSetPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Glacier2::StringSet",
            "::Ice::Object"
        };

        public static string ice_staticId() => "::Glacier2::StringSet";

        public static void write(Ice.OutputStream ostr, StringSetPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static StringSetPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new StringSetPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new StringSetPrxHelper(reference);

        private StringSetPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private StringSetPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }

    public sealed class IdentitySetPrxHelper : Ice.ObjectPrxHelperBase, IdentitySetPrx
    {
        public void add(global::Ice.Identity[] additions, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_addAsync(additions, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void remove(global::Ice.Identity[] deletions, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_removeAsync(deletions, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::Ice.Identity[] get(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task addAsync(global::Ice.Identity[] additions, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_addAsync(additions, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_addAsync(global::Ice.Identity[] iceP_additions, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_add(iceP_additions, context, synchronous, completed);
            return completed.Task;
        }

        private const string _add_name = "add";

        private void _iceI_add(global::Ice.Identity[] iceP_additions, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _add_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    global::Ice.IdentitySeqHelper.write(ostr, iceP_additions);
                });
        }

        public global::System.Threading.Tasks.Task removeAsync(global::Ice.Identity[] deletions, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_removeAsync(deletions, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_removeAsync(global::Ice.Identity[] iceP_deletions, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_remove(iceP_deletions, context, synchronous, completed);
            return completed.Task;
        }

        private const string _remove_name = "remove";

        private void _iceI_remove(global::Ice.Identity[] iceP_deletions, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _remove_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    global::Ice.IdentitySeqHelper.write(ostr, iceP_deletions);
                });
        }

        public global::System.Threading.Tasks.Task<global::Ice.Identity[]> getAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<global::Ice.Identity[]> _iceI_getAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_get_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<global::Ice.Identity[]>(progress, cancel);
            _iceI_get(context, synchronous, completed);
            return completed.Task;
        }

        private const string _get_name = "get";

        private void _iceI_get(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<global::Ice.Identity[]>(completed);
            outAsync.invoke(
                _get_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    global::Ice.Identity[] ret;
                    ret = global::Ice.IdentitySeqHelper.read(istr);
                    return ret;
                });
        }

        public static IdentitySetPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new IdentitySetPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static IdentitySetPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new IdentitySetPrxHelper(b) : null;

        public static IdentitySetPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static IdentitySetPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new IdentitySetPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static IdentitySetPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Glacier2::IdentitySet",
            "::Ice::Object"
        };

        public static string ice_staticId() => "::Glacier2::IdentitySet";

        public static void write(Ice.OutputStream ostr, IdentitySetPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static IdentitySetPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new IdentitySetPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new IdentitySetPrxHelper(reference);

        private IdentitySetPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private IdentitySetPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }

    public sealed class SessionControlPrxHelper : Ice.ObjectPrxHelperBase, SessionControlPrx
    {
        public StringSetPrx? categories(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_categoriesAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public StringSetPrx? adapterIds(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_adapterIdsAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public IdentitySetPrx? identities(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_identitiesAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public int getSessionTimeout(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getSessionTimeoutAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void destroy(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_destroyAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task<StringSetPrx?> categoriesAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_categoriesAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<StringSetPrx?> _iceI_categoriesAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_categories_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<StringSetPrx?>(progress, cancel);
            _iceI_categories(context, synchronous, completed);
            return completed.Task;
        }

        private const string _categories_name = "categories";

        private void _iceI_categories(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<StringSetPrx?>(completed);
            outAsync.invoke(
                _categories_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    StringSetPrx? ret;
                    ret = StringSetPrxHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<StringSetPrx?> adapterIdsAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_adapterIdsAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<StringSetPrx?> _iceI_adapterIdsAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_adapterIds_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<StringSetPrx?>(progress, cancel);
            _iceI_adapterIds(context, synchronous, completed);
            return completed.Task;
        }

        private const string _adapterIds_name = "adapterIds";

        private void _iceI_adapterIds(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<StringSetPrx?>(completed);
            outAsync.invoke(
                _adapterIds_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    StringSetPrx? ret;
                    ret = StringSetPrxHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<IdentitySetPrx?> identitiesAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_identitiesAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<IdentitySetPrx?> _iceI_identitiesAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_identities_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<IdentitySetPrx?>(progress, cancel);
            _iceI_identities(context, synchronous, completed);
            return completed.Task;
        }

        private const string _identities_name = "identities";

        private void _iceI_identities(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<IdentitySetPrx?>(completed);
            outAsync.invoke(
                _identities_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    IdentitySetPrx? ret;
                    ret = IdentitySetPrxHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<int> getSessionTimeoutAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getSessionTimeoutAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<int> _iceI_getSessionTimeoutAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getSessionTimeout_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<int>(progress, cancel);
            _iceI_getSessionTimeout(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getSessionTimeout_name = "getSessionTimeout";

        private void _iceI_getSessionTimeout(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<int>(completed);
            outAsync.invoke(
                _getSessionTimeout_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    int ret;
                    ret = istr.readInt();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task destroyAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_destroyAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_destroyAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_destroy(context, synchronous, completed);
            return completed.Task;
        }

        private const string _destroy_name = "destroy";

        private void _iceI_destroy(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _destroy_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous);
        }

        public static SessionControlPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new SessionControlPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static SessionControlPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new SessionControlPrxHelper(b) : null;

        public static SessionControlPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static SessionControlPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new SessionControlPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static SessionControlPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Glacier2::SessionControl",
            "::Ice::Object"
        };

        public static string ice_staticId() => "::Glacier2::SessionControl";

        public static void write(Ice.OutputStream ostr, SessionControlPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static SessionControlPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new SessionControlPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new SessionControlPrxHelper(reference);

        private SessionControlPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private SessionControlPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }

    public sealed class SessionManagerPrxHelper : Ice.ObjectPrxHelperBase, SessionManagerPrx
    {
        public SessionPrx? create(string userId, SessionControlPrx? control, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_createAsync(userId, control, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task<SessionPrx?> createAsync(string userId, SessionControlPrx? control, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_createAsync(userId, control, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<SessionPrx?> _iceI_createAsync(string iceP_userId, SessionControlPrx? iceP_control, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_create_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<SessionPrx?>(progress, cancel);
            _iceI_create(iceP_userId, iceP_control, context, synchronous, completed);
            return completed.Task;
        }

        private const string _create_name = "create";

        private void _iceI_create(string iceP_userId, SessionControlPrx? iceP_control, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<SessionPrx?>(completed);
            outAsync.invoke(
                _create_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_userId);
                    SessionControlPrxHelper.write(ostr, iceP_control);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(CannotCreateSessionException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    SessionPrx? ret;
                    ret = SessionPrxHelper.read(istr);
                    return ret;
                });
        }

        public static SessionManagerPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new SessionManagerPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static SessionManagerPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new SessionManagerPrxHelper(b) : null;

        public static SessionManagerPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static SessionManagerPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new SessionManagerPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static SessionManagerPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Glacier2::SessionManager",
            "::Ice::Object"
        };

        public static string ice_staticId() => "::Glacier2::SessionManager";

        public static void write(Ice.OutputStream ostr, SessionManagerPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static SessionManagerPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new SessionManagerPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new SessionManagerPrxHelper(reference);

        private SessionManagerPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private SessionManagerPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }

    public sealed class SSLSessionManagerPrxHelper : Ice.ObjectPrxHelperBase, SSLSessionManagerPrx
    {
        public SessionPrx? create(SSLInfo info, SessionControlPrx? control, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_createAsync(info, control, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task<SessionPrx?> createAsync(SSLInfo info, SessionControlPrx? control, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_createAsync(info, control, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<SessionPrx?> _iceI_createAsync(SSLInfo iceP_info, SessionControlPrx? iceP_control, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_create_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<SessionPrx?>(progress, cancel);
            _iceI_create(iceP_info, iceP_control, context, synchronous, completed);
            return completed.Task;
        }

        private const string _create_name = "create";

        private void _iceI_create(SSLInfo iceP_info, SessionControlPrx? iceP_control, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<SessionPrx?>(completed);
            outAsync.invoke(
                _create_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    SSLInfo.ice_write(ostr, iceP_info);
                    SessionControlPrxHelper.write(ostr, iceP_control);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(CannotCreateSessionException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    SessionPrx? ret;
                    ret = SessionPrxHelper.read(istr);
                    return ret;
                });
        }

        public static SSLSessionManagerPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new SSLSessionManagerPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static SSLSessionManagerPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new SSLSessionManagerPrxHelper(b) : null;

        public static SSLSessionManagerPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static SSLSessionManagerPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new SSLSessionManagerPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static SSLSessionManagerPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Glacier2::SSLSessionManager",
            "::Ice::Object"
        };

        public static string ice_staticId() => "::Glacier2::SSLSessionManager";

        public static void write(Ice.OutputStream ostr, SSLSessionManagerPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static SSLSessionManagerPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new SSLSessionManagerPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new SSLSessionManagerPrxHelper(reference);

        private SSLSessionManagerPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private SSLSessionManagerPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }
}

namespace Glacier2
{
    public abstract class SessionDisp_ : Ice.ObjectImpl, Session
    {
        public abstract void destroy(Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::Glacier2::Session";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "destroy" => Session.iceD_destroyAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }

    public abstract class StringSetDisp_ : Ice.ObjectImpl, StringSet
    {
        public abstract void add(string[] additions, Ice.Current current);

        public abstract void remove(string[] deletions, Ice.Current current);

        public abstract string[] get(Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::Glacier2::StringSet";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "add" => StringSet.iceD_addAsync(this, request),
                "remove" => StringSet.iceD_removeAsync(this, request),
                "get" => StringSet.iceD_getAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }

    public abstract class IdentitySetDisp_ : Ice.ObjectImpl, IdentitySet
    {
        public abstract void add(global::Ice.Identity[] additions, Ice.Current current);

        public abstract void remove(global::Ice.Identity[] deletions, Ice.Current current);

        public abstract global::Ice.Identity[] get(Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::Glacier2::IdentitySet";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "add" => IdentitySet.iceD_addAsync(this, request),
                "remove" => IdentitySet.iceD_removeAsync(this, request),
                "get" => IdentitySet.iceD_getAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }

    public abstract class SessionControlDisp_ : Ice.ObjectImpl, SessionControl
    {
        public abstract StringSetPrx? categories(Ice.Current current);

        public abstract StringSetPrx? adapterIds(Ice.Current current);

        public abstract IdentitySetPrx? identities(Ice.Current current);

        public abstract int getSessionTimeout(Ice.Current current);

        public abstract void destroy(Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::Glacier2::SessionControl";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "categories" => SessionControl.iceD_categoriesAsync(this, request),
                "adapterIds" => SessionControl.iceD_adapterIdsAsync(this, request),
                "identities" => SessionControl.iceD_identitiesAsync(this, request),
                "getSessionTimeout" => SessionControl.iceD_getSessionTimeoutAsync(this, request),
                "destroy" => SessionControl.iceD_destroyAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }

    public abstract class SessionManagerDisp_ : Ice.ObjectImpl, SessionManager
    {
        public abstract SessionPrx? create(string userId, SessionControlPrx? control, Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::Glacier2::SessionManager";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "create" => SessionManager.iceD_createAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }

    public abstract class SSLSessionManagerDisp_ : Ice.ObjectImpl, SSLSessionManager
    {
        public abstract SessionPrx? create(SSLInfo info, SessionControlPrx? control, Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::Glacier2::SSLSessionManager";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "create" => SSLSessionManager.iceD_createAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }
}

namespace Glacier2
{
    public partial interface Session
    {
        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_destroyAsync(
            Session obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            obj.destroy(request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }
    }

    public partial interface StringSet
    {
        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_addAsync(
            StringSet obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string[] iceP_additions;
            iceP_additions = global::Ice.StringSeqHelper.read(istr);
            istr.endEncapsulation();
            obj.add(iceP_additions, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_removeAsync(
            StringSet obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string[] iceP_deletions;
            iceP_deletions = global::Ice.StringSeqHelper.read(istr);
            istr.endEncapsulation();
            obj.remove(iceP_deletions, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getAsync(
            StringSet obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.get(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            global::Ice.StringSeqHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }
    }

    public partial interface IdentitySet
    {
        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_addAsync(
            IdentitySet obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            global::Ice.Identity[] iceP_additions;
            iceP_additions = global::Ice.IdentitySeqHelper.read(istr);
            istr.endEncapsulation();
            obj.add(iceP_additions, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_removeAsync(
            IdentitySet obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            global::Ice.Identity[] iceP_deletions;
            iceP_deletions = global::Ice.IdentitySeqHelper.read(istr);
            istr.endEncapsulation();
            obj.remove(iceP_deletions, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getAsync(
            IdentitySet obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.get(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            global::Ice.IdentitySeqHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }
    }

    public partial interface SessionControl
    {
        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_categoriesAsync(
            SessionControl obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.categories(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            StringSetPrxHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_adapterIdsAsync(
            SessionControl obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.adapterIds(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            StringSetPrxHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_identitiesAsync(
            SessionControl obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.identities(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            IdentitySetPrxHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getSessionTimeoutAsync(
            SessionControl obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.getSessionTimeout(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeInt(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_destroyAsync(
            SessionControl obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            obj.destroy(request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }
    }

    public partial interface SessionManager
    {
        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_createAsync(
            SessionManager obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_userId;
            SessionControlPrx? iceP_control;
            iceP_userId = istr.readString();
            iceP_control = SessionControlPrxHelper.read(istr);
            istr.endEncapsulation();
            var ret = obj.create(iceP_userId, iceP_control, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            SessionPrxHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }
    }

    public partial interface SSLSessionManager
    {
        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_createAsync(
            SSLSessionManager obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            SSLInfo iceP_info;
            SessionControlPrx? iceP_control;
            iceP_info = new SSLInfo(istr);
            iceP_control = SessionControlPrxHelper.read(istr);
            istr.endEncapsulation();
            var ret = obj.create(iceP_info, iceP_control, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            SessionPrxHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }
    }
}
