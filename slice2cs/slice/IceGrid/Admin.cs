//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Admin.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#nullable enable

[assembly:Ice.Slice("Admin.ice")]

#pragma warning disable CS1591 // Missing XML Comment
#pragma warning disable CS1573 // Parameter has no matching param tag in the XML comment
#pragma warning disable CS0612 // Type or member is obsolete
#pragma warning disable CS0618 // Type or member is obsolete
#pragma warning disable CS0619 // Type or member is obsolete

namespace IceGrid
{
    /// <summary>
    /// An enumeration representing the state of the server.
    /// </summary>

    public enum ServerState
    {
        /// <summary>
        /// The server is not running.
        /// </summary>

        Inactive,
        /// <summary>
        /// The server is being activated and will change to the active state when the registered server object adapters
        ///  are activated or to the activation timed out state if the activation timeout expires.
        /// </summary>

        Activating,
        /// <summary>
        /// The activation timed out state indicates that the server activation timed out.
        /// </summary>

        ActivationTimedOut,
        /// <summary>
        /// The server is running.
        /// </summary>

        Active,
        /// <summary>
        /// The server is being deactivated.
        /// </summary>

        Deactivating,
        /// <summary>
        /// The server is being destroyed.
        /// </summary>

        Destroying,
        /// <summary>
        /// The server is destroyed.
        /// </summary>

        Destroyed
    }

    public sealed class ServerStateHelper
    {
        public static void write(Ice.OutputStream ostr, ServerState v)
        {
            ostr.writeEnum((int)v, 6);
        }

        public static ServerState read(Ice.InputStream istr)
        {
            ServerState v;
            v = (ServerState)istr.readEnum(6);
            return v;
        }
    }

    public sealed partial record class ObjectInfo
    {
        public global::Ice.ObjectPrx? proxy;

        public string type = "";

        partial void ice_initialize();

        public ObjectInfo()
        {
            ice_initialize();
        }

        public ObjectInfo(global::Ice.ObjectPrx? proxy, string type)
        {
            this.proxy = proxy;
            global::System.ArgumentNullException.ThrowIfNull(type);
            this.type = type;
            ice_initialize();
        }

        public ObjectInfo(Ice.InputStream istr)
        {
            this.proxy = istr.readProxy();
            this.type = istr.readString();
            ice_initialize();
        }

        public void ice_writeMembers(Ice.OutputStream ostr)
        {
            ostr.writeProxy(this.proxy);
            ostr.writeString(this.type);
        }

        public static void ice_write(Ice.OutputStream ostr, ObjectInfo v)
        {
            v.ice_writeMembers(ostr);
        }

        public static ObjectInfo ice_read(Ice.InputStream istr) => new(istr);
    }

    public sealed partial record class AdapterInfo
    {
        public string id = "";

        public global::Ice.ObjectPrx? proxy;

        public string replicaGroupId = "";

        partial void ice_initialize();

        public AdapterInfo()
        {
            ice_initialize();
        }

        public AdapterInfo(string id, global::Ice.ObjectPrx? proxy, string replicaGroupId)
        {
            global::System.ArgumentNullException.ThrowIfNull(id);
            this.id = id;
            this.proxy = proxy;
            global::System.ArgumentNullException.ThrowIfNull(replicaGroupId);
            this.replicaGroupId = replicaGroupId;
            ice_initialize();
        }

        public AdapterInfo(Ice.InputStream istr)
        {
            this.id = istr.readString();
            this.proxy = istr.readProxy();
            this.replicaGroupId = istr.readString();
            ice_initialize();
        }

        public void ice_writeMembers(Ice.OutputStream ostr)
        {
            ostr.writeString(this.id);
            ostr.writeProxy(this.proxy);
            ostr.writeString(this.replicaGroupId);
        }

        public static void ice_write(Ice.OutputStream ostr, AdapterInfo v)
        {
            v.ice_writeMembers(ostr);
        }

        public static AdapterInfo ice_read(Ice.InputStream istr) => new(istr);
    }

    public sealed partial record class ServerInfo
    {
        public string application = "";

        public string uuid = "";

        public int revision;

        public string node = "";

        public ServerDescriptor? descriptor;

        public string sessionId = "";

        partial void ice_initialize();

        public ServerInfo()
        {
            ice_initialize();
        }

        public ServerInfo(string application, string uuid, int revision, string node, ServerDescriptor? descriptor, string sessionId)
        {
            global::System.ArgumentNullException.ThrowIfNull(application);
            this.application = application;
            global::System.ArgumentNullException.ThrowIfNull(uuid);
            this.uuid = uuid;
            this.revision = revision;
            global::System.ArgumentNullException.ThrowIfNull(node);
            this.node = node;
            this.descriptor = descriptor;
            global::System.ArgumentNullException.ThrowIfNull(sessionId);
            this.sessionId = sessionId;
            ice_initialize();
        }

        public ServerInfo(Ice.InputStream istr)
        {
            this.application = istr.readString();
            this.uuid = istr.readString();
            this.revision = istr.readInt();
            this.node = istr.readString();
            istr.readValue((ServerDescriptor? v) => { this.descriptor = v; });
            this.sessionId = istr.readString();
            ice_initialize();
        }

        public void ice_writeMembers(Ice.OutputStream ostr)
        {
            ostr.writeString(this.application);
            ostr.writeString(this.uuid);
            ostr.writeInt(this.revision);
            ostr.writeString(this.node);
            ostr.writeValue(this.descriptor);
            ostr.writeString(this.sessionId);
        }

        public static void ice_write(Ice.OutputStream ostr, ServerInfo v)
        {
            v.ice_writeMembers(ostr);
        }

        public static ServerInfo ice_read(Ice.InputStream istr) => new(istr);
    }

    public sealed partial record class NodeInfo
    {
        public string name = "";

        public string os = "";

        public string hostname = "";

        public string release = "";

        public string version = "";

        public string machine = "";

        public int nProcessors;

        public string dataDir = "";

        partial void ice_initialize();

        public NodeInfo()
        {
            ice_initialize();
        }

        public NodeInfo(string name, string os, string hostname, string release, string version, string machine, int nProcessors, string dataDir)
        {
            global::System.ArgumentNullException.ThrowIfNull(name);
            this.name = name;
            global::System.ArgumentNullException.ThrowIfNull(os);
            this.os = os;
            global::System.ArgumentNullException.ThrowIfNull(hostname);
            this.hostname = hostname;
            global::System.ArgumentNullException.ThrowIfNull(release);
            this.release = release;
            global::System.ArgumentNullException.ThrowIfNull(version);
            this.version = version;
            global::System.ArgumentNullException.ThrowIfNull(machine);
            this.machine = machine;
            this.nProcessors = nProcessors;
            global::System.ArgumentNullException.ThrowIfNull(dataDir);
            this.dataDir = dataDir;
            ice_initialize();
        }

        public NodeInfo(Ice.InputStream istr)
        {
            this.name = istr.readString();
            this.os = istr.readString();
            this.hostname = istr.readString();
            this.release = istr.readString();
            this.version = istr.readString();
            this.machine = istr.readString();
            this.nProcessors = istr.readInt();
            this.dataDir = istr.readString();
            ice_initialize();
        }

        public void ice_writeMembers(Ice.OutputStream ostr)
        {
            ostr.writeString(this.name);
            ostr.writeString(this.os);
            ostr.writeString(this.hostname);
            ostr.writeString(this.release);
            ostr.writeString(this.version);
            ostr.writeString(this.machine);
            ostr.writeInt(this.nProcessors);
            ostr.writeString(this.dataDir);
        }

        public static void ice_write(Ice.OutputStream ostr, NodeInfo v)
        {
            v.ice_writeMembers(ostr);
        }

        public static NodeInfo ice_read(Ice.InputStream istr) => new(istr);
    }

    public sealed partial record class RegistryInfo
    {
        public string name = "";

        public string hostname = "";

        partial void ice_initialize();

        public RegistryInfo()
        {
            ice_initialize();
        }

        public RegistryInfo(string name, string hostname)
        {
            global::System.ArgumentNullException.ThrowIfNull(name);
            this.name = name;
            global::System.ArgumentNullException.ThrowIfNull(hostname);
            this.hostname = hostname;
            ice_initialize();
        }

        public RegistryInfo(Ice.InputStream istr)
        {
            this.name = istr.readString();
            this.hostname = istr.readString();
            ice_initialize();
        }

        public void ice_writeMembers(Ice.OutputStream ostr)
        {
            ostr.writeString(this.name);
            ostr.writeString(this.hostname);
        }

        public static void ice_write(Ice.OutputStream ostr, RegistryInfo v)
        {
            v.ice_writeMembers(ostr);
        }

        public static RegistryInfo ice_read(Ice.InputStream istr) => new(istr);
    }

    public partial record struct LoadInfo
    {
        public float avg1;

        public float avg5;

        public float avg15;

        partial void ice_initialize();

        public LoadInfo(float avg1, float avg5, float avg15)
        {
            this.avg1 = avg1;
            this.avg5 = avg5;
            this.avg15 = avg15;
            ice_initialize();
        }

        public LoadInfo(Ice.InputStream istr)
        {
            this.avg1 = istr.readFloat();
            this.avg5 = istr.readFloat();
            this.avg15 = istr.readFloat();
            ice_initialize();
        }

        public void ice_writeMembers(Ice.OutputStream ostr)
        {
            ostr.writeFloat(this.avg1);
            ostr.writeFloat(this.avg5);
            ostr.writeFloat(this.avg15);
        }

        public static void ice_write(Ice.OutputStream ostr, LoadInfo v)
        {
            v.ice_writeMembers(ostr);
        }

        public static LoadInfo ice_read(Ice.InputStream istr) => new(istr);
    }

    public sealed partial record class ApplicationInfo
    {
        public string uuid = "";

        public long createTime;

        public string createUser = "";

        public long updateTime;

        public string updateUser = "";

        public int revision;

        public ApplicationDescriptor descriptor;

        partial void ice_initialize();

        public ApplicationInfo(ApplicationDescriptor descriptor)
        {
            global::System.ArgumentNullException.ThrowIfNull(descriptor);
            this.descriptor = descriptor;
            ice_initialize();
        }

        public ApplicationInfo(string uuid, long createTime, string createUser, long updateTime, string updateUser, int revision, ApplicationDescriptor descriptor)
        {
            global::System.ArgumentNullException.ThrowIfNull(uuid);
            this.uuid = uuid;
            this.createTime = createTime;
            global::System.ArgumentNullException.ThrowIfNull(createUser);
            this.createUser = createUser;
            this.updateTime = updateTime;
            global::System.ArgumentNullException.ThrowIfNull(updateUser);
            this.updateUser = updateUser;
            this.revision = revision;
            global::System.ArgumentNullException.ThrowIfNull(descriptor);
            this.descriptor = descriptor;
            ice_initialize();
        }

        public ApplicationInfo(Ice.InputStream istr)
        {
            this.uuid = istr.readString();
            this.createTime = istr.readLong();
            this.createUser = istr.readString();
            this.updateTime = istr.readLong();
            this.updateUser = istr.readString();
            this.revision = istr.readInt();
            this.descriptor = new ApplicationDescriptor(istr);
            ice_initialize();
        }

        public void ice_writeMembers(Ice.OutputStream ostr)
        {
            ostr.writeString(this.uuid);
            ostr.writeLong(this.createTime);
            ostr.writeString(this.createUser);
            ostr.writeLong(this.updateTime);
            ostr.writeString(this.updateUser);
            ostr.writeInt(this.revision);
            ApplicationDescriptor.ice_write(ostr, this.descriptor);
        }

        public static void ice_write(Ice.OutputStream ostr, ApplicationInfo v)
        {
            v.ice_writeMembers(ostr);
        }

        public static ApplicationInfo ice_read(Ice.InputStream istr) => new(istr);
    }

    public sealed partial record class ApplicationUpdateInfo
    {
        public long updateTime;

        public string updateUser = "";

        public int revision;

        public ApplicationUpdateDescriptor descriptor;

        partial void ice_initialize();

        public ApplicationUpdateInfo(ApplicationUpdateDescriptor descriptor)
        {
            global::System.ArgumentNullException.ThrowIfNull(descriptor);
            this.descriptor = descriptor;
            ice_initialize();
        }

        public ApplicationUpdateInfo(long updateTime, string updateUser, int revision, ApplicationUpdateDescriptor descriptor)
        {
            this.updateTime = updateTime;
            global::System.ArgumentNullException.ThrowIfNull(updateUser);
            this.updateUser = updateUser;
            this.revision = revision;
            global::System.ArgumentNullException.ThrowIfNull(descriptor);
            this.descriptor = descriptor;
            ice_initialize();
        }

        public ApplicationUpdateInfo(Ice.InputStream istr)
        {
            this.updateTime = istr.readLong();
            this.updateUser = istr.readString();
            this.revision = istr.readInt();
            this.descriptor = new ApplicationUpdateDescriptor(istr);
            ice_initialize();
        }

        public void ice_writeMembers(Ice.OutputStream ostr)
        {
            ostr.writeLong(this.updateTime);
            ostr.writeString(this.updateUser);
            ostr.writeInt(this.revision);
            ApplicationUpdateDescriptor.ice_write(ostr, this.descriptor);
        }

        public static void ice_write(Ice.OutputStream ostr, ApplicationUpdateInfo v)
        {
            v.ice_writeMembers(ostr);
        }

        public static ApplicationUpdateInfo ice_read(Ice.InputStream istr) => new(istr);
    }

    [Ice.SliceTypeId("::IceGrid::Admin")]
    public partial interface Admin : Ice.Object
    {
        /// <summary>
        /// Add an application to IceGrid.
        /// </summary>
        /// <param name="descriptor">The application descriptor.
        ///  </param>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock or if another session is
        ///  holding the lock.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        void addApplication(ApplicationDescriptor descriptor, Ice.Current current);

        /// <summary>
        /// Synchronize a deployed application with the given application descriptor.
        /// This operation will replace the
        ///  current descriptor with this new descriptor.
        /// </summary>
        ///  <param name="descriptor">The application descriptor.
        ///  </param>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock or if another session is
        ///  holding the lock.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.
        ///  </exception>
        /// <exception name="ApplicationNotExistException">Raised if the application doesn't exist.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        void syncApplication(ApplicationDescriptor descriptor, Ice.Current current);

        /// <summary>
        /// Update a deployed application with the given update application descriptor.
        /// </summary>
        /// <param name="descriptor">The update descriptor.
        ///  </param>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock or if another session is
        ///  holding the lock.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.
        ///  </exception>
        /// <exception name="ApplicationNotExistException">Raised if the application doesn't exist.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        void updateApplication(ApplicationUpdateDescriptor descriptor, Ice.Current current);

        /// <summary>
        /// Synchronize a deployed application with the given application descriptor.
        /// This operation will replace the
        ///  current descriptor with this new descriptor only if no server restarts are necessary for the update of the
        ///  application. If some servers need to be restarted, the synchronization is rejected with a
        ///  DeploymentException.
        /// </summary>
        ///  <param name="descriptor">The application descriptor.
        ///  </param>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock or if another session is
        ///  holding the lock.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.
        ///  </exception>
        /// <exception name="ApplicationNotExistException">Raised if the application doesn't exist.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        void syncApplicationWithoutRestart(ApplicationDescriptor descriptor, Ice.Current current);

        /// <summary>
        /// Update a deployed application with the given update application descriptor only if no server restarts are
        ///  necessary for the update of the application.
        /// If some servers need to be restarted, the synchronization is
        ///  rejected with a DeploymentException.
        /// </summary>
        ///  <param name="descriptor">The update descriptor.
        ///  </param>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock or if another session is
        ///  holding the lock.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.
        ///  </exception>
        /// <exception name="ApplicationNotExistException">Raised if the application doesn't exist.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        void updateApplicationWithoutRestart(ApplicationUpdateDescriptor descriptor, Ice.Current current);

        /// <summary>
        /// Remove an application from IceGrid.
        /// </summary>
        /// <param name="name">The application name.
        ///  </param>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock or if another session is
        ///  holding the lock.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.
        ///  </exception>
        /// <exception name="ApplicationNotExistException">Raised if the application doesn't exist.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        void removeApplication(string name, Ice.Current current);

        /// <summary>
        /// Instantiate a server template from an application on the given node.
        /// </summary>
        /// <param name="application">The application name.
        ///  </param>
        /// <param name="node">The name of the node where the server will be deployed.
        ///  </param>
        /// <param name="desc">The descriptor of the server instance to deploy.
        ///  </param>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock or if another session is
        ///  holding the lock.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if server instantiation failed.
        ///  </exception>
        /// <exception name="ApplicationNotExistException">Raised if the application doesn't exist.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        void instantiateServer(string application, string node, ServerInstanceDescriptor desc, Ice.Current current);

        /// <summary>
        /// Get an application descriptor.
        /// </summary>
        /// <param name="name">The application name.
        ///  </param>
        /// <returns>The application descriptor.
        ///  </returns>
        /// <exception name="ApplicationNotExistException">Raised if the application doesn't exist.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        ApplicationInfo getApplicationInfo(string name, Ice.Current current);

        /// <summary>
        /// Get the default application descriptor.
        /// </summary>
        /// <returns>The default application descriptor.
        ///  </returns>
        /// <exception name="DeploymentException">Raised if the default application descriptor can't be accessed or is invalid.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        ApplicationDescriptor getDefaultApplicationDescriptor(Ice.Current current);

        /// <summary>
        /// Get all the IceGrid applications currently registered.
        /// </summary>
        /// <returns>The application names.</returns>
        /// <param name="current">The Current object for the dispatch.</param>

        string[] getAllApplicationNames(Ice.Current current);

        /// <summary>
        /// Get the server information for the server with the given id.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <returns>The server information.</returns>
        /// <param name="current">The Current object for the dispatch.</param>

        ServerInfo getServerInfo(string id, Ice.Current current);

        /// <summary>
        /// Get a server's state.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <returns>The server state.
        ///  </returns>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        ServerState getServerState(string id, Ice.Current current);

        /// <summary>
        /// Get a server's system process id.
        /// The process id is operating system dependent.
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <returns>The server's process id.
        ///  </returns>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        int getServerPid(string id, Ice.Current current);

        /// <summary>
        /// Get the category for server admin objects.
        /// You can manufacture a server admin proxy from the admin proxy by
        ///  changing its identity: use the server ID as name and the returned category as category.
        /// </summary>
        ///  <returns>The category for server admin objects.</returns>
        /// <param name="current">The Current object for the dispatch.</param>

        string getServerAdminCategory(Ice.Current current);

        /// <summary>
        /// Get a proxy to the server's admin object.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <returns>A proxy to the server's admin object. The returned proxy is never null.
        ///  </returns>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        global::Ice.ObjectPrx? getServerAdmin(string id, Ice.Current current);

        /// <summary>
        /// Enable or disable a server.
        /// A disabled server can't be started on demand or administratively. The enable
        ///  state of the server is not persistent: if the node is shut down and restarted, the server will be enabled by
        ///  default.
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <param name="enabled">True to enable the server, false to disable it.
        ///  </param>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        void enableServer(string id, bool enabled, Ice.Current current);

        /// <summary>
        /// Check if the server is enabled or disabled.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <returns>True if the server is enabled.
        ///  </returns>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        bool isServerEnabled(string id, Ice.Current current);

        /// <summary>
        /// Start a server and wait for its activation.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <param name="current">The Current object for the dispatch.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task startServerAsync(string id, Ice.Current current);

        /// <summary>
        /// Stop a server.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <param name="current">The Current object for the dispatch.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task stopServerAsync(string id, Ice.Current current);

        /// <summary>
        /// Send signal to a server.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <param name="signal">The signal, for example SIGTERM or 15.
        ///  </param>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.
        ///  </exception>
        /// <exception name="BadSignalException">Raised if the signal is not recognized by the target server.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        void sendSignal(string id, string signal, Ice.Current current);

        /// <summary>
        /// Get all the server ids registered with IceGrid.
        /// </summary>
        /// <returns>The server ids.</returns>
        /// <param name="current">The Current object for the dispatch.</param>

        string[] getAllServerIds(Ice.Current current);

        /// <summary>
        /// Get the adapter information for the replica group or adapter with the given id.
        /// </summary>
        /// <param name="id">The adapter id.
        ///  </param>
        /// <returns>A sequence of adapter information structures. If the given id refers to an adapter, this sequence
        ///  will contain only one element. If the given id refers to a replica group, the sequence will contain the
        ///  adapter information of each member of the replica group.
        ///  </returns>
        /// <exception name="AdapterNotExistException">Raised if the adapter or replica group doesn't exist.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        AdapterInfo[] getAdapterInfo(string id, Ice.Current current);

        /// <summary>
        /// Remove the adapter with the given id.
        /// </summary>
        /// <param name="id">The adapter id.
        ///  </param>
        /// <exception name="AdapterNotExistException">Raised if the adapter doesn't exist.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        void removeAdapter(string id, Ice.Current current);

        /// <summary>
        /// Get all the adapter ids registered with IceGrid.
        /// </summary>
        /// <returns>The adapter ids.</returns>
        /// <param name="current">The Current object for the dispatch.</param>

        string[] getAllAdapterIds(Ice.Current current);

        /// <summary>
        /// Add an object to the object registry.
        /// IceGrid will get the object type by calling ice_id on the
        ///  given proxy. The object must be reachable.
        /// </summary>
        ///  <param name="obj">The object to be added to the registry.
        ///  </param>
        /// <exception name="ObjectExistsException">Raised if the object is already registered.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the object can't be added. This might be raised if the invocation on
        ///  the proxy to get the object type failed.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        void addObject(global::Ice.ObjectPrx? obj, Ice.Current current);

        /// <summary>
        /// Update an object in the object registry.
        /// Only objects added with this interface can be updated with this
        ///  operation. Objects added with deployment descriptors should be updated with the deployment mechanism.
        /// </summary>
        ///  <param name="obj">The object to be updated to the registry.
        ///  </param>
        /// <exception name="ObjectNotRegisteredException">Raised if the object isn't registered with the registry.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the object can't be updated. This might happen if the object was added
        ///  with a deployment descriptor.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        void updateObject(global::Ice.ObjectPrx? obj, Ice.Current current);

        /// <summary>
        /// Add an object to the object registry and explicitly specify its type.
        /// </summary>
        /// <param name="obj">The object to be added to the registry. The proxy is never null.
        ///  </param>
        /// <param name="type">The object type.
        ///  </param>
        /// <exception name="ObjectExistsException">Raised if the object is already registered.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        void addObjectWithType(global::Ice.ObjectPrx? obj, string type, Ice.Current current);

        /// <summary>
        /// Remove an object from the object registry.
        /// Only objects added with this interface can be removed with this
        ///  operation. Objects added with deployment descriptors should be removed with the deployment mechanism.
        /// </summary>
        ///  <param name="id">The identity of the object to be removed from the registry.
        ///  </param>
        /// <exception name="ObjectNotRegisteredException">Raised if the object isn't registered with the registry.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the object can't be removed. This might happen if the object was added
        ///  with a deployment descriptor.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        void removeObject(global::Ice.Identity id, Ice.Current current);

        /// <summary>
        /// Get the object info for the object with the given identity.
        /// </summary>
        /// <param name="id">The identity of the object.
        ///  </param>
        /// <returns>The object info.
        ///  </returns>
        /// <exception name="ObjectNotRegisteredException">Raised if the object isn't registered with the registry.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        ObjectInfo getObjectInfo(global::Ice.Identity id, Ice.Current current);

        /// <summary>
        /// Get the object info of all the registered objects with the given type.
        /// </summary>
        /// <param name="type">The type of the object.
        ///  </param>
        /// <returns>The object infos.</returns>
        /// <param name="current">The Current object for the dispatch.</param>

        ObjectInfo[] getObjectInfosByType(string type, Ice.Current current);

        /// <summary>
        /// Get the object info of all the registered objects whose stringified identities match the given expression.
        /// </summary>
        /// <param name="expr">The expression to match against the stringified identities of registered objects. The expression
        ///  may contain a trailing wildcard (*) character.
        ///  </param>
        /// <returns>All the object infos with a stringified identity matching the given expression.</returns>
        /// <param name="current">The Current object for the dispatch.</param>

        ObjectInfo[] getAllObjectInfos(string expr, Ice.Current current);

        /// <summary>
        /// Ping an IceGrid node to see if it is active.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <returns>true if the node ping succeeded, false otherwise.
        ///  </returns>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        bool pingNode(string name, Ice.Current current);

        /// <summary>
        /// Get the load averages of the node.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <returns>The node load information.
        ///  </returns>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        LoadInfo getNodeLoad(string name, Ice.Current current);

        /// <summary>
        /// Get the node information for the node with the given name.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <returns>The node information.
        ///  </returns>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        NodeInfo getNodeInfo(string name, Ice.Current current);

        /// <summary>
        /// Get a proxy to the IceGrid node's admin object.
        /// </summary>
        /// <param name="name">The IceGrid node name
        ///  </param>
        /// <returns>A proxy to the IceGrid node's admin object. The returned proxy is never null.
        ///  </returns>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        global::Ice.ObjectPrx? getNodeAdmin(string name, Ice.Current current);

        /// <summary>
        /// Get the number of physical processor sockets for the machine running the node with the given name.
        /// Note that this method will return 1 on operating systems where this can't be automatically determined and
        ///  where the IceGrid.Node.ProcessorSocketCount property for the node is not set.
        /// </summary>
        ///  <param name="name">The node name.
        ///  </param>
        /// <returns>The number of processor sockets or 1 if the number of sockets can't determined.
        ///  </returns>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        int getNodeProcessorSocketCount(string name, Ice.Current current);

        /// <summary>
        /// Shutdown an IceGrid node.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        void shutdownNode(string name, Ice.Current current);

        /// <summary>
        /// Get the hostname of this node.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <returns>The node hostname.
        ///  </returns>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        string getNodeHostname(string name, Ice.Current current);

        /// <summary>
        /// Get all the IceGrid nodes currently registered.
        /// </summary>
        /// <returns>The node names.</returns>
        /// <param name="current">The Current object for the dispatch.</param>

        string[] getAllNodeNames(Ice.Current current);

        /// <summary>
        /// Ping an IceGrid registry to see if it is active.
        /// </summary>
        /// <param name="name">The registry name.
        ///  </param>
        /// <returns>true if the registry ping succeeded, false otherwise.
        ///  </returns>
        /// <exception name="RegistryNotExistException">Raised if the registry doesn't exist.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        bool pingRegistry(string name, Ice.Current current);

        /// <summary>
        /// Get the registry information for the registry with the given name.
        /// </summary>
        /// <param name="name">The registry name.
        ///  </param>
        /// <returns>The registry information.
        ///  </returns>
        /// <exception name="RegistryNotExistException">Raised if the registry doesn't exist.
        ///  </exception>
        /// <exception name="RegistryUnreachableException">Raised if the registry could not be reached.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        RegistryInfo getRegistryInfo(string name, Ice.Current current);

        /// <summary>
        /// Get a proxy to the IceGrid registry's admin object.
        /// </summary>
        /// <param name="name">The registry name
        ///  </param>
        /// <returns>A proxy to the IceGrid registry's admin object. The returned proxy is never null.
        ///  </returns>
        /// <exception name="RegistryNotExistException">Raised if the registry doesn't exist.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        global::Ice.ObjectPrx? getRegistryAdmin(string name, Ice.Current current);

        /// <summary>
        /// Shutdown an IceGrid registry.
        /// </summary>
        /// <param name="name">The registry name.
        ///  </param>
        /// <exception name="RegistryNotExistException">Raised if the registry doesn't exist.
        ///  </exception>
        /// <exception name="RegistryUnreachableException">Raised if the registry could not be reached.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        void shutdownRegistry(string name, Ice.Current current);

        /// <summary>
        /// Get all the IceGrid registries currently registered.
        /// </summary>
        /// <returns>The registry names.</returns>
        /// <param name="current">The Current object for the dispatch.</param>

        string[] getAllRegistryNames(Ice.Current current);

        /// <summary>
        /// Shut down the IceGrid registry.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        void shutdown(Ice.Current current);
    }

    [Ice.SliceTypeId("::IceGrid::FileIterator")]
    public partial interface FileIterator : Ice.Object
    {
        /// <summary>
        /// Read lines from the log file.
        /// </summary>
        /// <param name="size">Specifies the maximum number of bytes to be received. The server will ensure that the returned
        ///  message doesn't exceed the given size.
        ///  </param>
        /// <param name="lines">The lines read from the file. If there was nothing to read from the file since the last call to
        ///  read, an empty sequence is returned. The last line of the sequence is always incomplete (and therefore no
        ///  '\n' should be added when writing the last line to the to the output device).
        ///  </param>
        /// <returns>True if EOF is encountered.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if there was a problem to read lines from the file.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        bool read(int size, out string[] lines, Ice.Current current);

        /// <summary>
        /// Destroy the iterator.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        void destroy(Ice.Current current);
    }

    public sealed partial record class ServerDynamicInfo
    {
        public string id = "";

        public ServerState state;

        public int pid;

        public bool enabled;

        partial void ice_initialize();

        public ServerDynamicInfo()
        {
            ice_initialize();
        }

        public ServerDynamicInfo(string id, ServerState state, int pid, bool enabled)
        {
            global::System.ArgumentNullException.ThrowIfNull(id);
            this.id = id;
            this.state = state;
            this.pid = pid;
            this.enabled = enabled;
            ice_initialize();
        }

        public ServerDynamicInfo(Ice.InputStream istr)
        {
            this.id = istr.readString();
            this.state = (ServerState)istr.readEnum(6);
            this.pid = istr.readInt();
            this.enabled = istr.readBool();
            ice_initialize();
        }

        public void ice_writeMembers(Ice.OutputStream ostr)
        {
            ostr.writeString(this.id);
            ostr.writeEnum((int)this.state, 6);
            ostr.writeInt(this.pid);
            ostr.writeBool(this.enabled);
        }

        public static void ice_write(Ice.OutputStream ostr, ServerDynamicInfo v)
        {
            v.ice_writeMembers(ostr);
        }

        public static ServerDynamicInfo ice_read(Ice.InputStream istr) => new(istr);
    }

    public sealed partial record class AdapterDynamicInfo
    {
        public string id = "";

        public global::Ice.ObjectPrx? proxy;

        partial void ice_initialize();

        public AdapterDynamicInfo()
        {
            ice_initialize();
        }

        public AdapterDynamicInfo(string id, global::Ice.ObjectPrx? proxy)
        {
            global::System.ArgumentNullException.ThrowIfNull(id);
            this.id = id;
            this.proxy = proxy;
            ice_initialize();
        }

        public AdapterDynamicInfo(Ice.InputStream istr)
        {
            this.id = istr.readString();
            this.proxy = istr.readProxy();
            ice_initialize();
        }

        public void ice_writeMembers(Ice.OutputStream ostr)
        {
            ostr.writeString(this.id);
            ostr.writeProxy(this.proxy);
        }

        public static void ice_write(Ice.OutputStream ostr, AdapterDynamicInfo v)
        {
            v.ice_writeMembers(ostr);
        }

        public static AdapterDynamicInfo ice_read(Ice.InputStream istr) => new(istr);
    }

    public sealed partial record class NodeDynamicInfo
    {
        public NodeInfo info;

        public ServerDynamicInfo[] servers;

        public AdapterDynamicInfo[] adapters;

        partial void ice_initialize();

        public NodeDynamicInfo(NodeInfo info, ServerDynamicInfo[] servers, AdapterDynamicInfo[] adapters)
        {
            global::System.ArgumentNullException.ThrowIfNull(info);
            this.info = info;
            global::System.ArgumentNullException.ThrowIfNull(servers);
            this.servers = servers;
            global::System.ArgumentNullException.ThrowIfNull(adapters);
            this.adapters = adapters;
            ice_initialize();
        }

        public NodeDynamicInfo(Ice.InputStream istr)
        {
            this.info = new NodeInfo(istr);
            this.servers = ServerDynamicInfoSeqHelper.read(istr);
            this.adapters = AdapterDynamicInfoSeqHelper.read(istr);
            ice_initialize();
        }

        public void ice_writeMembers(Ice.OutputStream ostr)
        {
            NodeInfo.ice_write(ostr, this.info);
            ServerDynamicInfoSeqHelper.write(ostr, this.servers);
            AdapterDynamicInfoSeqHelper.write(ostr, this.adapters);
        }

        public static void ice_write(Ice.OutputStream ostr, NodeDynamicInfo v)
        {
            v.ice_writeMembers(ostr);
        }

        public static NodeDynamicInfo ice_read(Ice.InputStream istr) => new(istr);
    }

    [Ice.SliceTypeId("::IceGrid::RegistryObserver")]
    public partial interface RegistryObserver : Ice.Object
    {
        /// <summary>
        /// The registryInit operation is called after registration of an observer to indicate the state of
        ///  the registries.
        /// </summary>
        /// <param name="registries">The current state of the registries.</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void registryInit(RegistryInfo[] registries, Ice.Current current);

        /// <summary>
        /// The registryUp operation is called to notify an observer that a registry replica came up.
        /// </summary>
        /// <param name="registryReplica">The registry state.</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void registryUp(RegistryInfo registryReplica, Ice.Current current);

        /// <summary>
        /// The registryDown operation is called to notify an observer that a registry replica went down.
        /// </summary>
        /// <param name="name">The registry name.</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void registryDown(string name, Ice.Current current);
    }

    [Ice.SliceTypeId("::IceGrid::NodeObserver")]
    public partial interface NodeObserver : Ice.Object
    {
        /// <summary>
        /// The nodeInit operation indicates the current state of nodes.
        /// It is called after the
        ///  registration of an observer.
        /// </summary>
        ///  <param name="nodes">The current state of the nodes.</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void nodeInit(NodeDynamicInfo[] nodes, Ice.Current current);

        /// <summary>
        /// The nodeUp operation is called to notify an observer that a node came up.
        /// </summary>
        /// <param name="node">The node state.</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void nodeUp(NodeDynamicInfo node, Ice.Current current);

        /// <summary>
        /// The nodeDown operation is called to notify an observer that a node went down.
        /// </summary>
        /// <param name="name">The node name.</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void nodeDown(string name, Ice.Current current);

        /// <summary>
        /// The updateServer operation is called to notify an observer that the state of a server changed.
        /// </summary>
        /// <param name="node">The node hosting the server.
        ///  </param>
        /// <param name="updatedInfo">The new server state.</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void updateServer(string node, ServerDynamicInfo updatedInfo, Ice.Current current);

        /// <summary>
        /// The updateAdapter operation is called to notify an observer that the state of an adapter
        ///  changed.
        /// </summary>
        /// <param name="node">The node hosting the adapter.
        ///  </param>
        /// <param name="updatedInfo">The new adapter state.</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void updateAdapter(string node, AdapterDynamicInfo updatedInfo, Ice.Current current);
    }

    [Ice.SliceTypeId("::IceGrid::ApplicationObserver")]
    public partial interface ApplicationObserver : Ice.Object
    {
        /// <summary>
        /// applicationInit is called after the registration of an observer to indicate the state of the
        ///  registry.
        /// </summary>
        /// <param name="serial">The current serial number of the registry database. This serial number allows observers to
        ///  make sure that their internal state is synchronized with the registry.
        ///  </param>
        /// <param name="applications">The applications currently registered with the registry.</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void applicationInit(int serial, ApplicationInfo[] applications, Ice.Current current);

        /// <summary>
        /// The applicationAdded operation is called to notify an observer that an application was added.
        /// </summary>
        /// <param name="serial">The new serial number of the registry database.
        ///  </param>
        /// <param name="desc">The descriptor of the new application.</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void applicationAdded(int serial, ApplicationInfo desc, Ice.Current current);

        /// <summary>
        /// The applicationRemoved operation is called to notify an observer that an application was
        ///  removed.
        /// </summary>
        /// <param name="serial">The new serial number of the registry database.
        ///  </param>
        /// <param name="name">The name of the application that was removed.</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void applicationRemoved(int serial, string name, Ice.Current current);

        /// <summary>
        /// The applicationUpdated operation is called to notify an observer that an application was
        ///  updated.
        /// </summary>
        /// <param name="serial">The new serial number of the registry database.
        ///  </param>
        /// <param name="desc">The descriptor of the update.</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void applicationUpdated(int serial, ApplicationUpdateInfo desc, Ice.Current current);
    }

    [Ice.SliceTypeId("::IceGrid::AdapterObserver")]
    public partial interface AdapterObserver : Ice.Object
    {
        /// <summary>
        /// adapterInit is called after registration of an observer to indicate the state of the registry.
        /// </summary>
        /// <param name="adpts">The adapters that were dynamically registered with the registry (not through the deployment
        ///  mechanism).</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void adapterInit(AdapterInfo[] adpts, Ice.Current current);

        /// <summary>
        /// The adapterAdded operation is called to notify an observer when a dynamically-registered
        ///  adapter was added.
        /// </summary>
        /// <param name="info">The details of the new adapter.</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void adapterAdded(AdapterInfo info, Ice.Current current);

        /// <summary>
        /// The adapterUpdated operation is called to notify an observer when a dynamically-registered adapter was
        ///  updated.
        /// </summary>
        /// <param name="info">The details of the updated adapter.</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void adapterUpdated(AdapterInfo info, Ice.Current current);

        /// <summary>
        /// The adapterRemoved operation is called to notify an observer when a dynamically-registered adapter was
        ///  removed.
        /// </summary>
        /// <param name="id">The ID of the removed adapter.</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void adapterRemoved(string id, Ice.Current current);
    }

    [Ice.SliceTypeId("::IceGrid::ObjectObserver")]
    public partial interface ObjectObserver : Ice.Object
    {
        /// <summary>
        /// objectInit is called after the registration of an observer to indicate the state of the
        ///  registry.
        /// </summary>
        /// <param name="objects">The objects registered with the Admin interface (not through the deployment
        ///  mechanism).</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void objectInit(ObjectInfo[] objects, Ice.Current current);

        /// <summary>
        /// The objectAdded operation is called to notify an observer when an object was added to the
        ///  Admin interface.
        /// </summary>
        /// <param name="info">The details of the added object.</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void objectAdded(ObjectInfo info, Ice.Current current);

        /// <summary>
        /// objectUpdated is called to notify an observer when an object registered with the Admin
        ///  interface was updated.
        /// </summary>
        /// <param name="info">The details of the updated object.</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void objectUpdated(ObjectInfo info, Ice.Current current);

        /// <summary>
        /// objectRemoved is called to notify an observer when an object registered with the Admin
        ///  interface was removed.
        /// </summary>
        /// <param name="id">The identity of the removed object.</param>
        /// <param name="current">The Current object for the dispatch.</param>

        void objectRemoved(global::Ice.Identity id, Ice.Current current);
    }

    [Ice.SliceTypeId("::IceGrid::AdminSession")]
    public partial interface AdminSession : global::Glacier2.Session
    {
        /// <summary>
        /// Keep the session alive.
        /// As of Ice 3.8, there is no need to call this operation, and its implementation does nothing.
        /// </summary>
        /// <param name="current">The Current object for the dispatch.</param>

        [global::System.Obsolete]
        void keepAlive(Ice.Current current);

        /// <summary>
        /// Get the admin interface.
        /// The admin object returned by this operation can only be accessed by the session.
        /// </summary>
        ///  <returns>The admin interface proxy. The returned proxy is never null.</returns>
        /// <param name="current">The Current object for the dispatch.</param>

        AdminPrx? getAdmin(Ice.Current current);

        /// <summary>
        /// Get a "template" proxy for admin callback objects.
        /// An Admin client uses this proxy to set the category of
        ///  its callback objects, and the published endpoints of the object adapter hosting the admin callback objects.
        /// </summary>
        ///  <returns>A template proxy. The returned proxy is null when the Admin session was established using Glacier2.</returns>
        /// <param name="current">The Current object for the dispatch.</param>

        global::Ice.ObjectPrx? getAdminCallbackTemplate(Ice.Current current);

        /// <summary>
        /// Set the observer proxies that receive notifications when the state of the registry or nodes changes.
        /// </summary>
        /// <param name="registryObs">The registry observer.
        ///  </param>
        /// <param name="nodeObs">The node observer.
        ///  </param>
        /// <param name="appObs">The application observer.
        ///  </param>
        /// <param name="adptObs">The adapter observer.
        ///  </param>
        /// <param name="objObs">The object observer.
        ///  </param>
        /// <exception name="ObserverAlreadyRegisteredException">Raised if an observer is already registered with this registry.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        void setObservers(RegistryObserverPrx? registryObs, NodeObserverPrx? nodeObs, ApplicationObserverPrx? appObs, AdapterObserverPrx? adptObs, ObjectObserverPrx? objObs, Ice.Current current);

        /// <summary>
        /// Set the observer identities that receive notifications the state of the registry or nodes changes.
        /// This
        ///  operation should be used by clients that are using a bidirectional connection to communicate with the
        ///  session.
        /// </summary>
        ///  <param name="registryObs">The registry observer identity.
        ///  </param>
        /// <param name="nodeObs">The node observer identity.
        ///  </param>
        /// <param name="appObs">The application observer.
        ///  </param>
        /// <param name="adptObs">The adapter observer.
        ///  </param>
        /// <param name="objObs">The object observer.
        ///  </param>
        /// <exception name="ObserverAlreadyRegisteredException">Raised if an observer is already registered with this registry.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        void setObserversByIdentity(global::Ice.Identity registryObs, global::Ice.Identity nodeObs, global::Ice.Identity appObs, global::Ice.Identity adptObs, global::Ice.Identity objObs, Ice.Current current);

        /// <summary>
        /// Acquires an exclusive lock to start updating the registry applications.
        /// </summary>
        /// <returns>The current serial.
        ///  </returns>
        /// <exception name="AccessDeniedException">Raised if the exclusive lock can't be acquired. This might happen if the lock
        ///  is currently acquired by another session.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        int startUpdate(Ice.Current current);

        /// <summary>
        /// Finish updating the registry and release the exclusive lock.
        /// </summary>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        void finishUpdate(Ice.Current current);

        /// <summary>
        /// Get the name of the registry replica hosting this session.
        /// </summary>
        /// <returns>The replica name of the registry.</returns>
        /// <param name="current">The Current object for the dispatch.</param>

        string getReplicaName(Ice.Current current);

        /// <summary>
        /// Open the given server log file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <param name="path">The path of the log file. A log file can be opened only if it's declared in the server or
        ///  service deployment descriptor.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If
        ///  0 or positive, the file is read from the last count lines.
        ///  </param>
        /// <returns>An iterator to read the file. The returned proxy is never null.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if the file can't be read.
        ///  </exception>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        FileIteratorPrx? openServerLog(string id, string path, int count, Ice.Current current);

        /// <summary>
        /// Open the given server stderr file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If
        ///  0 or positive, the file is read from the last count lines.
        ///  </param>
        /// <returns>An iterator to read the file. The returned proxy is never null.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if the file can't be read.
        ///  </exception>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        FileIteratorPrx? openServerStdErr(string id, int count, Ice.Current current);

        /// <summary>
        /// Open the given server stdout file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining.
        ///  If 0 or positive, the file is read from the last count lines.
        ///  </param>
        /// <returns>An iterator to read the file. The returned proxy is never null.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if the file can't be read.
        ///  </exception>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        FileIteratorPrx? openServerStdOut(string id, int count, Ice.Current current);

        /// <summary>
        /// Open the given node stderr file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="name">The node name.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If
        ///  0 or positive, the file is read from the last count lines.
        ///  </param>
        /// <returns>An iterator to read the file. The returned proxy is never null.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if the file can't be read.
        ///  </exception>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        FileIteratorPrx? openNodeStdErr(string name, int count, Ice.Current current);

        /// <summary>
        /// Open the given node stdout file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="name">The node name.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If
        ///  0 or positive, the file is read from the last count lines.
        ///  </param>
        /// <returns>An iterator to read the file. The returned proxy is never null.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if the file can't be read.
        ///  </exception>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        FileIteratorPrx? openNodeStdOut(string name, int count, Ice.Current current);

        /// <summary>
        /// Open the given registry stderr file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="name">The registry name.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If
        ///  0 or positive, the file is read from the last count lines.
        ///  </param>
        /// <returns>An iterator to read the file. The returned proxy is never null.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if the file can't be read.
        ///  </exception>
        /// <exception name="RegistryNotExistException">Raised if the registry doesn't exist.
        ///  </exception>
        /// <exception name="RegistryUnreachableException">Raised if the registry could not be reached.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        FileIteratorPrx? openRegistryStdErr(string name, int count, Ice.Current current);

        /// <summary>
        /// Open the given registry stdout file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="name">The registry name.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If
        ///  0 or positive, the file is read from the last count lines.
        ///  </param>
        /// <returns>An iterator to read the file. The returned proxy is never null.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if the file can't be read.
        ///  </exception>
        /// <exception name="RegistryNotExistException">Raised if the registry doesn't exist.
        ///  </exception>
        /// <exception name="RegistryUnreachableException">Raised if the registry could not be reached.</exception>
        /// <param name="current">The Current object for the dispatch.</param>

        FileIteratorPrx? openRegistryStdOut(string name, int count, Ice.Current current);
    }
}

namespace IceGrid
{
    public record struct FileIterator_ReadResult(bool returnValue, string[] lines);
}

namespace IceGrid
{
    /// <summary>
    /// The IceGrid administrative interface.
    /// &lt;p class="Warning"&gt;Allowing access to this interface is a security risk!
    ///  Please see the IceGrid documentation for further information.
    /// </summary>

    public interface AdminPrx : Ice.ObjectPrx
    {
        /// <summary>
        /// Add an application to IceGrid.
        /// </summary>
        /// <param name="descriptor">The application descriptor.
        ///  </param>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock or if another session is
        ///  holding the lock.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void addApplication(ApplicationDescriptor descriptor, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Add an application to IceGrid.
        /// </summary>
        /// <param name="descriptor">The application descriptor.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task addApplicationAsync(ApplicationDescriptor descriptor, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Synchronize a deployed application with the given application descriptor.
        /// This operation will replace the
        ///  current descriptor with this new descriptor.
        /// </summary>
        ///  <param name="descriptor">The application descriptor.
        ///  </param>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock or if another session is
        ///  holding the lock.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.
        ///  </exception>
        /// <exception name="ApplicationNotExistException">Raised if the application doesn't exist.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void syncApplication(ApplicationDescriptor descriptor, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Synchronize a deployed application with the given application descriptor.
        /// This operation will replace the
        /// </summary>
        ///  <param name="descriptor">The application descriptor.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task syncApplicationAsync(ApplicationDescriptor descriptor, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Update a deployed application with the given update application descriptor.
        /// </summary>
        /// <param name="descriptor">The update descriptor.
        ///  </param>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock or if another session is
        ///  holding the lock.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.
        ///  </exception>
        /// <exception name="ApplicationNotExistException">Raised if the application doesn't exist.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void updateApplication(ApplicationUpdateDescriptor descriptor, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Update a deployed application with the given update application descriptor.
        /// </summary>
        /// <param name="descriptor">The update descriptor.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task updateApplicationAsync(ApplicationUpdateDescriptor descriptor, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Synchronize a deployed application with the given application descriptor.
        /// This operation will replace the
        ///  current descriptor with this new descriptor only if no server restarts are necessary for the update of the
        ///  application. If some servers need to be restarted, the synchronization is rejected with a
        ///  DeploymentException.
        /// </summary>
        ///  <param name="descriptor">The application descriptor.
        ///  </param>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock or if another session is
        ///  holding the lock.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.
        ///  </exception>
        /// <exception name="ApplicationNotExistException">Raised if the application doesn't exist.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void syncApplicationWithoutRestart(ApplicationDescriptor descriptor, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Synchronize a deployed application with the given application descriptor.
        /// This operation will replace the
        /// </summary>
        ///  <param name="descriptor">The application descriptor.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task syncApplicationWithoutRestartAsync(ApplicationDescriptor descriptor, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Update a deployed application with the given update application descriptor only if no server restarts are
        ///  necessary for the update of the application.
        /// If some servers need to be restarted, the synchronization is
        ///  rejected with a DeploymentException.
        /// </summary>
        ///  <param name="descriptor">The update descriptor.
        ///  </param>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock or if another session is
        ///  holding the lock.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.
        ///  </exception>
        /// <exception name="ApplicationNotExistException">Raised if the application doesn't exist.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void updateApplicationWithoutRestart(ApplicationUpdateDescriptor descriptor, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Update a deployed application with the given update application descriptor only if no server restarts are
        ///  necessary for the update of the application.
        /// If some servers need to be restarted, the synchronization is
        /// </summary>
        ///  <param name="descriptor">The update descriptor.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task updateApplicationWithoutRestartAsync(ApplicationUpdateDescriptor descriptor, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Remove an application from IceGrid.
        /// </summary>
        /// <param name="name">The application name.
        ///  </param>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock or if another session is
        ///  holding the lock.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.
        ///  </exception>
        /// <exception name="ApplicationNotExistException">Raised if the application doesn't exist.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void removeApplication(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Remove an application from IceGrid.
        /// </summary>
        /// <param name="name">The application name.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task removeApplicationAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Instantiate a server template from an application on the given node.
        /// </summary>
        /// <param name="application">The application name.
        ///  </param>
        /// <param name="node">The name of the node where the server will be deployed.
        ///  </param>
        /// <param name="desc">The descriptor of the server instance to deploy.
        ///  </param>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock or if another session is
        ///  holding the lock.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if server instantiation failed.
        ///  </exception>
        /// <exception name="ApplicationNotExistException">Raised if the application doesn't exist.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void instantiateServer(string application, string node, ServerInstanceDescriptor desc, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Instantiate a server template from an application on the given node.
        /// </summary>
        /// <param name="application">The application name.
        ///  </param>
        /// <param name="node">The name of the node where the server will be deployed.
        ///  </param>
        /// <param name="desc">The descriptor of the server instance to deploy.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task instantiateServerAsync(string application, string node, ServerInstanceDescriptor desc, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get an application descriptor.
        /// </summary>
        /// <param name="name">The application name.
        ///  </param>
        /// <returns>The application descriptor.
        ///  </returns>
        /// <exception name="ApplicationNotExistException">Raised if the application doesn't exist.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        ApplicationInfo getApplicationInfo(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get an application descriptor.
        /// </summary>
        /// <param name="name">The application name.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<ApplicationInfo> getApplicationInfoAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get the default application descriptor.
        /// </summary>
        /// <returns>The default application descriptor.
        ///  </returns>
        /// <exception name="DeploymentException">Raised if the default application descriptor can't be accessed or is invalid.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        ApplicationDescriptor getDefaultApplicationDescriptor(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get the default application descriptor.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<ApplicationDescriptor> getDefaultApplicationDescriptorAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get all the IceGrid applications currently registered.
        /// </summary>
        /// <returns>The application names.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        string[] getAllApplicationNames(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get all the IceGrid applications currently registered.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<string[]> getAllApplicationNamesAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get the server information for the server with the given id.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <returns>The server information.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        ServerInfo getServerInfo(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get the server information for the server with the given id.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<ServerInfo> getServerInfoAsync(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get a server's state.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <returns>The server state.
        ///  </returns>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        ServerState getServerState(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get a server's state.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<ServerState> getServerStateAsync(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get a server's system process id.
        /// The process id is operating system dependent.
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <returns>The server's process id.
        ///  </returns>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        int getServerPid(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get a server's system process id.
        /// The process id is operating system dependent.
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<int> getServerPidAsync(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get the category for server admin objects.
        /// You can manufacture a server admin proxy from the admin proxy by
        ///  changing its identity: use the server ID as name and the returned category as category.
        /// </summary>
        ///  <returns>The category for server admin objects.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        string getServerAdminCategory(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get the category for server admin objects.
        /// You can manufacture a server admin proxy from the admin proxy by
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<string> getServerAdminCategoryAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get a proxy to the server's admin object.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <returns>A proxy to the server's admin object. The returned proxy is never null.
        ///  </returns>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        global::Ice.ObjectPrx? getServerAdmin(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get a proxy to the server's admin object.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<global::Ice.ObjectPrx?> getServerAdminAsync(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Enable or disable a server.
        /// A disabled server can't be started on demand or administratively. The enable
        ///  state of the server is not persistent: if the node is shut down and restarted, the server will be enabled by
        ///  default.
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <param name="enabled">True to enable the server, false to disable it.
        ///  </param>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void enableServer(string id, bool enabled, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Enable or disable a server.
        /// A disabled server can't be started on demand or administratively. The enable
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <param name="enabled">True to enable the server, false to disable it.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task enableServerAsync(string id, bool enabled, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Check if the server is enabled or disabled.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <returns>True if the server is enabled.
        ///  </returns>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        bool isServerEnabled(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Check if the server is enabled or disabled.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<bool> isServerEnabledAsync(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Start a server and wait for its activation.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="ServerStartException">Raised if the server couldn't be started.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void startServer(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Start a server and wait for its activation.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task startServerAsync(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Stop a server.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="ServerStopException">Raised if the server couldn't be stopped.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void stopServer(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Stop a server.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task stopServerAsync(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Send signal to a server.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <param name="signal">The signal, for example SIGTERM or 15.
        ///  </param>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.
        ///  </exception>
        /// <exception name="BadSignalException">Raised if the signal is not recognized by the target server.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void sendSignal(string id, string signal, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Send signal to a server.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <param name="signal">The signal, for example SIGTERM or 15.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task sendSignalAsync(string id, string signal, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get all the server ids registered with IceGrid.
        /// </summary>
        /// <returns>The server ids.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        string[] getAllServerIds(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get all the server ids registered with IceGrid.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<string[]> getAllServerIdsAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get the adapter information for the replica group or adapter with the given id.
        /// </summary>
        /// <param name="id">The adapter id.
        ///  </param>
        /// <returns>A sequence of adapter information structures. If the given id refers to an adapter, this sequence
        ///  will contain only one element. If the given id refers to a replica group, the sequence will contain the
        ///  adapter information of each member of the replica group.
        ///  </returns>
        /// <exception name="AdapterNotExistException">Raised if the adapter or replica group doesn't exist.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        AdapterInfo[] getAdapterInfo(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get the adapter information for the replica group or adapter with the given id.
        /// </summary>
        /// <param name="id">The adapter id.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<AdapterInfo[]> getAdapterInfoAsync(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Remove the adapter with the given id.
        /// </summary>
        /// <param name="id">The adapter id.
        ///  </param>
        /// <exception name="AdapterNotExistException">Raised if the adapter doesn't exist.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void removeAdapter(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Remove the adapter with the given id.
        /// </summary>
        /// <param name="id">The adapter id.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task removeAdapterAsync(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get all the adapter ids registered with IceGrid.
        /// </summary>
        /// <returns>The adapter ids.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        string[] getAllAdapterIds(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get all the adapter ids registered with IceGrid.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<string[]> getAllAdapterIdsAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Add an object to the object registry.
        /// IceGrid will get the object type by calling ice_id on the
        ///  given proxy. The object must be reachable.
        /// </summary>
        ///  <param name="obj">The object to be added to the registry.
        ///  </param>
        /// <exception name="ObjectExistsException">Raised if the object is already registered.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the object can't be added. This might be raised if the invocation on
        ///  the proxy to get the object type failed.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void addObject(global::Ice.ObjectPrx? obj, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Add an object to the object registry.
        /// IceGrid will get the object type by calling ice_id on the
        /// </summary>
        ///  <param name="obj">The object to be added to the registry.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task addObjectAsync(global::Ice.ObjectPrx? obj, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Update an object in the object registry.
        /// Only objects added with this interface can be updated with this
        ///  operation. Objects added with deployment descriptors should be updated with the deployment mechanism.
        /// </summary>
        ///  <param name="obj">The object to be updated to the registry.
        ///  </param>
        /// <exception name="ObjectNotRegisteredException">Raised if the object isn't registered with the registry.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the object can't be updated. This might happen if the object was added
        ///  with a deployment descriptor.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void updateObject(global::Ice.ObjectPrx? obj, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Update an object in the object registry.
        /// Only objects added with this interface can be updated with this
        /// </summary>
        ///  <param name="obj">The object to be updated to the registry.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task updateObjectAsync(global::Ice.ObjectPrx? obj, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Add an object to the object registry and explicitly specify its type.
        /// </summary>
        /// <param name="obj">The object to be added to the registry. The proxy is never null.
        ///  </param>
        /// <param name="type">The object type.
        ///  </param>
        /// <exception name="ObjectExistsException">Raised if the object is already registered.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void addObjectWithType(global::Ice.ObjectPrx? obj, string type, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Add an object to the object registry and explicitly specify its type.
        /// </summary>
        /// <param name="obj">The object to be added to the registry. The proxy is never null.
        ///  </param>
        /// <param name="type">The object type.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task addObjectWithTypeAsync(global::Ice.ObjectPrx? obj, string type, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Remove an object from the object registry.
        /// Only objects added with this interface can be removed with this
        ///  operation. Objects added with deployment descriptors should be removed with the deployment mechanism.
        /// </summary>
        ///  <param name="id">The identity of the object to be removed from the registry.
        ///  </param>
        /// <exception name="ObjectNotRegisteredException">Raised if the object isn't registered with the registry.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the object can't be removed. This might happen if the object was added
        ///  with a deployment descriptor.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void removeObject(global::Ice.Identity id, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Remove an object from the object registry.
        /// Only objects added with this interface can be removed with this
        /// </summary>
        ///  <param name="id">The identity of the object to be removed from the registry.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task removeObjectAsync(global::Ice.Identity id, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get the object info for the object with the given identity.
        /// </summary>
        /// <param name="id">The identity of the object.
        ///  </param>
        /// <returns>The object info.
        ///  </returns>
        /// <exception name="ObjectNotRegisteredException">Raised if the object isn't registered with the registry.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        ObjectInfo getObjectInfo(global::Ice.Identity id, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get the object info for the object with the given identity.
        /// </summary>
        /// <param name="id">The identity of the object.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<ObjectInfo> getObjectInfoAsync(global::Ice.Identity id, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get the object info of all the registered objects with the given type.
        /// </summary>
        /// <param name="type">The type of the object.
        ///  </param>
        /// <returns>The object infos.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        ObjectInfo[] getObjectInfosByType(string type, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get the object info of all the registered objects with the given type.
        /// </summary>
        /// <param name="type">The type of the object.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<ObjectInfo[]> getObjectInfosByTypeAsync(string type, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get the object info of all the registered objects whose stringified identities match the given expression.
        /// </summary>
        /// <param name="expr">The expression to match against the stringified identities of registered objects. The expression
        ///  may contain a trailing wildcard (*) character.
        ///  </param>
        /// <returns>All the object infos with a stringified identity matching the given expression.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        ObjectInfo[] getAllObjectInfos(string expr, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get the object info of all the registered objects whose stringified identities match the given expression.
        /// </summary>
        /// <param name="expr">The expression to match against the stringified identities of registered objects. The expression
        ///  may contain a trailing wildcard (*) character.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<ObjectInfo[]> getAllObjectInfosAsync(string expr, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Ping an IceGrid node to see if it is active.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <returns>true if the node ping succeeded, false otherwise.
        ///  </returns>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        bool pingNode(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Ping an IceGrid node to see if it is active.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<bool> pingNodeAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get the load averages of the node.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <returns>The node load information.
        ///  </returns>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        LoadInfo getNodeLoad(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get the load averages of the node.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<LoadInfo> getNodeLoadAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get the node information for the node with the given name.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <returns>The node information.
        ///  </returns>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        NodeInfo getNodeInfo(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get the node information for the node with the given name.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<NodeInfo> getNodeInfoAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get a proxy to the IceGrid node's admin object.
        /// </summary>
        /// <param name="name">The IceGrid node name
        ///  </param>
        /// <returns>A proxy to the IceGrid node's admin object. The returned proxy is never null.
        ///  </returns>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        global::Ice.ObjectPrx? getNodeAdmin(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get a proxy to the IceGrid node's admin object.
        /// </summary>
        /// <param name="name">The IceGrid node name
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<global::Ice.ObjectPrx?> getNodeAdminAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get the number of physical processor sockets for the machine running the node with the given name.
        /// Note that this method will return 1 on operating systems where this can't be automatically determined and
        ///  where the IceGrid.Node.ProcessorSocketCount property for the node is not set.
        /// </summary>
        ///  <param name="name">The node name.
        ///  </param>
        /// <returns>The number of processor sockets or 1 if the number of sockets can't determined.
        ///  </returns>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        int getNodeProcessorSocketCount(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get the number of physical processor sockets for the machine running the node with the given name.
        /// Note that this method will return 1 on operating systems where this can't be automatically determined and
        /// </summary>
        ///  <param name="name">The node name.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<int> getNodeProcessorSocketCountAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Shutdown an IceGrid node.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void shutdownNode(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Shutdown an IceGrid node.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task shutdownNodeAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get the hostname of this node.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <returns>The node hostname.
        ///  </returns>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        string getNodeHostname(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get the hostname of this node.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<string> getNodeHostnameAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get all the IceGrid nodes currently registered.
        /// </summary>
        /// <returns>The node names.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        string[] getAllNodeNames(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get all the IceGrid nodes currently registered.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<string[]> getAllNodeNamesAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Ping an IceGrid registry to see if it is active.
        /// </summary>
        /// <param name="name">The registry name.
        ///  </param>
        /// <returns>true if the registry ping succeeded, false otherwise.
        ///  </returns>
        /// <exception name="RegistryNotExistException">Raised if the registry doesn't exist.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        bool pingRegistry(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Ping an IceGrid registry to see if it is active.
        /// </summary>
        /// <param name="name">The registry name.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<bool> pingRegistryAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get the registry information for the registry with the given name.
        /// </summary>
        /// <param name="name">The registry name.
        ///  </param>
        /// <returns>The registry information.
        ///  </returns>
        /// <exception name="RegistryNotExistException">Raised if the registry doesn't exist.
        ///  </exception>
        /// <exception name="RegistryUnreachableException">Raised if the registry could not be reached.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        RegistryInfo getRegistryInfo(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get the registry information for the registry with the given name.
        /// </summary>
        /// <param name="name">The registry name.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<RegistryInfo> getRegistryInfoAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get a proxy to the IceGrid registry's admin object.
        /// </summary>
        /// <param name="name">The registry name
        ///  </param>
        /// <returns>A proxy to the IceGrid registry's admin object. The returned proxy is never null.
        ///  </returns>
        /// <exception name="RegistryNotExistException">Raised if the registry doesn't exist.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        global::Ice.ObjectPrx? getRegistryAdmin(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get a proxy to the IceGrid registry's admin object.
        /// </summary>
        /// <param name="name">The registry name
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<global::Ice.ObjectPrx?> getRegistryAdminAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Shutdown an IceGrid registry.
        /// </summary>
        /// <param name="name">The registry name.
        ///  </param>
        /// <exception name="RegistryNotExistException">Raised if the registry doesn't exist.
        ///  </exception>
        /// <exception name="RegistryUnreachableException">Raised if the registry could not be reached.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void shutdownRegistry(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Shutdown an IceGrid registry.
        /// </summary>
        /// <param name="name">The registry name.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task shutdownRegistryAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get all the IceGrid registries currently registered.
        /// </summary>
        /// <returns>The registry names.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        string[] getAllRegistryNames(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get all the IceGrid registries currently registered.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<string[]> getAllRegistryNamesAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Shut down the IceGrid registry.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void shutdown(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Shut down the IceGrid registry.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task shutdownAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }

    /// <summary>
    /// This interface provides access to IceGrid log file contents.
    /// </summary>

    public interface FileIteratorPrx : Ice.ObjectPrx
    {
        /// <summary>
        /// Read lines from the log file.
        /// </summary>
        /// <param name="size">Specifies the maximum number of bytes to be received. The server will ensure that the returned
        ///  message doesn't exceed the given size.
        ///  </param>
        /// <param name="lines">The lines read from the file. If there was nothing to read from the file since the last call to
        ///  read, an empty sequence is returned. The last line of the sequence is always incomplete (and therefore no
        ///  '\n' should be added when writing the last line to the to the output device).
        ///  </param>
        /// <returns>True if EOF is encountered.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if there was a problem to read lines from the file.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        bool read(int size, out string[] lines, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Read lines from the log file.
        /// </summary>
        /// <param name="size">Specifies the maximum number of bytes to be received. The server will ensure that the returned
        ///  message doesn't exceed the given size.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<FileIterator_ReadResult> readAsync(int size, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Destroy the iterator.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void destroy(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Destroy the iterator.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task destroyAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }

    /// <summary>
    /// This interface allows applications to monitor changes the state of the registry.
    /// </summary>

    public interface RegistryObserverPrx : Ice.ObjectPrx
    {
        /// <summary>
        /// The registryInit operation is called after registration of an observer to indicate the state of
        ///  the registries.
        /// </summary>
        /// <param name="registries">The current state of the registries.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void registryInit(RegistryInfo[] registries, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// The registryInit operation is called after registration of an observer to indicate the state of
        ///  the registries.
        /// </summary>
        /// <param name="registries">The current state of the registries.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task registryInitAsync(RegistryInfo[] registries, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// The registryUp operation is called to notify an observer that a registry replica came up.
        /// </summary>
        /// <param name="registryReplica">The registry state.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void registryUp(RegistryInfo registryReplica, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// The registryUp operation is called to notify an observer that a registry replica came up.
        /// </summary>
        /// <param name="registryReplica">The registry state.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task registryUpAsync(RegistryInfo registryReplica, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// The registryDown operation is called to notify an observer that a registry replica went down.
        /// </summary>
        /// <param name="name">The registry name.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void registryDown(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// The registryDown operation is called to notify an observer that a registry replica went down.
        /// </summary>
        /// <param name="name">The registry name.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task registryDownAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }

    /// <summary>
    /// The node observer interface.
    /// Observers should implement this interface to receive information about the state of
    ///  the IceGrid nodes.
    /// </summary>

    public interface NodeObserverPrx : Ice.ObjectPrx
    {
        /// <summary>
        /// The nodeInit operation indicates the current state of nodes.
        /// It is called after the
        ///  registration of an observer.
        /// </summary>
        ///  <param name="nodes">The current state of the nodes.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void nodeInit(NodeDynamicInfo[] nodes, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// The nodeInit operation indicates the current state of nodes.
        /// It is called after the
        /// </summary>
        ///  <param name="nodes">The current state of the nodes.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task nodeInitAsync(NodeDynamicInfo[] nodes, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// The nodeUp operation is called to notify an observer that a node came up.
        /// </summary>
        /// <param name="node">The node state.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void nodeUp(NodeDynamicInfo node, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// The nodeUp operation is called to notify an observer that a node came up.
        /// </summary>
        /// <param name="node">The node state.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task nodeUpAsync(NodeDynamicInfo node, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// The nodeDown operation is called to notify an observer that a node went down.
        /// </summary>
        /// <param name="name">The node name.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void nodeDown(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// The nodeDown operation is called to notify an observer that a node went down.
        /// </summary>
        /// <param name="name">The node name.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task nodeDownAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// The updateServer operation is called to notify an observer that the state of a server changed.
        /// </summary>
        /// <param name="node">The node hosting the server.
        ///  </param>
        /// <param name="updatedInfo">The new server state.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void updateServer(string node, ServerDynamicInfo updatedInfo, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// The updateServer operation is called to notify an observer that the state of a server changed.
        /// </summary>
        /// <param name="node">The node hosting the server.
        ///  </param>
        /// <param name="updatedInfo">The new server state.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task updateServerAsync(string node, ServerDynamicInfo updatedInfo, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// The updateAdapter operation is called to notify an observer that the state of an adapter
        ///  changed.
        /// </summary>
        /// <param name="node">The node hosting the adapter.
        ///  </param>
        /// <param name="updatedInfo">The new adapter state.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void updateAdapter(string node, AdapterDynamicInfo updatedInfo, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// The updateAdapter operation is called to notify an observer that the state of an adapter
        ///  changed.
        /// </summary>
        /// <param name="node">The node hosting the adapter.
        ///  </param>
        /// <param name="updatedInfo">The new adapter state.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task updateAdapterAsync(string node, AdapterDynamicInfo updatedInfo, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }

    /// <summary>
    /// The database observer interface.
    /// Observers should implement this interface to receive information about the
    ///  state of the IceGrid registry database.
    /// </summary>

    public interface ApplicationObserverPrx : Ice.ObjectPrx
    {
        /// <summary>
        /// applicationInit is called after the registration of an observer to indicate the state of the
        ///  registry.
        /// </summary>
        /// <param name="serial">The current serial number of the registry database. This serial number allows observers to
        ///  make sure that their internal state is synchronized with the registry.
        ///  </param>
        /// <param name="applications">The applications currently registered with the registry.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void applicationInit(int serial, ApplicationInfo[] applications, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// applicationInit is called after the registration of an observer to indicate the state of the
        ///  registry.
        /// </summary>
        /// <param name="serial">The current serial number of the registry database. This serial number allows observers to
        ///  make sure that their internal state is synchronized with the registry.
        ///  </param>
        /// <param name="applications">The applications currently registered with the registry.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task applicationInitAsync(int serial, ApplicationInfo[] applications, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// The applicationAdded operation is called to notify an observer that an application was added.
        /// </summary>
        /// <param name="serial">The new serial number of the registry database.
        ///  </param>
        /// <param name="desc">The descriptor of the new application.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void applicationAdded(int serial, ApplicationInfo desc, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// The applicationAdded operation is called to notify an observer that an application was added.
        /// </summary>
        /// <param name="serial">The new serial number of the registry database.
        ///  </param>
        /// <param name="desc">The descriptor of the new application.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task applicationAddedAsync(int serial, ApplicationInfo desc, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// The applicationRemoved operation is called to notify an observer that an application was
        ///  removed.
        /// </summary>
        /// <param name="serial">The new serial number of the registry database.
        ///  </param>
        /// <param name="name">The name of the application that was removed.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void applicationRemoved(int serial, string name, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// The applicationRemoved operation is called to notify an observer that an application was
        ///  removed.
        /// </summary>
        /// <param name="serial">The new serial number of the registry database.
        ///  </param>
        /// <param name="name">The name of the application that was removed.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task applicationRemovedAsync(int serial, string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// The applicationUpdated operation is called to notify an observer that an application was
        ///  updated.
        /// </summary>
        /// <param name="serial">The new serial number of the registry database.
        ///  </param>
        /// <param name="desc">The descriptor of the update.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void applicationUpdated(int serial, ApplicationUpdateInfo desc, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// The applicationUpdated operation is called to notify an observer that an application was
        ///  updated.
        /// </summary>
        /// <param name="serial">The new serial number of the registry database.
        ///  </param>
        /// <param name="desc">The descriptor of the update.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task applicationUpdatedAsync(int serial, ApplicationUpdateInfo desc, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }

    /// <summary>
    /// This interface allows applications to monitor the state of object adapters that are registered with IceGrid.
    /// </summary>

    public interface AdapterObserverPrx : Ice.ObjectPrx
    {
        /// <summary>
        /// adapterInit is called after registration of an observer to indicate the state of the registry.
        /// </summary>
        /// <param name="adpts">The adapters that were dynamically registered with the registry (not through the deployment
        ///  mechanism).</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void adapterInit(AdapterInfo[] adpts, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// adapterInit is called after registration of an observer to indicate the state of the registry.
        /// </summary>
        /// <param name="adpts">The adapters that were dynamically registered with the registry (not through the deployment
        ///  mechanism).</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task adapterInitAsync(AdapterInfo[] adpts, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// The adapterAdded operation is called to notify an observer when a dynamically-registered
        ///  adapter was added.
        /// </summary>
        /// <param name="info">The details of the new adapter.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void adapterAdded(AdapterInfo info, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// The adapterAdded operation is called to notify an observer when a dynamically-registered
        ///  adapter was added.
        /// </summary>
        /// <param name="info">The details of the new adapter.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task adapterAddedAsync(AdapterInfo info, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// The adapterUpdated operation is called to notify an observer when a dynamically-registered adapter was
        ///  updated.
        /// </summary>
        /// <param name="info">The details of the updated adapter.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void adapterUpdated(AdapterInfo info, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// The adapterUpdated operation is called to notify an observer when a dynamically-registered adapter was
        ///  updated.
        /// </summary>
        /// <param name="info">The details of the updated adapter.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task adapterUpdatedAsync(AdapterInfo info, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// The adapterRemoved operation is called to notify an observer when a dynamically-registered adapter was
        ///  removed.
        /// </summary>
        /// <param name="id">The ID of the removed adapter.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void adapterRemoved(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// The adapterRemoved operation is called to notify an observer when a dynamically-registered adapter was
        ///  removed.
        /// </summary>
        /// <param name="id">The ID of the removed adapter.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task adapterRemovedAsync(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }

    /// <summary>
    /// This interface allows applications to monitor IceGrid well-known objects.
    /// </summary>

    public interface ObjectObserverPrx : Ice.ObjectPrx
    {
        /// <summary>
        /// objectInit is called after the registration of an observer to indicate the state of the
        ///  registry.
        /// </summary>
        /// <param name="objects">The objects registered with the Admin interface (not through the deployment
        ///  mechanism).</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void objectInit(ObjectInfo[] objects, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// objectInit is called after the registration of an observer to indicate the state of the
        ///  registry.
        /// </summary>
        /// <param name="objects">The objects registered with the Admin interface (not through the deployment
        ///  mechanism).</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task objectInitAsync(ObjectInfo[] objects, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// The objectAdded operation is called to notify an observer when an object was added to the
        ///  Admin interface.
        /// </summary>
        /// <param name="info">The details of the added object.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void objectAdded(ObjectInfo info, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// The objectAdded operation is called to notify an observer when an object was added to the
        ///  Admin interface.
        /// </summary>
        /// <param name="info">The details of the added object.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task objectAddedAsync(ObjectInfo info, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// objectUpdated is called to notify an observer when an object registered with the Admin
        ///  interface was updated.
        /// </summary>
        /// <param name="info">The details of the updated object.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void objectUpdated(ObjectInfo info, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// objectUpdated is called to notify an observer when an object registered with the Admin
        ///  interface was updated.
        /// </summary>
        /// <param name="info">The details of the updated object.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task objectUpdatedAsync(ObjectInfo info, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// objectRemoved is called to notify an observer when an object registered with the Admin
        ///  interface was removed.
        /// </summary>
        /// <param name="id">The identity of the removed object.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void objectRemoved(global::Ice.Identity id, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// objectRemoved is called to notify an observer when an object registered with the Admin
        ///  interface was removed.
        /// </summary>
        /// <param name="id">The identity of the removed object.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task objectRemovedAsync(global::Ice.Identity id, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }

    /// <summary>
    /// Used by administrative clients to view, update, and receive observer updates from the IceGrid registry.
    /// Admin
    ///  sessions are created either via the Registry object or via the registry admin
    ///  SessionManager object.
    /// </summary>

    public interface AdminSessionPrx : global::Glacier2.SessionPrx
    {
        /// <summary>
        /// Keep the session alive.
        /// As of Ice 3.8, there is no need to call this operation, and its implementation does nothing.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        [global::System.Obsolete]
        void keepAlive(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Keep the session alive.
        /// As of Ice 3.8, there is no need to call this operation, and its implementation does nothing.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.Obsolete]
        global::System.Threading.Tasks.Task keepAliveAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get the admin interface.
        /// The admin object returned by this operation can only be accessed by the session.
        /// </summary>
        ///  <returns>The admin interface proxy. The returned proxy is never null.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        AdminPrx? getAdmin(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get the admin interface.
        /// The admin object returned by this operation can only be accessed by the session.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<AdminPrx?> getAdminAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get a "template" proxy for admin callback objects.
        /// An Admin client uses this proxy to set the category of
        ///  its callback objects, and the published endpoints of the object adapter hosting the admin callback objects.
        /// </summary>
        ///  <returns>A template proxy. The returned proxy is null when the Admin session was established using Glacier2.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        global::Ice.ObjectPrx? getAdminCallbackTemplate(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get a "template" proxy for admin callback objects.
        /// An Admin client uses this proxy to set the category of
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<global::Ice.ObjectPrx?> getAdminCallbackTemplateAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Set the observer proxies that receive notifications when the state of the registry or nodes changes.
        /// </summary>
        /// <param name="registryObs">The registry observer.
        ///  </param>
        /// <param name="nodeObs">The node observer.
        ///  </param>
        /// <param name="appObs">The application observer.
        ///  </param>
        /// <param name="adptObs">The adapter observer.
        ///  </param>
        /// <param name="objObs">The object observer.
        ///  </param>
        /// <exception name="ObserverAlreadyRegisteredException">Raised if an observer is already registered with this registry.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void setObservers(RegistryObserverPrx? registryObs, NodeObserverPrx? nodeObs, ApplicationObserverPrx? appObs, AdapterObserverPrx? adptObs, ObjectObserverPrx? objObs, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Set the observer proxies that receive notifications when the state of the registry or nodes changes.
        /// </summary>
        /// <param name="registryObs">The registry observer.
        ///  </param>
        /// <param name="nodeObs">The node observer.
        ///  </param>
        /// <param name="appObs">The application observer.
        ///  </param>
        /// <param name="adptObs">The adapter observer.
        ///  </param>
        /// <param name="objObs">The object observer.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task setObserversAsync(RegistryObserverPrx? registryObs, NodeObserverPrx? nodeObs, ApplicationObserverPrx? appObs, AdapterObserverPrx? adptObs, ObjectObserverPrx? objObs, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Set the observer identities that receive notifications the state of the registry or nodes changes.
        /// This
        ///  operation should be used by clients that are using a bidirectional connection to communicate with the
        ///  session.
        /// </summary>
        ///  <param name="registryObs">The registry observer identity.
        ///  </param>
        /// <param name="nodeObs">The node observer identity.
        ///  </param>
        /// <param name="appObs">The application observer.
        ///  </param>
        /// <param name="adptObs">The adapter observer.
        ///  </param>
        /// <param name="objObs">The object observer.
        ///  </param>
        /// <exception name="ObserverAlreadyRegisteredException">Raised if an observer is already registered with this registry.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void setObserversByIdentity(global::Ice.Identity registryObs, global::Ice.Identity nodeObs, global::Ice.Identity appObs, global::Ice.Identity adptObs, global::Ice.Identity objObs, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Set the observer identities that receive notifications the state of the registry or nodes changes.
        /// This
        /// </summary>
        ///  <param name="registryObs">The registry observer identity.
        ///  </param>
        /// <param name="nodeObs">The node observer identity.
        ///  </param>
        /// <param name="appObs">The application observer.
        ///  </param>
        /// <param name="adptObs">The adapter observer.
        ///  </param>
        /// <param name="objObs">The object observer.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task setObserversByIdentityAsync(global::Ice.Identity registryObs, global::Ice.Identity nodeObs, global::Ice.Identity appObs, global::Ice.Identity adptObs, global::Ice.Identity objObs, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Acquires an exclusive lock to start updating the registry applications.
        /// </summary>
        /// <returns>The current serial.
        ///  </returns>
        /// <exception name="AccessDeniedException">Raised if the exclusive lock can't be acquired. This might happen if the lock
        ///  is currently acquired by another session.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        int startUpdate(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Acquires an exclusive lock to start updating the registry applications.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<int> startUpdateAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Finish updating the registry and release the exclusive lock.
        /// </summary>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void finishUpdate(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Finish updating the registry and release the exclusive lock.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task finishUpdateAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Get the name of the registry replica hosting this session.
        /// </summary>
        /// <returns>The replica name of the registry.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        string getReplicaName(global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Get the name of the registry replica hosting this session.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<string> getReplicaNameAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Open the given server log file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <param name="path">The path of the log file. A log file can be opened only if it's declared in the server or
        ///  service deployment descriptor.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If
        ///  0 or positive, the file is read from the last count lines.
        ///  </param>
        /// <returns>An iterator to read the file. The returned proxy is never null.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if the file can't be read.
        ///  </exception>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        FileIteratorPrx? openServerLog(string id, string path, int count, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Open the given server log file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <param name="path">The path of the log file. A log file can be opened only if it's declared in the server or
        ///  service deployment descriptor.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If
        ///  0 or positive, the file is read from the last count lines.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<FileIteratorPrx?> openServerLogAsync(string id, string path, int count, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Open the given server stderr file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If
        ///  0 or positive, the file is read from the last count lines.
        ///  </param>
        /// <returns>An iterator to read the file. The returned proxy is never null.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if the file can't be read.
        ///  </exception>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        FileIteratorPrx? openServerStdErr(string id, int count, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Open the given server stderr file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If
        ///  0 or positive, the file is read from the last count lines.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<FileIteratorPrx?> openServerStdErrAsync(string id, int count, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Open the given server stdout file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining.
        ///  If 0 or positive, the file is read from the last count lines.
        ///  </param>
        /// <returns>An iterator to read the file. The returned proxy is never null.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if the file can't be read.
        ///  </exception>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        FileIteratorPrx? openServerStdOut(string id, int count, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Open the given server stdout file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining.
        ///  If 0 or positive, the file is read from the last count lines.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<FileIteratorPrx?> openServerStdOutAsync(string id, int count, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Open the given node stderr file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="name">The node name.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If
        ///  0 or positive, the file is read from the last count lines.
        ///  </param>
        /// <returns>An iterator to read the file. The returned proxy is never null.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if the file can't be read.
        ///  </exception>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        FileIteratorPrx? openNodeStdErr(string name, int count, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Open the given node stderr file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="name">The node name.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If
        ///  0 or positive, the file is read from the last count lines.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<FileIteratorPrx?> openNodeStdErrAsync(string name, int count, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Open the given node stdout file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="name">The node name.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If
        ///  0 or positive, the file is read from the last count lines.
        ///  </param>
        /// <returns>An iterator to read the file. The returned proxy is never null.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if the file can't be read.
        ///  </exception>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        FileIteratorPrx? openNodeStdOut(string name, int count, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Open the given node stdout file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="name">The node name.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If
        ///  0 or positive, the file is read from the last count lines.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<FileIteratorPrx?> openNodeStdOutAsync(string name, int count, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Open the given registry stderr file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="name">The registry name.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If
        ///  0 or positive, the file is read from the last count lines.
        ///  </param>
        /// <returns>An iterator to read the file. The returned proxy is never null.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if the file can't be read.
        ///  </exception>
        /// <exception name="RegistryNotExistException">Raised if the registry doesn't exist.
        ///  </exception>
        /// <exception name="RegistryUnreachableException">Raised if the registry could not be reached.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        FileIteratorPrx? openRegistryStdErr(string name, int count, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Open the given registry stderr file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="name">The registry name.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If
        ///  0 or positive, the file is read from the last count lines.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<FileIteratorPrx?> openRegistryStdErrAsync(string name, int count, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);

        /// <summary>
        /// Open the given registry stdout file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="name">The registry name.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If
        ///  0 or positive, the file is read from the last count lines.
        ///  </param>
        /// <returns>An iterator to read the file. The returned proxy is never null.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if the file can't be read.
        ///  </exception>
        /// <exception name="RegistryNotExistException">Raised if the registry doesn't exist.
        ///  </exception>
        /// <exception name="RegistryUnreachableException">Raised if the registry could not be reached.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        FileIteratorPrx? openRegistryStdOut(string name, int count, global::System.Collections.Generic.Dictionary<string, string>? context = null);

        /// <summary>
        /// Open the given registry stdout file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="name">The registry name.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If
        ///  0 or positive, the file is read from the last count lines.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<FileIteratorPrx?> openRegistryStdOutAsync(string name, int count, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default);
    }
}

namespace IceGrid
{
    public sealed class StringObjectProxyDictHelper
    {
        public static void write(Ice.OutputStream ostr,
                                 global::System.Collections.Generic.Dictionary<string, global::Ice.ObjectPrx?> v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Count);
                foreach(global::System.Collections.Generic.KeyValuePair<string, global::Ice.ObjectPrx?> e in v)
                {
                    ostr.writeString(e.Key);
                    ostr.writeProxy(e.Value);
                }
            }
        }

        public static global::System.Collections.Generic.Dictionary<string, global::Ice.ObjectPrx?> read(Ice.InputStream istr)
        {
            int sz = istr.readSize();
            global::System.Collections.Generic.Dictionary<string, global::Ice.ObjectPrx?> r = new global::System.Collections.Generic.Dictionary<string, global::Ice.ObjectPrx?>();
            for(int i = 0; i < sz; ++i)
            {
                string k;
                k = istr.readString();
                global::Ice.ObjectPrx? v;
                v = istr.readProxy();
                r[k] = v;
            }
            return r;
        }
    }

    public sealed class ObjectInfoSeqHelper
    {
        public static void write(Ice.OutputStream ostr, ObjectInfo[] v)
        {
            if (v is null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    v[ix].ice_writeMembers(ostr);
                }
            }
        }

        public static ObjectInfo[] read(Ice.InputStream istr)
        {
            ObjectInfo[] v;
            {
                int szx = istr.readAndCheckSeqSize(3);
                v = new ObjectInfo[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new ObjectInfo(istr);
                }
            }
            return v;
        }
    }

    public sealed class AdapterInfoSeqHelper
    {
        public static void write(Ice.OutputStream ostr, AdapterInfo[] v)
        {
            if (v is null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    v[ix].ice_writeMembers(ostr);
                }
            }
        }

        public static AdapterInfo[] read(Ice.InputStream istr)
        {
            AdapterInfo[] v;
            {
                int szx = istr.readAndCheckSeqSize(4);
                v = new AdapterInfo[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new AdapterInfo(istr);
                }
            }
            return v;
        }
    }

    public sealed class RegistryInfoSeqHelper
    {
        public static void write(Ice.OutputStream ostr, RegistryInfo[] v)
        {
            if (v is null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    v[ix].ice_writeMembers(ostr);
                }
            }
        }

        public static RegistryInfo[] read(Ice.InputStream istr)
        {
            RegistryInfo[] v;
            {
                int szx = istr.readAndCheckSeqSize(2);
                v = new RegistryInfo[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new RegistryInfo(istr);
                }
            }
            return v;
        }
    }

    public sealed class ApplicationInfoSeqHelper
    {
        public static void write(Ice.OutputStream ostr, ApplicationInfo[] v)
        {
            if (v is null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    v[ix].ice_writeMembers(ostr);
                }
            }
        }

        public static ApplicationInfo[] read(Ice.InputStream istr)
        {
            ApplicationInfo[] v;
            {
                int szx = istr.readAndCheckSeqSize(33);
                v = new ApplicationInfo[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new ApplicationInfo(istr);
                }
            }
            return v;
        }
    }

    public sealed class AdminPrxHelper : Ice.ObjectPrxHelperBase, AdminPrx
    {
        public void addApplication(ApplicationDescriptor descriptor, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_addApplicationAsync(descriptor, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void syncApplication(ApplicationDescriptor descriptor, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_syncApplicationAsync(descriptor, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void updateApplication(ApplicationUpdateDescriptor descriptor, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_updateApplicationAsync(descriptor, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void syncApplicationWithoutRestart(ApplicationDescriptor descriptor, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_syncApplicationWithoutRestartAsync(descriptor, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void updateApplicationWithoutRestart(ApplicationUpdateDescriptor descriptor, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_updateApplicationWithoutRestartAsync(descriptor, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void removeApplication(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_removeApplicationAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void instantiateServer(string application, string node, ServerInstanceDescriptor desc, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_instantiateServerAsync(application, node, desc, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public ApplicationInfo getApplicationInfo(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getApplicationInfoAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public ApplicationDescriptor getDefaultApplicationDescriptor(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getDefaultApplicationDescriptorAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public string[] getAllApplicationNames(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getAllApplicationNamesAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public ServerInfo getServerInfo(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getServerInfoAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public ServerState getServerState(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getServerStateAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public int getServerPid(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getServerPidAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public string getServerAdminCategory(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getServerAdminCategoryAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::Ice.ObjectPrx? getServerAdmin(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getServerAdminAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void enableServer(string id, bool enabled, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_enableServerAsync(id, enabled, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public bool isServerEnabled(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_isServerEnabledAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void startServer(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_startServerAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void stopServer(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_stopServerAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void sendSignal(string id, string signal, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_sendSignalAsync(id, signal, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public string[] getAllServerIds(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getAllServerIdsAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public AdapterInfo[] getAdapterInfo(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getAdapterInfoAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void removeAdapter(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_removeAdapterAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public string[] getAllAdapterIds(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getAllAdapterIdsAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void addObject(global::Ice.ObjectPrx? obj, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_addObjectAsync(obj, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void updateObject(global::Ice.ObjectPrx? obj, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_updateObjectAsync(obj, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void addObjectWithType(global::Ice.ObjectPrx? obj, string type, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_addObjectWithTypeAsync(obj, type, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void removeObject(global::Ice.Identity id, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_removeObjectAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public ObjectInfo getObjectInfo(global::Ice.Identity id, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getObjectInfoAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public ObjectInfo[] getObjectInfosByType(string type, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getObjectInfosByTypeAsync(type, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public ObjectInfo[] getAllObjectInfos(string expr, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getAllObjectInfosAsync(expr, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public bool pingNode(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_pingNodeAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public LoadInfo getNodeLoad(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getNodeLoadAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public NodeInfo getNodeInfo(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getNodeInfoAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::Ice.ObjectPrx? getNodeAdmin(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getNodeAdminAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public int getNodeProcessorSocketCount(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getNodeProcessorSocketCountAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void shutdownNode(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_shutdownNodeAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public string getNodeHostname(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getNodeHostnameAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public string[] getAllNodeNames(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getAllNodeNamesAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public bool pingRegistry(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_pingRegistryAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public RegistryInfo getRegistryInfo(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getRegistryInfoAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::Ice.ObjectPrx? getRegistryAdmin(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getRegistryAdminAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void shutdownRegistry(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_shutdownRegistryAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public string[] getAllRegistryNames(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getAllRegistryNamesAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void shutdown(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_shutdownAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task addApplicationAsync(ApplicationDescriptor descriptor, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_addApplicationAsync(descriptor, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_addApplicationAsync(ApplicationDescriptor iceP_descriptor, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_addApplication_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_addApplication(iceP_descriptor, context, synchronous, completed);
            return completed.Task;
        }

        private const string _addApplication_name = "addApplication";

        private void _iceI_addApplication(ApplicationDescriptor iceP_descriptor, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _addApplication_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ApplicationDescriptor.ice_write(ostr, iceP_descriptor);
                    ostr.writePendingValues();
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(AccessDeniedException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task syncApplicationAsync(ApplicationDescriptor descriptor, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_syncApplicationAsync(descriptor, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_syncApplicationAsync(ApplicationDescriptor iceP_descriptor, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_syncApplication_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_syncApplication(iceP_descriptor, context, synchronous, completed);
            return completed.Task;
        }

        private const string _syncApplication_name = "syncApplication";

        private void _iceI_syncApplication(ApplicationDescriptor iceP_descriptor, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _syncApplication_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ApplicationDescriptor.ice_write(ostr, iceP_descriptor);
                    ostr.writePendingValues();
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(AccessDeniedException)
                    {
                        throw;
                    }
                    catch(ApplicationNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task updateApplicationAsync(ApplicationUpdateDescriptor descriptor, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_updateApplicationAsync(descriptor, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_updateApplicationAsync(ApplicationUpdateDescriptor iceP_descriptor, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_updateApplication_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_updateApplication(iceP_descriptor, context, synchronous, completed);
            return completed.Task;
        }

        private const string _updateApplication_name = "updateApplication";

        private void _iceI_updateApplication(ApplicationUpdateDescriptor iceP_descriptor, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _updateApplication_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ApplicationUpdateDescriptor.ice_write(ostr, iceP_descriptor);
                    ostr.writePendingValues();
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(AccessDeniedException)
                    {
                        throw;
                    }
                    catch(ApplicationNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task syncApplicationWithoutRestartAsync(ApplicationDescriptor descriptor, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_syncApplicationWithoutRestartAsync(descriptor, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_syncApplicationWithoutRestartAsync(ApplicationDescriptor iceP_descriptor, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_syncApplicationWithoutRestart_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_syncApplicationWithoutRestart(iceP_descriptor, context, synchronous, completed);
            return completed.Task;
        }

        private const string _syncApplicationWithoutRestart_name = "syncApplicationWithoutRestart";

        private void _iceI_syncApplicationWithoutRestart(ApplicationDescriptor iceP_descriptor, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _syncApplicationWithoutRestart_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ApplicationDescriptor.ice_write(ostr, iceP_descriptor);
                    ostr.writePendingValues();
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(AccessDeniedException)
                    {
                        throw;
                    }
                    catch(ApplicationNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task updateApplicationWithoutRestartAsync(ApplicationUpdateDescriptor descriptor, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_updateApplicationWithoutRestartAsync(descriptor, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_updateApplicationWithoutRestartAsync(ApplicationUpdateDescriptor iceP_descriptor, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_updateApplicationWithoutRestart_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_updateApplicationWithoutRestart(iceP_descriptor, context, synchronous, completed);
            return completed.Task;
        }

        private const string _updateApplicationWithoutRestart_name = "updateApplicationWithoutRestart";

        private void _iceI_updateApplicationWithoutRestart(ApplicationUpdateDescriptor iceP_descriptor, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _updateApplicationWithoutRestart_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ApplicationUpdateDescriptor.ice_write(ostr, iceP_descriptor);
                    ostr.writePendingValues();
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(AccessDeniedException)
                    {
                        throw;
                    }
                    catch(ApplicationNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task removeApplicationAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_removeApplicationAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_removeApplicationAsync(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_removeApplication_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_removeApplication(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _removeApplication_name = "removeApplication";

        private void _iceI_removeApplication(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _removeApplication_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(AccessDeniedException)
                    {
                        throw;
                    }
                    catch(ApplicationNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task instantiateServerAsync(string application, string node, ServerInstanceDescriptor desc, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_instantiateServerAsync(application, node, desc, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_instantiateServerAsync(string iceP_application, string iceP_node, ServerInstanceDescriptor iceP_desc, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_instantiateServer_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_instantiateServer(iceP_application, iceP_node, iceP_desc, context, synchronous, completed);
            return completed.Task;
        }

        private const string _instantiateServer_name = "instantiateServer";

        private void _iceI_instantiateServer(string iceP_application, string iceP_node, ServerInstanceDescriptor iceP_desc, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _instantiateServer_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_application);
                    ostr.writeString(iceP_node);
                    ServerInstanceDescriptor.ice_write(ostr, iceP_desc);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(AccessDeniedException)
                    {
                        throw;
                    }
                    catch(ApplicationNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<ApplicationInfo> getApplicationInfoAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getApplicationInfoAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<ApplicationInfo> _iceI_getApplicationInfoAsync(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getApplicationInfo_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<ApplicationInfo>(progress, cancel);
            _iceI_getApplicationInfo(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getApplicationInfo_name = "getApplicationInfo";

        private void _iceI_getApplicationInfo(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<ApplicationInfo>(completed);
            outAsync.invoke(
                _getApplicationInfo_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ApplicationNotExistException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    ApplicationInfo ret;
                    ret = new ApplicationInfo(istr);
                    istr.readPendingValues();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<ApplicationDescriptor> getDefaultApplicationDescriptorAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getDefaultApplicationDescriptorAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<ApplicationDescriptor> _iceI_getDefaultApplicationDescriptorAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getDefaultApplicationDescriptor_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<ApplicationDescriptor>(progress, cancel);
            _iceI_getDefaultApplicationDescriptor(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getDefaultApplicationDescriptor_name = "getDefaultApplicationDescriptor";

        private void _iceI_getDefaultApplicationDescriptor(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<ApplicationDescriptor>(completed);
            outAsync.invoke(
                _getDefaultApplicationDescriptor_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    ApplicationDescriptor ret;
                    ret = new ApplicationDescriptor(istr);
                    istr.readPendingValues();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<string[]> getAllApplicationNamesAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getAllApplicationNamesAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<string[]> _iceI_getAllApplicationNamesAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getAllApplicationNames_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<string[]>(progress, cancel);
            _iceI_getAllApplicationNames(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getAllApplicationNames_name = "getAllApplicationNames";

        private void _iceI_getAllApplicationNames(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<string[]>(completed);
            outAsync.invoke(
                _getAllApplicationNames_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    string[] ret;
                    ret = global::Ice.StringSeqHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<ServerInfo> getServerInfoAsync(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getServerInfoAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<ServerInfo> _iceI_getServerInfoAsync(string iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getServerInfo_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<ServerInfo>(progress, cancel);
            _iceI_getServerInfo(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getServerInfo_name = "getServerInfo";

        private void _iceI_getServerInfo(string iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<ServerInfo>(completed);
            outAsync.invoke(
                _getServerInfo_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ServerNotExistException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    ServerInfo ret;
                    ret = new ServerInfo(istr);
                    istr.readPendingValues();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<ServerState> getServerStateAsync(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getServerStateAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<ServerState> _iceI_getServerStateAsync(string iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getServerState_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<ServerState>(progress, cancel);
            _iceI_getServerState(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getServerState_name = "getServerState";

        private void _iceI_getServerState(string iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<ServerState>(completed);
            outAsync.invoke(
                _getServerState_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ServerNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    ServerState ret;
                    ret = (ServerState)istr.readEnum(6);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<int> getServerPidAsync(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getServerPidAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<int> _iceI_getServerPidAsync(string iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getServerPid_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<int>(progress, cancel);
            _iceI_getServerPid(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getServerPid_name = "getServerPid";

        private void _iceI_getServerPid(string iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<int>(completed);
            outAsync.invoke(
                _getServerPid_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ServerNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    int ret;
                    ret = istr.readInt();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<string> getServerAdminCategoryAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getServerAdminCategoryAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<string> _iceI_getServerAdminCategoryAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getServerAdminCategory_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<string>(progress, cancel);
            _iceI_getServerAdminCategory(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getServerAdminCategory_name = "getServerAdminCategory";

        private void _iceI_getServerAdminCategory(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<string>(completed);
            outAsync.invoke(
                _getServerAdminCategory_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    string ret;
                    ret = istr.readString();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<global::Ice.ObjectPrx?> getServerAdminAsync(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getServerAdminAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<global::Ice.ObjectPrx?> _iceI_getServerAdminAsync(string iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getServerAdmin_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<global::Ice.ObjectPrx?>(progress, cancel);
            _iceI_getServerAdmin(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getServerAdmin_name = "getServerAdmin";

        private void _iceI_getServerAdmin(string iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<global::Ice.ObjectPrx?>(completed);
            outAsync.invoke(
                _getServerAdmin_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ServerNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    global::Ice.ObjectPrx? ret;
                    ret = istr.readProxy();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task enableServerAsync(string id, bool enabled, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_enableServerAsync(id, enabled, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_enableServerAsync(string iceP_id, bool iceP_enabled, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_enableServer_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_enableServer(iceP_id, iceP_enabled, context, synchronous, completed);
            return completed.Task;
        }

        private const string _enableServer_name = "enableServer";

        private void _iceI_enableServer(string iceP_id, bool iceP_enabled, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _enableServer_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                    ostr.writeBool(iceP_enabled);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ServerNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<bool> isServerEnabledAsync(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_isServerEnabledAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<bool> _iceI_isServerEnabledAsync(string iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_isServerEnabled_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<bool>(progress, cancel);
            _iceI_isServerEnabled(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _isServerEnabled_name = "isServerEnabled";

        private void _iceI_isServerEnabled(string iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<bool>(completed);
            outAsync.invoke(
                _isServerEnabled_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ServerNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    bool ret;
                    ret = istr.readBool();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task startServerAsync(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_startServerAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_startServerAsync(string iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_startServer_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_startServer(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _startServer_name = "startServer";

        private void _iceI_startServer(string iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _startServer_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ServerNotExistException)
                    {
                        throw;
                    }
                    catch(ServerStartException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task stopServerAsync(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_stopServerAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_stopServerAsync(string iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_stopServer_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_stopServer(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _stopServer_name = "stopServer";

        private void _iceI_stopServer(string iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _stopServer_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ServerNotExistException)
                    {
                        throw;
                    }
                    catch(ServerStopException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task sendSignalAsync(string id, string signal, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_sendSignalAsync(id, signal, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_sendSignalAsync(string iceP_id, string iceP_signal, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_sendSignal_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_sendSignal(iceP_id, iceP_signal, context, synchronous, completed);
            return completed.Task;
        }

        private const string _sendSignal_name = "sendSignal";

        private void _iceI_sendSignal(string iceP_id, string iceP_signal, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _sendSignal_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                    ostr.writeString(iceP_signal);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(BadSignalException)
                    {
                        throw;
                    }
                    catch(ServerNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<string[]> getAllServerIdsAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getAllServerIdsAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<string[]> _iceI_getAllServerIdsAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getAllServerIds_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<string[]>(progress, cancel);
            _iceI_getAllServerIds(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getAllServerIds_name = "getAllServerIds";

        private void _iceI_getAllServerIds(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<string[]>(completed);
            outAsync.invoke(
                _getAllServerIds_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    string[] ret;
                    ret = global::Ice.StringSeqHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<AdapterInfo[]> getAdapterInfoAsync(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getAdapterInfoAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<AdapterInfo[]> _iceI_getAdapterInfoAsync(string iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getAdapterInfo_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<AdapterInfo[]>(progress, cancel);
            _iceI_getAdapterInfo(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getAdapterInfo_name = "getAdapterInfo";

        private void _iceI_getAdapterInfo(string iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<AdapterInfo[]>(completed);
            outAsync.invoke(
                _getAdapterInfo_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(AdapterNotExistException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    AdapterInfo[] ret;
                    ret = AdapterInfoSeqHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task removeAdapterAsync(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_removeAdapterAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_removeAdapterAsync(string iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_removeAdapter_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_removeAdapter(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _removeAdapter_name = "removeAdapter";

        private void _iceI_removeAdapter(string iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _removeAdapter_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(AdapterNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<string[]> getAllAdapterIdsAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getAllAdapterIdsAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<string[]> _iceI_getAllAdapterIdsAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getAllAdapterIds_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<string[]>(progress, cancel);
            _iceI_getAllAdapterIds(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getAllAdapterIds_name = "getAllAdapterIds";

        private void _iceI_getAllAdapterIds(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<string[]>(completed);
            outAsync.invoke(
                _getAllAdapterIds_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    string[] ret;
                    ret = global::Ice.StringSeqHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task addObjectAsync(global::Ice.ObjectPrx? obj, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_addObjectAsync(obj, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_addObjectAsync(global::Ice.ObjectPrx? iceP_obj, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_addObject_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_addObject(iceP_obj, context, synchronous, completed);
            return completed.Task;
        }

        private const string _addObject_name = "addObject";

        private void _iceI_addObject(global::Ice.ObjectPrx? iceP_obj, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _addObject_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeProxy(iceP_obj);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ObjectExistsException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task updateObjectAsync(global::Ice.ObjectPrx? obj, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_updateObjectAsync(obj, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_updateObjectAsync(global::Ice.ObjectPrx? iceP_obj, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_updateObject_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_updateObject(iceP_obj, context, synchronous, completed);
            return completed.Task;
        }

        private const string _updateObject_name = "updateObject";

        private void _iceI_updateObject(global::Ice.ObjectPrx? iceP_obj, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _updateObject_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeProxy(iceP_obj);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ObjectNotRegisteredException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task addObjectWithTypeAsync(global::Ice.ObjectPrx? obj, string type, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_addObjectWithTypeAsync(obj, type, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_addObjectWithTypeAsync(global::Ice.ObjectPrx? iceP_obj, string iceP_type, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_addObjectWithType_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_addObjectWithType(iceP_obj, iceP_type, context, synchronous, completed);
            return completed.Task;
        }

        private const string _addObjectWithType_name = "addObjectWithType";

        private void _iceI_addObjectWithType(global::Ice.ObjectPrx? iceP_obj, string iceP_type, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _addObjectWithType_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeProxy(iceP_obj);
                    ostr.writeString(iceP_type);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ObjectExistsException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task removeObjectAsync(global::Ice.Identity id, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_removeObjectAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_removeObjectAsync(global::Ice.Identity iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_removeObject_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_removeObject(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _removeObject_name = "removeObject";

        private void _iceI_removeObject(global::Ice.Identity iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _removeObject_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    global::Ice.Identity.ice_write(ostr, iceP_id);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ObjectNotRegisteredException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<ObjectInfo> getObjectInfoAsync(global::Ice.Identity id, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getObjectInfoAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<ObjectInfo> _iceI_getObjectInfoAsync(global::Ice.Identity iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getObjectInfo_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<ObjectInfo>(progress, cancel);
            _iceI_getObjectInfo(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getObjectInfo_name = "getObjectInfo";

        private void _iceI_getObjectInfo(global::Ice.Identity iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<ObjectInfo>(completed);
            outAsync.invoke(
                _getObjectInfo_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    global::Ice.Identity.ice_write(ostr, iceP_id);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ObjectNotRegisteredException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    ObjectInfo ret;
                    ret = new ObjectInfo(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<ObjectInfo[]> getObjectInfosByTypeAsync(string type, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getObjectInfosByTypeAsync(type, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<ObjectInfo[]> _iceI_getObjectInfosByTypeAsync(string iceP_type, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getObjectInfosByType_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<ObjectInfo[]>(progress, cancel);
            _iceI_getObjectInfosByType(iceP_type, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getObjectInfosByType_name = "getObjectInfosByType";

        private void _iceI_getObjectInfosByType(string iceP_type, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<ObjectInfo[]>(completed);
            outAsync.invoke(
                _getObjectInfosByType_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_type);
                },
                read: (Ice.InputStream istr) =>
                {
                    ObjectInfo[] ret;
                    ret = ObjectInfoSeqHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<ObjectInfo[]> getAllObjectInfosAsync(string expr, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getAllObjectInfosAsync(expr, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<ObjectInfo[]> _iceI_getAllObjectInfosAsync(string iceP_expr, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getAllObjectInfos_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<ObjectInfo[]>(progress, cancel);
            _iceI_getAllObjectInfos(iceP_expr, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getAllObjectInfos_name = "getAllObjectInfos";

        private void _iceI_getAllObjectInfos(string iceP_expr, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<ObjectInfo[]>(completed);
            outAsync.invoke(
                _getAllObjectInfos_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_expr);
                },
                read: (Ice.InputStream istr) =>
                {
                    ObjectInfo[] ret;
                    ret = ObjectInfoSeqHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<bool> pingNodeAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_pingNodeAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<bool> _iceI_pingNodeAsync(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_pingNode_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<bool>(progress, cancel);
            _iceI_pingNode(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _pingNode_name = "pingNode";

        private void _iceI_pingNode(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<bool>(completed);
            outAsync.invoke(
                _pingNode_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(NodeNotExistException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    bool ret;
                    ret = istr.readBool();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<LoadInfo> getNodeLoadAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getNodeLoadAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<LoadInfo> _iceI_getNodeLoadAsync(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getNodeLoad_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<LoadInfo>(progress, cancel);
            _iceI_getNodeLoad(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getNodeLoad_name = "getNodeLoad";

        private void _iceI_getNodeLoad(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<LoadInfo>(completed);
            outAsync.invoke(
                _getNodeLoad_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(NodeNotExistException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    LoadInfo ret;
                    ret = new LoadInfo(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<NodeInfo> getNodeInfoAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getNodeInfoAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<NodeInfo> _iceI_getNodeInfoAsync(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getNodeInfo_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<NodeInfo>(progress, cancel);
            _iceI_getNodeInfo(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getNodeInfo_name = "getNodeInfo";

        private void _iceI_getNodeInfo(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<NodeInfo>(completed);
            outAsync.invoke(
                _getNodeInfo_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(NodeNotExistException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    NodeInfo ret;
                    ret = new NodeInfo(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<global::Ice.ObjectPrx?> getNodeAdminAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getNodeAdminAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<global::Ice.ObjectPrx?> _iceI_getNodeAdminAsync(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getNodeAdmin_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<global::Ice.ObjectPrx?>(progress, cancel);
            _iceI_getNodeAdmin(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getNodeAdmin_name = "getNodeAdmin";

        private void _iceI_getNodeAdmin(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<global::Ice.ObjectPrx?>(completed);
            outAsync.invoke(
                _getNodeAdmin_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(NodeNotExistException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    global::Ice.ObjectPrx? ret;
                    ret = istr.readProxy();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<int> getNodeProcessorSocketCountAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getNodeProcessorSocketCountAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<int> _iceI_getNodeProcessorSocketCountAsync(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getNodeProcessorSocketCount_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<int>(progress, cancel);
            _iceI_getNodeProcessorSocketCount(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getNodeProcessorSocketCount_name = "getNodeProcessorSocketCount";

        private void _iceI_getNodeProcessorSocketCount(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<int>(completed);
            outAsync.invoke(
                _getNodeProcessorSocketCount_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(NodeNotExistException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    int ret;
                    ret = istr.readInt();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task shutdownNodeAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_shutdownNodeAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_shutdownNodeAsync(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_shutdownNode_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_shutdownNode(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _shutdownNode_name = "shutdownNode";

        private void _iceI_shutdownNode(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _shutdownNode_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(NodeNotExistException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<string> getNodeHostnameAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getNodeHostnameAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<string> _iceI_getNodeHostnameAsync(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getNodeHostname_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<string>(progress, cancel);
            _iceI_getNodeHostname(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getNodeHostname_name = "getNodeHostname";

        private void _iceI_getNodeHostname(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<string>(completed);
            outAsync.invoke(
                _getNodeHostname_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(NodeNotExistException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    string ret;
                    ret = istr.readString();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<string[]> getAllNodeNamesAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getAllNodeNamesAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<string[]> _iceI_getAllNodeNamesAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getAllNodeNames_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<string[]>(progress, cancel);
            _iceI_getAllNodeNames(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getAllNodeNames_name = "getAllNodeNames";

        private void _iceI_getAllNodeNames(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<string[]>(completed);
            outAsync.invoke(
                _getAllNodeNames_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    string[] ret;
                    ret = global::Ice.StringSeqHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<bool> pingRegistryAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_pingRegistryAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<bool> _iceI_pingRegistryAsync(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_pingRegistry_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<bool>(progress, cancel);
            _iceI_pingRegistry(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _pingRegistry_name = "pingRegistry";

        private void _iceI_pingRegistry(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<bool>(completed);
            outAsync.invoke(
                _pingRegistry_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(RegistryNotExistException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    bool ret;
                    ret = istr.readBool();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<RegistryInfo> getRegistryInfoAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getRegistryInfoAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<RegistryInfo> _iceI_getRegistryInfoAsync(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getRegistryInfo_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<RegistryInfo>(progress, cancel);
            _iceI_getRegistryInfo(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getRegistryInfo_name = "getRegistryInfo";

        private void _iceI_getRegistryInfo(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<RegistryInfo>(completed);
            outAsync.invoke(
                _getRegistryInfo_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(RegistryUnreachableException)
                    {
                        throw;
                    }
                    catch(RegistryNotExistException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    RegistryInfo ret;
                    ret = new RegistryInfo(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<global::Ice.ObjectPrx?> getRegistryAdminAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getRegistryAdminAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<global::Ice.ObjectPrx?> _iceI_getRegistryAdminAsync(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getRegistryAdmin_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<global::Ice.ObjectPrx?>(progress, cancel);
            _iceI_getRegistryAdmin(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getRegistryAdmin_name = "getRegistryAdmin";

        private void _iceI_getRegistryAdmin(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<global::Ice.ObjectPrx?>(completed);
            outAsync.invoke(
                _getRegistryAdmin_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(RegistryNotExistException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    global::Ice.ObjectPrx? ret;
                    ret = istr.readProxy();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task shutdownRegistryAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_shutdownRegistryAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_shutdownRegistryAsync(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_shutdownRegistry_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_shutdownRegistry(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _shutdownRegistry_name = "shutdownRegistry";

        private void _iceI_shutdownRegistry(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _shutdownRegistry_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(RegistryUnreachableException)
                    {
                        throw;
                    }
                    catch(RegistryNotExistException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<string[]> getAllRegistryNamesAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getAllRegistryNamesAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<string[]> _iceI_getAllRegistryNamesAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getAllRegistryNames_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<string[]>(progress, cancel);
            _iceI_getAllRegistryNames(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getAllRegistryNames_name = "getAllRegistryNames";

        private void _iceI_getAllRegistryNames(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<string[]>(completed);
            outAsync.invoke(
                _getAllRegistryNames_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    string[] ret;
                    ret = global::Ice.StringSeqHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task shutdownAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_shutdownAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_shutdownAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_shutdown(context, synchronous, completed);
            return completed.Task;
        }

        private const string _shutdown_name = "shutdown";

        private void _iceI_shutdown(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _shutdown_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous);
        }

        public static AdminPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new AdminPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static AdminPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new AdminPrxHelper(b) : null;

        public static AdminPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static AdminPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new AdminPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static AdminPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::Admin"
        };

        public static string ice_staticId() => "::IceGrid::Admin";

        public static void write(Ice.OutputStream ostr, AdminPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static AdminPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new AdminPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new AdminPrxHelper(reference);

        private AdminPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private AdminPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }

    public sealed class FileIteratorPrxHelper : Ice.ObjectPrxHelperBase, FileIteratorPrx
    {
        public bool read(int size, out string[] lines, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                var result_ = _iceI_readAsync(size, context, null, global::System.Threading.CancellationToken.None, true).Result;
                lines = result_.lines;
                return result_.returnValue;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void destroy(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_destroyAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task<FileIterator_ReadResult> readAsync(int size, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_readAsync(size, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<FileIterator_ReadResult> _iceI_readAsync(int iceP_size, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_read_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<FileIterator_ReadResult>(progress, cancel);
            _iceI_read(iceP_size, context, synchronous, completed);
            return completed.Task;
        }

        private const string _read_name = "read";

        private void _iceI_read(int iceP_size, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<FileIterator_ReadResult>(completed);
            outAsync.invoke(
                _read_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_size);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(FileNotAvailableException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    var ret = new FileIterator_ReadResult();
                    ret.lines = global::Ice.StringSeqHelper.read(istr);
                    ret.returnValue = istr.readBool();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task destroyAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_destroyAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_destroyAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_destroy(context, synchronous, completed);
            return completed.Task;
        }

        private const string _destroy_name = "destroy";

        private void _iceI_destroy(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _destroy_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous);
        }

        public static FileIteratorPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new FileIteratorPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static FileIteratorPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new FileIteratorPrxHelper(b) : null;

        public static FileIteratorPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static FileIteratorPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new FileIteratorPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static FileIteratorPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::FileIterator"
        };

        public static string ice_staticId() => "::IceGrid::FileIterator";

        public static void write(Ice.OutputStream ostr, FileIteratorPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static FileIteratorPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new FileIteratorPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new FileIteratorPrxHelper(reference);

        private FileIteratorPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private FileIteratorPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }

    public sealed class ServerDynamicInfoSeqHelper
    {
        public static void write(Ice.OutputStream ostr, ServerDynamicInfo[] v)
        {
            if (v is null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    v[ix].ice_writeMembers(ostr);
                }
            }
        }

        public static ServerDynamicInfo[] read(Ice.InputStream istr)
        {
            ServerDynamicInfo[] v;
            {
                int szx = istr.readAndCheckSeqSize(7);
                v = new ServerDynamicInfo[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new ServerDynamicInfo(istr);
                }
            }
            return v;
        }
    }

    public sealed class AdapterDynamicInfoSeqHelper
    {
        public static void write(Ice.OutputStream ostr, AdapterDynamicInfo[] v)
        {
            if (v is null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    v[ix].ice_writeMembers(ostr);
                }
            }
        }

        public static AdapterDynamicInfo[] read(Ice.InputStream istr)
        {
            AdapterDynamicInfo[] v;
            {
                int szx = istr.readAndCheckSeqSize(3);
                v = new AdapterDynamicInfo[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new AdapterDynamicInfo(istr);
                }
            }
            return v;
        }
    }

    public sealed class RegistryObserverPrxHelper : Ice.ObjectPrxHelperBase, RegistryObserverPrx
    {
        public void registryInit(RegistryInfo[] registries, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_registryInitAsync(registries, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void registryUp(RegistryInfo registryReplica, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_registryUpAsync(registryReplica, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void registryDown(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_registryDownAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task registryInitAsync(RegistryInfo[] registries, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_registryInitAsync(registries, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_registryInitAsync(RegistryInfo[] iceP_registries, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_registryInit(iceP_registries, context, synchronous, completed);
            return completed.Task;
        }

        private const string _registryInit_name = "registryInit";

        private void _iceI_registryInit(RegistryInfo[] iceP_registries, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _registryInit_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    RegistryInfoSeqHelper.write(ostr, iceP_registries);
                });
        }

        public global::System.Threading.Tasks.Task registryUpAsync(RegistryInfo registryReplica, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_registryUpAsync(registryReplica, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_registryUpAsync(RegistryInfo iceP_registryReplica, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_registryUp(iceP_registryReplica, context, synchronous, completed);
            return completed.Task;
        }

        private const string _registryUp_name = "registryUp";

        private void _iceI_registryUp(RegistryInfo iceP_registryReplica, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _registryUp_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    RegistryInfo.ice_write(ostr, iceP_registryReplica);
                });
        }

        public global::System.Threading.Tasks.Task registryDownAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_registryDownAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_registryDownAsync(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_registryDown(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _registryDown_name = "registryDown";

        private void _iceI_registryDown(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _registryDown_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                });
        }

        public static RegistryObserverPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new RegistryObserverPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static RegistryObserverPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new RegistryObserverPrxHelper(b) : null;

        public static RegistryObserverPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static RegistryObserverPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new RegistryObserverPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static RegistryObserverPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::RegistryObserver"
        };

        public static string ice_staticId() => "::IceGrid::RegistryObserver";

        public static void write(Ice.OutputStream ostr, RegistryObserverPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static RegistryObserverPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new RegistryObserverPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new RegistryObserverPrxHelper(reference);

        private RegistryObserverPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private RegistryObserverPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }

    public sealed class NodeDynamicInfoSeqHelper
    {
        public static void write(Ice.OutputStream ostr, NodeDynamicInfo[] v)
        {
            if (v is null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    v[ix].ice_writeMembers(ostr);
                }
            }
        }

        public static NodeDynamicInfo[] read(Ice.InputStream istr)
        {
            NodeDynamicInfo[] v;
            {
                int szx = istr.readAndCheckSeqSize(13);
                v = new NodeDynamicInfo[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new NodeDynamicInfo(istr);
                }
            }
            return v;
        }
    }

    public sealed class NodeObserverPrxHelper : Ice.ObjectPrxHelperBase, NodeObserverPrx
    {
        public void nodeInit(NodeDynamicInfo[] nodes, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_nodeInitAsync(nodes, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void nodeUp(NodeDynamicInfo node, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_nodeUpAsync(node, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void nodeDown(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_nodeDownAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void updateServer(string node, ServerDynamicInfo updatedInfo, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_updateServerAsync(node, updatedInfo, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void updateAdapter(string node, AdapterDynamicInfo updatedInfo, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_updateAdapterAsync(node, updatedInfo, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task nodeInitAsync(NodeDynamicInfo[] nodes, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_nodeInitAsync(nodes, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_nodeInitAsync(NodeDynamicInfo[] iceP_nodes, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_nodeInit(iceP_nodes, context, synchronous, completed);
            return completed.Task;
        }

        private const string _nodeInit_name = "nodeInit";

        private void _iceI_nodeInit(NodeDynamicInfo[] iceP_nodes, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _nodeInit_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    NodeDynamicInfoSeqHelper.write(ostr, iceP_nodes);
                });
        }

        public global::System.Threading.Tasks.Task nodeUpAsync(NodeDynamicInfo node, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_nodeUpAsync(node, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_nodeUpAsync(NodeDynamicInfo iceP_node, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_nodeUp(iceP_node, context, synchronous, completed);
            return completed.Task;
        }

        private const string _nodeUp_name = "nodeUp";

        private void _iceI_nodeUp(NodeDynamicInfo iceP_node, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _nodeUp_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    NodeDynamicInfo.ice_write(ostr, iceP_node);
                });
        }

        public global::System.Threading.Tasks.Task nodeDownAsync(string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_nodeDownAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_nodeDownAsync(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_nodeDown(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _nodeDown_name = "nodeDown";

        private void _iceI_nodeDown(string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _nodeDown_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                });
        }

        public global::System.Threading.Tasks.Task updateServerAsync(string node, ServerDynamicInfo updatedInfo, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_updateServerAsync(node, updatedInfo, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_updateServerAsync(string iceP_node, ServerDynamicInfo iceP_updatedInfo, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_updateServer(iceP_node, iceP_updatedInfo, context, synchronous, completed);
            return completed.Task;
        }

        private const string _updateServer_name = "updateServer";

        private void _iceI_updateServer(string iceP_node, ServerDynamicInfo iceP_updatedInfo, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _updateServer_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_node);
                    ServerDynamicInfo.ice_write(ostr, iceP_updatedInfo);
                });
        }

        public global::System.Threading.Tasks.Task updateAdapterAsync(string node, AdapterDynamicInfo updatedInfo, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_updateAdapterAsync(node, updatedInfo, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_updateAdapterAsync(string iceP_node, AdapterDynamicInfo iceP_updatedInfo, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_updateAdapter(iceP_node, iceP_updatedInfo, context, synchronous, completed);
            return completed.Task;
        }

        private const string _updateAdapter_name = "updateAdapter";

        private void _iceI_updateAdapter(string iceP_node, AdapterDynamicInfo iceP_updatedInfo, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _updateAdapter_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_node);
                    AdapterDynamicInfo.ice_write(ostr, iceP_updatedInfo);
                });
        }

        public static NodeObserverPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new NodeObserverPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static NodeObserverPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new NodeObserverPrxHelper(b) : null;

        public static NodeObserverPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static NodeObserverPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new NodeObserverPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static NodeObserverPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::NodeObserver"
        };

        public static string ice_staticId() => "::IceGrid::NodeObserver";

        public static void write(Ice.OutputStream ostr, NodeObserverPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static NodeObserverPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new NodeObserverPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new NodeObserverPrxHelper(reference);

        private NodeObserverPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private NodeObserverPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }

    public sealed class ApplicationObserverPrxHelper : Ice.ObjectPrxHelperBase, ApplicationObserverPrx
    {
        public void applicationInit(int serial, ApplicationInfo[] applications, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_applicationInitAsync(serial, applications, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void applicationAdded(int serial, ApplicationInfo desc, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_applicationAddedAsync(serial, desc, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void applicationRemoved(int serial, string name, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_applicationRemovedAsync(serial, name, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void applicationUpdated(int serial, ApplicationUpdateInfo desc, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_applicationUpdatedAsync(serial, desc, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task applicationInitAsync(int serial, ApplicationInfo[] applications, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_applicationInitAsync(serial, applications, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_applicationInitAsync(int iceP_serial, ApplicationInfo[] iceP_applications, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_applicationInit(iceP_serial, iceP_applications, context, synchronous, completed);
            return completed.Task;
        }

        private const string _applicationInit_name = "applicationInit";

        private void _iceI_applicationInit(int iceP_serial, ApplicationInfo[] iceP_applications, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _applicationInit_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_serial);
                    ApplicationInfoSeqHelper.write(ostr, iceP_applications);
                    ostr.writePendingValues();
                });
        }

        public global::System.Threading.Tasks.Task applicationAddedAsync(int serial, ApplicationInfo desc, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_applicationAddedAsync(serial, desc, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_applicationAddedAsync(int iceP_serial, ApplicationInfo iceP_desc, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_applicationAdded(iceP_serial, iceP_desc, context, synchronous, completed);
            return completed.Task;
        }

        private const string _applicationAdded_name = "applicationAdded";

        private void _iceI_applicationAdded(int iceP_serial, ApplicationInfo iceP_desc, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _applicationAdded_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_serial);
                    ApplicationInfo.ice_write(ostr, iceP_desc);
                    ostr.writePendingValues();
                });
        }

        public global::System.Threading.Tasks.Task applicationRemovedAsync(int serial, string name, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_applicationRemovedAsync(serial, name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_applicationRemovedAsync(int iceP_serial, string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_applicationRemoved(iceP_serial, iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _applicationRemoved_name = "applicationRemoved";

        private void _iceI_applicationRemoved(int iceP_serial, string iceP_name, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _applicationRemoved_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_serial);
                    ostr.writeString(iceP_name);
                });
        }

        public global::System.Threading.Tasks.Task applicationUpdatedAsync(int serial, ApplicationUpdateInfo desc, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_applicationUpdatedAsync(serial, desc, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_applicationUpdatedAsync(int iceP_serial, ApplicationUpdateInfo iceP_desc, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_applicationUpdated(iceP_serial, iceP_desc, context, synchronous, completed);
            return completed.Task;
        }

        private const string _applicationUpdated_name = "applicationUpdated";

        private void _iceI_applicationUpdated(int iceP_serial, ApplicationUpdateInfo iceP_desc, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _applicationUpdated_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_serial);
                    ApplicationUpdateInfo.ice_write(ostr, iceP_desc);
                    ostr.writePendingValues();
                });
        }

        public static ApplicationObserverPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new ApplicationObserverPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static ApplicationObserverPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new ApplicationObserverPrxHelper(b) : null;

        public static ApplicationObserverPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static ApplicationObserverPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new ApplicationObserverPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static ApplicationObserverPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::ApplicationObserver"
        };

        public static string ice_staticId() => "::IceGrid::ApplicationObserver";

        public static void write(Ice.OutputStream ostr, ApplicationObserverPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static ApplicationObserverPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new ApplicationObserverPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new ApplicationObserverPrxHelper(reference);

        private ApplicationObserverPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private ApplicationObserverPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }

    public sealed class AdapterObserverPrxHelper : Ice.ObjectPrxHelperBase, AdapterObserverPrx
    {
        public void adapterInit(AdapterInfo[] adpts, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_adapterInitAsync(adpts, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void adapterAdded(AdapterInfo info, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_adapterAddedAsync(info, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void adapterUpdated(AdapterInfo info, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_adapterUpdatedAsync(info, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void adapterRemoved(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_adapterRemovedAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task adapterInitAsync(AdapterInfo[] adpts, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_adapterInitAsync(adpts, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_adapterInitAsync(AdapterInfo[] iceP_adpts, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_adapterInit(iceP_adpts, context, synchronous, completed);
            return completed.Task;
        }

        private const string _adapterInit_name = "adapterInit";

        private void _iceI_adapterInit(AdapterInfo[] iceP_adpts, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _adapterInit_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    AdapterInfoSeqHelper.write(ostr, iceP_adpts);
                });
        }

        public global::System.Threading.Tasks.Task adapterAddedAsync(AdapterInfo info, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_adapterAddedAsync(info, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_adapterAddedAsync(AdapterInfo iceP_info, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_adapterAdded(iceP_info, context, synchronous, completed);
            return completed.Task;
        }

        private const string _adapterAdded_name = "adapterAdded";

        private void _iceI_adapterAdded(AdapterInfo iceP_info, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _adapterAdded_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    AdapterInfo.ice_write(ostr, iceP_info);
                });
        }

        public global::System.Threading.Tasks.Task adapterUpdatedAsync(AdapterInfo info, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_adapterUpdatedAsync(info, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_adapterUpdatedAsync(AdapterInfo iceP_info, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_adapterUpdated(iceP_info, context, synchronous, completed);
            return completed.Task;
        }

        private const string _adapterUpdated_name = "adapterUpdated";

        private void _iceI_adapterUpdated(AdapterInfo iceP_info, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _adapterUpdated_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    AdapterInfo.ice_write(ostr, iceP_info);
                });
        }

        public global::System.Threading.Tasks.Task adapterRemovedAsync(string id, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_adapterRemovedAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_adapterRemovedAsync(string iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_adapterRemoved(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _adapterRemoved_name = "adapterRemoved";

        private void _iceI_adapterRemoved(string iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _adapterRemoved_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                });
        }

        public static AdapterObserverPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new AdapterObserverPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static AdapterObserverPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new AdapterObserverPrxHelper(b) : null;

        public static AdapterObserverPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static AdapterObserverPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new AdapterObserverPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static AdapterObserverPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::AdapterObserver"
        };

        public static string ice_staticId() => "::IceGrid::AdapterObserver";

        public static void write(Ice.OutputStream ostr, AdapterObserverPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static AdapterObserverPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new AdapterObserverPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new AdapterObserverPrxHelper(reference);

        private AdapterObserverPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private AdapterObserverPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }

    public sealed class ObjectObserverPrxHelper : Ice.ObjectPrxHelperBase, ObjectObserverPrx
    {
        public void objectInit(ObjectInfo[] objects, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_objectInitAsync(objects, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void objectAdded(ObjectInfo info, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_objectAddedAsync(info, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void objectUpdated(ObjectInfo info, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_objectUpdatedAsync(info, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void objectRemoved(global::Ice.Identity id, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_objectRemovedAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task objectInitAsync(ObjectInfo[] objects, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_objectInitAsync(objects, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_objectInitAsync(ObjectInfo[] iceP_objects, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_objectInit(iceP_objects, context, synchronous, completed);
            return completed.Task;
        }

        private const string _objectInit_name = "objectInit";

        private void _iceI_objectInit(ObjectInfo[] iceP_objects, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _objectInit_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ObjectInfoSeqHelper.write(ostr, iceP_objects);
                });
        }

        public global::System.Threading.Tasks.Task objectAddedAsync(ObjectInfo info, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_objectAddedAsync(info, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_objectAddedAsync(ObjectInfo iceP_info, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_objectAdded(iceP_info, context, synchronous, completed);
            return completed.Task;
        }

        private const string _objectAdded_name = "objectAdded";

        private void _iceI_objectAdded(ObjectInfo iceP_info, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _objectAdded_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ObjectInfo.ice_write(ostr, iceP_info);
                });
        }

        public global::System.Threading.Tasks.Task objectUpdatedAsync(ObjectInfo info, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_objectUpdatedAsync(info, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_objectUpdatedAsync(ObjectInfo iceP_info, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_objectUpdated(iceP_info, context, synchronous, completed);
            return completed.Task;
        }

        private const string _objectUpdated_name = "objectUpdated";

        private void _iceI_objectUpdated(ObjectInfo iceP_info, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _objectUpdated_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ObjectInfo.ice_write(ostr, iceP_info);
                });
        }

        public global::System.Threading.Tasks.Task objectRemovedAsync(global::Ice.Identity id, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_objectRemovedAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_objectRemovedAsync(global::Ice.Identity iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_objectRemoved(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _objectRemoved_name = "objectRemoved";

        private void _iceI_objectRemoved(global::Ice.Identity iceP_id, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _objectRemoved_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    global::Ice.Identity.ice_write(ostr, iceP_id);
                });
        }

        public static ObjectObserverPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new ObjectObserverPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static ObjectObserverPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new ObjectObserverPrxHelper(b) : null;

        public static ObjectObserverPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static ObjectObserverPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new ObjectObserverPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static ObjectObserverPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::ObjectObserver"
        };

        public static string ice_staticId() => "::IceGrid::ObjectObserver";

        public static void write(Ice.OutputStream ostr, ObjectObserverPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static ObjectObserverPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new ObjectObserverPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new ObjectObserverPrxHelper(reference);

        private ObjectObserverPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private ObjectObserverPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }

    public sealed class AdminSessionPrxHelper : Ice.ObjectPrxHelperBase, AdminSessionPrx
    {
        public void destroy(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_destroyAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void keepAlive(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_keepAliveAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public AdminPrx? getAdmin(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getAdminAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::Ice.ObjectPrx? getAdminCallbackTemplate(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getAdminCallbackTemplateAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void setObservers(RegistryObserverPrx? registryObs, NodeObserverPrx? nodeObs, ApplicationObserverPrx? appObs, AdapterObserverPrx? adptObs, ObjectObserverPrx? objObs, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_setObserversAsync(registryObs, nodeObs, appObs, adptObs, objObs, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void setObserversByIdentity(global::Ice.Identity registryObs, global::Ice.Identity nodeObs, global::Ice.Identity appObs, global::Ice.Identity adptObs, global::Ice.Identity objObs, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_setObserversByIdentityAsync(registryObs, nodeObs, appObs, adptObs, objObs, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public int startUpdate(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_startUpdateAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public void finishUpdate(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                _iceI_finishUpdateAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public string getReplicaName(global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_getReplicaNameAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public FileIteratorPrx? openServerLog(string id, string path, int count, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_openServerLogAsync(id, path, count, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public FileIteratorPrx? openServerStdErr(string id, int count, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_openServerStdErrAsync(id, count, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public FileIteratorPrx? openServerStdOut(string id, int count, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_openServerStdOutAsync(id, count, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public FileIteratorPrx? openNodeStdErr(string name, int count, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_openNodeStdErrAsync(name, count, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public FileIteratorPrx? openNodeStdOut(string name, int count, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_openNodeStdOutAsync(name, count, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public FileIteratorPrx? openRegistryStdErr(string name, int count, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_openRegistryStdErrAsync(name, count, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public FileIteratorPrx? openRegistryStdOut(string name, int count, global::System.Collections.Generic.Dictionary<string, string>? context = null)
        {
            try
            {
                return _iceI_openRegistryStdOutAsync(name, count, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch (global::System.AggregateException ex_)
            {
                throw ex_.InnerException!;
            }
        }

        public global::System.Threading.Tasks.Task destroyAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_destroyAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_destroyAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_destroy(context, synchronous, completed);
            return completed.Task;
        }

        private const string _destroy_name = "destroy";

        private void _iceI_destroy(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _destroy_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous);
        }

        public global::System.Threading.Tasks.Task keepAliveAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_keepAliveAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_keepAliveAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_keepAlive(context, synchronous, completed);
            return completed.Task;
        }

        private const string _keepAlive_name = "keepAlive";

        private void _iceI_keepAlive(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _keepAlive_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous);
        }

        public global::System.Threading.Tasks.Task<AdminPrx?> getAdminAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getAdminAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<AdminPrx?> _iceI_getAdminAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getAdmin_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<AdminPrx?>(progress, cancel);
            _iceI_getAdmin(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getAdmin_name = "getAdmin";

        private void _iceI_getAdmin(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<AdminPrx?>(completed);
            outAsync.invoke(
                _getAdmin_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    AdminPrx? ret;
                    ret = AdminPrxHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<global::Ice.ObjectPrx?> getAdminCallbackTemplateAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getAdminCallbackTemplateAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<global::Ice.ObjectPrx?> _iceI_getAdminCallbackTemplateAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getAdminCallbackTemplate_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<global::Ice.ObjectPrx?>(progress, cancel);
            _iceI_getAdminCallbackTemplate(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getAdminCallbackTemplate_name = "getAdminCallbackTemplate";

        private void _iceI_getAdminCallbackTemplate(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<global::Ice.ObjectPrx?>(completed);
            outAsync.invoke(
                _getAdminCallbackTemplate_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    global::Ice.ObjectPrx? ret;
                    ret = istr.readProxy();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task setObserversAsync(RegistryObserverPrx? registryObs, NodeObserverPrx? nodeObs, ApplicationObserverPrx? appObs, AdapterObserverPrx? adptObs, ObjectObserverPrx? objObs, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_setObserversAsync(registryObs, nodeObs, appObs, adptObs, objObs, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_setObserversAsync(RegistryObserverPrx? iceP_registryObs, NodeObserverPrx? iceP_nodeObs, ApplicationObserverPrx? iceP_appObs, AdapterObserverPrx? iceP_adptObs, ObjectObserverPrx? iceP_objObs, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_setObservers_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_setObservers(iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs, context, synchronous, completed);
            return completed.Task;
        }

        private const string _setObservers_name = "setObservers";

        private void _iceI_setObservers(RegistryObserverPrx? iceP_registryObs, NodeObserverPrx? iceP_nodeObs, ApplicationObserverPrx? iceP_appObs, AdapterObserverPrx? iceP_adptObs, ObjectObserverPrx? iceP_objObs, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _setObservers_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    RegistryObserverPrxHelper.write(ostr, iceP_registryObs);
                    NodeObserverPrxHelper.write(ostr, iceP_nodeObs);
                    ApplicationObserverPrxHelper.write(ostr, iceP_appObs);
                    AdapterObserverPrxHelper.write(ostr, iceP_adptObs);
                    ObjectObserverPrxHelper.write(ostr, iceP_objObs);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ObserverAlreadyRegisteredException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task setObserversByIdentityAsync(global::Ice.Identity registryObs, global::Ice.Identity nodeObs, global::Ice.Identity appObs, global::Ice.Identity adptObs, global::Ice.Identity objObs, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_setObserversByIdentityAsync(registryObs, nodeObs, appObs, adptObs, objObs, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_setObserversByIdentityAsync(global::Ice.Identity iceP_registryObs, global::Ice.Identity iceP_nodeObs, global::Ice.Identity iceP_appObs, global::Ice.Identity iceP_adptObs, global::Ice.Identity iceP_objObs, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_setObserversByIdentity_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_setObserversByIdentity(iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs, context, synchronous, completed);
            return completed.Task;
        }

        private const string _setObserversByIdentity_name = "setObserversByIdentity";

        private void _iceI_setObserversByIdentity(global::Ice.Identity iceP_registryObs, global::Ice.Identity iceP_nodeObs, global::Ice.Identity iceP_appObs, global::Ice.Identity iceP_adptObs, global::Ice.Identity iceP_objObs, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _setObserversByIdentity_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    global::Ice.Identity.ice_write(ostr, iceP_registryObs);
                    global::Ice.Identity.ice_write(ostr, iceP_nodeObs);
                    global::Ice.Identity.ice_write(ostr, iceP_appObs);
                    global::Ice.Identity.ice_write(ostr, iceP_adptObs);
                    global::Ice.Identity.ice_write(ostr, iceP_objObs);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ObserverAlreadyRegisteredException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<int> startUpdateAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_startUpdateAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<int> _iceI_startUpdateAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_startUpdate_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<int>(progress, cancel);
            _iceI_startUpdate(context, synchronous, completed);
            return completed.Task;
        }

        private const string _startUpdate_name = "startUpdate";

        private void _iceI_startUpdate(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<int>(completed);
            outAsync.invoke(
                _startUpdate_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(AccessDeniedException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    int ret;
                    ret = istr.readInt();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task finishUpdateAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_finishUpdateAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_finishUpdateAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_finishUpdate_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_finishUpdate(context, synchronous, completed);
            return completed.Task;
        }

        private const string _finishUpdate_name = "finishUpdate";

        private void _iceI_finishUpdate(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _finishUpdate_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(AccessDeniedException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<string> getReplicaNameAsync(global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_getReplicaNameAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<string> _iceI_getReplicaNameAsync(global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getReplicaName_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<string>(progress, cancel);
            _iceI_getReplicaName(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getReplicaName_name = "getReplicaName";

        private void _iceI_getReplicaName(global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<string>(completed);
            outAsync.invoke(
                _getReplicaName_name,
                Ice.OperationMode.Idempotent,
                null,
                context,
                synchronous,
                read: (Ice.InputStream istr) =>
                {
                    string ret;
                    ret = istr.readString();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<FileIteratorPrx?> openServerLogAsync(string id, string path, int count, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_openServerLogAsync(id, path, count, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<FileIteratorPrx?> _iceI_openServerLogAsync(string iceP_id, string iceP_path, int iceP_count, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_openServerLog_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<FileIteratorPrx?>(progress, cancel);
            _iceI_openServerLog(iceP_id, iceP_path, iceP_count, context, synchronous, completed);
            return completed.Task;
        }

        private const string _openServerLog_name = "openServerLog";

        private void _iceI_openServerLog(string iceP_id, string iceP_path, int iceP_count, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<FileIteratorPrx?>(completed);
            outAsync.invoke(
                _openServerLog_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                    ostr.writeString(iceP_path);
                    ostr.writeInt(iceP_count);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(FileNotAvailableException)
                    {
                        throw;
                    }
                    catch(ServerNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    FileIteratorPrx? ret;
                    ret = FileIteratorPrxHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<FileIteratorPrx?> openServerStdErrAsync(string id, int count, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_openServerStdErrAsync(id, count, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<FileIteratorPrx?> _iceI_openServerStdErrAsync(string iceP_id, int iceP_count, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_openServerStdErr_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<FileIteratorPrx?>(progress, cancel);
            _iceI_openServerStdErr(iceP_id, iceP_count, context, synchronous, completed);
            return completed.Task;
        }

        private const string _openServerStdErr_name = "openServerStdErr";

        private void _iceI_openServerStdErr(string iceP_id, int iceP_count, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<FileIteratorPrx?>(completed);
            outAsync.invoke(
                _openServerStdErr_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                    ostr.writeInt(iceP_count);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(FileNotAvailableException)
                    {
                        throw;
                    }
                    catch(ServerNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    FileIteratorPrx? ret;
                    ret = FileIteratorPrxHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<FileIteratorPrx?> openServerStdOutAsync(string id, int count, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_openServerStdOutAsync(id, count, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<FileIteratorPrx?> _iceI_openServerStdOutAsync(string iceP_id, int iceP_count, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_openServerStdOut_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<FileIteratorPrx?>(progress, cancel);
            _iceI_openServerStdOut(iceP_id, iceP_count, context, synchronous, completed);
            return completed.Task;
        }

        private const string _openServerStdOut_name = "openServerStdOut";

        private void _iceI_openServerStdOut(string iceP_id, int iceP_count, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<FileIteratorPrx?>(completed);
            outAsync.invoke(
                _openServerStdOut_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                    ostr.writeInt(iceP_count);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(FileNotAvailableException)
                    {
                        throw;
                    }
                    catch(ServerNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    FileIteratorPrx? ret;
                    ret = FileIteratorPrxHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<FileIteratorPrx?> openNodeStdErrAsync(string name, int count, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_openNodeStdErrAsync(name, count, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<FileIteratorPrx?> _iceI_openNodeStdErrAsync(string iceP_name, int iceP_count, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_openNodeStdErr_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<FileIteratorPrx?>(progress, cancel);
            _iceI_openNodeStdErr(iceP_name, iceP_count, context, synchronous, completed);
            return completed.Task;
        }

        private const string _openNodeStdErr_name = "openNodeStdErr";

        private void _iceI_openNodeStdErr(string iceP_name, int iceP_count, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<FileIteratorPrx?>(completed);
            outAsync.invoke(
                _openNodeStdErr_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                    ostr.writeInt(iceP_count);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(FileNotAvailableException)
                    {
                        throw;
                    }
                    catch(NodeNotExistException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    FileIteratorPrx? ret;
                    ret = FileIteratorPrxHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<FileIteratorPrx?> openNodeStdOutAsync(string name, int count, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_openNodeStdOutAsync(name, count, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<FileIteratorPrx?> _iceI_openNodeStdOutAsync(string iceP_name, int iceP_count, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_openNodeStdOut_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<FileIteratorPrx?>(progress, cancel);
            _iceI_openNodeStdOut(iceP_name, iceP_count, context, synchronous, completed);
            return completed.Task;
        }

        private const string _openNodeStdOut_name = "openNodeStdOut";

        private void _iceI_openNodeStdOut(string iceP_name, int iceP_count, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<FileIteratorPrx?>(completed);
            outAsync.invoke(
                _openNodeStdOut_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                    ostr.writeInt(iceP_count);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(FileNotAvailableException)
                    {
                        throw;
                    }
                    catch(NodeNotExistException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    FileIteratorPrx? ret;
                    ret = FileIteratorPrxHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<FileIteratorPrx?> openRegistryStdErrAsync(string name, int count, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_openRegistryStdErrAsync(name, count, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<FileIteratorPrx?> _iceI_openRegistryStdErrAsync(string iceP_name, int iceP_count, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_openRegistryStdErr_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<FileIteratorPrx?>(progress, cancel);
            _iceI_openRegistryStdErr(iceP_name, iceP_count, context, synchronous, completed);
            return completed.Task;
        }

        private const string _openRegistryStdErr_name = "openRegistryStdErr";

        private void _iceI_openRegistryStdErr(string iceP_name, int iceP_count, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<FileIteratorPrx?>(completed);
            outAsync.invoke(
                _openRegistryStdErr_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                    ostr.writeInt(iceP_count);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(RegistryUnreachableException)
                    {
                        throw;
                    }
                    catch(FileNotAvailableException)
                    {
                        throw;
                    }
                    catch(RegistryNotExistException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    FileIteratorPrx? ret;
                    ret = FileIteratorPrxHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<FileIteratorPrx?> openRegistryStdOutAsync(string name, int count, global::System.Collections.Generic.Dictionary<string, string>? context = null, global::System.IProgress<bool>? progress = null, global::System.Threading.CancellationToken cancel = default)
        {
            return _iceI_openRegistryStdOutAsync(name, count, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<FileIteratorPrx?> _iceI_openRegistryStdOutAsync(string iceP_name, int iceP_count, global::System.Collections.Generic.Dictionary<string, string>? context, global::System.IProgress<bool>? progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_openRegistryStdOut_name);
            var completed = new Ice.Internal.OperationTaskCompletionCallback<FileIteratorPrx?>(progress, cancel);
            _iceI_openRegistryStdOut(iceP_name, iceP_count, context, synchronous, completed);
            return completed.Task;
        }

        private const string _openRegistryStdOut_name = "openRegistryStdOut";

        private void _iceI_openRegistryStdOut(string iceP_name, int iceP_count, global::System.Collections.Generic.Dictionary<string, string>? context, bool synchronous, Ice.Internal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<FileIteratorPrx?>(completed);
            outAsync.invoke(
                _openRegistryStdOut_name,
                Ice.OperationMode.Normal,
                null,
                context,
                synchronous,
                write: (Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                    ostr.writeInt(iceP_count);
                },
                userException: (Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(RegistryUnreachableException)
                    {
                        throw;
                    }
                    catch(FileNotAvailableException)
                    {
                        throw;
                    }
                    catch(RegistryNotExistException)
                    {
                        throw;
                    }
                    catch(Ice.UserException)
                    {
                    }
                },
                read: (Ice.InputStream istr) =>
                {
                    FileIteratorPrx? ret;
                    ret = FileIteratorPrxHelper.read(istr);
                    return ret;
                });
        }

        public static AdminSessionPrx createProxy(Ice.Communicator communicator, string proxyString) =>
            new AdminSessionPrxHelper(Ice.ObjectPrxHelper.createProxy(communicator, proxyString));

        public static AdminSessionPrx? checkedCast(Ice.ObjectPrx? b, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            b is not null && b.ice_isA(ice_staticId(), ctx) ? new AdminSessionPrxHelper(b) : null;

        public static AdminSessionPrx? checkedCast(Ice.ObjectPrx? b, string f, global::System.Collections.Generic.Dictionary<string, string>? ctx = null) =>
            checkedCast(b?.ice_facet(f), ctx);

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static AdminSessionPrx? uncheckedCast(Ice.ObjectPrx? b) =>
            b is not null ? new AdminSessionPrxHelper(b) : null;

        [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(b))]

        public static AdminSessionPrx? uncheckedCast(Ice.ObjectPrx? b, string f) =>
            uncheckedCast(b?.ice_facet(f));

        private static readonly string[] _ids =
        {
            "::Glacier2::Session",
            "::Ice::Object",
            "::IceGrid::AdminSession"
        };

        public static string ice_staticId() => "::IceGrid::AdminSession";

        public static void write(Ice.OutputStream ostr, AdminSessionPrx? v)
        {
            ostr.writeProxy(v);
        }

        public static AdminSessionPrx? read(Ice.InputStream istr) =>
            istr.readProxy() is Ice.ObjectPrx proxy ? new AdminSessionPrxHelper(proxy) : null;

        protected override Ice.ObjectPrxHelperBase iceNewInstance(Ice.Internal.Reference reference) => new AdminSessionPrxHelper(reference);

        private AdminSessionPrxHelper(Ice.ObjectPrx proxy)
            : base(proxy)
        {
        }

        private AdminSessionPrxHelper(Ice.Internal.Reference reference)
            : base(reference)
        {
        }
    }
}

namespace IceGrid
{
    public abstract class AdminDisp_ : Ice.ObjectImpl, Admin
    {
        public abstract void addApplication(ApplicationDescriptor descriptor, Ice.Current current);

        public abstract void syncApplication(ApplicationDescriptor descriptor, Ice.Current current);

        public abstract void updateApplication(ApplicationUpdateDescriptor descriptor, Ice.Current current);

        public abstract void syncApplicationWithoutRestart(ApplicationDescriptor descriptor, Ice.Current current);

        public abstract void updateApplicationWithoutRestart(ApplicationUpdateDescriptor descriptor, Ice.Current current);

        public abstract void removeApplication(string name, Ice.Current current);

        public abstract void instantiateServer(string application, string node, ServerInstanceDescriptor desc, Ice.Current current);

        public abstract ApplicationInfo getApplicationInfo(string name, Ice.Current current);

        public abstract ApplicationDescriptor getDefaultApplicationDescriptor(Ice.Current current);

        public abstract string[] getAllApplicationNames(Ice.Current current);

        public abstract ServerInfo getServerInfo(string id, Ice.Current current);

        public abstract ServerState getServerState(string id, Ice.Current current);

        public abstract int getServerPid(string id, Ice.Current current);

        public abstract string getServerAdminCategory(Ice.Current current);

        public abstract global::Ice.ObjectPrx? getServerAdmin(string id, Ice.Current current);

        public abstract void enableServer(string id, bool enabled, Ice.Current current);

        public abstract bool isServerEnabled(string id, Ice.Current current);

        public abstract global::System.Threading.Tasks.Task startServerAsync(string id, Ice.Current current);

        public abstract global::System.Threading.Tasks.Task stopServerAsync(string id, Ice.Current current);

        public abstract void sendSignal(string id, string signal, Ice.Current current);

        public abstract string[] getAllServerIds(Ice.Current current);

        public abstract AdapterInfo[] getAdapterInfo(string id, Ice.Current current);

        public abstract void removeAdapter(string id, Ice.Current current);

        public abstract string[] getAllAdapterIds(Ice.Current current);

        public abstract void addObject(global::Ice.ObjectPrx? obj, Ice.Current current);

        public abstract void updateObject(global::Ice.ObjectPrx? obj, Ice.Current current);

        public abstract void addObjectWithType(global::Ice.ObjectPrx? obj, string type, Ice.Current current);

        public abstract void removeObject(global::Ice.Identity id, Ice.Current current);

        public abstract ObjectInfo getObjectInfo(global::Ice.Identity id, Ice.Current current);

        public abstract ObjectInfo[] getObjectInfosByType(string type, Ice.Current current);

        public abstract ObjectInfo[] getAllObjectInfos(string expr, Ice.Current current);

        public abstract bool pingNode(string name, Ice.Current current);

        public abstract LoadInfo getNodeLoad(string name, Ice.Current current);

        public abstract NodeInfo getNodeInfo(string name, Ice.Current current);

        public abstract global::Ice.ObjectPrx? getNodeAdmin(string name, Ice.Current current);

        public abstract int getNodeProcessorSocketCount(string name, Ice.Current current);

        public abstract void shutdownNode(string name, Ice.Current current);

        public abstract string getNodeHostname(string name, Ice.Current current);

        public abstract string[] getAllNodeNames(Ice.Current current);

        public abstract bool pingRegistry(string name, Ice.Current current);

        public abstract RegistryInfo getRegistryInfo(string name, Ice.Current current);

        public abstract global::Ice.ObjectPrx? getRegistryAdmin(string name, Ice.Current current);

        public abstract void shutdownRegistry(string name, Ice.Current current);

        public abstract string[] getAllRegistryNames(Ice.Current current);

        public abstract void shutdown(Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::IceGrid::Admin";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "addApplication" => Admin.iceD_addApplicationAsync(this, request),
                "syncApplication" => Admin.iceD_syncApplicationAsync(this, request),
                "updateApplication" => Admin.iceD_updateApplicationAsync(this, request),
                "syncApplicationWithoutRestart" => Admin.iceD_syncApplicationWithoutRestartAsync(this, request),
                "updateApplicationWithoutRestart" => Admin.iceD_updateApplicationWithoutRestartAsync(this, request),
                "removeApplication" => Admin.iceD_removeApplicationAsync(this, request),
                "instantiateServer" => Admin.iceD_instantiateServerAsync(this, request),
                "getApplicationInfo" => Admin.iceD_getApplicationInfoAsync(this, request),
                "getDefaultApplicationDescriptor" => Admin.iceD_getDefaultApplicationDescriptorAsync(this, request),
                "getAllApplicationNames" => Admin.iceD_getAllApplicationNamesAsync(this, request),
                "getServerInfo" => Admin.iceD_getServerInfoAsync(this, request),
                "getServerState" => Admin.iceD_getServerStateAsync(this, request),
                "getServerPid" => Admin.iceD_getServerPidAsync(this, request),
                "getServerAdminCategory" => Admin.iceD_getServerAdminCategoryAsync(this, request),
                "getServerAdmin" => Admin.iceD_getServerAdminAsync(this, request),
                "enableServer" => Admin.iceD_enableServerAsync(this, request),
                "isServerEnabled" => Admin.iceD_isServerEnabledAsync(this, request),
                "startServer" => Admin.iceD_startServerAsync(this, request),
                "stopServer" => Admin.iceD_stopServerAsync(this, request),
                "sendSignal" => Admin.iceD_sendSignalAsync(this, request),
                "getAllServerIds" => Admin.iceD_getAllServerIdsAsync(this, request),
                "getAdapterInfo" => Admin.iceD_getAdapterInfoAsync(this, request),
                "removeAdapter" => Admin.iceD_removeAdapterAsync(this, request),
                "getAllAdapterIds" => Admin.iceD_getAllAdapterIdsAsync(this, request),
                "addObject" => Admin.iceD_addObjectAsync(this, request),
                "updateObject" => Admin.iceD_updateObjectAsync(this, request),
                "addObjectWithType" => Admin.iceD_addObjectWithTypeAsync(this, request),
                "removeObject" => Admin.iceD_removeObjectAsync(this, request),
                "getObjectInfo" => Admin.iceD_getObjectInfoAsync(this, request),
                "getObjectInfosByType" => Admin.iceD_getObjectInfosByTypeAsync(this, request),
                "getAllObjectInfos" => Admin.iceD_getAllObjectInfosAsync(this, request),
                "pingNode" => Admin.iceD_pingNodeAsync(this, request),
                "getNodeLoad" => Admin.iceD_getNodeLoadAsync(this, request),
                "getNodeInfo" => Admin.iceD_getNodeInfoAsync(this, request),
                "getNodeAdmin" => Admin.iceD_getNodeAdminAsync(this, request),
                "getNodeProcessorSocketCount" => Admin.iceD_getNodeProcessorSocketCountAsync(this, request),
                "shutdownNode" => Admin.iceD_shutdownNodeAsync(this, request),
                "getNodeHostname" => Admin.iceD_getNodeHostnameAsync(this, request),
                "getAllNodeNames" => Admin.iceD_getAllNodeNamesAsync(this, request),
                "pingRegistry" => Admin.iceD_pingRegistryAsync(this, request),
                "getRegistryInfo" => Admin.iceD_getRegistryInfoAsync(this, request),
                "getRegistryAdmin" => Admin.iceD_getRegistryAdminAsync(this, request),
                "shutdownRegistry" => Admin.iceD_shutdownRegistryAsync(this, request),
                "getAllRegistryNames" => Admin.iceD_getAllRegistryNamesAsync(this, request),
                "shutdown" => Admin.iceD_shutdownAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }

    public abstract class FileIteratorDisp_ : Ice.ObjectImpl, FileIterator
    {
        public abstract bool read(int size, out string[] lines, Ice.Current current);

        public abstract void destroy(Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::IceGrid::FileIterator";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "read" => FileIterator.iceD_readAsync(this, request),
                "destroy" => FileIterator.iceD_destroyAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }

    public abstract class RegistryObserverDisp_ : Ice.ObjectImpl, RegistryObserver
    {
        public abstract void registryInit(RegistryInfo[] registries, Ice.Current current);

        public abstract void registryUp(RegistryInfo registryReplica, Ice.Current current);

        public abstract void registryDown(string name, Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::IceGrid::RegistryObserver";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "registryInit" => RegistryObserver.iceD_registryInitAsync(this, request),
                "registryUp" => RegistryObserver.iceD_registryUpAsync(this, request),
                "registryDown" => RegistryObserver.iceD_registryDownAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }

    public abstract class NodeObserverDisp_ : Ice.ObjectImpl, NodeObserver
    {
        public abstract void nodeInit(NodeDynamicInfo[] nodes, Ice.Current current);

        public abstract void nodeUp(NodeDynamicInfo node, Ice.Current current);

        public abstract void nodeDown(string name, Ice.Current current);

        public abstract void updateServer(string node, ServerDynamicInfo updatedInfo, Ice.Current current);

        public abstract void updateAdapter(string node, AdapterDynamicInfo updatedInfo, Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::IceGrid::NodeObserver";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "nodeInit" => NodeObserver.iceD_nodeInitAsync(this, request),
                "nodeUp" => NodeObserver.iceD_nodeUpAsync(this, request),
                "nodeDown" => NodeObserver.iceD_nodeDownAsync(this, request),
                "updateServer" => NodeObserver.iceD_updateServerAsync(this, request),
                "updateAdapter" => NodeObserver.iceD_updateAdapterAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }

    public abstract class ApplicationObserverDisp_ : Ice.ObjectImpl, ApplicationObserver
    {
        public abstract void applicationInit(int serial, ApplicationInfo[] applications, Ice.Current current);

        public abstract void applicationAdded(int serial, ApplicationInfo desc, Ice.Current current);

        public abstract void applicationRemoved(int serial, string name, Ice.Current current);

        public abstract void applicationUpdated(int serial, ApplicationUpdateInfo desc, Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::IceGrid::ApplicationObserver";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "applicationInit" => ApplicationObserver.iceD_applicationInitAsync(this, request),
                "applicationAdded" => ApplicationObserver.iceD_applicationAddedAsync(this, request),
                "applicationRemoved" => ApplicationObserver.iceD_applicationRemovedAsync(this, request),
                "applicationUpdated" => ApplicationObserver.iceD_applicationUpdatedAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }

    public abstract class AdapterObserverDisp_ : Ice.ObjectImpl, AdapterObserver
    {
        public abstract void adapterInit(AdapterInfo[] adpts, Ice.Current current);

        public abstract void adapterAdded(AdapterInfo info, Ice.Current current);

        public abstract void adapterUpdated(AdapterInfo info, Ice.Current current);

        public abstract void adapterRemoved(string id, Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::IceGrid::AdapterObserver";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "adapterInit" => AdapterObserver.iceD_adapterInitAsync(this, request),
                "adapterAdded" => AdapterObserver.iceD_adapterAddedAsync(this, request),
                "adapterUpdated" => AdapterObserver.iceD_adapterUpdatedAsync(this, request),
                "adapterRemoved" => AdapterObserver.iceD_adapterRemovedAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }

    public abstract class ObjectObserverDisp_ : Ice.ObjectImpl, ObjectObserver
    {
        public abstract void objectInit(ObjectInfo[] objects, Ice.Current current);

        public abstract void objectAdded(ObjectInfo info, Ice.Current current);

        public abstract void objectUpdated(ObjectInfo info, Ice.Current current);

        public abstract void objectRemoved(global::Ice.Identity id, Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::IceGrid::ObjectObserver";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "objectInit" => ObjectObserver.iceD_objectInitAsync(this, request),
                "objectAdded" => ObjectObserver.iceD_objectAddedAsync(this, request),
                "objectUpdated" => ObjectObserver.iceD_objectUpdatedAsync(this, request),
                "objectRemoved" => ObjectObserver.iceD_objectRemovedAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }

    public abstract class AdminSessionDisp_ : Ice.ObjectImpl, AdminSession
    {
        public abstract void keepAlive(Ice.Current current);

        public abstract AdminPrx? getAdmin(Ice.Current current);

        public abstract global::Ice.ObjectPrx? getAdminCallbackTemplate(Ice.Current current);

        public abstract void setObservers(RegistryObserverPrx? registryObs, NodeObserverPrx? nodeObs, ApplicationObserverPrx? appObs, AdapterObserverPrx? adptObs, ObjectObserverPrx? objObs, Ice.Current current);

        public abstract void setObserversByIdentity(global::Ice.Identity registryObs, global::Ice.Identity nodeObs, global::Ice.Identity appObs, global::Ice.Identity adptObs, global::Ice.Identity objObs, Ice.Current current);

        public abstract int startUpdate(Ice.Current current);

        public abstract void finishUpdate(Ice.Current current);

        public abstract string getReplicaName(Ice.Current current);

        public abstract FileIteratorPrx? openServerLog(string id, string path, int count, Ice.Current current);

        public abstract FileIteratorPrx? openServerStdErr(string id, int count, Ice.Current current);

        public abstract FileIteratorPrx? openServerStdOut(string id, int count, Ice.Current current);

        public abstract FileIteratorPrx? openNodeStdErr(string name, int count, Ice.Current current);

        public abstract FileIteratorPrx? openNodeStdOut(string name, int count, Ice.Current current);

        public abstract FileIteratorPrx? openRegistryStdErr(string name, int count, Ice.Current current);

        public abstract FileIteratorPrx? openRegistryStdOut(string name, int count, Ice.Current current);

        public abstract void destroy(Ice.Current current);

        public override string ice_id(Ice.Current current) => ice_staticId();

        public static new string ice_staticId() => "::IceGrid::AdminSession";

        public override global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> dispatchAsync(Ice.IncomingRequest request) =>
            request.current.operation switch
            {
                "destroy" => global::Glacier2.Session.iceD_destroyAsync(this, request),
                "keepAlive" => AdminSession.iceD_keepAliveAsync(this, request),
                "getAdmin" => AdminSession.iceD_getAdminAsync(this, request),
                "getAdminCallbackTemplate" => AdminSession.iceD_getAdminCallbackTemplateAsync(this, request),
                "setObservers" => AdminSession.iceD_setObserversAsync(this, request),
                "setObserversByIdentity" => AdminSession.iceD_setObserversByIdentityAsync(this, request),
                "startUpdate" => AdminSession.iceD_startUpdateAsync(this, request),
                "finishUpdate" => AdminSession.iceD_finishUpdateAsync(this, request),
                "getReplicaName" => AdminSession.iceD_getReplicaNameAsync(this, request),
                "openServerLog" => AdminSession.iceD_openServerLogAsync(this, request),
                "openServerStdErr" => AdminSession.iceD_openServerStdErrAsync(this, request),
                "openServerStdOut" => AdminSession.iceD_openServerStdOutAsync(this, request),
                "openNodeStdErr" => AdminSession.iceD_openNodeStdErrAsync(this, request),
                "openNodeStdOut" => AdminSession.iceD_openNodeStdOutAsync(this, request),
                "openRegistryStdErr" => AdminSession.iceD_openRegistryStdErrAsync(this, request),
                "openRegistryStdOut" => AdminSession.iceD_openRegistryStdOutAsync(this, request),
                "ice_id" => Ice.Object.iceD_ice_idAsync(this, request),
                "ice_ids" => Ice.Object.iceD_ice_idsAsync(this, request),
                "ice_isA" => Ice.Object.iceD_ice_isAAsync(this, request),
                "ice_ping" => Ice.Object.iceD_ice_pingAsync(this, request),
                _ => throw new Ice.OperationNotExistException()
            };
    }
}

namespace IceGrid
{
    public partial interface Admin
    {
        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_addApplicationAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            ApplicationDescriptor iceP_descriptor;
            iceP_descriptor = new ApplicationDescriptor(istr);
            istr.readPendingValues();
            istr.endEncapsulation();
            obj.addApplication(iceP_descriptor, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_syncApplicationAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            ApplicationDescriptor iceP_descriptor;
            iceP_descriptor = new ApplicationDescriptor(istr);
            istr.readPendingValues();
            istr.endEncapsulation();
            obj.syncApplication(iceP_descriptor, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_updateApplicationAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            ApplicationUpdateDescriptor iceP_descriptor;
            iceP_descriptor = new ApplicationUpdateDescriptor(istr);
            istr.readPendingValues();
            istr.endEncapsulation();
            obj.updateApplication(iceP_descriptor, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_syncApplicationWithoutRestartAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            ApplicationDescriptor iceP_descriptor;
            iceP_descriptor = new ApplicationDescriptor(istr);
            istr.readPendingValues();
            istr.endEncapsulation();
            obj.syncApplicationWithoutRestart(iceP_descriptor, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_updateApplicationWithoutRestartAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            ApplicationUpdateDescriptor iceP_descriptor;
            iceP_descriptor = new ApplicationUpdateDescriptor(istr);
            istr.readPendingValues();
            istr.endEncapsulation();
            obj.updateApplicationWithoutRestart(iceP_descriptor, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_removeApplicationAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_name;
            iceP_name = istr.readString();
            istr.endEncapsulation();
            obj.removeApplication(iceP_name, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_instantiateServerAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_application;
            string iceP_node;
            ServerInstanceDescriptor iceP_desc;
            iceP_application = istr.readString();
            iceP_node = istr.readString();
            iceP_desc = new ServerInstanceDescriptor(istr);
            istr.endEncapsulation();
            obj.instantiateServer(iceP_application, iceP_node, iceP_desc, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getApplicationInfoAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_name;
            iceP_name = istr.readString();
            istr.endEncapsulation();
            var ret = obj.getApplicationInfo(iceP_name, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ApplicationInfo.ice_write(ostr, ret);
            ostr.writePendingValues();
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getDefaultApplicationDescriptorAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.getDefaultApplicationDescriptor(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ApplicationDescriptor.ice_write(ostr, ret);
            ostr.writePendingValues();
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getAllApplicationNamesAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.getAllApplicationNames(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            global::Ice.StringSeqHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getServerInfoAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_id;
            iceP_id = istr.readString();
            istr.endEncapsulation();
            var ret = obj.getServerInfo(iceP_id, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ServerInfo.ice_write(ostr, ret);
            ostr.writePendingValues();
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getServerStateAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_id;
            iceP_id = istr.readString();
            istr.endEncapsulation();
            var ret = obj.getServerState(iceP_id, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeEnum((int)ret, 6);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getServerPidAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_id;
            iceP_id = istr.readString();
            istr.endEncapsulation();
            var ret = obj.getServerPid(iceP_id, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeInt(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getServerAdminCategoryAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.getServerAdminCategory(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeString(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getServerAdminAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_id;
            iceP_id = istr.readString();
            istr.endEncapsulation();
            var ret = obj.getServerAdmin(iceP_id, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeProxy(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_enableServerAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_id;
            bool iceP_enabled;
            iceP_id = istr.readString();
            iceP_enabled = istr.readBool();
            istr.endEncapsulation();
            obj.enableServer(iceP_id, iceP_enabled, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_isServerEnabledAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_id;
            iceP_id = istr.readString();
            istr.endEncapsulation();
            var ret = obj.isServerEnabled(iceP_id, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeBool(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static async global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_startServerAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_id;
            iceP_id = istr.readString();
            istr.endEncapsulation();
            await obj.startServerAsync(iceP_id, request.current).ConfigureAwait(false);
            return Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current);
        }

        protected static async global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_stopServerAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_id;
            iceP_id = istr.readString();
            istr.endEncapsulation();
            await obj.stopServerAsync(iceP_id, request.current).ConfigureAwait(false);
            return Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current);
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_sendSignalAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_id;
            string iceP_signal;
            iceP_id = istr.readString();
            iceP_signal = istr.readString();
            istr.endEncapsulation();
            obj.sendSignal(iceP_id, iceP_signal, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getAllServerIdsAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.getAllServerIds(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            global::Ice.StringSeqHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getAdapterInfoAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_id;
            iceP_id = istr.readString();
            istr.endEncapsulation();
            var ret = obj.getAdapterInfo(iceP_id, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            AdapterInfoSeqHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_removeAdapterAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_id;
            iceP_id = istr.readString();
            istr.endEncapsulation();
            obj.removeAdapter(iceP_id, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getAllAdapterIdsAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.getAllAdapterIds(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            global::Ice.StringSeqHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_addObjectAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            global::Ice.ObjectPrx? iceP_obj;
            iceP_obj = istr.readProxy();
            istr.endEncapsulation();
            obj.addObject(iceP_obj, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_updateObjectAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            global::Ice.ObjectPrx? iceP_obj;
            iceP_obj = istr.readProxy();
            istr.endEncapsulation();
            obj.updateObject(iceP_obj, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_addObjectWithTypeAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            global::Ice.ObjectPrx? iceP_obj;
            string iceP_type;
            iceP_obj = istr.readProxy();
            iceP_type = istr.readString();
            istr.endEncapsulation();
            obj.addObjectWithType(iceP_obj, iceP_type, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_removeObjectAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            global::Ice.Identity iceP_id;
            iceP_id = new global::Ice.Identity(istr);
            istr.endEncapsulation();
            obj.removeObject(iceP_id, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getObjectInfoAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            global::Ice.Identity iceP_id;
            iceP_id = new global::Ice.Identity(istr);
            istr.endEncapsulation();
            var ret = obj.getObjectInfo(iceP_id, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ObjectInfo.ice_write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getObjectInfosByTypeAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_type;
            iceP_type = istr.readString();
            istr.endEncapsulation();
            var ret = obj.getObjectInfosByType(iceP_type, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ObjectInfoSeqHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getAllObjectInfosAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_expr;
            iceP_expr = istr.readString();
            istr.endEncapsulation();
            var ret = obj.getAllObjectInfos(iceP_expr, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ObjectInfoSeqHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_pingNodeAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_name;
            iceP_name = istr.readString();
            istr.endEncapsulation();
            var ret = obj.pingNode(iceP_name, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeBool(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getNodeLoadAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_name;
            iceP_name = istr.readString();
            istr.endEncapsulation();
            var ret = obj.getNodeLoad(iceP_name, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ret.ice_writeMembers(ostr);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getNodeInfoAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_name;
            iceP_name = istr.readString();
            istr.endEncapsulation();
            var ret = obj.getNodeInfo(iceP_name, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            NodeInfo.ice_write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getNodeAdminAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_name;
            iceP_name = istr.readString();
            istr.endEncapsulation();
            var ret = obj.getNodeAdmin(iceP_name, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeProxy(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getNodeProcessorSocketCountAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_name;
            iceP_name = istr.readString();
            istr.endEncapsulation();
            var ret = obj.getNodeProcessorSocketCount(iceP_name, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeInt(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_shutdownNodeAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_name;
            iceP_name = istr.readString();
            istr.endEncapsulation();
            obj.shutdownNode(iceP_name, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getNodeHostnameAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_name;
            iceP_name = istr.readString();
            istr.endEncapsulation();
            var ret = obj.getNodeHostname(iceP_name, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeString(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getAllNodeNamesAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.getAllNodeNames(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            global::Ice.StringSeqHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_pingRegistryAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_name;
            iceP_name = istr.readString();
            istr.endEncapsulation();
            var ret = obj.pingRegistry(iceP_name, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeBool(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getRegistryInfoAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_name;
            iceP_name = istr.readString();
            istr.endEncapsulation();
            var ret = obj.getRegistryInfo(iceP_name, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            RegistryInfo.ice_write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getRegistryAdminAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_name;
            iceP_name = istr.readString();
            istr.endEncapsulation();
            var ret = obj.getRegistryAdmin(iceP_name, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeProxy(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_shutdownRegistryAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_name;
            iceP_name = istr.readString();
            istr.endEncapsulation();
            obj.shutdownRegistry(iceP_name, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getAllRegistryNamesAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.getAllRegistryNames(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            global::Ice.StringSeqHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_shutdownAsync(
            Admin obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            obj.shutdown(request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }
    }

    public partial interface FileIterator
    {
        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_readAsync(
            FileIterator obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            int iceP_size;
            iceP_size = istr.readInt();
            istr.endEncapsulation();
            string[] iceP_lines;
            var ret = obj.read(iceP_size, out iceP_lines, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            global::Ice.StringSeqHelper.write(ostr, iceP_lines);
            ostr.writeBool(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_destroyAsync(
            FileIterator obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            obj.destroy(request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }
    }

    public partial interface RegistryObserver
    {
        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_registryInitAsync(
            RegistryObserver obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            RegistryInfo[] iceP_registries;
            iceP_registries = RegistryInfoSeqHelper.read(istr);
            istr.endEncapsulation();
            obj.registryInit(iceP_registries, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_registryUpAsync(
            RegistryObserver obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            RegistryInfo iceP_registryReplica;
            iceP_registryReplica = new RegistryInfo(istr);
            istr.endEncapsulation();
            obj.registryUp(iceP_registryReplica, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_registryDownAsync(
            RegistryObserver obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_name;
            iceP_name = istr.readString();
            istr.endEncapsulation();
            obj.registryDown(iceP_name, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }
    }

    public partial interface NodeObserver
    {
        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_nodeInitAsync(
            NodeObserver obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            NodeDynamicInfo[] iceP_nodes;
            iceP_nodes = NodeDynamicInfoSeqHelper.read(istr);
            istr.endEncapsulation();
            obj.nodeInit(iceP_nodes, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_nodeUpAsync(
            NodeObserver obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            NodeDynamicInfo iceP_node;
            iceP_node = new NodeDynamicInfo(istr);
            istr.endEncapsulation();
            obj.nodeUp(iceP_node, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_nodeDownAsync(
            NodeObserver obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_name;
            iceP_name = istr.readString();
            istr.endEncapsulation();
            obj.nodeDown(iceP_name, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_updateServerAsync(
            NodeObserver obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_node;
            ServerDynamicInfo iceP_updatedInfo;
            iceP_node = istr.readString();
            iceP_updatedInfo = new ServerDynamicInfo(istr);
            istr.endEncapsulation();
            obj.updateServer(iceP_node, iceP_updatedInfo, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_updateAdapterAsync(
            NodeObserver obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_node;
            AdapterDynamicInfo iceP_updatedInfo;
            iceP_node = istr.readString();
            iceP_updatedInfo = new AdapterDynamicInfo(istr);
            istr.endEncapsulation();
            obj.updateAdapter(iceP_node, iceP_updatedInfo, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }
    }

    public partial interface ApplicationObserver
    {
        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_applicationInitAsync(
            ApplicationObserver obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            int iceP_serial;
            ApplicationInfo[] iceP_applications;
            iceP_serial = istr.readInt();
            iceP_applications = ApplicationInfoSeqHelper.read(istr);
            istr.readPendingValues();
            istr.endEncapsulation();
            obj.applicationInit(iceP_serial, iceP_applications, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_applicationAddedAsync(
            ApplicationObserver obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            int iceP_serial;
            ApplicationInfo iceP_desc;
            iceP_serial = istr.readInt();
            iceP_desc = new ApplicationInfo(istr);
            istr.readPendingValues();
            istr.endEncapsulation();
            obj.applicationAdded(iceP_serial, iceP_desc, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_applicationRemovedAsync(
            ApplicationObserver obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            int iceP_serial;
            string iceP_name;
            iceP_serial = istr.readInt();
            iceP_name = istr.readString();
            istr.endEncapsulation();
            obj.applicationRemoved(iceP_serial, iceP_name, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_applicationUpdatedAsync(
            ApplicationObserver obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            int iceP_serial;
            ApplicationUpdateInfo iceP_desc;
            iceP_serial = istr.readInt();
            iceP_desc = new ApplicationUpdateInfo(istr);
            istr.readPendingValues();
            istr.endEncapsulation();
            obj.applicationUpdated(iceP_serial, iceP_desc, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }
    }

    public partial interface AdapterObserver
    {
        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_adapterInitAsync(
            AdapterObserver obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            AdapterInfo[] iceP_adpts;
            iceP_adpts = AdapterInfoSeqHelper.read(istr);
            istr.endEncapsulation();
            obj.adapterInit(iceP_adpts, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_adapterAddedAsync(
            AdapterObserver obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            AdapterInfo iceP_info;
            iceP_info = new AdapterInfo(istr);
            istr.endEncapsulation();
            obj.adapterAdded(iceP_info, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_adapterUpdatedAsync(
            AdapterObserver obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            AdapterInfo iceP_info;
            iceP_info = new AdapterInfo(istr);
            istr.endEncapsulation();
            obj.adapterUpdated(iceP_info, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_adapterRemovedAsync(
            AdapterObserver obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_id;
            iceP_id = istr.readString();
            istr.endEncapsulation();
            obj.adapterRemoved(iceP_id, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }
    }

    public partial interface ObjectObserver
    {
        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_objectInitAsync(
            ObjectObserver obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            ObjectInfo[] iceP_objects;
            iceP_objects = ObjectInfoSeqHelper.read(istr);
            istr.endEncapsulation();
            obj.objectInit(iceP_objects, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_objectAddedAsync(
            ObjectObserver obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            ObjectInfo iceP_info;
            iceP_info = new ObjectInfo(istr);
            istr.endEncapsulation();
            obj.objectAdded(iceP_info, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_objectUpdatedAsync(
            ObjectObserver obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            ObjectInfo iceP_info;
            iceP_info = new ObjectInfo(istr);
            istr.endEncapsulation();
            obj.objectUpdated(iceP_info, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_objectRemovedAsync(
            ObjectObserver obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            global::Ice.Identity iceP_id;
            iceP_id = new global::Ice.Identity(istr);
            istr.endEncapsulation();
            obj.objectRemoved(iceP_id, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }
    }

    public partial interface AdminSession
    {
        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_keepAliveAsync(
            AdminSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            obj.keepAlive(request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getAdminAsync(
            AdminSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.getAdmin(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            AdminPrxHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getAdminCallbackTemplateAsync(
            AdminSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.getAdminCallbackTemplate(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeProxy(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_setObserversAsync(
            AdminSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            RegistryObserverPrx? iceP_registryObs;
            NodeObserverPrx? iceP_nodeObs;
            ApplicationObserverPrx? iceP_appObs;
            AdapterObserverPrx? iceP_adptObs;
            ObjectObserverPrx? iceP_objObs;
            iceP_registryObs = RegistryObserverPrxHelper.read(istr);
            iceP_nodeObs = NodeObserverPrxHelper.read(istr);
            iceP_appObs = ApplicationObserverPrxHelper.read(istr);
            iceP_adptObs = AdapterObserverPrxHelper.read(istr);
            iceP_objObs = ObjectObserverPrxHelper.read(istr);
            istr.endEncapsulation();
            obj.setObservers(iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_setObserversByIdentityAsync(
            AdminSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            global::Ice.Identity iceP_registryObs;
            global::Ice.Identity iceP_nodeObs;
            global::Ice.Identity iceP_appObs;
            global::Ice.Identity iceP_adptObs;
            global::Ice.Identity iceP_objObs;
            iceP_registryObs = new global::Ice.Identity(istr);
            iceP_nodeObs = new global::Ice.Identity(istr);
            iceP_appObs = new global::Ice.Identity(istr);
            iceP_adptObs = new global::Ice.Identity(istr);
            iceP_objObs = new global::Ice.Identity(istr);
            istr.endEncapsulation();
            obj.setObserversByIdentity(iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs, request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_startUpdateAsync(
            AdminSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.startUpdate(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeInt(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_finishUpdateAsync(
            AdminSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            obj.finishUpdate(request.current);
            return new(Ice.CurrentExtensions.createEmptyOutgoingResponse(request.current));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_getReplicaNameAsync(
            AdminSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Idempotent, request.current.mode);
            request.inputStream.skipEmptyEncapsulation();
            var ret = obj.getReplicaName(request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            ostr.writeString(ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_openServerLogAsync(
            AdminSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_id;
            string iceP_path;
            int iceP_count;
            iceP_id = istr.readString();
            iceP_path = istr.readString();
            iceP_count = istr.readInt();
            istr.endEncapsulation();
            var ret = obj.openServerLog(iceP_id, iceP_path, iceP_count, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            FileIteratorPrxHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_openServerStdErrAsync(
            AdminSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_id;
            int iceP_count;
            iceP_id = istr.readString();
            iceP_count = istr.readInt();
            istr.endEncapsulation();
            var ret = obj.openServerStdErr(iceP_id, iceP_count, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            FileIteratorPrxHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_openServerStdOutAsync(
            AdminSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_id;
            int iceP_count;
            iceP_id = istr.readString();
            iceP_count = istr.readInt();
            istr.endEncapsulation();
            var ret = obj.openServerStdOut(iceP_id, iceP_count, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            FileIteratorPrxHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_openNodeStdErrAsync(
            AdminSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_name;
            int iceP_count;
            iceP_name = istr.readString();
            iceP_count = istr.readInt();
            istr.endEncapsulation();
            var ret = obj.openNodeStdErr(iceP_name, iceP_count, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            FileIteratorPrxHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_openNodeStdOutAsync(
            AdminSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_name;
            int iceP_count;
            iceP_name = istr.readString();
            iceP_count = istr.readInt();
            istr.endEncapsulation();
            var ret = obj.openNodeStdOut(iceP_name, iceP_count, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            FileIteratorPrxHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_openRegistryStdErrAsync(
            AdminSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_name;
            int iceP_count;
            iceP_name = istr.readString();
            iceP_count = istr.readInt();
            istr.endEncapsulation();
            var ret = obj.openRegistryStdErr(iceP_name, iceP_count, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            FileIteratorPrxHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }

        protected static global::System.Threading.Tasks.ValueTask<Ice.OutgoingResponse> iceD_openRegistryStdOutAsync(
            AdminSession obj,
            Ice.IncomingRequest request)
        {
            Ice.ObjectImpl.iceCheckMode(Ice.OperationMode.Normal, request.current.mode);
            var istr = request.inputStream;
            istr.startEncapsulation();
            string iceP_name;
            int iceP_count;
            iceP_name = istr.readString();
            iceP_count = istr.readInt();
            istr.endEncapsulation();
            var ret = obj.openRegistryStdOut(iceP_name, iceP_count, request.current);
            var ostr = Ice.CurrentExtensions.startReplyStream(request.current);
            ostr.startEncapsulation(request.current.encoding, null);
            FileIteratorPrxHelper.write(ostr, ret);
            ostr.endEncapsulation();
            return new(new Ice.OutgoingResponse(ostr));
        }
    }
}
