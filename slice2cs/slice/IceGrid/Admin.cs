//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Admin.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//


using _System = global::System;

#pragma warning disable 1591

namespace IceGrid
{
    /// <summary>
    /// An enumeration representing the state of the server.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public enum ServerState
    {
        /// <summary>
        /// The server is not running.
        /// </summary>

        Inactive,
        /// <summary>
        /// The server is being activated and will change to the active state when the registered server object adapters
        ///  are activated or to the activation timed out state if the activation timeout expires.
        /// </summary>

        Activating,
        /// <summary>
        /// The activation timed out state indicates that the server activation timed out.
        /// </summary>

        ActivationTimedOut,
        /// <summary>
        /// The server is running.
        /// </summary>

        Active,
        /// <summary>
        /// The server is being deactivated.
        /// </summary>

        Deactivating,
        /// <summary>
        /// The server is being destroyed.
        /// </summary>

        Destroying,
        /// <summary>
        /// The server is destroyed.
        /// </summary>

        Destroyed
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public sealed class ServerStateHelper
    {
        public static void write(global::Ice.OutputStream ostr, ServerState v)
        {
            ostr.writeEnum((int)v, 6);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static ServerState read(global::Ice.InputStream istr)
        {
            ServerState v;
            v = (ServerState)istr.readEnum(6);
            return v;
        }
    }

    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial class ObjectInfo : global::System.ICloneable
    {
        #region Slice data members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public global::Ice.ObjectPrx proxy;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public string type;

        #endregion

        partial void ice_initialize();

        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public ObjectInfo()
        {
            this.type = "";
            ice_initialize();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public ObjectInfo(global::Ice.ObjectPrx proxy, string type)
        {
            this.proxy = proxy;
            this.type = type;
            ice_initialize();
        }

        #endregion

        #region ICloneable members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public object Clone()
        {
            return MemberwiseClone();
        }

        #endregion

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public override int GetHashCode()
        {
            int h_ = 5381;
            global::IceInternal.HashUtil.hashAdd(ref h_, "::IceGrid::ObjectInfo");
            global::IceInternal.HashUtil.hashAdd(ref h_, proxy);
            global::IceInternal.HashUtil.hashAdd(ref h_, type);
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public override bool Equals(object other)
        {
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            if(other == null)
            {
                return false;
            }
            if(GetType() != other.GetType())
            {
                return false;
            }
            ObjectInfo o = (ObjectInfo)other;
            if(this.proxy == null)
            {
                if(o.proxy != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.proxy.Equals(o.proxy))
                {
                    return false;
                }
            }
            if(this.type == null)
            {
                if(o.type != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.type.Equals(o.type))
                {
                    return false;
                }
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static bool operator==(ObjectInfo lhs, ObjectInfo rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static bool operator!=(ObjectInfo lhs, ObjectInfo rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public void ice_writeMembers(global::Ice.OutputStream ostr)
        {
            ostr.writeProxy(this.proxy);
            ostr.writeString(this.type);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public void ice_readMembers(global::Ice.InputStream istr)
        {
            this.proxy = istr.readProxy();
            this.type = istr.readString();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static void ice_write(global::Ice.OutputStream ostr, ObjectInfo v)
        {
            if(v == null)
            {
                _nullMarshalValue.ice_writeMembers(ostr);
            }
            else
            {
                v.ice_writeMembers(ostr);
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static ObjectInfo ice_read(global::Ice.InputStream istr)
        {
            var v = new ObjectInfo();
            v.ice_readMembers(istr);
            return v;
        }

        private static readonly ObjectInfo _nullMarshalValue = new ObjectInfo();

        #endregion
    }

    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial class AdapterInfo : global::System.ICloneable
    {
        #region Slice data members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public string id;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public global::Ice.ObjectPrx proxy;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public string replicaGroupId;

        #endregion

        partial void ice_initialize();

        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public AdapterInfo()
        {
            this.id = "";
            this.replicaGroupId = "";
            ice_initialize();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public AdapterInfo(string id, global::Ice.ObjectPrx proxy, string replicaGroupId)
        {
            this.id = id;
            this.proxy = proxy;
            this.replicaGroupId = replicaGroupId;
            ice_initialize();
        }

        #endregion

        #region ICloneable members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public object Clone()
        {
            return MemberwiseClone();
        }

        #endregion

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public override int GetHashCode()
        {
            int h_ = 5381;
            global::IceInternal.HashUtil.hashAdd(ref h_, "::IceGrid::AdapterInfo");
            global::IceInternal.HashUtil.hashAdd(ref h_, id);
            global::IceInternal.HashUtil.hashAdd(ref h_, proxy);
            global::IceInternal.HashUtil.hashAdd(ref h_, replicaGroupId);
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public override bool Equals(object other)
        {
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            if(other == null)
            {
                return false;
            }
            if(GetType() != other.GetType())
            {
                return false;
            }
            AdapterInfo o = (AdapterInfo)other;
            if(this.id == null)
            {
                if(o.id != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.id.Equals(o.id))
                {
                    return false;
                }
            }
            if(this.proxy == null)
            {
                if(o.proxy != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.proxy.Equals(o.proxy))
                {
                    return false;
                }
            }
            if(this.replicaGroupId == null)
            {
                if(o.replicaGroupId != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.replicaGroupId.Equals(o.replicaGroupId))
                {
                    return false;
                }
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static bool operator==(AdapterInfo lhs, AdapterInfo rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static bool operator!=(AdapterInfo lhs, AdapterInfo rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public void ice_writeMembers(global::Ice.OutputStream ostr)
        {
            ostr.writeString(this.id);
            ostr.writeProxy(this.proxy);
            ostr.writeString(this.replicaGroupId);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public void ice_readMembers(global::Ice.InputStream istr)
        {
            this.id = istr.readString();
            this.proxy = istr.readProxy();
            this.replicaGroupId = istr.readString();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static void ice_write(global::Ice.OutputStream ostr, AdapterInfo v)
        {
            if(v == null)
            {
                _nullMarshalValue.ice_writeMembers(ostr);
            }
            else
            {
                v.ice_writeMembers(ostr);
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static AdapterInfo ice_read(global::Ice.InputStream istr)
        {
            var v = new AdapterInfo();
            v.ice_readMembers(istr);
            return v;
        }

        private static readonly AdapterInfo _nullMarshalValue = new AdapterInfo();

        #endregion
    }

    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial class ServerInfo : global::System.ICloneable
    {
        #region Slice data members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public string application;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public string uuid;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public int revision;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public string node;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public ServerDescriptor descriptor;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public string sessionId;

        #endregion

        partial void ice_initialize();

        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public ServerInfo()
        {
            this.application = "";
            this.uuid = "";
            this.node = "";
            this.sessionId = "";
            ice_initialize();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public ServerInfo(string application, string uuid, int revision, string node, ServerDescriptor descriptor, string sessionId)
        {
            this.application = application;
            this.uuid = uuid;
            this.revision = revision;
            this.node = node;
            this.descriptor = descriptor;
            this.sessionId = sessionId;
            ice_initialize();
        }

        #endregion

        #region ICloneable members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public object Clone()
        {
            return MemberwiseClone();
        }

        #endregion

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public override int GetHashCode()
        {
            int h_ = 5381;
            global::IceInternal.HashUtil.hashAdd(ref h_, "::IceGrid::ServerInfo");
            global::IceInternal.HashUtil.hashAdd(ref h_, application);
            global::IceInternal.HashUtil.hashAdd(ref h_, uuid);
            global::IceInternal.HashUtil.hashAdd(ref h_, revision);
            global::IceInternal.HashUtil.hashAdd(ref h_, node);
            global::IceInternal.HashUtil.hashAdd(ref h_, descriptor);
            global::IceInternal.HashUtil.hashAdd(ref h_, sessionId);
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public override bool Equals(object other)
        {
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            if(other == null)
            {
                return false;
            }
            if(GetType() != other.GetType())
            {
                return false;
            }
            ServerInfo o = (ServerInfo)other;
            if(this.application == null)
            {
                if(o.application != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.application.Equals(o.application))
                {
                    return false;
                }
            }
            if(this.uuid == null)
            {
                if(o.uuid != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.uuid.Equals(o.uuid))
                {
                    return false;
                }
            }
            if(!this.revision.Equals(o.revision))
            {
                return false;
            }
            if(this.node == null)
            {
                if(o.node != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.node.Equals(o.node))
                {
                    return false;
                }
            }
            if(this.descriptor == null)
            {
                if(o.descriptor != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.descriptor.Equals(o.descriptor))
                {
                    return false;
                }
            }
            if(this.sessionId == null)
            {
                if(o.sessionId != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.sessionId.Equals(o.sessionId))
                {
                    return false;
                }
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static bool operator==(ServerInfo lhs, ServerInfo rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static bool operator!=(ServerInfo lhs, ServerInfo rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public void ice_writeMembers(global::Ice.OutputStream ostr)
        {
            ostr.writeString(this.application);
            ostr.writeString(this.uuid);
            ostr.writeInt(this.revision);
            ostr.writeString(this.node);
            ostr.writeValue(this.descriptor);
            ostr.writeString(this.sessionId);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public void ice_readMembers(global::Ice.InputStream istr)
        {
            this.application = istr.readString();
            this.uuid = istr.readString();
            this.revision = istr.readInt();
            this.node = istr.readString();
            istr.readValue((ServerDescriptor v) => { this.descriptor = v; });
            this.sessionId = istr.readString();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static void ice_write(global::Ice.OutputStream ostr, ServerInfo v)
        {
            if(v == null)
            {
                _nullMarshalValue.ice_writeMembers(ostr);
            }
            else
            {
                v.ice_writeMembers(ostr);
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static ServerInfo ice_read(global::Ice.InputStream istr)
        {
            var v = new ServerInfo();
            v.ice_readMembers(istr);
            return v;
        }

        private static readonly ServerInfo _nullMarshalValue = new ServerInfo();

        #endregion
    }

    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial class NodeInfo : global::System.ICloneable
    {
        #region Slice data members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public string name;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public string os;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public string hostname;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public string release;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public string version;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public string machine;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public int nProcessors;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public string dataDir;

        #endregion

        partial void ice_initialize();

        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public NodeInfo()
        {
            this.name = "";
            this.os = "";
            this.hostname = "";
            this.release = "";
            this.version = "";
            this.machine = "";
            this.dataDir = "";
            ice_initialize();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public NodeInfo(string name, string os, string hostname, string release, string version, string machine, int nProcessors, string dataDir)
        {
            this.name = name;
            this.os = os;
            this.hostname = hostname;
            this.release = release;
            this.version = version;
            this.machine = machine;
            this.nProcessors = nProcessors;
            this.dataDir = dataDir;
            ice_initialize();
        }

        #endregion

        #region ICloneable members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public object Clone()
        {
            return MemberwiseClone();
        }

        #endregion

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public override int GetHashCode()
        {
            int h_ = 5381;
            global::IceInternal.HashUtil.hashAdd(ref h_, "::IceGrid::NodeInfo");
            global::IceInternal.HashUtil.hashAdd(ref h_, name);
            global::IceInternal.HashUtil.hashAdd(ref h_, os);
            global::IceInternal.HashUtil.hashAdd(ref h_, hostname);
            global::IceInternal.HashUtil.hashAdd(ref h_, release);
            global::IceInternal.HashUtil.hashAdd(ref h_, version);
            global::IceInternal.HashUtil.hashAdd(ref h_, machine);
            global::IceInternal.HashUtil.hashAdd(ref h_, nProcessors);
            global::IceInternal.HashUtil.hashAdd(ref h_, dataDir);
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public override bool Equals(object other)
        {
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            if(other == null)
            {
                return false;
            }
            if(GetType() != other.GetType())
            {
                return false;
            }
            NodeInfo o = (NodeInfo)other;
            if(this.name == null)
            {
                if(o.name != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.name.Equals(o.name))
                {
                    return false;
                }
            }
            if(this.os == null)
            {
                if(o.os != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.os.Equals(o.os))
                {
                    return false;
                }
            }
            if(this.hostname == null)
            {
                if(o.hostname != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.hostname.Equals(o.hostname))
                {
                    return false;
                }
            }
            if(this.release == null)
            {
                if(o.release != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.release.Equals(o.release))
                {
                    return false;
                }
            }
            if(this.version == null)
            {
                if(o.version != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.version.Equals(o.version))
                {
                    return false;
                }
            }
            if(this.machine == null)
            {
                if(o.machine != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.machine.Equals(o.machine))
                {
                    return false;
                }
            }
            if(!this.nProcessors.Equals(o.nProcessors))
            {
                return false;
            }
            if(this.dataDir == null)
            {
                if(o.dataDir != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.dataDir.Equals(o.dataDir))
                {
                    return false;
                }
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static bool operator==(NodeInfo lhs, NodeInfo rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static bool operator!=(NodeInfo lhs, NodeInfo rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public void ice_writeMembers(global::Ice.OutputStream ostr)
        {
            ostr.writeString(this.name);
            ostr.writeString(this.os);
            ostr.writeString(this.hostname);
            ostr.writeString(this.release);
            ostr.writeString(this.version);
            ostr.writeString(this.machine);
            ostr.writeInt(this.nProcessors);
            ostr.writeString(this.dataDir);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public void ice_readMembers(global::Ice.InputStream istr)
        {
            this.name = istr.readString();
            this.os = istr.readString();
            this.hostname = istr.readString();
            this.release = istr.readString();
            this.version = istr.readString();
            this.machine = istr.readString();
            this.nProcessors = istr.readInt();
            this.dataDir = istr.readString();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static void ice_write(global::Ice.OutputStream ostr, NodeInfo v)
        {
            if(v == null)
            {
                _nullMarshalValue.ice_writeMembers(ostr);
            }
            else
            {
                v.ice_writeMembers(ostr);
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static NodeInfo ice_read(global::Ice.InputStream istr)
        {
            var v = new NodeInfo();
            v.ice_readMembers(istr);
            return v;
        }

        private static readonly NodeInfo _nullMarshalValue = new NodeInfo();

        #endregion
    }

    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial class RegistryInfo : global::System.ICloneable
    {
        #region Slice data members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public string name;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public string hostname;

        #endregion

        partial void ice_initialize();

        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public RegistryInfo()
        {
            this.name = "";
            this.hostname = "";
            ice_initialize();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public RegistryInfo(string name, string hostname)
        {
            this.name = name;
            this.hostname = hostname;
            ice_initialize();
        }

        #endregion

        #region ICloneable members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public object Clone()
        {
            return MemberwiseClone();
        }

        #endregion

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public override int GetHashCode()
        {
            int h_ = 5381;
            global::IceInternal.HashUtil.hashAdd(ref h_, "::IceGrid::RegistryInfo");
            global::IceInternal.HashUtil.hashAdd(ref h_, name);
            global::IceInternal.HashUtil.hashAdd(ref h_, hostname);
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public override bool Equals(object other)
        {
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            if(other == null)
            {
                return false;
            }
            if(GetType() != other.GetType())
            {
                return false;
            }
            RegistryInfo o = (RegistryInfo)other;
            if(this.name == null)
            {
                if(o.name != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.name.Equals(o.name))
                {
                    return false;
                }
            }
            if(this.hostname == null)
            {
                if(o.hostname != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.hostname.Equals(o.hostname))
                {
                    return false;
                }
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static bool operator==(RegistryInfo lhs, RegistryInfo rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static bool operator!=(RegistryInfo lhs, RegistryInfo rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public void ice_writeMembers(global::Ice.OutputStream ostr)
        {
            ostr.writeString(this.name);
            ostr.writeString(this.hostname);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public void ice_readMembers(global::Ice.InputStream istr)
        {
            this.name = istr.readString();
            this.hostname = istr.readString();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static void ice_write(global::Ice.OutputStream ostr, RegistryInfo v)
        {
            if(v == null)
            {
                _nullMarshalValue.ice_writeMembers(ostr);
            }
            else
            {
                v.ice_writeMembers(ostr);
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static RegistryInfo ice_read(global::Ice.InputStream istr)
        {
            var v = new RegistryInfo();
            v.ice_readMembers(istr);
            return v;
        }

        private static readonly RegistryInfo _nullMarshalValue = new RegistryInfo();

        #endregion
    }

    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial struct LoadInfo
    {
        #region Slice data members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public float avg1;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public float avg5;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public float avg15;

        #endregion

        partial void ice_initialize();

        #region Constructor

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public LoadInfo(float avg1, float avg5, float avg15)
        {
            this.avg1 = avg1;
            this.avg5 = avg5;
            this.avg15 = avg15;
            ice_initialize();
        }

        #endregion

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public override int GetHashCode()
        {
            int h_ = 5381;
            global::IceInternal.HashUtil.hashAdd(ref h_, "::IceGrid::LoadInfo");
            global::IceInternal.HashUtil.hashAdd(ref h_, avg1);
            global::IceInternal.HashUtil.hashAdd(ref h_, avg5);
            global::IceInternal.HashUtil.hashAdd(ref h_, avg15);
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public override bool Equals(object other)
        {
            if(!(other is LoadInfo))
            {
                return false;
            }
            LoadInfo o = (LoadInfo)other;
            if(!this.avg1.Equals(o.avg1))
            {
                return false;
            }
            if(!this.avg5.Equals(o.avg5))
            {
                return false;
            }
            if(!this.avg15.Equals(o.avg15))
            {
                return false;
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static bool operator==(LoadInfo lhs, LoadInfo rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static bool operator!=(LoadInfo lhs, LoadInfo rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public void ice_writeMembers(global::Ice.OutputStream ostr)
        {
            ostr.writeFloat(this.avg1);
            ostr.writeFloat(this.avg5);
            ostr.writeFloat(this.avg15);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public void ice_readMembers(global::Ice.InputStream istr)
        {
            this.avg1 = istr.readFloat();
            this.avg5 = istr.readFloat();
            this.avg15 = istr.readFloat();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static void ice_write(global::Ice.OutputStream ostr, LoadInfo v)
        {
            v.ice_writeMembers(ostr);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static LoadInfo ice_read(global::Ice.InputStream istr)
        {
            var v = new LoadInfo();
            v.ice_readMembers(istr);
            return v;
        }

        #endregion
    }

    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial class ApplicationInfo : global::System.ICloneable
    {
        #region Slice data members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public string uuid;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public long createTime;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public string createUser;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public long updateTime;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public string updateUser;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public int revision;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public ApplicationDescriptor descriptor;

        #endregion

        partial void ice_initialize();

        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public ApplicationInfo()
        {
            this.uuid = "";
            this.createUser = "";
            this.updateUser = "";
            this.descriptor = new ApplicationDescriptor();
            ice_initialize();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public ApplicationInfo(string uuid, long createTime, string createUser, long updateTime, string updateUser, int revision, ApplicationDescriptor descriptor)
        {
            this.uuid = uuid;
            this.createTime = createTime;
            this.createUser = createUser;
            this.updateTime = updateTime;
            this.updateUser = updateUser;
            this.revision = revision;
            this.descriptor = descriptor;
            ice_initialize();
        }

        #endregion

        #region ICloneable members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public object Clone()
        {
            return MemberwiseClone();
        }

        #endregion

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public override int GetHashCode()
        {
            int h_ = 5381;
            global::IceInternal.HashUtil.hashAdd(ref h_, "::IceGrid::ApplicationInfo");
            global::IceInternal.HashUtil.hashAdd(ref h_, uuid);
            global::IceInternal.HashUtil.hashAdd(ref h_, createTime);
            global::IceInternal.HashUtil.hashAdd(ref h_, createUser);
            global::IceInternal.HashUtil.hashAdd(ref h_, updateTime);
            global::IceInternal.HashUtil.hashAdd(ref h_, updateUser);
            global::IceInternal.HashUtil.hashAdd(ref h_, revision);
            global::IceInternal.HashUtil.hashAdd(ref h_, descriptor);
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public override bool Equals(object other)
        {
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            if(other == null)
            {
                return false;
            }
            if(GetType() != other.GetType())
            {
                return false;
            }
            ApplicationInfo o = (ApplicationInfo)other;
            if(this.uuid == null)
            {
                if(o.uuid != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.uuid.Equals(o.uuid))
                {
                    return false;
                }
            }
            if(!this.createTime.Equals(o.createTime))
            {
                return false;
            }
            if(this.createUser == null)
            {
                if(o.createUser != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.createUser.Equals(o.createUser))
                {
                    return false;
                }
            }
            if(!this.updateTime.Equals(o.updateTime))
            {
                return false;
            }
            if(this.updateUser == null)
            {
                if(o.updateUser != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.updateUser.Equals(o.updateUser))
                {
                    return false;
                }
            }
            if(!this.revision.Equals(o.revision))
            {
                return false;
            }
            if(this.descriptor == null)
            {
                if(o.descriptor != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.descriptor.Equals(o.descriptor))
                {
                    return false;
                }
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static bool operator==(ApplicationInfo lhs, ApplicationInfo rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static bool operator!=(ApplicationInfo lhs, ApplicationInfo rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public void ice_writeMembers(global::Ice.OutputStream ostr)
        {
            ostr.writeString(this.uuid);
            ostr.writeLong(this.createTime);
            ostr.writeString(this.createUser);
            ostr.writeLong(this.updateTime);
            ostr.writeString(this.updateUser);
            ostr.writeInt(this.revision);
            ApplicationDescriptor.ice_write(ostr, this.descriptor);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public void ice_readMembers(global::Ice.InputStream istr)
        {
            this.uuid = istr.readString();
            this.createTime = istr.readLong();
            this.createUser = istr.readString();
            this.updateTime = istr.readLong();
            this.updateUser = istr.readString();
            this.revision = istr.readInt();
            this.descriptor = ApplicationDescriptor.ice_read(istr);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static void ice_write(global::Ice.OutputStream ostr, ApplicationInfo v)
        {
            if(v == null)
            {
                _nullMarshalValue.ice_writeMembers(ostr);
            }
            else
            {
                v.ice_writeMembers(ostr);
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static ApplicationInfo ice_read(global::Ice.InputStream istr)
        {
            var v = new ApplicationInfo();
            v.ice_readMembers(istr);
            return v;
        }

        private static readonly ApplicationInfo _nullMarshalValue = new ApplicationInfo();

        #endregion
    }

    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial class ApplicationUpdateInfo : global::System.ICloneable
    {
        #region Slice data members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public long updateTime;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public string updateUser;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public int revision;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public ApplicationUpdateDescriptor descriptor;

        #endregion

        partial void ice_initialize();

        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public ApplicationUpdateInfo()
        {
            this.updateUser = "";
            this.descriptor = new ApplicationUpdateDescriptor();
            ice_initialize();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public ApplicationUpdateInfo(long updateTime, string updateUser, int revision, ApplicationUpdateDescriptor descriptor)
        {
            this.updateTime = updateTime;
            this.updateUser = updateUser;
            this.revision = revision;
            this.descriptor = descriptor;
            ice_initialize();
        }

        #endregion

        #region ICloneable members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public object Clone()
        {
            return MemberwiseClone();
        }

        #endregion

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public override int GetHashCode()
        {
            int h_ = 5381;
            global::IceInternal.HashUtil.hashAdd(ref h_, "::IceGrid::ApplicationUpdateInfo");
            global::IceInternal.HashUtil.hashAdd(ref h_, updateTime);
            global::IceInternal.HashUtil.hashAdd(ref h_, updateUser);
            global::IceInternal.HashUtil.hashAdd(ref h_, revision);
            global::IceInternal.HashUtil.hashAdd(ref h_, descriptor);
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public override bool Equals(object other)
        {
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            if(other == null)
            {
                return false;
            }
            if(GetType() != other.GetType())
            {
                return false;
            }
            ApplicationUpdateInfo o = (ApplicationUpdateInfo)other;
            if(!this.updateTime.Equals(o.updateTime))
            {
                return false;
            }
            if(this.updateUser == null)
            {
                if(o.updateUser != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.updateUser.Equals(o.updateUser))
                {
                    return false;
                }
            }
            if(!this.revision.Equals(o.revision))
            {
                return false;
            }
            if(this.descriptor == null)
            {
                if(o.descriptor != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.descriptor.Equals(o.descriptor))
                {
                    return false;
                }
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static bool operator==(ApplicationUpdateInfo lhs, ApplicationUpdateInfo rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static bool operator!=(ApplicationUpdateInfo lhs, ApplicationUpdateInfo rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public void ice_writeMembers(global::Ice.OutputStream ostr)
        {
            ostr.writeLong(this.updateTime);
            ostr.writeString(this.updateUser);
            ostr.writeInt(this.revision);
            ApplicationUpdateDescriptor.ice_write(ostr, this.descriptor);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public void ice_readMembers(global::Ice.InputStream istr)
        {
            this.updateTime = istr.readLong();
            this.updateUser = istr.readString();
            this.revision = istr.readInt();
            this.descriptor = ApplicationUpdateDescriptor.ice_read(istr);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static void ice_write(global::Ice.OutputStream ostr, ApplicationUpdateInfo v)
        {
            if(v == null)
            {
                _nullMarshalValue.ice_writeMembers(ostr);
            }
            else
            {
                v.ice_writeMembers(ostr);
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static ApplicationUpdateInfo ice_read(global::Ice.InputStream istr)
        {
            var v = new ApplicationUpdateInfo();
            v.ice_readMembers(istr);
            return v;
        }

        private static readonly ApplicationUpdateInfo _nullMarshalValue = new ApplicationUpdateInfo();

        #endregion
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial interface Admin : global::Ice.Object, AdminOperations_
    {
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial interface FileIterator : global::Ice.Object, FileIteratorOperations_
    {
    }

    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial class ServerDynamicInfo : global::System.ICloneable
    {
        #region Slice data members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public string id;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public ServerState state;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public int pid;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public bool enabled;

        #endregion

        partial void ice_initialize();

        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public ServerDynamicInfo()
        {
            this.id = "";
            ice_initialize();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public ServerDynamicInfo(string id, ServerState state, int pid, bool enabled)
        {
            this.id = id;
            this.state = state;
            this.pid = pid;
            this.enabled = enabled;
            ice_initialize();
        }

        #endregion

        #region ICloneable members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public object Clone()
        {
            return MemberwiseClone();
        }

        #endregion

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public override int GetHashCode()
        {
            int h_ = 5381;
            global::IceInternal.HashUtil.hashAdd(ref h_, "::IceGrid::ServerDynamicInfo");
            global::IceInternal.HashUtil.hashAdd(ref h_, id);
            global::IceInternal.HashUtil.hashAdd(ref h_, state);
            global::IceInternal.HashUtil.hashAdd(ref h_, pid);
            global::IceInternal.HashUtil.hashAdd(ref h_, enabled);
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public override bool Equals(object other)
        {
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            if(other == null)
            {
                return false;
            }
            if(GetType() != other.GetType())
            {
                return false;
            }
            ServerDynamicInfo o = (ServerDynamicInfo)other;
            if(this.id == null)
            {
                if(o.id != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.id.Equals(o.id))
                {
                    return false;
                }
            }
            if(!this.state.Equals(o.state))
            {
                return false;
            }
            if(!this.pid.Equals(o.pid))
            {
                return false;
            }
            if(!this.enabled.Equals(o.enabled))
            {
                return false;
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static bool operator==(ServerDynamicInfo lhs, ServerDynamicInfo rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static bool operator!=(ServerDynamicInfo lhs, ServerDynamicInfo rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public void ice_writeMembers(global::Ice.OutputStream ostr)
        {
            ostr.writeString(this.id);
            ostr.writeEnum((int)this.state, 6);
            ostr.writeInt(this.pid);
            ostr.writeBool(this.enabled);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public void ice_readMembers(global::Ice.InputStream istr)
        {
            this.id = istr.readString();
            this.state = (ServerState)istr.readEnum(6);
            this.pid = istr.readInt();
            this.enabled = istr.readBool();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static void ice_write(global::Ice.OutputStream ostr, ServerDynamicInfo v)
        {
            if(v == null)
            {
                _nullMarshalValue.ice_writeMembers(ostr);
            }
            else
            {
                v.ice_writeMembers(ostr);
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static ServerDynamicInfo ice_read(global::Ice.InputStream istr)
        {
            var v = new ServerDynamicInfo();
            v.ice_readMembers(istr);
            return v;
        }

        private static readonly ServerDynamicInfo _nullMarshalValue = new ServerDynamicInfo();

        #endregion
    }

    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial class AdapterDynamicInfo : global::System.ICloneable
    {
        #region Slice data members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public string id;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public global::Ice.ObjectPrx proxy;

        #endregion

        partial void ice_initialize();

        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public AdapterDynamicInfo()
        {
            this.id = "";
            ice_initialize();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public AdapterDynamicInfo(string id, global::Ice.ObjectPrx proxy)
        {
            this.id = id;
            this.proxy = proxy;
            ice_initialize();
        }

        #endregion

        #region ICloneable members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public object Clone()
        {
            return MemberwiseClone();
        }

        #endregion

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public override int GetHashCode()
        {
            int h_ = 5381;
            global::IceInternal.HashUtil.hashAdd(ref h_, "::IceGrid::AdapterDynamicInfo");
            global::IceInternal.HashUtil.hashAdd(ref h_, id);
            global::IceInternal.HashUtil.hashAdd(ref h_, proxy);
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public override bool Equals(object other)
        {
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            if(other == null)
            {
                return false;
            }
            if(GetType() != other.GetType())
            {
                return false;
            }
            AdapterDynamicInfo o = (AdapterDynamicInfo)other;
            if(this.id == null)
            {
                if(o.id != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.id.Equals(o.id))
                {
                    return false;
                }
            }
            if(this.proxy == null)
            {
                if(o.proxy != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.proxy.Equals(o.proxy))
                {
                    return false;
                }
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static bool operator==(AdapterDynamicInfo lhs, AdapterDynamicInfo rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static bool operator!=(AdapterDynamicInfo lhs, AdapterDynamicInfo rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public void ice_writeMembers(global::Ice.OutputStream ostr)
        {
            ostr.writeString(this.id);
            ostr.writeProxy(this.proxy);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public void ice_readMembers(global::Ice.InputStream istr)
        {
            this.id = istr.readString();
            this.proxy = istr.readProxy();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static void ice_write(global::Ice.OutputStream ostr, AdapterDynamicInfo v)
        {
            if(v == null)
            {
                _nullMarshalValue.ice_writeMembers(ostr);
            }
            else
            {
                v.ice_writeMembers(ostr);
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static AdapterDynamicInfo ice_read(global::Ice.InputStream istr)
        {
            var v = new AdapterDynamicInfo();
            v.ice_readMembers(istr);
            return v;
        }

        private static readonly AdapterDynamicInfo _nullMarshalValue = new AdapterDynamicInfo();

        #endregion
    }

    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial class NodeDynamicInfo : global::System.ICloneable
    {
        #region Slice data members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public NodeInfo info;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public ServerDynamicInfo[] servers;

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public AdapterDynamicInfo[] adapters;

        #endregion

        partial void ice_initialize();

        #region Constructors

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public NodeDynamicInfo()
        {
            this.info = new NodeInfo();
            ice_initialize();
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public NodeDynamicInfo(NodeInfo info, ServerDynamicInfo[] servers, AdapterDynamicInfo[] adapters)
        {
            this.info = info;
            this.servers = servers;
            this.adapters = adapters;
            ice_initialize();
        }

        #endregion

        #region ICloneable members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public object Clone()
        {
            return MemberwiseClone();
        }

        #endregion

        #region Object members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public override int GetHashCode()
        {
            int h_ = 5381;
            global::IceInternal.HashUtil.hashAdd(ref h_, "::IceGrid::NodeDynamicInfo");
            global::IceInternal.HashUtil.hashAdd(ref h_, info);
            global::IceInternal.HashUtil.hashAdd(ref h_, servers);
            global::IceInternal.HashUtil.hashAdd(ref h_, adapters);
            return h_;
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public override bool Equals(object other)
        {
            if(object.ReferenceEquals(this, other))
            {
                return true;
            }
            if(other == null)
            {
                return false;
            }
            if(GetType() != other.GetType())
            {
                return false;
            }
            NodeDynamicInfo o = (NodeDynamicInfo)other;
            if(this.info == null)
            {
                if(o.info != null)
                {
                    return false;
                }
            }
            else
            {
                if(!this.info.Equals(o.info))
                {
                    return false;
                }
            }
            if(this.servers == null)
            {
                if(o.servers != null)
                {
                    return false;
                }
            }
            else
            {
                if(!IceUtilInternal.Arrays.Equals(this.servers, o.servers))
                {
                    return false;
                }
            }
            if(this.adapters == null)
            {
                if(o.adapters != null)
                {
                    return false;
                }
            }
            else
            {
                if(!IceUtilInternal.Arrays.Equals(this.adapters, o.adapters))
                {
                    return false;
                }
            }
            return true;
        }

        #endregion

        #region Comparison members

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static bool operator==(NodeDynamicInfo lhs, NodeDynamicInfo rhs)
        {
            return Equals(lhs, rhs);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static bool operator!=(NodeDynamicInfo lhs, NodeDynamicInfo rhs)
        {
            return !Equals(lhs, rhs);
        }

        #endregion

        #region Marshaling support

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public void ice_writeMembers(global::Ice.OutputStream ostr)
        {
            NodeInfo.ice_write(ostr, this.info);
            ServerDynamicInfoSeqHelper.write(ostr, this.servers);
            AdapterDynamicInfoSeqHelper.write(ostr, this.adapters);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public void ice_readMembers(global::Ice.InputStream istr)
        {
            this.info = NodeInfo.ice_read(istr);
            this.servers = ServerDynamicInfoSeqHelper.read(istr);
            this.adapters = AdapterDynamicInfoSeqHelper.read(istr);
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static void ice_write(global::Ice.OutputStream ostr, NodeDynamicInfo v)
        {
            if(v == null)
            {
                _nullMarshalValue.ice_writeMembers(ostr);
            }
            else
            {
                v.ice_writeMembers(ostr);
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        public static NodeDynamicInfo ice_read(global::Ice.InputStream istr)
        {
            var v = new NodeDynamicInfo();
            v.ice_readMembers(istr);
            return v;
        }

        private static readonly NodeDynamicInfo _nullMarshalValue = new NodeDynamicInfo();

        #endregion
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial interface RegistryObserver : global::Ice.Object, RegistryObserverOperations_
    {
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial interface NodeObserver : global::Ice.Object, NodeObserverOperations_
    {
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial interface ApplicationObserver : global::Ice.Object, ApplicationObserverOperations_
    {
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial interface AdapterObserver : global::Ice.Object, AdapterObserverOperations_
    {
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial interface ObjectObserver : global::Ice.Object, ObjectObserverOperations_
    {
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1715")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1722")]
    [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1724")]
    public partial interface AdminSession : global::Ice.Object, AdminSessionOperations_, global::Glacier2.Session
    {
    }
}

namespace IceGrid
{
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_addApplication();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_syncApplication();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_updateApplication();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_syncApplicationWithoutRestart();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_updateApplicationWithoutRestart();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_removeApplication();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_instantiateServer();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_getApplicationInfo(ApplicationInfo ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_getDefaultApplicationDescriptor(ApplicationDescriptor ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_getAllApplicationNames(string[] ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_getServerInfo(ServerInfo ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_getServerState(ServerState ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_getServerPid(int ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_getServerAdminCategory(string ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_getServerAdmin(global::Ice.ObjectPrx ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_enableServer();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_isServerEnabled(bool ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_startServer();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_stopServer();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_sendSignal();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_getAllServerIds(string[] ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_getAdapterInfo(AdapterInfo[] ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_removeAdapter();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_getAllAdapterIds(string[] ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_addObject();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_updateObject();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_addObjectWithType();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_removeObject();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_getObjectInfo(ObjectInfo ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_getObjectInfosByType(ObjectInfo[] ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_getAllObjectInfos(ObjectInfo[] ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_pingNode(bool ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_getNodeLoad(LoadInfo ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_getNodeInfo(NodeInfo ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_getNodeAdmin(global::Ice.ObjectPrx ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_getNodeProcessorSocketCount(int ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_shutdownNode();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_getNodeHostname(string ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_getAllNodeNames(string[] ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_pingRegistry(bool ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_getRegistryInfo(RegistryInfo ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_getRegistryAdmin(global::Ice.ObjectPrx ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_shutdownRegistry();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_getAllRegistryNames(string[] ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_Admin_shutdown();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_FileIterator_read(bool ret, string[] lines);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_FileIterator_destroy();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_RegistryObserver_registryInit();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_RegistryObserver_registryUp();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_RegistryObserver_registryDown();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_NodeObserver_nodeInit();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_NodeObserver_nodeUp();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_NodeObserver_nodeDown();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_NodeObserver_updateServer();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_NodeObserver_updateAdapter();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_ApplicationObserver_applicationInit();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_ApplicationObserver_applicationAdded();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_ApplicationObserver_applicationRemoved();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_ApplicationObserver_applicationUpdated();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_AdapterObserver_adapterInit();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_AdapterObserver_adapterAdded();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_AdapterObserver_adapterUpdated();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_AdapterObserver_adapterRemoved();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_ObjectObserver_objectInit();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_ObjectObserver_objectAdded();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_ObjectObserver_objectUpdated();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_ObjectObserver_objectRemoved();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_AdminSession_keepAlive();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_AdminSession_getAdmin(AdminPrx ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_AdminSession_getAdminCallbackTemplate(global::Ice.ObjectPrx ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_AdminSession_setObservers();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_AdminSession_setObserversByIdentity();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_AdminSession_startUpdate(int ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_AdminSession_finishUpdate();

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_AdminSession_getReplicaName(string ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_AdminSession_openServerLog(FileIteratorPrx ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_AdminSession_openServerStdErr(FileIteratorPrx ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_AdminSession_openServerStdOut(FileIteratorPrx ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_AdminSession_openNodeStdErr(FileIteratorPrx ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_AdminSession_openNodeStdOut(FileIteratorPrx ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_AdminSession_openRegistryStdErr(FileIteratorPrx ret);

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public delegate void Callback_AdminSession_openRegistryStdOut(FileIteratorPrx ret);
}

namespace IceGrid
{
    public struct FileIterator_ReadResult
    {
        public FileIterator_ReadResult(bool returnValue, string[] lines)
        {
            this.returnValue = returnValue;
            this.lines = lines;
        }

        public bool returnValue;
        public string[] lines;
    }
}

namespace IceGrid
{
    /// <summary>
    /// The IceGrid administrative interface.
    /// &lt;p class="Warning"&gt;Allowing access to this interface is a security risk!
    ///  Please see the IceGrid documentation for further information.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public interface AdminPrx : global::Ice.ObjectPrx
    {
        /// <summary>
        /// Add an application to IceGrid.
        /// </summary>
        /// <param name="descriptor">The application descriptor.
        ///  </param>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock or if another session is
        ///  holding the lock.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void addApplication(ApplicationDescriptor descriptor, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Add an application to IceGrid.
        /// </summary>
        /// <param name="descriptor">The application descriptor.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task addApplicationAsync(ApplicationDescriptor descriptor, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Synchronize a deployed application with the given application descriptor.
        /// This operation will replace the
        ///  current descriptor with this new descriptor.
        /// </summary>
        ///  <param name="descriptor">The application descriptor.
        ///  </param>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock or if another session is
        ///  holding the lock.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.
        ///  </exception>
        /// <exception name="ApplicationNotExistException">Raised if the application doesn't exist.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void syncApplication(ApplicationDescriptor descriptor, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Synchronize a deployed application with the given application descriptor.
        /// This operation will replace the
        /// </summary>
        ///  <param name="descriptor">The application descriptor.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task syncApplicationAsync(ApplicationDescriptor descriptor, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Update a deployed application with the given update application descriptor.
        /// </summary>
        /// <param name="descriptor">The update descriptor.
        ///  </param>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock or if another session is
        ///  holding the lock.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.
        ///  </exception>
        /// <exception name="ApplicationNotExistException">Raised if the application doesn't exist.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void updateApplication(ApplicationUpdateDescriptor descriptor, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Update a deployed application with the given update application descriptor.
        /// </summary>
        /// <param name="descriptor">The update descriptor.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task updateApplicationAsync(ApplicationUpdateDescriptor descriptor, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Synchronize a deployed application with the given application descriptor.
        /// This operation will replace the
        ///  current descriptor with this new descriptor only if no server restarts are necessary for the update of the
        ///  application. If some servers need to be restarted, the synchronization is rejected with a DeploymentException.
        /// </summary>
        ///  <param name="descriptor">The application descriptor.
        ///  </param>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock or if another session is
        ///  holding the lock.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.
        ///  </exception>
        /// <exception name="ApplicationNotExistException">Raised if the application doesn't exist.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void syncApplicationWithoutRestart(ApplicationDescriptor descriptor, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Synchronize a deployed application with the given application descriptor.
        /// This operation will replace the
        /// </summary>
        ///  <param name="descriptor">The application descriptor.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task syncApplicationWithoutRestartAsync(ApplicationDescriptor descriptor, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Update a deployed application with the given update application descriptor only if no server restarts are
        ///  necessary for the update of the application.
        /// If some servers need to be restarted, the synchronization is
        ///  rejected with a DeploymentException.
        /// </summary>
        ///  <param name="descriptor">The update descriptor.
        ///  </param>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock or if another session is
        ///  holding the lock.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.
        ///  </exception>
        /// <exception name="ApplicationNotExistException">Raised if the application doesn't exist.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void updateApplicationWithoutRestart(ApplicationUpdateDescriptor descriptor, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Update a deployed application with the given update application descriptor only if no server restarts are
        ///  necessary for the update of the application.
        /// If some servers need to be restarted, the synchronization is
        /// </summary>
        ///  <param name="descriptor">The update descriptor.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task updateApplicationWithoutRestartAsync(ApplicationUpdateDescriptor descriptor, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Remove an application from IceGrid.
        /// </summary>
        /// <param name="name">The application name.
        ///  </param>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock or if another session is
        ///  holding the lock.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.
        ///  </exception>
        /// <exception name="ApplicationNotExistException">Raised if the application doesn't exist.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void removeApplication(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Remove an application from IceGrid.
        /// </summary>
        /// <param name="name">The application name.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task removeApplicationAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Instantiate a server template from an application on the given node.
        /// </summary>
        /// <param name="application">The application name.
        ///  </param>
        /// <param name="node">The name of the node where the server will be deployed.
        ///  </param>
        /// <param name="desc">The descriptor of the server instance to deploy.
        ///  </param>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock or if another session is
        ///  holding the lock.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if server instantiation failed.
        ///  </exception>
        /// <exception name="ApplicationNotExistException">Raised if the application doesn't exist.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void instantiateServer(string application, string node, ServerInstanceDescriptor desc, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Instantiate a server template from an application on the given node.
        /// </summary>
        /// <param name="application">The application name.
        ///  </param>
        /// <param name="node">The name of the node where the server will be deployed.
        ///  </param>
        /// <param name="desc">The descriptor of the server instance to deploy.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task instantiateServerAsync(string application, string node, ServerInstanceDescriptor desc, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get an application descriptor.
        /// </summary>
        /// <param name="name">The application name.
        ///  </param>
        /// <returns>The application descriptor.
        ///  </returns>
        /// <exception name="ApplicationNotExistException">Raised if the application doesn't exist.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        ApplicationInfo getApplicationInfo(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get an application descriptor.
        /// </summary>
        /// <param name="name">The application name.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<ApplicationInfo> getApplicationInfoAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get the default application descriptor.
        /// </summary>
        /// <returns>The default application descriptor.
        ///  </returns>
        /// <exception name="DeploymentException">Raised if the default application descriptor can't be accessed or is invalid.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        ApplicationDescriptor getDefaultApplicationDescriptor(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get the default application descriptor.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<ApplicationDescriptor> getDefaultApplicationDescriptorAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get all the IceGrid applications currently registered.
        /// </summary>
        /// <returns>The application names.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        string[] getAllApplicationNames(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get all the IceGrid applications currently registered.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<string[]> getAllApplicationNamesAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get the server information for the server with the given id.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <returns>The server information.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        ServerInfo getServerInfo(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get the server information for the server with the given id.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<ServerInfo> getServerInfoAsync(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get a server's state.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <returns>The server state.
        ///  </returns>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        ServerState getServerState(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get a server's state.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<ServerState> getServerStateAsync(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get a server's system process id.
        /// The process id is operating system dependent.
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <returns>The server's process id.
        ///  </returns>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        int getServerPid(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get a server's system process id.
        /// The process id is operating system dependent.
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<int> getServerPidAsync(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get the category for server admin objects.
        /// You can manufacture a server admin proxy from the admin proxy by
        ///  changing its identity: use the server ID as name and the returned category as category.
        /// </summary>
        ///  <returns>The category for server admin objects.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        string getServerAdminCategory(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get the category for server admin objects.
        /// You can manufacture a server admin proxy from the admin proxy by
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<string> getServerAdminCategoryAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get a proxy to the server's admin object.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <returns>A proxy to the server's admin object. The returned proxy is never null.
        ///  </returns>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        global::Ice.ObjectPrx getServerAdmin(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get a proxy to the server's admin object.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<global::Ice.ObjectPrx> getServerAdminAsync(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Enable or disable a server.
        /// A disabled server can't be started on demand or administratively. The enable state
        ///  of the server is not persistent: if the node is shut down and restarted, the server will be enabled by default.
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <param name="enabled">True to enable the server, false to disable it.
        ///  </param>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void enableServer(string id, bool enabled, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Enable or disable a server.
        /// A disabled server can't be started on demand or administratively. The enable state
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <param name="enabled">True to enable the server, false to disable it.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task enableServerAsync(string id, bool enabled, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Check if the server is enabled or disabled.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <returns>True if the server is enabled.
        ///  </returns>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        bool isServerEnabled(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Check if the server is enabled or disabled.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<bool> isServerEnabledAsync(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Start a server and wait for its activation.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="ServerStartException">Raised if the server couldn't be started.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void startServer(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Start a server and wait for its activation.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task startServerAsync(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Stop a server.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="ServerStopException">Raised if the server couldn't be stopped.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void stopServer(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Stop a server.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task stopServerAsync(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Send signal to a server.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <param name="signal">The signal, for example SIGTERM or 15.
        ///  </param>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.
        ///  </exception>
        /// <exception name="BadSignalException">Raised if the signal is not recognized by the target server.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void sendSignal(string id, string signal, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Send signal to a server.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <param name="signal">The signal, for example SIGTERM or 15.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task sendSignalAsync(string id, string signal, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get all the server ids registered with IceGrid.
        /// </summary>
        /// <returns>The server ids.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        string[] getAllServerIds(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get all the server ids registered with IceGrid.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<string[]> getAllServerIdsAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get the adapter information for the replica group or adapter with the given id.
        /// </summary>
        /// <param name="id">The adapter id.
        ///  </param>
        /// <returns>A sequence of adapter information structures. If the given id refers to an adapter, this sequence will
        ///  contain only one element. If the given id refers to a replica group, the sequence will contain the adapter
        ///  information of each member of the replica group.
        ///  </returns>
        /// <exception name="AdapterNotExistException">Raised if the adapter or replica group doesn't exist.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        AdapterInfo[] getAdapterInfo(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get the adapter information for the replica group or adapter with the given id.
        /// </summary>
        /// <param name="id">The adapter id.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<AdapterInfo[]> getAdapterInfoAsync(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Remove the adapter with the given id.
        /// </summary>
        /// <param name="id">The adapter id.
        ///  </param>
        /// <exception name="AdapterNotExistException">Raised if the adapter doesn't exist.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void removeAdapter(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Remove the adapter with the given id.
        /// </summary>
        /// <param name="id">The adapter id.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task removeAdapterAsync(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get all the adapter ids registered with IceGrid.
        /// </summary>
        /// <returns>The adapter ids.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        string[] getAllAdapterIds(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get all the adapter ids registered with IceGrid.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<string[]> getAllAdapterIdsAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Add an object to the object registry.
        /// IceGrid will get the object type by calling ice_id on the
        ///  given proxy. The object must be reachable.
        /// </summary>
        ///  <param name="obj">The object to be added to the registry.
        ///  </param>
        /// <exception name="ObjectExistsException">Raised if the object is already registered.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the object can't be added. This might be raised if the invocation on the
        ///  proxy to get the object type failed.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void addObject(global::Ice.ObjectPrx obj, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Add an object to the object registry.
        /// IceGrid will get the object type by calling ice_id on the
        /// </summary>
        ///  <param name="obj">The object to be added to the registry.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task addObjectAsync(global::Ice.ObjectPrx obj, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Update an object in the object registry.
        /// Only objects added with this interface can be updated with this
        ///  operation. Objects added with deployment descriptors should be updated with the deployment mechanism.
        /// </summary>
        ///  <param name="obj">The object to be updated to the registry.
        ///  </param>
        /// <exception name="ObjectNotRegisteredException">Raised if the object isn't registered with the registry.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the object can't be updated. This might happen if the object was added
        ///  with a deployment descriptor.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void updateObject(global::Ice.ObjectPrx obj, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Update an object in the object registry.
        /// Only objects added with this interface can be updated with this
        /// </summary>
        ///  <param name="obj">The object to be updated to the registry.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task updateObjectAsync(global::Ice.ObjectPrx obj, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Add an object to the object registry and explicitly specify its type.
        /// </summary>
        /// <param name="obj">The object to be added to the registry. The proxy is never null.
        ///  </param>
        /// <param name="type">The object type.
        ///  </param>
        /// <exception name="ObjectExistsException">Raised if the object is already registered.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void addObjectWithType(global::Ice.ObjectPrx obj, string type, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Add an object to the object registry and explicitly specify its type.
        /// </summary>
        /// <param name="obj">The object to be added to the registry. The proxy is never null.
        ///  </param>
        /// <param name="type">The object type.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task addObjectWithTypeAsync(global::Ice.ObjectPrx obj, string type, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Remove an object from the object registry.
        /// Only objects added with this interface can be removed with this
        ///  operation. Objects added with deployment descriptors should be removed with the deployment mechanism.
        /// </summary>
        ///  <param name="id">The identity of the object to be removed from the registry.
        ///  </param>
        /// <exception name="ObjectNotRegisteredException">Raised if the object isn't registered with the registry.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the object can't be removed. This might happen if the object was added
        ///  with a deployment descriptor.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void removeObject(global::Ice.Identity id, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Remove an object from the object registry.
        /// Only objects added with this interface can be removed with this
        /// </summary>
        ///  <param name="id">The identity of the object to be removed from the registry.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task removeObjectAsync(global::Ice.Identity id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get the object info for the object with the given identity.
        /// </summary>
        /// <param name="id">The identity of the object.
        ///  </param>
        /// <returns>The object info.
        ///  </returns>
        /// <exception name="ObjectNotRegisteredException">Raised if the object isn't registered with the registry.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        ObjectInfo getObjectInfo(global::Ice.Identity id, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get the object info for the object with the given identity.
        /// </summary>
        /// <param name="id">The identity of the object.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<ObjectInfo> getObjectInfoAsync(global::Ice.Identity id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get the object info of all the registered objects with the given type.
        /// </summary>
        /// <param name="type">The type of the object.
        ///  </param>
        /// <returns>The object infos.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        ObjectInfo[] getObjectInfosByType(string type, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get the object info of all the registered objects with the given type.
        /// </summary>
        /// <param name="type">The type of the object.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<ObjectInfo[]> getObjectInfosByTypeAsync(string type, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get the object info of all the registered objects whose stringified identities match the given expression.
        /// </summary>
        /// <param name="expr">The expression to match against the stringified identities of registered objects. The expression
        ///  may contain a trailing wildcard (*) character.
        ///  </param>
        /// <returns>All the object infos with a stringified identity matching the given expression.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        ObjectInfo[] getAllObjectInfos(string expr, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get the object info of all the registered objects whose stringified identities match the given expression.
        /// </summary>
        /// <param name="expr">The expression to match against the stringified identities of registered objects. The expression
        ///  may contain a trailing wildcard (*) character.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<ObjectInfo[]> getAllObjectInfosAsync(string expr, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Ping an IceGrid node to see if it is active.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <returns>true if the node ping succeeded, false otherwise.
        ///  </returns>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        bool pingNode(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Ping an IceGrid node to see if it is active.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<bool> pingNodeAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get the load averages of the node.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <returns>The node load information.
        ///  </returns>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        LoadInfo getNodeLoad(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get the load averages of the node.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<LoadInfo> getNodeLoadAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get the node information for the node with the given name.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <returns>The node information.
        ///  </returns>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        NodeInfo getNodeInfo(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get the node information for the node with the given name.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<NodeInfo> getNodeInfoAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get a proxy to the IceGrid node's admin object.
        /// </summary>
        /// <param name="name">The IceGrid node name
        ///  </param>
        /// <returns>A proxy to the IceGrid node's admin object. The returned proxy is never null.
        ///  </returns>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        global::Ice.ObjectPrx getNodeAdmin(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get a proxy to the IceGrid node's admin object.
        /// </summary>
        /// <param name="name">The IceGrid node name
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<global::Ice.ObjectPrx> getNodeAdminAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get the number of physical processor sockets for the machine running the node with the given name.
        /// Note that this method will return 1 on operating systems where this can't be automatically determined and where
        ///  the IceGrid.Node.ProcessorSocketCount property for the node is not set.
        /// </summary>
        ///  <param name="name">The node name.
        ///  </param>
        /// <returns>The number of processor sockets or 1 if the number of sockets can't determined.
        ///  </returns>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        int getNodeProcessorSocketCount(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get the number of physical processor sockets for the machine running the node with the given name.
        /// Note that this method will return 1 on operating systems where this can't be automatically determined and where
        /// </summary>
        ///  <param name="name">The node name.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<int> getNodeProcessorSocketCountAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Shutdown an IceGrid node.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void shutdownNode(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Shutdown an IceGrid node.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task shutdownNodeAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get the hostname of this node.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <returns>The node hostname.
        ///  </returns>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        string getNodeHostname(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get the hostname of this node.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<string> getNodeHostnameAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get all the IceGrid nodes currently registered.
        /// </summary>
        /// <returns>The node names.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        string[] getAllNodeNames(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get all the IceGrid nodes currently registered.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<string[]> getAllNodeNamesAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Ping an IceGrid registry to see if it is active.
        /// </summary>
        /// <param name="name">The registry name.
        ///  </param>
        /// <returns>true if the registry ping succeeded, false otherwise.
        ///  </returns>
        /// <exception name="RegistryNotExistException">Raised if the registry doesn't exist.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        bool pingRegistry(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Ping an IceGrid registry to see if it is active.
        /// </summary>
        /// <param name="name">The registry name.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<bool> pingRegistryAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get the registry information for the registry with the given name.
        /// </summary>
        /// <param name="name">The registry name.
        ///  </param>
        /// <returns>The registry information.
        ///  </returns>
        /// <exception name="RegistryNotExistException">Raised if the registry doesn't exist.
        ///  </exception>
        /// <exception name="RegistryUnreachableException">Raised if the registry could not be reached.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        RegistryInfo getRegistryInfo(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get the registry information for the registry with the given name.
        /// </summary>
        /// <param name="name">The registry name.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<RegistryInfo> getRegistryInfoAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get a proxy to the IceGrid registry's admin object.
        /// </summary>
        /// <param name="name">The registry name
        ///  </param>
        /// <returns>A proxy to the IceGrid registry's admin object. The returned proxy is never null.
        ///  </returns>
        /// <exception name="RegistryNotExistException">Raised if the registry doesn't exist.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        global::Ice.ObjectPrx getRegistryAdmin(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get a proxy to the IceGrid registry's admin object.
        /// </summary>
        /// <param name="name">The registry name
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<global::Ice.ObjectPrx> getRegistryAdminAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Shutdown an IceGrid registry.
        /// </summary>
        /// <param name="name">The registry name.
        ///  </param>
        /// <exception name="RegistryNotExistException">Raised if the registry doesn't exist.
        ///  </exception>
        /// <exception name="RegistryUnreachableException">Raised if the registry could not be reached.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void shutdownRegistry(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Shutdown an IceGrid registry.
        /// </summary>
        /// <param name="name">The registry name.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task shutdownRegistryAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get all the IceGrid registries currently registered.
        /// </summary>
        /// <returns>The registry names.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        string[] getAllRegistryNames(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get all the IceGrid registries currently registered.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<string[]> getAllRegistryNamesAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Shut down the IceGrid registry.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void shutdown(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Shut down the IceGrid registry.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task shutdownAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());
    }

    /// <summary>
    /// This interface provides access to IceGrid log file contents.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public interface FileIteratorPrx : global::Ice.ObjectPrx
    {
        /// <summary>
        /// Read lines from the log file.
        /// </summary>
        /// <param name="size">Specifies the maximum number of bytes to be received. The server will ensure that the returned
        ///  message doesn't exceed the given size.
        ///  </param>
        /// <param name="lines">The lines read from the file. If there was nothing to read from the file since the last call to
        ///  read, an empty sequence is returned. The last line of the sequence is always incomplete (and therefore no '\n'
        ///  should be added when writing the last line to the to the output device).
        ///  </param>
        /// <returns>True if EOF is encountered.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if there was a problem to read lines from the file.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        bool read(int size, out string[] lines, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Read lines from the log file.
        /// </summary>
        /// <param name="size">Specifies the maximum number of bytes to be received. The server will ensure that the returned
        ///  message doesn't exceed the given size.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<FileIterator_ReadResult> readAsync(int size, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Destroy the iterator.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void destroy(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Destroy the iterator.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task destroyAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());
    }

    /// <summary>
    /// This interface allows applications to monitor changes the state of the registry.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public interface RegistryObserverPrx : global::Ice.ObjectPrx
    {
        /// <summary>
        /// The registryInit operation is called after registration of an observer to indicate the state of
        ///  the registries.
        /// </summary>
        /// <param name="registries">The current state of the registries.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void registryInit(RegistryInfo[] registries, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// The registryInit operation is called after registration of an observer to indicate the state of
        ///  the registries.
        /// </summary>
        /// <param name="registries">The current state of the registries.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task registryInitAsync(RegistryInfo[] registries, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// The nodeUp operation is called to notify an observer that a node came up.
        /// </summary>
        /// <param name="node">The node state.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void registryUp(RegistryInfo node, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// The nodeUp operation is called to notify an observer that a node came up.
        /// </summary>
        /// <param name="node">The node state.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task registryUpAsync(RegistryInfo node, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// The nodeDown operation is called to notify an observer that a node went down.
        /// </summary>
        /// <param name="name">The node name.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void registryDown(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// The nodeDown operation is called to notify an observer that a node went down.
        /// </summary>
        /// <param name="name">The node name.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task registryDownAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());
    }

    /// <summary>
    /// The node observer interface.
    /// Observers should implement this interface to receive information about the state of
    ///  the IceGrid nodes.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public interface NodeObserverPrx : global::Ice.ObjectPrx
    {
        /// <summary>
        /// The nodeInit operation indicates the current state of nodes.
        /// It is called after the registration
        ///  of an observer.
        /// </summary>
        ///  <param name="nodes">The current state of the nodes.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void nodeInit(NodeDynamicInfo[] nodes, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// The nodeInit operation indicates the current state of nodes.
        /// It is called after the registration
        /// </summary>
        ///  <param name="nodes">The current state of the nodes.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task nodeInitAsync(NodeDynamicInfo[] nodes, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// The nodeUp operation is called to notify an observer that a node came up.
        /// </summary>
        /// <param name="node">The node state.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void nodeUp(NodeDynamicInfo node, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// The nodeUp operation is called to notify an observer that a node came up.
        /// </summary>
        /// <param name="node">The node state.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task nodeUpAsync(NodeDynamicInfo node, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// The nodeDown operation is called to notify an observer that a node went down.
        /// </summary>
        /// <param name="name">The node name.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void nodeDown(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// The nodeDown operation is called to notify an observer that a node went down.
        /// </summary>
        /// <param name="name">The node name.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task nodeDownAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// The updateServer operation is called to notify an observer that the state of a server changed.
        /// </summary>
        /// <param name="node">The node hosting the server.
        ///  </param>
        /// <param name="updatedInfo">The new server state.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void updateServer(string node, ServerDynamicInfo updatedInfo, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// The updateServer operation is called to notify an observer that the state of a server changed.
        /// </summary>
        /// <param name="node">The node hosting the server.
        ///  </param>
        /// <param name="updatedInfo">The new server state.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task updateServerAsync(string node, ServerDynamicInfo updatedInfo, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// The updateAdapter operation is called to notify an observer that the state of an adapter changed.
        /// </summary>
        /// <param name="node">The node hosting the adapter.
        ///  </param>
        /// <param name="updatedInfo">The new adapter state.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void updateAdapter(string node, AdapterDynamicInfo updatedInfo, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// The updateAdapter operation is called to notify an observer that the state of an adapter changed.
        /// </summary>
        /// <param name="node">The node hosting the adapter.
        ///  </param>
        /// <param name="updatedInfo">The new adapter state.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task updateAdapterAsync(string node, AdapterDynamicInfo updatedInfo, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());
    }

    /// <summary>
    /// The database observer interface.
    /// Observers should implement this interface to receive information about the state
    ///  of the IceGrid registry database.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public interface ApplicationObserverPrx : global::Ice.ObjectPrx
    {
        /// <summary>
        /// applicationInit is called after the registration of an observer to indicate the state of the
        ///  registry.
        /// </summary>
        /// <param name="serial">The current serial number of the registry database. This serial number allows observers to make
        ///  sure that their internal state is synchronized with the registry.
        ///  </param>
        /// <param name="applications">The applications currently registered with the registry.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void applicationInit(int serial, ApplicationInfo[] applications, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// applicationInit is called after the registration of an observer to indicate the state of the
        ///  registry.
        /// </summary>
        /// <param name="serial">The current serial number of the registry database. This serial number allows observers to make
        ///  sure that their internal state is synchronized with the registry.
        ///  </param>
        /// <param name="applications">The applications currently registered with the registry.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task applicationInitAsync(int serial, ApplicationInfo[] applications, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// The applicationAdded operation is called to notify an observer that an application was added.
        /// </summary>
        /// <param name="serial">The new serial number of the registry database.
        ///  </param>
        /// <param name="desc">The descriptor of the new application.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void applicationAdded(int serial, ApplicationInfo desc, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// The applicationAdded operation is called to notify an observer that an application was added.
        /// </summary>
        /// <param name="serial">The new serial number of the registry database.
        ///  </param>
        /// <param name="desc">The descriptor of the new application.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task applicationAddedAsync(int serial, ApplicationInfo desc, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// The applicationRemoved operation is called to notify an observer that an application was removed.
        /// </summary>
        /// <param name="serial">The new serial number of the registry database.
        ///  </param>
        /// <param name="name">The name of the application that was removed.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void applicationRemoved(int serial, string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// The applicationRemoved operation is called to notify an observer that an application was removed.
        /// </summary>
        /// <param name="serial">The new serial number of the registry database.
        ///  </param>
        /// <param name="name">The name of the application that was removed.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task applicationRemovedAsync(int serial, string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// The applicationUpdated operation is called to notify an observer that an application was updated.
        /// </summary>
        /// <param name="serial">The new serial number of the registry database.
        ///  </param>
        /// <param name="desc">The descriptor of the update.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void applicationUpdated(int serial, ApplicationUpdateInfo desc, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// The applicationUpdated operation is called to notify an observer that an application was updated.
        /// </summary>
        /// <param name="serial">The new serial number of the registry database.
        ///  </param>
        /// <param name="desc">The descriptor of the update.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task applicationUpdatedAsync(int serial, ApplicationUpdateInfo desc, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());
    }

    /// <summary>
    /// This interface allows applications to monitor the state of object adapters that are registered with IceGrid.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public interface AdapterObserverPrx : global::Ice.ObjectPrx
    {
        /// <summary>
        /// adapterInit is called after registration of an observer to indicate the state of the registry.
        /// </summary>
        /// <param name="adpts">The adapters that were dynamically registered with the registry (not through the deployment
        ///  mechanism).</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void adapterInit(AdapterInfo[] adpts, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// adapterInit is called after registration of an observer to indicate the state of the registry.
        /// </summary>
        /// <param name="adpts">The adapters that were dynamically registered with the registry (not through the deployment
        ///  mechanism).</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task adapterInitAsync(AdapterInfo[] adpts, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// The adapterAdded operation is called to notify an observer when a dynamically-registered adapter
        ///  was added.
        /// </summary>
        /// <param name="info">The details of the new adapter.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void adapterAdded(AdapterInfo info, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// The adapterAdded operation is called to notify an observer when a dynamically-registered adapter
        ///  was added.
        /// </summary>
        /// <param name="info">The details of the new adapter.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task adapterAddedAsync(AdapterInfo info, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// The adapterUpdated operation is called to notify an observer when a dynamically-registered adapter was updated.
        /// </summary>
        /// <param name="info">The details of the updated adapter.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void adapterUpdated(AdapterInfo info, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// The adapterUpdated operation is called to notify an observer when a dynamically-registered adapter was updated.
        /// </summary>
        /// <param name="info">The details of the updated adapter.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task adapterUpdatedAsync(AdapterInfo info, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// The adapterRemoved operation is called to notify an observer when a dynamically-registered adapter was removed.
        /// </summary>
        /// <param name="id">The ID of the removed adapter.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void adapterRemoved(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// The adapterRemoved operation is called to notify an observer when a dynamically-registered adapter was removed.
        /// </summary>
        /// <param name="id">The ID of the removed adapter.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task adapterRemovedAsync(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());
    }

    /// <summary>
    /// This interface allows applications to monitor IceGrid well-known objects.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public interface ObjectObserverPrx : global::Ice.ObjectPrx
    {
        /// <summary>
        /// objectInit is called after the registration of an observer to indicate the state of the registry.
        /// </summary>
        /// <param name="objects">The objects registered with the Admin interface (not through the deployment mechanism).</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void objectInit(ObjectInfo[] objects, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// objectInit is called after the registration of an observer to indicate the state of the registry.
        /// </summary>
        /// <param name="objects">The objects registered with the Admin interface (not through the deployment mechanism).</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task objectInitAsync(ObjectInfo[] objects, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// The objectAdded operation is called to notify an observer when an object was added to the
        ///  Admin interface.
        /// </summary>
        /// <param name="info">The details of the added object.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void objectAdded(ObjectInfo info, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// The objectAdded operation is called to notify an observer when an object was added to the
        ///  Admin interface.
        /// </summary>
        /// <param name="info">The details of the added object.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task objectAddedAsync(ObjectInfo info, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// objectUpdated is called to notify an observer when an object registered with the Admin
        ///  interface was updated.
        /// </summary>
        /// <param name="info">The details of the updated object.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void objectUpdated(ObjectInfo info, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// objectUpdated is called to notify an observer when an object registered with the Admin
        ///  interface was updated.
        /// </summary>
        /// <param name="info">The details of the updated object.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task objectUpdatedAsync(ObjectInfo info, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// objectRemoved is called to notify an observer when an object registered with the Admin
        ///  interface was removed.
        /// </summary>
        /// <param name="id">The identity of the removed object.</param>
        /// <param name="context">The Context map to send with the invocation.</param>

        void objectRemoved(global::Ice.Identity id, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// objectRemoved is called to notify an observer when an object registered with the Admin
        ///  interface was removed.
        /// </summary>
        /// <param name="id">The identity of the removed object.</param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task objectRemovedAsync(global::Ice.Identity id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());
    }

    /// <summary>
    /// Used by administrative clients to view, update, and receive observer updates from the IceGrid registry.
    /// Admin
    ///  sessions are created either via the Registry object or via the registry admin SessionManager
    ///  object.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public interface AdminSessionPrx : global::Glacier2.SessionPrx
    {
        /// <summary>
        /// Keep the session alive.
        /// Clients should call this operation regularly to prevent the server from reaping the
        ///  session.
        /// </summary>
        /// <param name="context">The Context map to send with the invocation.</param>

        void keepAlive(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Keep the session alive.
        /// Clients should call this operation regularly to prevent the server from reaping the
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task keepAliveAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get the admin interface.
        /// The admin object returned by this operation can only be accessed by the session.
        /// </summary>
        ///  <returns>The admin interface proxy. The returned proxy is never null.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        AdminPrx getAdmin(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get the admin interface.
        /// The admin object returned by this operation can only be accessed by the session.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<AdminPrx> getAdminAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get a "template" proxy for admin callback objects.
        /// An Admin client uses this proxy to set the category of its
        ///  callback objects, and the published endpoints of the object adapter hosting the admin callback objects.
        /// </summary>
        ///  <returns>A template proxy. The returned proxy is null when the Admin session was established using Glacier2.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        global::Ice.ObjectPrx getAdminCallbackTemplate(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get a "template" proxy for admin callback objects.
        /// An Admin client uses this proxy to set the category of its
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<global::Ice.ObjectPrx> getAdminCallbackTemplateAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Set the observer proxies that receive notifications when the state of the registry or nodes changes.
        /// </summary>
        /// <param name="registryObs">The registry observer.
        ///  </param>
        /// <param name="nodeObs">The node observer.
        ///  </param>
        /// <param name="appObs">The application observer.
        ///  </param>
        /// <param name="adptObs">The adapter observer.
        ///  </param>
        /// <param name="objObs">The object observer.
        ///  </param>
        /// <exception name="ObserverAlreadyRegisteredException">Raised if an observer is already registered with this registry.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void setObservers(RegistryObserverPrx registryObs, NodeObserverPrx nodeObs, ApplicationObserverPrx appObs, AdapterObserverPrx adptObs, ObjectObserverPrx objObs, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Set the observer proxies that receive notifications when the state of the registry or nodes changes.
        /// </summary>
        /// <param name="registryObs">The registry observer.
        ///  </param>
        /// <param name="nodeObs">The node observer.
        ///  </param>
        /// <param name="appObs">The application observer.
        ///  </param>
        /// <param name="adptObs">The adapter observer.
        ///  </param>
        /// <param name="objObs">The object observer.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task setObserversAsync(RegistryObserverPrx registryObs, NodeObserverPrx nodeObs, ApplicationObserverPrx appObs, AdapterObserverPrx adptObs, ObjectObserverPrx objObs, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Set the observer identities that receive notifications the state of the registry or nodes changes.
        /// This
        ///  operation should be used by clients that are using a bidirectional connection to communicate with the session.
        /// </summary>
        ///  <param name="registryObs">The registry observer identity.
        ///  </param>
        /// <param name="nodeObs">The node observer identity.
        ///  </param>
        /// <param name="appObs">The application observer.
        ///  </param>
        /// <param name="adptObs">The adapter observer.
        ///  </param>
        /// <param name="objObs">The object observer.
        ///  </param>
        /// <exception name="ObserverAlreadyRegisteredException">Raised if an observer is already registered with this registry.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void setObserversByIdentity(global::Ice.Identity registryObs, global::Ice.Identity nodeObs, global::Ice.Identity appObs, global::Ice.Identity adptObs, global::Ice.Identity objObs, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Set the observer identities that receive notifications the state of the registry or nodes changes.
        /// This
        /// </summary>
        ///  <param name="registryObs">The registry observer identity.
        ///  </param>
        /// <param name="nodeObs">The node observer identity.
        ///  </param>
        /// <param name="appObs">The application observer.
        ///  </param>
        /// <param name="adptObs">The adapter observer.
        ///  </param>
        /// <param name="objObs">The object observer.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task setObserversByIdentityAsync(global::Ice.Identity registryObs, global::Ice.Identity nodeObs, global::Ice.Identity appObs, global::Ice.Identity adptObs, global::Ice.Identity objObs, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Acquires an exclusive lock to start updating the registry applications.
        /// </summary>
        /// <returns>The current serial.
        ///  </returns>
        /// <exception name="AccessDeniedException">Raised if the exclusive lock can't be acquired. This might happen if the lock is
        ///  currently acquired by another session.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        int startUpdate(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Acquires an exclusive lock to start updating the registry applications.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<int> startUpdateAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Finish updating the registry and release the exclusive lock.
        /// </summary>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        void finishUpdate(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Finish updating the registry and release the exclusive lock.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task finishUpdateAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Get the name of the registry replica hosting this session.
        /// </summary>
        /// <returns>The replica name of the registry.</returns>
        /// <param name="context">The Context map to send with the invocation.</param>

        string getReplicaName(global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Get the name of the registry replica hosting this session.
        /// </summary>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<string> getReplicaNameAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Open the given server log file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <param name="path">The path of the log file. A log file can be opened only if it's declared in the server or service
        ///  deployment descriptor.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If 0
        ///  or positive, the file is read from the last count lines.
        ///  </param>
        /// <returns>An iterator to read the file. The returned proxy is never null.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if the file can't be read.
        ///  </exception>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        FileIteratorPrx openServerLog(string id, string path, int count, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Open the given server log file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <param name="path">The path of the log file. A log file can be opened only if it's declared in the server or service
        ///  deployment descriptor.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If 0
        ///  or positive, the file is read from the last count lines.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<FileIteratorPrx> openServerLogAsync(string id, string path, int count, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Open the given server stderr file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If 0
        ///  or positive, the file is read from the last count lines.
        ///  </param>
        /// <returns>An iterator to read the file. The returned proxy is never null.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if the file can't be read.
        ///  </exception>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        FileIteratorPrx openServerStdErr(string id, int count, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Open the given server stderr file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If 0
        ///  or positive, the file is read from the last count lines.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<FileIteratorPrx> openServerStdErrAsync(string id, int count, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Open the given server stdout file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining.
        ///  If 0 or positive, the file is read from the last count lines.
        ///  </param>
        /// <returns>An iterator to read the file. The returned proxy is never null.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if the file can't be read.
        ///   </exception>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        FileIteratorPrx openServerStdOut(string id, int count, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Open the given server stdout file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining.
        ///  If 0 or positive, the file is read from the last count lines.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<FileIteratorPrx> openServerStdOutAsync(string id, int count, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Open the given node stderr file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="name">The node name.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If 0
        ///  or positive, the file is read from the last count lines.
        ///  </param>
        /// <returns>An iterator to read the file. The returned proxy is never null.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if the file can't be read.
        ///  </exception>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        FileIteratorPrx openNodeStdErr(string name, int count, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Open the given node stderr file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="name">The node name.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If 0
        ///  or positive, the file is read from the last count lines.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<FileIteratorPrx> openNodeStdErrAsync(string name, int count, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Open the given node stdout file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="name">The node name.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If 0
        ///  or positive, the file is read from the last count lines.
        ///  </param>
        /// <returns>An iterator to read the file. The returned proxy is never null.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if the file can't be read.
        ///  </exception>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        FileIteratorPrx openNodeStdOut(string name, int count, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Open the given node stdout file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="name">The node name.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If 0
        ///  or positive, the file is read from the last count lines.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<FileIteratorPrx> openNodeStdOutAsync(string name, int count, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Open the given registry stderr file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="name">The registry name.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If 0
        ///  or positive, the file is read from the last count lines.
        ///  </param>
        /// <returns>An iterator to read the file. The returned proxy is never null.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if the file can't be read.
        ///  </exception>
        /// <exception name="RegistryNotExistException">Raised if the registry doesn't exist.
        ///  </exception>
        /// <exception name="RegistryUnreachableException">Raised if the registry could not be reached.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        FileIteratorPrx openRegistryStdErr(string name, int count, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Open the given registry stderr file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="name">The registry name.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If 0
        ///  or positive, the file is read from the last count lines.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<FileIteratorPrx> openRegistryStdErrAsync(string name, int count, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());

        /// <summary>
        /// Open the given registry stdout file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="name">The registry name.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If 0
        ///  or positive, the file is read from the last count lines.
        ///  </param>
        /// <returns>An iterator to read the file. The returned proxy is never null.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if the file can't be read.
        ///  </exception>
        /// <exception name="RegistryNotExistException">Raised if the registry doesn't exist.
        ///  </exception>
        /// <exception name="RegistryUnreachableException">Raised if the registry could not be reached.</exception>
        /// <param name="context">The Context map to send with the invocation.</param>

        FileIteratorPrx openRegistryStdOut(string name, int count, global::Ice.OptionalContext context = new global::Ice.OptionalContext());

        /// <summary>
        /// Open the given registry stdout file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="name">The registry name.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If 0
        ///  or positive, the file is read from the last count lines.
        ///  </param>
        /// <param name="context">Context map to send with the invocation.</param>
        /// <param name="progress">Sent progress provider.</param>
        /// <param name="cancel">A cancellation token that receives the cancellation requests.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        global::System.Threading.Tasks.Task<FileIteratorPrx> openRegistryStdOutAsync(string name, int count, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken());
    }
}

namespace IceGrid
{
    /// <summary>
    /// The IceGrid administrative interface.
    /// &lt;p class="Warning"&gt;Allowing access to this interface is a security risk!
    ///  Please see the IceGrid documentation for further information.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public interface AdminOperations_
    {
        /// <summary>
        /// Add an application to IceGrid.
        /// </summary>
        /// <param name="descriptor">The application descriptor.
        ///  </param>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock or if another session is
        ///  holding the lock.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void addApplication(ApplicationDescriptor descriptor, global::Ice.Current current = null);

        /// <summary>
        /// Synchronize a deployed application with the given application descriptor.
        /// This operation will replace the
        ///  current descriptor with this new descriptor.
        /// </summary>
        ///  <param name="descriptor">The application descriptor.
        ///  </param>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock or if another session is
        ///  holding the lock.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.
        ///  </exception>
        /// <exception name="ApplicationNotExistException">Raised if the application doesn't exist.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void syncApplication(ApplicationDescriptor descriptor, global::Ice.Current current = null);

        /// <summary>
        /// Update a deployed application with the given update application descriptor.
        /// </summary>
        /// <param name="descriptor">The update descriptor.
        ///  </param>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock or if another session is
        ///  holding the lock.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.
        ///  </exception>
        /// <exception name="ApplicationNotExistException">Raised if the application doesn't exist.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void updateApplication(ApplicationUpdateDescriptor descriptor, global::Ice.Current current = null);

        /// <summary>
        /// Synchronize a deployed application with the given application descriptor.
        /// This operation will replace the
        ///  current descriptor with this new descriptor only if no server restarts are necessary for the update of the
        ///  application. If some servers need to be restarted, the synchronization is rejected with a DeploymentException.
        /// </summary>
        ///  <param name="descriptor">The application descriptor.
        ///  </param>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock or if another session is
        ///  holding the lock.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.
        ///  </exception>
        /// <exception name="ApplicationNotExistException">Raised if the application doesn't exist.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void syncApplicationWithoutRestart(ApplicationDescriptor descriptor, global::Ice.Current current = null);

        /// <summary>
        /// Update a deployed application with the given update application descriptor only if no server restarts are
        ///  necessary for the update of the application.
        /// If some servers need to be restarted, the synchronization is
        ///  rejected with a DeploymentException.
        /// </summary>
        ///  <param name="descriptor">The update descriptor.
        ///  </param>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock or if another session is
        ///  holding the lock.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.
        ///  </exception>
        /// <exception name="ApplicationNotExistException">Raised if the application doesn't exist.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void updateApplicationWithoutRestart(ApplicationUpdateDescriptor descriptor, global::Ice.Current current = null);

        /// <summary>
        /// Remove an application from IceGrid.
        /// </summary>
        /// <param name="name">The application name.
        ///  </param>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock or if another session is
        ///  holding the lock.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.
        ///  </exception>
        /// <exception name="ApplicationNotExistException">Raised if the application doesn't exist.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void removeApplication(string name, global::Ice.Current current = null);

        /// <summary>
        /// Instantiate a server template from an application on the given node.
        /// </summary>
        /// <param name="application">The application name.
        ///  </param>
        /// <param name="node">The name of the node where the server will be deployed.
        ///  </param>
        /// <param name="desc">The descriptor of the server instance to deploy.
        ///  </param>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock or if another session is
        ///  holding the lock.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if server instantiation failed.
        ///  </exception>
        /// <exception name="ApplicationNotExistException">Raised if the application doesn't exist.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void instantiateServer(string application, string node, ServerInstanceDescriptor desc, global::Ice.Current current = null);

        /// <summary>
        /// Get an application descriptor.
        /// </summary>
        /// <param name="name">The application name.
        ///  </param>
        /// <returns>The application descriptor.
        ///  </returns>
        /// <exception name="ApplicationNotExistException">Raised if the application doesn't exist.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        ApplicationInfo getApplicationInfo(string name, global::Ice.Current current = null);

        /// <summary>
        /// Get the default application descriptor.
        /// </summary>
        /// <returns>The default application descriptor.
        ///  </returns>
        /// <exception name="DeploymentException">Raised if the default application descriptor can't be accessed or is invalid.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        ApplicationDescriptor getDefaultApplicationDescriptor(global::Ice.Current current = null);

        /// <summary>
        /// Get all the IceGrid applications currently registered.
        /// </summary>
        /// <returns>The application names.</returns>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        string[] getAllApplicationNames(global::Ice.Current current = null);

        /// <summary>
        /// Get the server information for the server with the given id.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <returns>The server information.</returns>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        ServerInfo getServerInfo(string id, global::Ice.Current current = null);

        /// <summary>
        /// Get a server's state.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <returns>The server state.
        ///  </returns>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        ServerState getServerState(string id, global::Ice.Current current = null);

        /// <summary>
        /// Get a server's system process id.
        /// The process id is operating system dependent.
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <returns>The server's process id.
        ///  </returns>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        int getServerPid(string id, global::Ice.Current current = null);

        /// <summary>
        /// Get the category for server admin objects.
        /// You can manufacture a server admin proxy from the admin proxy by
        ///  changing its identity: use the server ID as name and the returned category as category.
        /// </summary>
        ///  <returns>The category for server admin objects.</returns>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        string getServerAdminCategory(global::Ice.Current current = null);

        /// <summary>
        /// Get a proxy to the server's admin object.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <returns>A proxy to the server's admin object. The returned proxy is never null.
        ///  </returns>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        global::Ice.ObjectPrx getServerAdmin(string id, global::Ice.Current current = null);

        /// <summary>
        /// Enable or disable a server.
        /// A disabled server can't be started on demand or administratively. The enable state
        ///  of the server is not persistent: if the node is shut down and restarted, the server will be enabled by default.
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <param name="enabled">True to enable the server, false to disable it.
        ///  </param>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void enableServer(string id, bool enabled, global::Ice.Current current = null);

        /// <summary>
        /// Check if the server is enabled or disabled.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <returns>True if the server is enabled.
        ///  </returns>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        bool isServerEnabled(string id, global::Ice.Current current = null);

        /// <summary>
        /// Start a server and wait for its activation.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        global::System.Threading.Tasks.Task startServerAsync(string id, global::Ice.Current current = null);

        /// <summary>
        /// Stop a server.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <param name="current">The Current object for the invocation.</param>
        /// <returns>The task object representing the asynchronous operation.</returns>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        global::System.Threading.Tasks.Task stopServerAsync(string id, global::Ice.Current current = null);

        /// <summary>
        /// Send signal to a server.
        /// </summary>
        /// <param name="id">The server id.
        ///  </param>
        /// <param name="signal">The signal, for example SIGTERM or 15.
        ///  </param>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.
        ///  </exception>
        /// <exception name="BadSignalException">Raised if the signal is not recognized by the target server.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void sendSignal(string id, string signal, global::Ice.Current current = null);

        /// <summary>
        /// Get all the server ids registered with IceGrid.
        /// </summary>
        /// <returns>The server ids.</returns>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        string[] getAllServerIds(global::Ice.Current current = null);

        /// <summary>
        /// Get the adapter information for the replica group or adapter with the given id.
        /// </summary>
        /// <param name="id">The adapter id.
        ///  </param>
        /// <returns>A sequence of adapter information structures. If the given id refers to an adapter, this sequence will
        ///  contain only one element. If the given id refers to a replica group, the sequence will contain the adapter
        ///  information of each member of the replica group.
        ///  </returns>
        /// <exception name="AdapterNotExistException">Raised if the adapter or replica group doesn't exist.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        AdapterInfo[] getAdapterInfo(string id, global::Ice.Current current = null);

        /// <summary>
        /// Remove the adapter with the given id.
        /// </summary>
        /// <param name="id">The adapter id.
        ///  </param>
        /// <exception name="AdapterNotExistException">Raised if the adapter doesn't exist.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void removeAdapter(string id, global::Ice.Current current = null);

        /// <summary>
        /// Get all the adapter ids registered with IceGrid.
        /// </summary>
        /// <returns>The adapter ids.</returns>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        string[] getAllAdapterIds(global::Ice.Current current = null);

        /// <summary>
        /// Add an object to the object registry.
        /// IceGrid will get the object type by calling ice_id on the
        ///  given proxy. The object must be reachable.
        /// </summary>
        ///  <param name="obj">The object to be added to the registry.
        ///  </param>
        /// <exception name="ObjectExistsException">Raised if the object is already registered.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the object can't be added. This might be raised if the invocation on the
        ///  proxy to get the object type failed.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void addObject(global::Ice.ObjectPrx obj, global::Ice.Current current = null);

        /// <summary>
        /// Update an object in the object registry.
        /// Only objects added with this interface can be updated with this
        ///  operation. Objects added with deployment descriptors should be updated with the deployment mechanism.
        /// </summary>
        ///  <param name="obj">The object to be updated to the registry.
        ///  </param>
        /// <exception name="ObjectNotRegisteredException">Raised if the object isn't registered with the registry.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the object can't be updated. This might happen if the object was added
        ///  with a deployment descriptor.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void updateObject(global::Ice.ObjectPrx obj, global::Ice.Current current = null);

        /// <summary>
        /// Add an object to the object registry and explicitly specify its type.
        /// </summary>
        /// <param name="obj">The object to be added to the registry. The proxy is never null.
        ///  </param>
        /// <param name="type">The object type.
        ///  </param>
        /// <exception name="ObjectExistsException">Raised if the object is already registered.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if application deployment failed.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void addObjectWithType(global::Ice.ObjectPrx obj, string type, global::Ice.Current current = null);

        /// <summary>
        /// Remove an object from the object registry.
        /// Only objects added with this interface can be removed with this
        ///  operation. Objects added with deployment descriptors should be removed with the deployment mechanism.
        /// </summary>
        ///  <param name="id">The identity of the object to be removed from the registry.
        ///  </param>
        /// <exception name="ObjectNotRegisteredException">Raised if the object isn't registered with the registry.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the object can't be removed. This might happen if the object was added
        ///  with a deployment descriptor.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void removeObject(global::Ice.Identity id, global::Ice.Current current = null);

        /// <summary>
        /// Get the object info for the object with the given identity.
        /// </summary>
        /// <param name="id">The identity of the object.
        ///  </param>
        /// <returns>The object info.
        ///  </returns>
        /// <exception name="ObjectNotRegisteredException">Raised if the object isn't registered with the registry.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        ObjectInfo getObjectInfo(global::Ice.Identity id, global::Ice.Current current = null);

        /// <summary>
        /// Get the object info of all the registered objects with the given type.
        /// </summary>
        /// <param name="type">The type of the object.
        ///  </param>
        /// <returns>The object infos.</returns>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        ObjectInfo[] getObjectInfosByType(string type, global::Ice.Current current = null);

        /// <summary>
        /// Get the object info of all the registered objects whose stringified identities match the given expression.
        /// </summary>
        /// <param name="expr">The expression to match against the stringified identities of registered objects. The expression
        ///  may contain a trailing wildcard (*) character.
        ///  </param>
        /// <returns>All the object infos with a stringified identity matching the given expression.</returns>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        ObjectInfo[] getAllObjectInfos(string expr, global::Ice.Current current = null);

        /// <summary>
        /// Ping an IceGrid node to see if it is active.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <returns>true if the node ping succeeded, false otherwise.
        ///  </returns>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        bool pingNode(string name, global::Ice.Current current = null);

        /// <summary>
        /// Get the load averages of the node.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <returns>The node load information.
        ///  </returns>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        LoadInfo getNodeLoad(string name, global::Ice.Current current = null);

        /// <summary>
        /// Get the node information for the node with the given name.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <returns>The node information.
        ///  </returns>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        NodeInfo getNodeInfo(string name, global::Ice.Current current = null);

        /// <summary>
        /// Get a proxy to the IceGrid node's admin object.
        /// </summary>
        /// <param name="name">The IceGrid node name
        ///  </param>
        /// <returns>A proxy to the IceGrid node's admin object. The returned proxy is never null.
        ///  </returns>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        global::Ice.ObjectPrx getNodeAdmin(string name, global::Ice.Current current = null);

        /// <summary>
        /// Get the number of physical processor sockets for the machine running the node with the given name.
        /// Note that this method will return 1 on operating systems where this can't be automatically determined and where
        ///  the IceGrid.Node.ProcessorSocketCount property for the node is not set.
        /// </summary>
        ///  <param name="name">The node name.
        ///  </param>
        /// <returns>The number of processor sockets or 1 if the number of sockets can't determined.
        ///  </returns>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        int getNodeProcessorSocketCount(string name, global::Ice.Current current = null);

        /// <summary>
        /// Shutdown an IceGrid node.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void shutdownNode(string name, global::Ice.Current current = null);

        /// <summary>
        /// Get the hostname of this node.
        /// </summary>
        /// <param name="name">The node name.
        ///  </param>
        /// <returns>The node hostname.
        ///  </returns>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        string getNodeHostname(string name, global::Ice.Current current = null);

        /// <summary>
        /// Get all the IceGrid nodes currently registered.
        /// </summary>
        /// <returns>The node names.</returns>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        string[] getAllNodeNames(global::Ice.Current current = null);

        /// <summary>
        /// Ping an IceGrid registry to see if it is active.
        /// </summary>
        /// <param name="name">The registry name.
        ///  </param>
        /// <returns>true if the registry ping succeeded, false otherwise.
        ///  </returns>
        /// <exception name="RegistryNotExistException">Raised if the registry doesn't exist.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        bool pingRegistry(string name, global::Ice.Current current = null);

        /// <summary>
        /// Get the registry information for the registry with the given name.
        /// </summary>
        /// <param name="name">The registry name.
        ///  </param>
        /// <returns>The registry information.
        ///  </returns>
        /// <exception name="RegistryNotExistException">Raised if the registry doesn't exist.
        ///  </exception>
        /// <exception name="RegistryUnreachableException">Raised if the registry could not be reached.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        RegistryInfo getRegistryInfo(string name, global::Ice.Current current = null);

        /// <summary>
        /// Get a proxy to the IceGrid registry's admin object.
        /// </summary>
        /// <param name="name">The registry name
        ///  </param>
        /// <returns>A proxy to the IceGrid registry's admin object. The returned proxy is never null.
        ///  </returns>
        /// <exception name="RegistryNotExistException">Raised if the registry doesn't exist.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        global::Ice.ObjectPrx getRegistryAdmin(string name, global::Ice.Current current = null);

        /// <summary>
        /// Shutdown an IceGrid registry.
        /// </summary>
        /// <param name="name">The registry name.
        ///  </param>
        /// <exception name="RegistryNotExistException">Raised if the registry doesn't exist.
        ///  </exception>
        /// <exception name="RegistryUnreachableException">Raised if the registry could not be reached.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void shutdownRegistry(string name, global::Ice.Current current = null);

        /// <summary>
        /// Get all the IceGrid registries currently registered.
        /// </summary>
        /// <returns>The registry names.</returns>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        string[] getAllRegistryNames(global::Ice.Current current = null);

        /// <summary>
        /// Shut down the IceGrid registry.
        /// </summary>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void shutdown(global::Ice.Current current = null);
    }

    /// <summary>
    /// This interface provides access to IceGrid log file contents.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public interface FileIteratorOperations_
    {
        /// <summary>
        /// Read lines from the log file.
        /// </summary>
        /// <param name="size">Specifies the maximum number of bytes to be received. The server will ensure that the returned
        ///  message doesn't exceed the given size.
        ///  </param>
        /// <param name="lines">The lines read from the file. If there was nothing to read from the file since the last call to
        ///  read, an empty sequence is returned. The last line of the sequence is always incomplete (and therefore no '\n'
        ///  should be added when writing the last line to the to the output device).
        ///  </param>
        /// <returns>True if EOF is encountered.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if there was a problem to read lines from the file.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        bool read(int size, out string[] lines, global::Ice.Current current = null);

        /// <summary>
        /// Destroy the iterator.
        /// </summary>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void destroy(global::Ice.Current current = null);
    }

    /// <summary>
    /// This interface allows applications to monitor changes the state of the registry.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public interface RegistryObserverOperations_
    {
        /// <summary>
        /// The registryInit operation is called after registration of an observer to indicate the state of
        ///  the registries.
        /// </summary>
        /// <param name="registries">The current state of the registries.</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void registryInit(RegistryInfo[] registries, global::Ice.Current current = null);

        /// <summary>
        /// The nodeUp operation is called to notify an observer that a node came up.
        /// </summary>
        /// <param name="node">The node state.</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void registryUp(RegistryInfo node, global::Ice.Current current = null);

        /// <summary>
        /// The nodeDown operation is called to notify an observer that a node went down.
        /// </summary>
        /// <param name="name">The node name.</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void registryDown(string name, global::Ice.Current current = null);
    }

    /// <summary>
    /// The node observer interface.
    /// Observers should implement this interface to receive information about the state of
    ///  the IceGrid nodes.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public interface NodeObserverOperations_
    {
        /// <summary>
        /// The nodeInit operation indicates the current state of nodes.
        /// It is called after the registration
        ///  of an observer.
        /// </summary>
        ///  <param name="nodes">The current state of the nodes.</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void nodeInit(NodeDynamicInfo[] nodes, global::Ice.Current current = null);

        /// <summary>
        /// The nodeUp operation is called to notify an observer that a node came up.
        /// </summary>
        /// <param name="node">The node state.</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void nodeUp(NodeDynamicInfo node, global::Ice.Current current = null);

        /// <summary>
        /// The nodeDown operation is called to notify an observer that a node went down.
        /// </summary>
        /// <param name="name">The node name.</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void nodeDown(string name, global::Ice.Current current = null);

        /// <summary>
        /// The updateServer operation is called to notify an observer that the state of a server changed.
        /// </summary>
        /// <param name="node">The node hosting the server.
        ///  </param>
        /// <param name="updatedInfo">The new server state.</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void updateServer(string node, ServerDynamicInfo updatedInfo, global::Ice.Current current = null);

        /// <summary>
        /// The updateAdapter operation is called to notify an observer that the state of an adapter changed.
        /// </summary>
        /// <param name="node">The node hosting the adapter.
        ///  </param>
        /// <param name="updatedInfo">The new adapter state.</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void updateAdapter(string node, AdapterDynamicInfo updatedInfo, global::Ice.Current current = null);
    }

    /// <summary>
    /// The database observer interface.
    /// Observers should implement this interface to receive information about the state
    ///  of the IceGrid registry database.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public interface ApplicationObserverOperations_
    {
        /// <summary>
        /// applicationInit is called after the registration of an observer to indicate the state of the
        ///  registry.
        /// </summary>
        /// <param name="serial">The current serial number of the registry database. This serial number allows observers to make
        ///  sure that their internal state is synchronized with the registry.
        ///  </param>
        /// <param name="applications">The applications currently registered with the registry.</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void applicationInit(int serial, ApplicationInfo[] applications, global::Ice.Current current = null);

        /// <summary>
        /// The applicationAdded operation is called to notify an observer that an application was added.
        /// </summary>
        /// <param name="serial">The new serial number of the registry database.
        ///  </param>
        /// <param name="desc">The descriptor of the new application.</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void applicationAdded(int serial, ApplicationInfo desc, global::Ice.Current current = null);

        /// <summary>
        /// The applicationRemoved operation is called to notify an observer that an application was removed.
        /// </summary>
        /// <param name="serial">The new serial number of the registry database.
        ///  </param>
        /// <param name="name">The name of the application that was removed.</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void applicationRemoved(int serial, string name, global::Ice.Current current = null);

        /// <summary>
        /// The applicationUpdated operation is called to notify an observer that an application was updated.
        /// </summary>
        /// <param name="serial">The new serial number of the registry database.
        ///  </param>
        /// <param name="desc">The descriptor of the update.</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void applicationUpdated(int serial, ApplicationUpdateInfo desc, global::Ice.Current current = null);
    }

    /// <summary>
    /// This interface allows applications to monitor the state of object adapters that are registered with IceGrid.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public interface AdapterObserverOperations_
    {
        /// <summary>
        /// adapterInit is called after registration of an observer to indicate the state of the registry.
        /// </summary>
        /// <param name="adpts">The adapters that were dynamically registered with the registry (not through the deployment
        ///  mechanism).</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void adapterInit(AdapterInfo[] adpts, global::Ice.Current current = null);

        /// <summary>
        /// The adapterAdded operation is called to notify an observer when a dynamically-registered adapter
        ///  was added.
        /// </summary>
        /// <param name="info">The details of the new adapter.</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void adapterAdded(AdapterInfo info, global::Ice.Current current = null);

        /// <summary>
        /// The adapterUpdated operation is called to notify an observer when a dynamically-registered adapter was updated.
        /// </summary>
        /// <param name="info">The details of the updated adapter.</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void adapterUpdated(AdapterInfo info, global::Ice.Current current = null);

        /// <summary>
        /// The adapterRemoved operation is called to notify an observer when a dynamically-registered adapter was removed.
        /// </summary>
        /// <param name="id">The ID of the removed adapter.</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void adapterRemoved(string id, global::Ice.Current current = null);
    }

    /// <summary>
    /// This interface allows applications to monitor IceGrid well-known objects.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public interface ObjectObserverOperations_
    {
        /// <summary>
        /// objectInit is called after the registration of an observer to indicate the state of the registry.
        /// </summary>
        /// <param name="objects">The objects registered with the Admin interface (not through the deployment mechanism).</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void objectInit(ObjectInfo[] objects, global::Ice.Current current = null);

        /// <summary>
        /// The objectAdded operation is called to notify an observer when an object was added to the
        ///  Admin interface.
        /// </summary>
        /// <param name="info">The details of the added object.</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void objectAdded(ObjectInfo info, global::Ice.Current current = null);

        /// <summary>
        /// objectUpdated is called to notify an observer when an object registered with the Admin
        ///  interface was updated.
        /// </summary>
        /// <param name="info">The details of the updated object.</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void objectUpdated(ObjectInfo info, global::Ice.Current current = null);

        /// <summary>
        /// objectRemoved is called to notify an observer when an object registered with the Admin
        ///  interface was removed.
        /// </summary>
        /// <param name="id">The identity of the removed object.</param>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void objectRemoved(global::Ice.Identity id, global::Ice.Current current = null);
    }

    /// <summary>
    /// Used by administrative clients to view, update, and receive observer updates from the IceGrid registry.
    /// Admin
    ///  sessions are created either via the Registry object or via the registry admin SessionManager
    ///  object.
    /// </summary>

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public interface AdminSessionOperations_ : global::Glacier2.SessionOperations_
    {
        /// <summary>
        /// Keep the session alive.
        /// Clients should call this operation regularly to prevent the server from reaping the
        ///  session.
        /// </summary>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void keepAlive(global::Ice.Current current = null);

        /// <summary>
        /// Get the admin interface.
        /// The admin object returned by this operation can only be accessed by the session.
        /// </summary>
        ///  <returns>The admin interface proxy. The returned proxy is never null.</returns>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        AdminPrx getAdmin(global::Ice.Current current = null);

        /// <summary>
        /// Get a "template" proxy for admin callback objects.
        /// An Admin client uses this proxy to set the category of its
        ///  callback objects, and the published endpoints of the object adapter hosting the admin callback objects.
        /// </summary>
        ///  <returns>A template proxy. The returned proxy is null when the Admin session was established using Glacier2.</returns>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        global::Ice.ObjectPrx getAdminCallbackTemplate(global::Ice.Current current = null);

        /// <summary>
        /// Set the observer proxies that receive notifications when the state of the registry or nodes changes.
        /// </summary>
        /// <param name="registryObs">The registry observer.
        ///  </param>
        /// <param name="nodeObs">The node observer.
        ///  </param>
        /// <param name="appObs">The application observer.
        ///  </param>
        /// <param name="adptObs">The adapter observer.
        ///  </param>
        /// <param name="objObs">The object observer.
        ///  </param>
        /// <exception name="ObserverAlreadyRegisteredException">Raised if an observer is already registered with this registry.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void setObservers(RegistryObserverPrx registryObs, NodeObserverPrx nodeObs, ApplicationObserverPrx appObs, AdapterObserverPrx adptObs, ObjectObserverPrx objObs, global::Ice.Current current = null);

        /// <summary>
        /// Set the observer identities that receive notifications the state of the registry or nodes changes.
        /// This
        ///  operation should be used by clients that are using a bidirectional connection to communicate with the session.
        /// </summary>
        ///  <param name="registryObs">The registry observer identity.
        ///  </param>
        /// <param name="nodeObs">The node observer identity.
        ///  </param>
        /// <param name="appObs">The application observer.
        ///  </param>
        /// <param name="adptObs">The adapter observer.
        ///  </param>
        /// <param name="objObs">The object observer.
        ///  </param>
        /// <exception name="ObserverAlreadyRegisteredException">Raised if an observer is already registered with this registry.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void setObserversByIdentity(global::Ice.Identity registryObs, global::Ice.Identity nodeObs, global::Ice.Identity appObs, global::Ice.Identity adptObs, global::Ice.Identity objObs, global::Ice.Current current = null);

        /// <summary>
        /// Acquires an exclusive lock to start updating the registry applications.
        /// </summary>
        /// <returns>The current serial.
        ///  </returns>
        /// <exception name="AccessDeniedException">Raised if the exclusive lock can't be acquired. This might happen if the lock is
        ///  currently acquired by another session.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        int startUpdate(global::Ice.Current current = null);

        /// <summary>
        /// Finish updating the registry and release the exclusive lock.
        /// </summary>
        /// <exception name="AccessDeniedException">Raised if the session doesn't hold the exclusive lock.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        void finishUpdate(global::Ice.Current current = null);

        /// <summary>
        /// Get the name of the registry replica hosting this session.
        /// </summary>
        /// <returns>The replica name of the registry.</returns>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        string getReplicaName(global::Ice.Current current = null);

        /// <summary>
        /// Open the given server log file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <param name="path">The path of the log file. A log file can be opened only if it's declared in the server or service
        ///  deployment descriptor.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If 0
        ///  or positive, the file is read from the last count lines.
        ///  </param>
        /// <returns>An iterator to read the file. The returned proxy is never null.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if the file can't be read.
        ///  </exception>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        FileIteratorPrx openServerLog(string id, string path, int count, global::Ice.Current current = null);

        /// <summary>
        /// Open the given server stderr file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If 0
        ///  or positive, the file is read from the last count lines.
        ///  </param>
        /// <returns>An iterator to read the file. The returned proxy is never null.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if the file can't be read.
        ///  </exception>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        FileIteratorPrx openServerStdErr(string id, int count, global::Ice.Current current = null);

        /// <summary>
        /// Open the given server stdout file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="id">The server id.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining.
        ///  If 0 or positive, the file is read from the last count lines.
        ///  </param>
        /// <returns>An iterator to read the file. The returned proxy is never null.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if the file can't be read.
        ///   </exception>
        /// <exception name="ServerNotExistException">Raised if the server doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.
        ///  </exception>
        /// <exception name="DeploymentException">Raised if the server couldn't be deployed on the node.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        FileIteratorPrx openServerStdOut(string id, int count, global::Ice.Current current = null);

        /// <summary>
        /// Open the given node stderr file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="name">The node name.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If 0
        ///  or positive, the file is read from the last count lines.
        ///  </param>
        /// <returns>An iterator to read the file. The returned proxy is never null.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if the file can't be read.
        ///  </exception>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        FileIteratorPrx openNodeStdErr(string name, int count, global::Ice.Current current = null);

        /// <summary>
        /// Open the given node stdout file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="name">The node name.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If 0
        ///  or positive, the file is read from the last count lines.
        ///  </param>
        /// <returns>An iterator to read the file. The returned proxy is never null.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if the file can't be read.
        ///  </exception>
        /// <exception name="NodeNotExistException">Raised if the node doesn't exist.
        ///  </exception>
        /// <exception name="NodeUnreachableException">Raised if the node could not be reached.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        FileIteratorPrx openNodeStdOut(string name, int count, global::Ice.Current current = null);

        /// <summary>
        /// Open the given registry stderr file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="name">The registry name.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If 0
        ///  or positive, the file is read from the last count lines.
        ///  </param>
        /// <returns>An iterator to read the file. The returned proxy is never null.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if the file can't be read.
        ///  </exception>
        /// <exception name="RegistryNotExistException">Raised if the registry doesn't exist.
        ///  </exception>
        /// <exception name="RegistryUnreachableException">Raised if the registry could not be reached.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        FileIteratorPrx openRegistryStdErr(string name, int count, global::Ice.Current current = null);

        /// <summary>
        /// Open the given registry stdout file for reading.
        /// The file can be read with the returned file iterator.
        /// </summary>
        ///  <param name="name">The registry name.
        ///  </param>
        /// <param name="count">Specifies where to start reading the file. If negative, the file is read from the begining. If 0
        ///  or positive, the file is read from the last count lines.
        ///  </param>
        /// <returns>An iterator to read the file. The returned proxy is never null.
        ///  </returns>
        /// <exception name="FileNotAvailableException">Raised if the file can't be read.
        ///  </exception>
        /// <exception name="RegistryNotExistException">Raised if the registry doesn't exist.
        ///  </exception>
        /// <exception name="RegistryUnreachableException">Raised if the registry could not be reached.</exception>
        /// <param name="current">The Current object for the invocation.</param>

        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
        FileIteratorPrx openRegistryStdOut(string name, int count, global::Ice.Current current = null);
    }
}

namespace IceGrid
{
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public sealed class StringObjectProxyDictHelper
    {
        public static void write(global::Ice.OutputStream ostr,
                                 global::System.Collections.Generic.Dictionary<string, global::Ice.ObjectPrx> v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Count);
                foreach(global::System.Collections.Generic.KeyValuePair<string, global::Ice.ObjectPrx> e in v)
                {
                    ostr.writeString(e.Key);
                    ostr.writeProxy(e.Value);
                }
            }
        }

        public static global::System.Collections.Generic.Dictionary<string, global::Ice.ObjectPrx> read(global::Ice.InputStream istr)
        {
            int sz = istr.readSize();
            global::System.Collections.Generic.Dictionary<string, global::Ice.ObjectPrx> r = new global::System.Collections.Generic.Dictionary<string, global::Ice.ObjectPrx>();
            for(int i = 0; i < sz; ++i)
            {
                string k;
                k = istr.readString();
                global::Ice.ObjectPrx v;
                v = istr.readProxy();
                r[k] = v;
            }
            return r;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public sealed class ObjectInfoSeqHelper
    {
        public static void write(global::Ice.OutputStream ostr, ObjectInfo[] v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    (v[ix] == null ? new ObjectInfo() : v[ix]).ice_writeMembers(ostr);
                }
            }
        }

        public static ObjectInfo[] read(global::Ice.InputStream istr)
        {
            ObjectInfo[] v;
            {
                int szx = istr.readAndCheckSeqSize(3);
                v = new ObjectInfo[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new ObjectInfo();
                    v[ix].ice_readMembers(istr);
                }
            }
            return v;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public sealed class AdapterInfoSeqHelper
    {
        public static void write(global::Ice.OutputStream ostr, AdapterInfo[] v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    (v[ix] == null ? new AdapterInfo() : v[ix]).ice_writeMembers(ostr);
                }
            }
        }

        public static AdapterInfo[] read(global::Ice.InputStream istr)
        {
            AdapterInfo[] v;
            {
                int szx = istr.readAndCheckSeqSize(4);
                v = new AdapterInfo[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new AdapterInfo();
                    v[ix].ice_readMembers(istr);
                }
            }
            return v;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public sealed class RegistryInfoSeqHelper
    {
        public static void write(global::Ice.OutputStream ostr, RegistryInfo[] v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    (v[ix] == null ? new RegistryInfo() : v[ix]).ice_writeMembers(ostr);
                }
            }
        }

        public static RegistryInfo[] read(global::Ice.InputStream istr)
        {
            RegistryInfo[] v;
            {
                int szx = istr.readAndCheckSeqSize(2);
                v = new RegistryInfo[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new RegistryInfo();
                    v[ix].ice_readMembers(istr);
                }
            }
            return v;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public sealed class ApplicationInfoSeqHelper
    {
        public static void write(global::Ice.OutputStream ostr, ApplicationInfo[] v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    (v[ix] == null ? new ApplicationInfo() : v[ix]).ice_writeMembers(ostr);
                }
            }
        }

        public static ApplicationInfo[] read(global::Ice.InputStream istr)
        {
            ApplicationInfo[] v;
            {
                int szx = istr.readAndCheckSeqSize(33);
                v = new ApplicationInfo[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new ApplicationInfo();
                    v[ix].ice_readMembers(istr);
                }
            }
            return v;
        }
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public sealed class AdminPrxHelper : global::Ice.ObjectPrxHelperBase, AdminPrx
    {
        public AdminPrxHelper()
        {
        }

        #region Synchronous operations

        public void addApplication(ApplicationDescriptor descriptor, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_addApplicationAsync(descriptor, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void syncApplication(ApplicationDescriptor descriptor, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_syncApplicationAsync(descriptor, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void updateApplication(ApplicationUpdateDescriptor descriptor, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_updateApplicationAsync(descriptor, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void syncApplicationWithoutRestart(ApplicationDescriptor descriptor, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_syncApplicationWithoutRestartAsync(descriptor, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void updateApplicationWithoutRestart(ApplicationUpdateDescriptor descriptor, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_updateApplicationWithoutRestartAsync(descriptor, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void removeApplication(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_removeApplicationAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void instantiateServer(string application, string node, ServerInstanceDescriptor desc, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_instantiateServerAsync(application, node, desc, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public ApplicationInfo getApplicationInfo(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getApplicationInfoAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public ApplicationDescriptor getDefaultApplicationDescriptor(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getDefaultApplicationDescriptorAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public string[] getAllApplicationNames(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getAllApplicationNamesAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public ServerInfo getServerInfo(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getServerInfoAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public ServerState getServerState(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getServerStateAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public int getServerPid(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getServerPidAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public string getServerAdminCategory(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getServerAdminCategoryAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public global::Ice.ObjectPrx getServerAdmin(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getServerAdminAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void enableServer(string id, bool enabled, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_enableServerAsync(id, enabled, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public bool isServerEnabled(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_isServerEnabledAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void startServer(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_startServerAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void stopServer(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_stopServerAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void sendSignal(string id, string signal, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_sendSignalAsync(id, signal, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public string[] getAllServerIds(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getAllServerIdsAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public AdapterInfo[] getAdapterInfo(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getAdapterInfoAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void removeAdapter(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_removeAdapterAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public string[] getAllAdapterIds(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getAllAdapterIdsAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void addObject(global::Ice.ObjectPrx obj, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_addObjectAsync(obj, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void updateObject(global::Ice.ObjectPrx obj, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_updateObjectAsync(obj, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void addObjectWithType(global::Ice.ObjectPrx obj, string type, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_addObjectWithTypeAsync(obj, type, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void removeObject(global::Ice.Identity id, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_removeObjectAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public ObjectInfo getObjectInfo(global::Ice.Identity id, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getObjectInfoAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public ObjectInfo[] getObjectInfosByType(string type, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getObjectInfosByTypeAsync(type, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public ObjectInfo[] getAllObjectInfos(string expr, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getAllObjectInfosAsync(expr, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public bool pingNode(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_pingNodeAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public LoadInfo getNodeLoad(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getNodeLoadAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public NodeInfo getNodeInfo(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getNodeInfoAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public global::Ice.ObjectPrx getNodeAdmin(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getNodeAdminAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public int getNodeProcessorSocketCount(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getNodeProcessorSocketCountAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void shutdownNode(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_shutdownNodeAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public string getNodeHostname(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getNodeHostnameAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public string[] getAllNodeNames(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getAllNodeNamesAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public bool pingRegistry(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_pingRegistryAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public RegistryInfo getRegistryInfo(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getRegistryInfoAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public global::Ice.ObjectPrx getRegistryAdmin(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getRegistryAdminAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void shutdownRegistry(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_shutdownRegistryAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public string[] getAllRegistryNames(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getAllRegistryNamesAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void shutdown(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_shutdownAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        #endregion

        #region Async Task operations

        public global::System.Threading.Tasks.Task addApplicationAsync(ApplicationDescriptor descriptor, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_addApplicationAsync(descriptor, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_addApplicationAsync(ApplicationDescriptor iceP_descriptor, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_addApplication_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_addApplication(iceP_descriptor, context, synchronous, completed);
            return completed.Task;
        }

        private const string _addApplication_name = "addApplication";

        private void _iceI_addApplication(ApplicationDescriptor iceP_descriptor, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _addApplication_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ApplicationDescriptor.ice_write(ostr, iceP_descriptor);
                    ostr.writePendingValues();
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(AccessDeniedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task syncApplicationAsync(ApplicationDescriptor descriptor, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_syncApplicationAsync(descriptor, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_syncApplicationAsync(ApplicationDescriptor iceP_descriptor, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_syncApplication_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_syncApplication(iceP_descriptor, context, synchronous, completed);
            return completed.Task;
        }

        private const string _syncApplication_name = "syncApplication";

        private void _iceI_syncApplication(ApplicationDescriptor iceP_descriptor, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _syncApplication_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ApplicationDescriptor.ice_write(ostr, iceP_descriptor);
                    ostr.writePendingValues();
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ApplicationNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(AccessDeniedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task updateApplicationAsync(ApplicationUpdateDescriptor descriptor, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_updateApplicationAsync(descriptor, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_updateApplicationAsync(ApplicationUpdateDescriptor iceP_descriptor, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_updateApplication_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_updateApplication(iceP_descriptor, context, synchronous, completed);
            return completed.Task;
        }

        private const string _updateApplication_name = "updateApplication";

        private void _iceI_updateApplication(ApplicationUpdateDescriptor iceP_descriptor, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _updateApplication_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ApplicationUpdateDescriptor.ice_write(ostr, iceP_descriptor);
                    ostr.writePendingValues();
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ApplicationNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(AccessDeniedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task syncApplicationWithoutRestartAsync(ApplicationDescriptor descriptor, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_syncApplicationWithoutRestartAsync(descriptor, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_syncApplicationWithoutRestartAsync(ApplicationDescriptor iceP_descriptor, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_syncApplicationWithoutRestart_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_syncApplicationWithoutRestart(iceP_descriptor, context, synchronous, completed);
            return completed.Task;
        }

        private const string _syncApplicationWithoutRestart_name = "syncApplicationWithoutRestart";

        private void _iceI_syncApplicationWithoutRestart(ApplicationDescriptor iceP_descriptor, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _syncApplicationWithoutRestart_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ApplicationDescriptor.ice_write(ostr, iceP_descriptor);
                    ostr.writePendingValues();
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ApplicationNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(AccessDeniedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task updateApplicationWithoutRestartAsync(ApplicationUpdateDescriptor descriptor, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_updateApplicationWithoutRestartAsync(descriptor, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_updateApplicationWithoutRestartAsync(ApplicationUpdateDescriptor iceP_descriptor, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_updateApplicationWithoutRestart_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_updateApplicationWithoutRestart(iceP_descriptor, context, synchronous, completed);
            return completed.Task;
        }

        private const string _updateApplicationWithoutRestart_name = "updateApplicationWithoutRestart";

        private void _iceI_updateApplicationWithoutRestart(ApplicationUpdateDescriptor iceP_descriptor, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _updateApplicationWithoutRestart_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ApplicationUpdateDescriptor.ice_write(ostr, iceP_descriptor);
                    ostr.writePendingValues();
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ApplicationNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(AccessDeniedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task removeApplicationAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_removeApplicationAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_removeApplicationAsync(string iceP_name, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_removeApplication_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_removeApplication(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _removeApplication_name = "removeApplication";

        private void _iceI_removeApplication(string iceP_name, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _removeApplication_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ApplicationNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(AccessDeniedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task instantiateServerAsync(string application, string node, ServerInstanceDescriptor desc, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_instantiateServerAsync(application, node, desc, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_instantiateServerAsync(string iceP_application, string iceP_node, ServerInstanceDescriptor iceP_desc, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_instantiateServer_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_instantiateServer(iceP_application, iceP_node, iceP_desc, context, synchronous, completed);
            return completed.Task;
        }

        private const string _instantiateServer_name = "instantiateServer";

        private void _iceI_instantiateServer(string iceP_application, string iceP_node, ServerInstanceDescriptor iceP_desc, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _instantiateServer_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_application);
                    ostr.writeString(iceP_node);
                    ServerInstanceDescriptor.ice_write(ostr, iceP_desc);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ApplicationNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(AccessDeniedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<ApplicationInfo> getApplicationInfoAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getApplicationInfoAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<ApplicationInfo> _iceI_getApplicationInfoAsync(string iceP_name, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getApplicationInfo_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<ApplicationInfo>(progress, cancel);
            _iceI_getApplicationInfo(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getApplicationInfo_name = "getApplicationInfo";

        private void _iceI_getApplicationInfo(string iceP_name, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<ApplicationInfo>(completed);
            outAsync.invoke(
                _getApplicationInfo_name,
                global::Ice.OperationMode.Nonmutating,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ApplicationNotExistException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    ApplicationInfo ret = null;
                    ret = ApplicationInfo.ice_read(istr);
                    istr.readPendingValues();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<ApplicationDescriptor> getDefaultApplicationDescriptorAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getDefaultApplicationDescriptorAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<ApplicationDescriptor> _iceI_getDefaultApplicationDescriptorAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getDefaultApplicationDescriptor_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<ApplicationDescriptor>(progress, cancel);
            _iceI_getDefaultApplicationDescriptor(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getDefaultApplicationDescriptor_name = "getDefaultApplicationDescriptor";

        private void _iceI_getDefaultApplicationDescriptor(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<ApplicationDescriptor>(completed);
            outAsync.invoke(
                _getDefaultApplicationDescriptor_name,
                global::Ice.OperationMode.Nonmutating,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    ApplicationDescriptor ret = null;
                    ret = ApplicationDescriptor.ice_read(istr);
                    istr.readPendingValues();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<string[]> getAllApplicationNamesAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getAllApplicationNamesAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<string[]> _iceI_getAllApplicationNamesAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getAllApplicationNames_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<string[]>(progress, cancel);
            _iceI_getAllApplicationNames(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getAllApplicationNames_name = "getAllApplicationNames";

        private void _iceI_getAllApplicationNames(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<string[]>(completed);
            outAsync.invoke(
                _getAllApplicationNames_name,
                global::Ice.OperationMode.Nonmutating,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                read: (global::Ice.InputStream istr) =>
                {
                    string[] ret;
                    ret = global::Ice.StringSeqHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<ServerInfo> getServerInfoAsync(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getServerInfoAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<ServerInfo> _iceI_getServerInfoAsync(string iceP_id, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getServerInfo_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<ServerInfo>(progress, cancel);
            _iceI_getServerInfo(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getServerInfo_name = "getServerInfo";

        private void _iceI_getServerInfo(string iceP_id, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<ServerInfo>(completed);
            outAsync.invoke(
                _getServerInfo_name,
                global::Ice.OperationMode.Nonmutating,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ServerNotExistException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    ServerInfo ret = null;
                    ret = ServerInfo.ice_read(istr);
                    istr.readPendingValues();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<ServerState> getServerStateAsync(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getServerStateAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<ServerState> _iceI_getServerStateAsync(string iceP_id, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getServerState_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<ServerState>(progress, cancel);
            _iceI_getServerState(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getServerState_name = "getServerState";

        private void _iceI_getServerState(string iceP_id, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<ServerState>(completed);
            outAsync.invoke(
                _getServerState_name,
                global::Ice.OperationMode.Nonmutating,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ServerNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    ServerState ret;
                    ret = (ServerState)istr.readEnum(6);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<int> getServerPidAsync(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getServerPidAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<int> _iceI_getServerPidAsync(string iceP_id, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getServerPid_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<int>(progress, cancel);
            _iceI_getServerPid(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getServerPid_name = "getServerPid";

        private void _iceI_getServerPid(string iceP_id, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<int>(completed);
            outAsync.invoke(
                _getServerPid_name,
                global::Ice.OperationMode.Nonmutating,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ServerNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    int ret;
                    ret = istr.readInt();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<string> getServerAdminCategoryAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getServerAdminCategoryAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<string> _iceI_getServerAdminCategoryAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getServerAdminCategory_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<string>(progress, cancel);
            _iceI_getServerAdminCategory(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getServerAdminCategory_name = "getServerAdminCategory";

        private void _iceI_getServerAdminCategory(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<string>(completed);
            outAsync.invoke(
                _getServerAdminCategory_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                read: (global::Ice.InputStream istr) =>
                {
                    string ret;
                    ret = istr.readString();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<global::Ice.ObjectPrx> getServerAdminAsync(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getServerAdminAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<global::Ice.ObjectPrx> _iceI_getServerAdminAsync(string iceP_id, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getServerAdmin_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<global::Ice.ObjectPrx>(progress, cancel);
            _iceI_getServerAdmin(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getServerAdmin_name = "getServerAdmin";

        private void _iceI_getServerAdmin(string iceP_id, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<global::Ice.ObjectPrx>(completed);
            outAsync.invoke(
                _getServerAdmin_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ServerNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    global::Ice.ObjectPrx ret;
                    ret = istr.readProxy();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task enableServerAsync(string id, bool enabled, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_enableServerAsync(id, enabled, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_enableServerAsync(string iceP_id, bool iceP_enabled, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_enableServer_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_enableServer(iceP_id, iceP_enabled, context, synchronous, completed);
            return completed.Task;
        }

        private const string _enableServer_name = "enableServer";

        private void _iceI_enableServer(string iceP_id, bool iceP_enabled, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _enableServer_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                    ostr.writeBool(iceP_enabled);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ServerNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<bool> isServerEnabledAsync(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_isServerEnabledAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<bool> _iceI_isServerEnabledAsync(string iceP_id, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_isServerEnabled_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<bool>(progress, cancel);
            _iceI_isServerEnabled(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _isServerEnabled_name = "isServerEnabled";

        private void _iceI_isServerEnabled(string iceP_id, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<bool>(completed);
            outAsync.invoke(
                _isServerEnabled_name,
                global::Ice.OperationMode.Nonmutating,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ServerNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    bool ret;
                    ret = istr.readBool();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task startServerAsync(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_startServerAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_startServerAsync(string iceP_id, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_startServer_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_startServer(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _startServer_name = "startServer";

        private void _iceI_startServer(string iceP_id, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _startServer_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ServerNotExistException)
                    {
                        throw;
                    }
                    catch(ServerStartException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task stopServerAsync(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_stopServerAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_stopServerAsync(string iceP_id, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_stopServer_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_stopServer(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _stopServer_name = "stopServer";

        private void _iceI_stopServer(string iceP_id, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _stopServer_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ServerNotExistException)
                    {
                        throw;
                    }
                    catch(ServerStopException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task sendSignalAsync(string id, string signal, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_sendSignalAsync(id, signal, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_sendSignalAsync(string iceP_id, string iceP_signal, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_sendSignal_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_sendSignal(iceP_id, iceP_signal, context, synchronous, completed);
            return completed.Task;
        }

        private const string _sendSignal_name = "sendSignal";

        private void _iceI_sendSignal(string iceP_id, string iceP_signal, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _sendSignal_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                    ostr.writeString(iceP_signal);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ServerNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(BadSignalException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<string[]> getAllServerIdsAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getAllServerIdsAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<string[]> _iceI_getAllServerIdsAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getAllServerIds_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<string[]>(progress, cancel);
            _iceI_getAllServerIds(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getAllServerIds_name = "getAllServerIds";

        private void _iceI_getAllServerIds(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<string[]>(completed);
            outAsync.invoke(
                _getAllServerIds_name,
                global::Ice.OperationMode.Nonmutating,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                read: (global::Ice.InputStream istr) =>
                {
                    string[] ret;
                    ret = global::Ice.StringSeqHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<AdapterInfo[]> getAdapterInfoAsync(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getAdapterInfoAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<AdapterInfo[]> _iceI_getAdapterInfoAsync(string iceP_id, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getAdapterInfo_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<AdapterInfo[]>(progress, cancel);
            _iceI_getAdapterInfo(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getAdapterInfo_name = "getAdapterInfo";

        private void _iceI_getAdapterInfo(string iceP_id, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<AdapterInfo[]>(completed);
            outAsync.invoke(
                _getAdapterInfo_name,
                global::Ice.OperationMode.Nonmutating,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(AdapterNotExistException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    AdapterInfo[] ret;
                    ret = AdapterInfoSeqHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task removeAdapterAsync(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_removeAdapterAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_removeAdapterAsync(string iceP_id, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_removeAdapter_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_removeAdapter(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _removeAdapter_name = "removeAdapter";

        private void _iceI_removeAdapter(string iceP_id, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _removeAdapter_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(AdapterNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<string[]> getAllAdapterIdsAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getAllAdapterIdsAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<string[]> _iceI_getAllAdapterIdsAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getAllAdapterIds_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<string[]>(progress, cancel);
            _iceI_getAllAdapterIds(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getAllAdapterIds_name = "getAllAdapterIds";

        private void _iceI_getAllAdapterIds(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<string[]>(completed);
            outAsync.invoke(
                _getAllAdapterIds_name,
                global::Ice.OperationMode.Nonmutating,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                read: (global::Ice.InputStream istr) =>
                {
                    string[] ret;
                    ret = global::Ice.StringSeqHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task addObjectAsync(global::Ice.ObjectPrx obj, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_addObjectAsync(obj, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_addObjectAsync(global::Ice.ObjectPrx iceP_obj, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_addObject_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_addObject(iceP_obj, context, synchronous, completed);
            return completed.Task;
        }

        private const string _addObject_name = "addObject";

        private void _iceI_addObject(global::Ice.ObjectPrx iceP_obj, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _addObject_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeProxy(iceP_obj);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ObjectExistsException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task updateObjectAsync(global::Ice.ObjectPrx obj, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_updateObjectAsync(obj, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_updateObjectAsync(global::Ice.ObjectPrx iceP_obj, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_updateObject_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_updateObject(iceP_obj, context, synchronous, completed);
            return completed.Task;
        }

        private const string _updateObject_name = "updateObject";

        private void _iceI_updateObject(global::Ice.ObjectPrx iceP_obj, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _updateObject_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeProxy(iceP_obj);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ObjectNotRegisteredException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task addObjectWithTypeAsync(global::Ice.ObjectPrx obj, string type, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_addObjectWithTypeAsync(obj, type, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_addObjectWithTypeAsync(global::Ice.ObjectPrx iceP_obj, string iceP_type, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_addObjectWithType_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_addObjectWithType(iceP_obj, iceP_type, context, synchronous, completed);
            return completed.Task;
        }

        private const string _addObjectWithType_name = "addObjectWithType";

        private void _iceI_addObjectWithType(global::Ice.ObjectPrx iceP_obj, string iceP_type, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _addObjectWithType_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeProxy(iceP_obj);
                    ostr.writeString(iceP_type);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ObjectExistsException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task removeObjectAsync(global::Ice.Identity id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_removeObjectAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_removeObjectAsync(global::Ice.Identity iceP_id, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_removeObject_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_removeObject(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _removeObject_name = "removeObject";

        private void _iceI_removeObject(global::Ice.Identity iceP_id, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _removeObject_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    global::Ice.Identity.ice_write(ostr, iceP_id);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ObjectNotRegisteredException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<ObjectInfo> getObjectInfoAsync(global::Ice.Identity id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getObjectInfoAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<ObjectInfo> _iceI_getObjectInfoAsync(global::Ice.Identity iceP_id, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getObjectInfo_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<ObjectInfo>(progress, cancel);
            _iceI_getObjectInfo(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getObjectInfo_name = "getObjectInfo";

        private void _iceI_getObjectInfo(global::Ice.Identity iceP_id, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<ObjectInfo>(completed);
            outAsync.invoke(
                _getObjectInfo_name,
                global::Ice.OperationMode.Nonmutating,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    global::Ice.Identity.ice_write(ostr, iceP_id);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ObjectNotRegisteredException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    ObjectInfo ret = null;
                    ret = ObjectInfo.ice_read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<ObjectInfo[]> getObjectInfosByTypeAsync(string type, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getObjectInfosByTypeAsync(type, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<ObjectInfo[]> _iceI_getObjectInfosByTypeAsync(string iceP_type, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getObjectInfosByType_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<ObjectInfo[]>(progress, cancel);
            _iceI_getObjectInfosByType(iceP_type, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getObjectInfosByType_name = "getObjectInfosByType";

        private void _iceI_getObjectInfosByType(string iceP_type, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<ObjectInfo[]>(completed);
            outAsync.invoke(
                _getObjectInfosByType_name,
                global::Ice.OperationMode.Nonmutating,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_type);
                },
                read: (global::Ice.InputStream istr) =>
                {
                    ObjectInfo[] ret;
                    ret = ObjectInfoSeqHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<ObjectInfo[]> getAllObjectInfosAsync(string expr, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getAllObjectInfosAsync(expr, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<ObjectInfo[]> _iceI_getAllObjectInfosAsync(string iceP_expr, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getAllObjectInfos_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<ObjectInfo[]>(progress, cancel);
            _iceI_getAllObjectInfos(iceP_expr, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getAllObjectInfos_name = "getAllObjectInfos";

        private void _iceI_getAllObjectInfos(string iceP_expr, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<ObjectInfo[]>(completed);
            outAsync.invoke(
                _getAllObjectInfos_name,
                global::Ice.OperationMode.Nonmutating,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_expr);
                },
                read: (global::Ice.InputStream istr) =>
                {
                    ObjectInfo[] ret;
                    ret = ObjectInfoSeqHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<bool> pingNodeAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_pingNodeAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<bool> _iceI_pingNodeAsync(string iceP_name, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_pingNode_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<bool>(progress, cancel);
            _iceI_pingNode(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _pingNode_name = "pingNode";

        private void _iceI_pingNode(string iceP_name, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<bool>(completed);
            outAsync.invoke(
                _pingNode_name,
                global::Ice.OperationMode.Nonmutating,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(NodeNotExistException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    bool ret;
                    ret = istr.readBool();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<LoadInfo> getNodeLoadAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getNodeLoadAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<LoadInfo> _iceI_getNodeLoadAsync(string iceP_name, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getNodeLoad_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<LoadInfo>(progress, cancel);
            _iceI_getNodeLoad(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getNodeLoad_name = "getNodeLoad";

        private void _iceI_getNodeLoad(string iceP_name, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<LoadInfo>(completed);
            outAsync.invoke(
                _getNodeLoad_name,
                global::Ice.OperationMode.Nonmutating,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(NodeNotExistException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    LoadInfo ret = new LoadInfo();
                    ret.ice_readMembers(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<NodeInfo> getNodeInfoAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getNodeInfoAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<NodeInfo> _iceI_getNodeInfoAsync(string iceP_name, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getNodeInfo_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<NodeInfo>(progress, cancel);
            _iceI_getNodeInfo(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getNodeInfo_name = "getNodeInfo";

        private void _iceI_getNodeInfo(string iceP_name, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<NodeInfo>(completed);
            outAsync.invoke(
                _getNodeInfo_name,
                global::Ice.OperationMode.Nonmutating,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(NodeNotExistException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    NodeInfo ret = null;
                    ret = NodeInfo.ice_read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<global::Ice.ObjectPrx> getNodeAdminAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getNodeAdminAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<global::Ice.ObjectPrx> _iceI_getNodeAdminAsync(string iceP_name, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getNodeAdmin_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<global::Ice.ObjectPrx>(progress, cancel);
            _iceI_getNodeAdmin(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getNodeAdmin_name = "getNodeAdmin";

        private void _iceI_getNodeAdmin(string iceP_name, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<global::Ice.ObjectPrx>(completed);
            outAsync.invoke(
                _getNodeAdmin_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(NodeNotExistException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    global::Ice.ObjectPrx ret;
                    ret = istr.readProxy();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<int> getNodeProcessorSocketCountAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getNodeProcessorSocketCountAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<int> _iceI_getNodeProcessorSocketCountAsync(string iceP_name, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getNodeProcessorSocketCount_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<int>(progress, cancel);
            _iceI_getNodeProcessorSocketCount(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getNodeProcessorSocketCount_name = "getNodeProcessorSocketCount";

        private void _iceI_getNodeProcessorSocketCount(string iceP_name, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<int>(completed);
            outAsync.invoke(
                _getNodeProcessorSocketCount_name,
                global::Ice.OperationMode.Nonmutating,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(NodeNotExistException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    int ret;
                    ret = istr.readInt();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task shutdownNodeAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_shutdownNodeAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_shutdownNodeAsync(string iceP_name, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_shutdownNode_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_shutdownNode(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _shutdownNode_name = "shutdownNode";

        private void _iceI_shutdownNode(string iceP_name, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _shutdownNode_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(NodeNotExistException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<string> getNodeHostnameAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getNodeHostnameAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<string> _iceI_getNodeHostnameAsync(string iceP_name, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getNodeHostname_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<string>(progress, cancel);
            _iceI_getNodeHostname(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getNodeHostname_name = "getNodeHostname";

        private void _iceI_getNodeHostname(string iceP_name, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<string>(completed);
            outAsync.invoke(
                _getNodeHostname_name,
                global::Ice.OperationMode.Nonmutating,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(NodeNotExistException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    string ret;
                    ret = istr.readString();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<string[]> getAllNodeNamesAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getAllNodeNamesAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<string[]> _iceI_getAllNodeNamesAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getAllNodeNames_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<string[]>(progress, cancel);
            _iceI_getAllNodeNames(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getAllNodeNames_name = "getAllNodeNames";

        private void _iceI_getAllNodeNames(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<string[]>(completed);
            outAsync.invoke(
                _getAllNodeNames_name,
                global::Ice.OperationMode.Nonmutating,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                read: (global::Ice.InputStream istr) =>
                {
                    string[] ret;
                    ret = global::Ice.StringSeqHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<bool> pingRegistryAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_pingRegistryAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<bool> _iceI_pingRegistryAsync(string iceP_name, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_pingRegistry_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<bool>(progress, cancel);
            _iceI_pingRegistry(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _pingRegistry_name = "pingRegistry";

        private void _iceI_pingRegistry(string iceP_name, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<bool>(completed);
            outAsync.invoke(
                _pingRegistry_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(RegistryNotExistException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    bool ret;
                    ret = istr.readBool();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<RegistryInfo> getRegistryInfoAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getRegistryInfoAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<RegistryInfo> _iceI_getRegistryInfoAsync(string iceP_name, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getRegistryInfo_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<RegistryInfo>(progress, cancel);
            _iceI_getRegistryInfo(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getRegistryInfo_name = "getRegistryInfo";

        private void _iceI_getRegistryInfo(string iceP_name, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<RegistryInfo>(completed);
            outAsync.invoke(
                _getRegistryInfo_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(RegistryNotExistException)
                    {
                        throw;
                    }
                    catch(RegistryUnreachableException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    RegistryInfo ret = null;
                    ret = RegistryInfo.ice_read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<global::Ice.ObjectPrx> getRegistryAdminAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getRegistryAdminAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<global::Ice.ObjectPrx> _iceI_getRegistryAdminAsync(string iceP_name, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getRegistryAdmin_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<global::Ice.ObjectPrx>(progress, cancel);
            _iceI_getRegistryAdmin(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _getRegistryAdmin_name = "getRegistryAdmin";

        private void _iceI_getRegistryAdmin(string iceP_name, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<global::Ice.ObjectPrx>(completed);
            outAsync.invoke(
                _getRegistryAdmin_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(RegistryNotExistException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    global::Ice.ObjectPrx ret;
                    ret = istr.readProxy();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task shutdownRegistryAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_shutdownRegistryAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_shutdownRegistryAsync(string iceP_name, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_shutdownRegistry_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_shutdownRegistry(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _shutdownRegistry_name = "shutdownRegistry";

        private void _iceI_shutdownRegistry(string iceP_name, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _shutdownRegistry_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(RegistryNotExistException)
                    {
                        throw;
                    }
                    catch(RegistryUnreachableException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<string[]> getAllRegistryNamesAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getAllRegistryNamesAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<string[]> _iceI_getAllRegistryNamesAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getAllRegistryNames_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<string[]>(progress, cancel);
            _iceI_getAllRegistryNames(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getAllRegistryNames_name = "getAllRegistryNames";

        private void _iceI_getAllRegistryNames(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<string[]>(completed);
            outAsync.invoke(
                _getAllRegistryNames_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                read: (global::Ice.InputStream istr) =>
                {
                    string[] ret;
                    ret = global::Ice.StringSeqHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task shutdownAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_shutdownAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_shutdownAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_shutdown(context, synchronous, completed);
            return completed.Task;
        }

        private const string _shutdown_name = "shutdown";

        private void _iceI_shutdown(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _shutdown_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous);
        }

        #endregion

        #region Checked and unchecked cast operations

        public static AdminPrx checkedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            AdminPrx r = b as AdminPrx;
            if((r == null) && b.ice_isA(ice_staticId()))
            {
                AdminPrxHelper h = new AdminPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static AdminPrx checkedCast(global::Ice.ObjectPrx b, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            AdminPrx r = b as AdminPrx;
            if((r == null) && b.ice_isA(ice_staticId(), ctx))
            {
                AdminPrxHelper h = new AdminPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static AdminPrx checkedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId()))
                {
                    AdminPrxHelper h = new AdminPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static AdminPrx checkedCast(global::Ice.ObjectPrx b, string f, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId(), ctx))
                {
                    AdminPrxHelper h = new AdminPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static AdminPrx uncheckedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            AdminPrx r = b as AdminPrx;
            if(r == null)
            {
                AdminPrxHelper h = new AdminPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static AdminPrx uncheckedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            AdminPrxHelper h = new AdminPrxHelper();
            h.iceCopyFrom(bb);
            return h;
        }

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::Admin"
        };

        public static string ice_staticId() => "::IceGrid::Admin";

        #endregion

        #region Marshaling support

        public static void write(global::Ice.OutputStream ostr, AdminPrx v)
        {
            ostr.writeProxy(v);
        }

        public static AdminPrx read(global::Ice.InputStream istr)
        {
            global::Ice.ObjectPrx proxy = istr.readProxy();
            if(proxy != null)
            {
                AdminPrxHelper result = new AdminPrxHelper();
                result.iceCopyFrom(proxy);
                return result;
            }
            return null;
        }

        #endregion
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public sealed class FileIteratorPrxHelper : global::Ice.ObjectPrxHelperBase, FileIteratorPrx
    {
        public FileIteratorPrxHelper()
        {
        }

        #region Synchronous operations

        public bool read(int size, out string[] lines, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                var result_ = _iceI_readAsync(size, context, null, global::System.Threading.CancellationToken.None, true).Result;
                lines = result_.lines;
                return result_.returnValue;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void destroy(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_destroyAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        #endregion

        #region Async Task operations

        public global::System.Threading.Tasks.Task<FileIterator_ReadResult> readAsync(int size, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_readAsync(size, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<FileIterator_ReadResult> _iceI_readAsync(int iceP_size, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_read_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<FileIterator_ReadResult>(progress, cancel);
            _iceI_read(iceP_size, context, synchronous, completed);
            return completed.Task;
        }

        private const string _read_name = "read";

        private void _iceI_read(int iceP_size, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<FileIterator_ReadResult>(completed);
            outAsync.invoke(
                _read_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_size);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(FileNotAvailableException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    FileIterator_ReadResult ret = new FileIterator_ReadResult();
                    ret.lines = global::Ice.StringSeqHelper.read(istr);
                    ret.returnValue = istr.readBool();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task destroyAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_destroyAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_destroyAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_destroy(context, synchronous, completed);
            return completed.Task;
        }

        private const string _destroy_name = "destroy";

        private void _iceI_destroy(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _destroy_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous);
        }

        #endregion

        #region Checked and unchecked cast operations

        public static FileIteratorPrx checkedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            FileIteratorPrx r = b as FileIteratorPrx;
            if((r == null) && b.ice_isA(ice_staticId()))
            {
                FileIteratorPrxHelper h = new FileIteratorPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static FileIteratorPrx checkedCast(global::Ice.ObjectPrx b, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            FileIteratorPrx r = b as FileIteratorPrx;
            if((r == null) && b.ice_isA(ice_staticId(), ctx))
            {
                FileIteratorPrxHelper h = new FileIteratorPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static FileIteratorPrx checkedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId()))
                {
                    FileIteratorPrxHelper h = new FileIteratorPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static FileIteratorPrx checkedCast(global::Ice.ObjectPrx b, string f, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId(), ctx))
                {
                    FileIteratorPrxHelper h = new FileIteratorPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static FileIteratorPrx uncheckedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            FileIteratorPrx r = b as FileIteratorPrx;
            if(r == null)
            {
                FileIteratorPrxHelper h = new FileIteratorPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static FileIteratorPrx uncheckedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            FileIteratorPrxHelper h = new FileIteratorPrxHelper();
            h.iceCopyFrom(bb);
            return h;
        }

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::FileIterator"
        };

        public static string ice_staticId() => "::IceGrid::FileIterator";

        #endregion

        #region Marshaling support

        public static void write(global::Ice.OutputStream ostr, FileIteratorPrx v)
        {
            ostr.writeProxy(v);
        }

        public static FileIteratorPrx read(global::Ice.InputStream istr)
        {
            global::Ice.ObjectPrx proxy = istr.readProxy();
            if(proxy != null)
            {
                FileIteratorPrxHelper result = new FileIteratorPrxHelper();
                result.iceCopyFrom(proxy);
                return result;
            }
            return null;
        }

        #endregion
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public sealed class ServerDynamicInfoSeqHelper
    {
        public static void write(global::Ice.OutputStream ostr, ServerDynamicInfo[] v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    (v[ix] == null ? new ServerDynamicInfo() : v[ix]).ice_writeMembers(ostr);
                }
            }
        }

        public static ServerDynamicInfo[] read(global::Ice.InputStream istr)
        {
            ServerDynamicInfo[] v;
            {
                int szx = istr.readAndCheckSeqSize(7);
                v = new ServerDynamicInfo[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new ServerDynamicInfo();
                    v[ix].ice_readMembers(istr);
                }
            }
            return v;
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public sealed class AdapterDynamicInfoSeqHelper
    {
        public static void write(global::Ice.OutputStream ostr, AdapterDynamicInfo[] v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    (v[ix] == null ? new AdapterDynamicInfo() : v[ix]).ice_writeMembers(ostr);
                }
            }
        }

        public static AdapterDynamicInfo[] read(global::Ice.InputStream istr)
        {
            AdapterDynamicInfo[] v;
            {
                int szx = istr.readAndCheckSeqSize(3);
                v = new AdapterDynamicInfo[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new AdapterDynamicInfo();
                    v[ix].ice_readMembers(istr);
                }
            }
            return v;
        }
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public sealed class RegistryObserverPrxHelper : global::Ice.ObjectPrxHelperBase, RegistryObserverPrx
    {
        public RegistryObserverPrxHelper()
        {
        }

        #region Synchronous operations

        public void registryInit(RegistryInfo[] registries, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_registryInitAsync(registries, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void registryUp(RegistryInfo node, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_registryUpAsync(node, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void registryDown(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_registryDownAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        #endregion

        #region Async Task operations

        public global::System.Threading.Tasks.Task registryInitAsync(RegistryInfo[] registries, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_registryInitAsync(registries, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_registryInitAsync(RegistryInfo[] iceP_registries, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_registryInit(iceP_registries, context, synchronous, completed);
            return completed.Task;
        }

        private const string _registryInit_name = "registryInit";

        private void _iceI_registryInit(RegistryInfo[] iceP_registries, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _registryInit_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    RegistryInfoSeqHelper.write(ostr, iceP_registries);
                });
        }

        public global::System.Threading.Tasks.Task registryUpAsync(RegistryInfo node, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_registryUpAsync(node, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_registryUpAsync(RegistryInfo iceP_node, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_registryUp(iceP_node, context, synchronous, completed);
            return completed.Task;
        }

        private const string _registryUp_name = "registryUp";

        private void _iceI_registryUp(RegistryInfo iceP_node, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _registryUp_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    RegistryInfo.ice_write(ostr, iceP_node);
                });
        }

        public global::System.Threading.Tasks.Task registryDownAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_registryDownAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_registryDownAsync(string iceP_name, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_registryDown(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _registryDown_name = "registryDown";

        private void _iceI_registryDown(string iceP_name, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _registryDown_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                });
        }

        #endregion

        #region Checked and unchecked cast operations

        public static RegistryObserverPrx checkedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            RegistryObserverPrx r = b as RegistryObserverPrx;
            if((r == null) && b.ice_isA(ice_staticId()))
            {
                RegistryObserverPrxHelper h = new RegistryObserverPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static RegistryObserverPrx checkedCast(global::Ice.ObjectPrx b, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            RegistryObserverPrx r = b as RegistryObserverPrx;
            if((r == null) && b.ice_isA(ice_staticId(), ctx))
            {
                RegistryObserverPrxHelper h = new RegistryObserverPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static RegistryObserverPrx checkedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId()))
                {
                    RegistryObserverPrxHelper h = new RegistryObserverPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static RegistryObserverPrx checkedCast(global::Ice.ObjectPrx b, string f, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId(), ctx))
                {
                    RegistryObserverPrxHelper h = new RegistryObserverPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static RegistryObserverPrx uncheckedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            RegistryObserverPrx r = b as RegistryObserverPrx;
            if(r == null)
            {
                RegistryObserverPrxHelper h = new RegistryObserverPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static RegistryObserverPrx uncheckedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            RegistryObserverPrxHelper h = new RegistryObserverPrxHelper();
            h.iceCopyFrom(bb);
            return h;
        }

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::RegistryObserver"
        };

        public static string ice_staticId() => "::IceGrid::RegistryObserver";

        #endregion

        #region Marshaling support

        public static void write(global::Ice.OutputStream ostr, RegistryObserverPrx v)
        {
            ostr.writeProxy(v);
        }

        public static RegistryObserverPrx read(global::Ice.InputStream istr)
        {
            global::Ice.ObjectPrx proxy = istr.readProxy();
            if(proxy != null)
            {
                RegistryObserverPrxHelper result = new RegistryObserverPrxHelper();
                result.iceCopyFrom(proxy);
                return result;
            }
            return null;
        }

        #endregion
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public sealed class NodeDynamicInfoSeqHelper
    {
        public static void write(global::Ice.OutputStream ostr, NodeDynamicInfo[] v)
        {
            if(v == null)
            {
                ostr.writeSize(0);
            }
            else
            {
                ostr.writeSize(v.Length);
                for(int ix = 0; ix < v.Length; ++ix)
                {
                    (v[ix] == null ? new NodeDynamicInfo() : v[ix]).ice_writeMembers(ostr);
                }
            }
        }

        public static NodeDynamicInfo[] read(global::Ice.InputStream istr)
        {
            NodeDynamicInfo[] v;
            {
                int szx = istr.readAndCheckSeqSize(13);
                v = new NodeDynamicInfo[szx];
                for(int ix = 0; ix < szx; ++ix)
                {
                    v[ix] = new NodeDynamicInfo();
                    v[ix].ice_readMembers(istr);
                }
            }
            return v;
        }
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public sealed class NodeObserverPrxHelper : global::Ice.ObjectPrxHelperBase, NodeObserverPrx
    {
        public NodeObserverPrxHelper()
        {
        }

        #region Synchronous operations

        public void nodeInit(NodeDynamicInfo[] nodes, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_nodeInitAsync(nodes, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void nodeUp(NodeDynamicInfo node, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_nodeUpAsync(node, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void nodeDown(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_nodeDownAsync(name, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void updateServer(string node, ServerDynamicInfo updatedInfo, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_updateServerAsync(node, updatedInfo, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void updateAdapter(string node, AdapterDynamicInfo updatedInfo, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_updateAdapterAsync(node, updatedInfo, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        #endregion

        #region Async Task operations

        public global::System.Threading.Tasks.Task nodeInitAsync(NodeDynamicInfo[] nodes, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_nodeInitAsync(nodes, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_nodeInitAsync(NodeDynamicInfo[] iceP_nodes, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_nodeInit(iceP_nodes, context, synchronous, completed);
            return completed.Task;
        }

        private const string _nodeInit_name = "nodeInit";

        private void _iceI_nodeInit(NodeDynamicInfo[] iceP_nodes, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _nodeInit_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    NodeDynamicInfoSeqHelper.write(ostr, iceP_nodes);
                });
        }

        public global::System.Threading.Tasks.Task nodeUpAsync(NodeDynamicInfo node, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_nodeUpAsync(node, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_nodeUpAsync(NodeDynamicInfo iceP_node, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_nodeUp(iceP_node, context, synchronous, completed);
            return completed.Task;
        }

        private const string _nodeUp_name = "nodeUp";

        private void _iceI_nodeUp(NodeDynamicInfo iceP_node, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _nodeUp_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    NodeDynamicInfo.ice_write(ostr, iceP_node);
                });
        }

        public global::System.Threading.Tasks.Task nodeDownAsync(string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_nodeDownAsync(name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_nodeDownAsync(string iceP_name, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_nodeDown(iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _nodeDown_name = "nodeDown";

        private void _iceI_nodeDown(string iceP_name, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _nodeDown_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                });
        }

        public global::System.Threading.Tasks.Task updateServerAsync(string node, ServerDynamicInfo updatedInfo, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_updateServerAsync(node, updatedInfo, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_updateServerAsync(string iceP_node, ServerDynamicInfo iceP_updatedInfo, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_updateServer(iceP_node, iceP_updatedInfo, context, synchronous, completed);
            return completed.Task;
        }

        private const string _updateServer_name = "updateServer";

        private void _iceI_updateServer(string iceP_node, ServerDynamicInfo iceP_updatedInfo, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _updateServer_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_node);
                    ServerDynamicInfo.ice_write(ostr, iceP_updatedInfo);
                });
        }

        public global::System.Threading.Tasks.Task updateAdapterAsync(string node, AdapterDynamicInfo updatedInfo, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_updateAdapterAsync(node, updatedInfo, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_updateAdapterAsync(string iceP_node, AdapterDynamicInfo iceP_updatedInfo, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_updateAdapter(iceP_node, iceP_updatedInfo, context, synchronous, completed);
            return completed.Task;
        }

        private const string _updateAdapter_name = "updateAdapter";

        private void _iceI_updateAdapter(string iceP_node, AdapterDynamicInfo iceP_updatedInfo, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _updateAdapter_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_node);
                    AdapterDynamicInfo.ice_write(ostr, iceP_updatedInfo);
                });
        }

        #endregion

        #region Checked and unchecked cast operations

        public static NodeObserverPrx checkedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            NodeObserverPrx r = b as NodeObserverPrx;
            if((r == null) && b.ice_isA(ice_staticId()))
            {
                NodeObserverPrxHelper h = new NodeObserverPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static NodeObserverPrx checkedCast(global::Ice.ObjectPrx b, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            NodeObserverPrx r = b as NodeObserverPrx;
            if((r == null) && b.ice_isA(ice_staticId(), ctx))
            {
                NodeObserverPrxHelper h = new NodeObserverPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static NodeObserverPrx checkedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId()))
                {
                    NodeObserverPrxHelper h = new NodeObserverPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static NodeObserverPrx checkedCast(global::Ice.ObjectPrx b, string f, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId(), ctx))
                {
                    NodeObserverPrxHelper h = new NodeObserverPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static NodeObserverPrx uncheckedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            NodeObserverPrx r = b as NodeObserverPrx;
            if(r == null)
            {
                NodeObserverPrxHelper h = new NodeObserverPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static NodeObserverPrx uncheckedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            NodeObserverPrxHelper h = new NodeObserverPrxHelper();
            h.iceCopyFrom(bb);
            return h;
        }

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::NodeObserver"
        };

        public static string ice_staticId() => "::IceGrid::NodeObserver";

        #endregion

        #region Marshaling support

        public static void write(global::Ice.OutputStream ostr, NodeObserverPrx v)
        {
            ostr.writeProxy(v);
        }

        public static NodeObserverPrx read(global::Ice.InputStream istr)
        {
            global::Ice.ObjectPrx proxy = istr.readProxy();
            if(proxy != null)
            {
                NodeObserverPrxHelper result = new NodeObserverPrxHelper();
                result.iceCopyFrom(proxy);
                return result;
            }
            return null;
        }

        #endregion
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public sealed class ApplicationObserverPrxHelper : global::Ice.ObjectPrxHelperBase, ApplicationObserverPrx
    {
        public ApplicationObserverPrxHelper()
        {
        }

        #region Synchronous operations

        public void applicationInit(int serial, ApplicationInfo[] applications, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_applicationInitAsync(serial, applications, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void applicationAdded(int serial, ApplicationInfo desc, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_applicationAddedAsync(serial, desc, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void applicationRemoved(int serial, string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_applicationRemovedAsync(serial, name, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void applicationUpdated(int serial, ApplicationUpdateInfo desc, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_applicationUpdatedAsync(serial, desc, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        #endregion

        #region Async Task operations

        public global::System.Threading.Tasks.Task applicationInitAsync(int serial, ApplicationInfo[] applications, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_applicationInitAsync(serial, applications, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_applicationInitAsync(int iceP_serial, ApplicationInfo[] iceP_applications, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_applicationInit(iceP_serial, iceP_applications, context, synchronous, completed);
            return completed.Task;
        }

        private const string _applicationInit_name = "applicationInit";

        private void _iceI_applicationInit(int iceP_serial, ApplicationInfo[] iceP_applications, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _applicationInit_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_serial);
                    ApplicationInfoSeqHelper.write(ostr, iceP_applications);
                    ostr.writePendingValues();
                });
        }

        public global::System.Threading.Tasks.Task applicationAddedAsync(int serial, ApplicationInfo desc, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_applicationAddedAsync(serial, desc, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_applicationAddedAsync(int iceP_serial, ApplicationInfo iceP_desc, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_applicationAdded(iceP_serial, iceP_desc, context, synchronous, completed);
            return completed.Task;
        }

        private const string _applicationAdded_name = "applicationAdded";

        private void _iceI_applicationAdded(int iceP_serial, ApplicationInfo iceP_desc, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _applicationAdded_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_serial);
                    ApplicationInfo.ice_write(ostr, iceP_desc);
                    ostr.writePendingValues();
                });
        }

        public global::System.Threading.Tasks.Task applicationRemovedAsync(int serial, string name, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_applicationRemovedAsync(serial, name, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_applicationRemovedAsync(int iceP_serial, string iceP_name, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_applicationRemoved(iceP_serial, iceP_name, context, synchronous, completed);
            return completed.Task;
        }

        private const string _applicationRemoved_name = "applicationRemoved";

        private void _iceI_applicationRemoved(int iceP_serial, string iceP_name, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _applicationRemoved_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_serial);
                    ostr.writeString(iceP_name);
                });
        }

        public global::System.Threading.Tasks.Task applicationUpdatedAsync(int serial, ApplicationUpdateInfo desc, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_applicationUpdatedAsync(serial, desc, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_applicationUpdatedAsync(int iceP_serial, ApplicationUpdateInfo iceP_desc, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_applicationUpdated(iceP_serial, iceP_desc, context, synchronous, completed);
            return completed.Task;
        }

        private const string _applicationUpdated_name = "applicationUpdated";

        private void _iceI_applicationUpdated(int iceP_serial, ApplicationUpdateInfo iceP_desc, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _applicationUpdated_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeInt(iceP_serial);
                    ApplicationUpdateInfo.ice_write(ostr, iceP_desc);
                    ostr.writePendingValues();
                });
        }

        #endregion

        #region Checked and unchecked cast operations

        public static ApplicationObserverPrx checkedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            ApplicationObserverPrx r = b as ApplicationObserverPrx;
            if((r == null) && b.ice_isA(ice_staticId()))
            {
                ApplicationObserverPrxHelper h = new ApplicationObserverPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static ApplicationObserverPrx checkedCast(global::Ice.ObjectPrx b, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            ApplicationObserverPrx r = b as ApplicationObserverPrx;
            if((r == null) && b.ice_isA(ice_staticId(), ctx))
            {
                ApplicationObserverPrxHelper h = new ApplicationObserverPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static ApplicationObserverPrx checkedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId()))
                {
                    ApplicationObserverPrxHelper h = new ApplicationObserverPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static ApplicationObserverPrx checkedCast(global::Ice.ObjectPrx b, string f, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId(), ctx))
                {
                    ApplicationObserverPrxHelper h = new ApplicationObserverPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static ApplicationObserverPrx uncheckedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            ApplicationObserverPrx r = b as ApplicationObserverPrx;
            if(r == null)
            {
                ApplicationObserverPrxHelper h = new ApplicationObserverPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static ApplicationObserverPrx uncheckedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            ApplicationObserverPrxHelper h = new ApplicationObserverPrxHelper();
            h.iceCopyFrom(bb);
            return h;
        }

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::ApplicationObserver"
        };

        public static string ice_staticId() => "::IceGrid::ApplicationObserver";

        #endregion

        #region Marshaling support

        public static void write(global::Ice.OutputStream ostr, ApplicationObserverPrx v)
        {
            ostr.writeProxy(v);
        }

        public static ApplicationObserverPrx read(global::Ice.InputStream istr)
        {
            global::Ice.ObjectPrx proxy = istr.readProxy();
            if(proxy != null)
            {
                ApplicationObserverPrxHelper result = new ApplicationObserverPrxHelper();
                result.iceCopyFrom(proxy);
                return result;
            }
            return null;
        }

        #endregion
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public sealed class AdapterObserverPrxHelper : global::Ice.ObjectPrxHelperBase, AdapterObserverPrx
    {
        public AdapterObserverPrxHelper()
        {
        }

        #region Synchronous operations

        public void adapterInit(AdapterInfo[] adpts, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_adapterInitAsync(adpts, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void adapterAdded(AdapterInfo info, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_adapterAddedAsync(info, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void adapterUpdated(AdapterInfo info, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_adapterUpdatedAsync(info, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void adapterRemoved(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_adapterRemovedAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        #endregion

        #region Async Task operations

        public global::System.Threading.Tasks.Task adapterInitAsync(AdapterInfo[] adpts, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_adapterInitAsync(adpts, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_adapterInitAsync(AdapterInfo[] iceP_adpts, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_adapterInit(iceP_adpts, context, synchronous, completed);
            return completed.Task;
        }

        private const string _adapterInit_name = "adapterInit";

        private void _iceI_adapterInit(AdapterInfo[] iceP_adpts, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _adapterInit_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    AdapterInfoSeqHelper.write(ostr, iceP_adpts);
                });
        }

        public global::System.Threading.Tasks.Task adapterAddedAsync(AdapterInfo info, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_adapterAddedAsync(info, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_adapterAddedAsync(AdapterInfo iceP_info, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_adapterAdded(iceP_info, context, synchronous, completed);
            return completed.Task;
        }

        private const string _adapterAdded_name = "adapterAdded";

        private void _iceI_adapterAdded(AdapterInfo iceP_info, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _adapterAdded_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    AdapterInfo.ice_write(ostr, iceP_info);
                });
        }

        public global::System.Threading.Tasks.Task adapterUpdatedAsync(AdapterInfo info, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_adapterUpdatedAsync(info, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_adapterUpdatedAsync(AdapterInfo iceP_info, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_adapterUpdated(iceP_info, context, synchronous, completed);
            return completed.Task;
        }

        private const string _adapterUpdated_name = "adapterUpdated";

        private void _iceI_adapterUpdated(AdapterInfo iceP_info, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _adapterUpdated_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    AdapterInfo.ice_write(ostr, iceP_info);
                });
        }

        public global::System.Threading.Tasks.Task adapterRemovedAsync(string id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_adapterRemovedAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_adapterRemovedAsync(string iceP_id, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_adapterRemoved(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _adapterRemoved_name = "adapterRemoved";

        private void _iceI_adapterRemoved(string iceP_id, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _adapterRemoved_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                });
        }

        #endregion

        #region Checked and unchecked cast operations

        public static AdapterObserverPrx checkedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            AdapterObserverPrx r = b as AdapterObserverPrx;
            if((r == null) && b.ice_isA(ice_staticId()))
            {
                AdapterObserverPrxHelper h = new AdapterObserverPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static AdapterObserverPrx checkedCast(global::Ice.ObjectPrx b, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            AdapterObserverPrx r = b as AdapterObserverPrx;
            if((r == null) && b.ice_isA(ice_staticId(), ctx))
            {
                AdapterObserverPrxHelper h = new AdapterObserverPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static AdapterObserverPrx checkedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId()))
                {
                    AdapterObserverPrxHelper h = new AdapterObserverPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static AdapterObserverPrx checkedCast(global::Ice.ObjectPrx b, string f, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId(), ctx))
                {
                    AdapterObserverPrxHelper h = new AdapterObserverPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static AdapterObserverPrx uncheckedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            AdapterObserverPrx r = b as AdapterObserverPrx;
            if(r == null)
            {
                AdapterObserverPrxHelper h = new AdapterObserverPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static AdapterObserverPrx uncheckedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            AdapterObserverPrxHelper h = new AdapterObserverPrxHelper();
            h.iceCopyFrom(bb);
            return h;
        }

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::AdapterObserver"
        };

        public static string ice_staticId() => "::IceGrid::AdapterObserver";

        #endregion

        #region Marshaling support

        public static void write(global::Ice.OutputStream ostr, AdapterObserverPrx v)
        {
            ostr.writeProxy(v);
        }

        public static AdapterObserverPrx read(global::Ice.InputStream istr)
        {
            global::Ice.ObjectPrx proxy = istr.readProxy();
            if(proxy != null)
            {
                AdapterObserverPrxHelper result = new AdapterObserverPrxHelper();
                result.iceCopyFrom(proxy);
                return result;
            }
            return null;
        }

        #endregion
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public sealed class ObjectObserverPrxHelper : global::Ice.ObjectPrxHelperBase, ObjectObserverPrx
    {
        public ObjectObserverPrxHelper()
        {
        }

        #region Synchronous operations

        public void objectInit(ObjectInfo[] objects, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_objectInitAsync(objects, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void objectAdded(ObjectInfo info, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_objectAddedAsync(info, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void objectUpdated(ObjectInfo info, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_objectUpdatedAsync(info, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void objectRemoved(global::Ice.Identity id, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_objectRemovedAsync(id, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        #endregion

        #region Async Task operations

        public global::System.Threading.Tasks.Task objectInitAsync(ObjectInfo[] objects, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_objectInitAsync(objects, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_objectInitAsync(ObjectInfo[] iceP_objects, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_objectInit(iceP_objects, context, synchronous, completed);
            return completed.Task;
        }

        private const string _objectInit_name = "objectInit";

        private void _iceI_objectInit(ObjectInfo[] iceP_objects, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _objectInit_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ObjectInfoSeqHelper.write(ostr, iceP_objects);
                });
        }

        public global::System.Threading.Tasks.Task objectAddedAsync(ObjectInfo info, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_objectAddedAsync(info, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_objectAddedAsync(ObjectInfo iceP_info, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_objectAdded(iceP_info, context, synchronous, completed);
            return completed.Task;
        }

        private const string _objectAdded_name = "objectAdded";

        private void _iceI_objectAdded(ObjectInfo iceP_info, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _objectAdded_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ObjectInfo.ice_write(ostr, iceP_info);
                });
        }

        public global::System.Threading.Tasks.Task objectUpdatedAsync(ObjectInfo info, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_objectUpdatedAsync(info, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_objectUpdatedAsync(ObjectInfo iceP_info, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_objectUpdated(iceP_info, context, synchronous, completed);
            return completed.Task;
        }

        private const string _objectUpdated_name = "objectUpdated";

        private void _iceI_objectUpdated(ObjectInfo iceP_info, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _objectUpdated_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ObjectInfo.ice_write(ostr, iceP_info);
                });
        }

        public global::System.Threading.Tasks.Task objectRemovedAsync(global::Ice.Identity id, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_objectRemovedAsync(id, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_objectRemovedAsync(global::Ice.Identity iceP_id, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_objectRemoved(iceP_id, context, synchronous, completed);
            return completed.Task;
        }

        private const string _objectRemoved_name = "objectRemoved";

        private void _iceI_objectRemoved(global::Ice.Identity iceP_id, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _objectRemoved_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    global::Ice.Identity.ice_write(ostr, iceP_id);
                });
        }

        #endregion

        #region Checked and unchecked cast operations

        public static ObjectObserverPrx checkedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            ObjectObserverPrx r = b as ObjectObserverPrx;
            if((r == null) && b.ice_isA(ice_staticId()))
            {
                ObjectObserverPrxHelper h = new ObjectObserverPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static ObjectObserverPrx checkedCast(global::Ice.ObjectPrx b, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            ObjectObserverPrx r = b as ObjectObserverPrx;
            if((r == null) && b.ice_isA(ice_staticId(), ctx))
            {
                ObjectObserverPrxHelper h = new ObjectObserverPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static ObjectObserverPrx checkedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId()))
                {
                    ObjectObserverPrxHelper h = new ObjectObserverPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static ObjectObserverPrx checkedCast(global::Ice.ObjectPrx b, string f, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId(), ctx))
                {
                    ObjectObserverPrxHelper h = new ObjectObserverPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static ObjectObserverPrx uncheckedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            ObjectObserverPrx r = b as ObjectObserverPrx;
            if(r == null)
            {
                ObjectObserverPrxHelper h = new ObjectObserverPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static ObjectObserverPrx uncheckedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            ObjectObserverPrxHelper h = new ObjectObserverPrxHelper();
            h.iceCopyFrom(bb);
            return h;
        }

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::ObjectObserver"
        };

        public static string ice_staticId() => "::IceGrid::ObjectObserver";

        #endregion

        #region Marshaling support

        public static void write(global::Ice.OutputStream ostr, ObjectObserverPrx v)
        {
            ostr.writeProxy(v);
        }

        public static ObjectObserverPrx read(global::Ice.InputStream istr)
        {
            global::Ice.ObjectPrx proxy = istr.readProxy();
            if(proxy != null)
            {
                ObjectObserverPrxHelper result = new ObjectObserverPrxHelper();
                result.iceCopyFrom(proxy);
                return result;
            }
            return null;
        }

        #endregion
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public sealed class AdminSessionPrxHelper : global::Ice.ObjectPrxHelperBase, AdminSessionPrx
    {
        public AdminSessionPrxHelper()
        {
        }

        #region Synchronous operations

        public void destroy(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_destroyAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void keepAlive(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_keepAliveAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public AdminPrx getAdmin(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getAdminAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public global::Ice.ObjectPrx getAdminCallbackTemplate(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getAdminCallbackTemplateAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void setObservers(RegistryObserverPrx registryObs, NodeObserverPrx nodeObs, ApplicationObserverPrx appObs, AdapterObserverPrx adptObs, ObjectObserverPrx objObs, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_setObserversAsync(registryObs, nodeObs, appObs, adptObs, objObs, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void setObserversByIdentity(global::Ice.Identity registryObs, global::Ice.Identity nodeObs, global::Ice.Identity appObs, global::Ice.Identity adptObs, global::Ice.Identity objObs, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_setObserversByIdentityAsync(registryObs, nodeObs, appObs, adptObs, objObs, context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public int startUpdate(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_startUpdateAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public void finishUpdate(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                _iceI_finishUpdateAsync(context, null, global::System.Threading.CancellationToken.None, true).Wait();
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public string getReplicaName(global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_getReplicaNameAsync(context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public FileIteratorPrx openServerLog(string id, string path, int count, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_openServerLogAsync(id, path, count, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public FileIteratorPrx openServerStdErr(string id, int count, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_openServerStdErrAsync(id, count, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public FileIteratorPrx openServerStdOut(string id, int count, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_openServerStdOutAsync(id, count, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public FileIteratorPrx openNodeStdErr(string name, int count, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_openNodeStdErrAsync(name, count, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public FileIteratorPrx openNodeStdOut(string name, int count, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_openNodeStdOutAsync(name, count, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public FileIteratorPrx openRegistryStdErr(string name, int count, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_openRegistryStdErrAsync(name, count, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        public FileIteratorPrx openRegistryStdOut(string name, int count, global::Ice.OptionalContext context = new global::Ice.OptionalContext())
        {
            try
            {
                return _iceI_openRegistryStdOutAsync(name, count, context, null, global::System.Threading.CancellationToken.None, true).Result;
            }
            catch(global::System.AggregateException ex_)
            {
                throw ex_.InnerException;
            }
        }

        #endregion

        #region Async Task operations

        public global::System.Threading.Tasks.Task destroyAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_destroyAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_destroyAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_destroy(context, synchronous, completed);
            return completed.Task;
        }

        private const string _destroy_name = "destroy";

        private void _iceI_destroy(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _destroy_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous);
        }

        public global::System.Threading.Tasks.Task keepAliveAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_keepAliveAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_keepAliveAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_keepAlive(context, synchronous, completed);
            return completed.Task;
        }

        private const string _keepAlive_name = "keepAlive";

        private void _iceI_keepAlive(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _keepAlive_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous);
        }

        public global::System.Threading.Tasks.Task<AdminPrx> getAdminAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getAdminAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<AdminPrx> _iceI_getAdminAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getAdmin_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<AdminPrx>(progress, cancel);
            _iceI_getAdmin(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getAdmin_name = "getAdmin";

        private void _iceI_getAdmin(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<AdminPrx>(completed);
            outAsync.invoke(
                _getAdmin_name,
                global::Ice.OperationMode.Nonmutating,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                read: (global::Ice.InputStream istr) =>
                {
                    AdminPrx ret;
                    ret = AdminPrxHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<global::Ice.ObjectPrx> getAdminCallbackTemplateAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getAdminCallbackTemplateAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<global::Ice.ObjectPrx> _iceI_getAdminCallbackTemplateAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getAdminCallbackTemplate_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<global::Ice.ObjectPrx>(progress, cancel);
            _iceI_getAdminCallbackTemplate(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getAdminCallbackTemplate_name = "getAdminCallbackTemplate";

        private void _iceI_getAdminCallbackTemplate(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<global::Ice.ObjectPrx>(completed);
            outAsync.invoke(
                _getAdminCallbackTemplate_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                read: (global::Ice.InputStream istr) =>
                {
                    global::Ice.ObjectPrx ret;
                    ret = istr.readProxy();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task setObserversAsync(RegistryObserverPrx registryObs, NodeObserverPrx nodeObs, ApplicationObserverPrx appObs, AdapterObserverPrx adptObs, ObjectObserverPrx objObs, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_setObserversAsync(registryObs, nodeObs, appObs, adptObs, objObs, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_setObserversAsync(RegistryObserverPrx iceP_registryObs, NodeObserverPrx iceP_nodeObs, ApplicationObserverPrx iceP_appObs, AdapterObserverPrx iceP_adptObs, ObjectObserverPrx iceP_objObs, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_setObservers_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_setObservers(iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs, context, synchronous, completed);
            return completed.Task;
        }

        private const string _setObservers_name = "setObservers";

        private void _iceI_setObservers(RegistryObserverPrx iceP_registryObs, NodeObserverPrx iceP_nodeObs, ApplicationObserverPrx iceP_appObs, AdapterObserverPrx iceP_adptObs, ObjectObserverPrx iceP_objObs, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _setObservers_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    RegistryObserverPrxHelper.write(ostr, iceP_registryObs);
                    NodeObserverPrxHelper.write(ostr, iceP_nodeObs);
                    ApplicationObserverPrxHelper.write(ostr, iceP_appObs);
                    AdapterObserverPrxHelper.write(ostr, iceP_adptObs);
                    ObjectObserverPrxHelper.write(ostr, iceP_objObs);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ObserverAlreadyRegisteredException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task setObserversByIdentityAsync(global::Ice.Identity registryObs, global::Ice.Identity nodeObs, global::Ice.Identity appObs, global::Ice.Identity adptObs, global::Ice.Identity objObs, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_setObserversByIdentityAsync(registryObs, nodeObs, appObs, adptObs, objObs, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_setObserversByIdentityAsync(global::Ice.Identity iceP_registryObs, global::Ice.Identity iceP_nodeObs, global::Ice.Identity iceP_appObs, global::Ice.Identity iceP_adptObs, global::Ice.Identity iceP_objObs, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_setObserversByIdentity_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_setObserversByIdentity(iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs, context, synchronous, completed);
            return completed.Task;
        }

        private const string _setObserversByIdentity_name = "setObserversByIdentity";

        private void _iceI_setObserversByIdentity(global::Ice.Identity iceP_registryObs, global::Ice.Identity iceP_nodeObs, global::Ice.Identity iceP_appObs, global::Ice.Identity iceP_adptObs, global::Ice.Identity iceP_objObs, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _setObserversByIdentity_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    global::Ice.Identity.ice_write(ostr, iceP_registryObs);
                    global::Ice.Identity.ice_write(ostr, iceP_nodeObs);
                    global::Ice.Identity.ice_write(ostr, iceP_appObs);
                    global::Ice.Identity.ice_write(ostr, iceP_adptObs);
                    global::Ice.Identity.ice_write(ostr, iceP_objObs);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ObserverAlreadyRegisteredException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<int> startUpdateAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_startUpdateAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<int> _iceI_startUpdateAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_startUpdate_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<int>(progress, cancel);
            _iceI_startUpdate(context, synchronous, completed);
            return completed.Task;
        }

        private const string _startUpdate_name = "startUpdate";

        private void _iceI_startUpdate(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<int>(completed);
            outAsync.invoke(
                _startUpdate_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(AccessDeniedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    int ret;
                    ret = istr.readInt();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task finishUpdateAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_finishUpdateAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task _iceI_finishUpdateAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_finishUpdate_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<object>(progress, cancel);
            _iceI_finishUpdate(context, synchronous, completed);
            return completed.Task;
        }

        private const string _finishUpdate_name = "finishUpdate";

        private void _iceI_finishUpdate(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<object>(completed);
            outAsync.invoke(
                _finishUpdate_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(AccessDeniedException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                });
        }

        public global::System.Threading.Tasks.Task<string> getReplicaNameAsync(global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_getReplicaNameAsync(context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<string> _iceI_getReplicaNameAsync(global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_getReplicaName_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<string>(progress, cancel);
            _iceI_getReplicaName(context, synchronous, completed);
            return completed.Task;
        }

        private const string _getReplicaName_name = "getReplicaName";

        private void _iceI_getReplicaName(global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<string>(completed);
            outAsync.invoke(
                _getReplicaName_name,
                global::Ice.OperationMode.Idempotent,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                read: (global::Ice.InputStream istr) =>
                {
                    string ret;
                    ret = istr.readString();
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<FileIteratorPrx> openServerLogAsync(string id, string path, int count, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_openServerLogAsync(id, path, count, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<FileIteratorPrx> _iceI_openServerLogAsync(string iceP_id, string iceP_path, int iceP_count, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_openServerLog_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<FileIteratorPrx>(progress, cancel);
            _iceI_openServerLog(iceP_id, iceP_path, iceP_count, context, synchronous, completed);
            return completed.Task;
        }

        private const string _openServerLog_name = "openServerLog";

        private void _iceI_openServerLog(string iceP_id, string iceP_path, int iceP_count, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<FileIteratorPrx>(completed);
            outAsync.invoke(
                _openServerLog_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                    ostr.writeString(iceP_path);
                    ostr.writeInt(iceP_count);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ServerNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(FileNotAvailableException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    FileIteratorPrx ret;
                    ret = FileIteratorPrxHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<FileIteratorPrx> openServerStdErrAsync(string id, int count, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_openServerStdErrAsync(id, count, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<FileIteratorPrx> _iceI_openServerStdErrAsync(string iceP_id, int iceP_count, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_openServerStdErr_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<FileIteratorPrx>(progress, cancel);
            _iceI_openServerStdErr(iceP_id, iceP_count, context, synchronous, completed);
            return completed.Task;
        }

        private const string _openServerStdErr_name = "openServerStdErr";

        private void _iceI_openServerStdErr(string iceP_id, int iceP_count, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<FileIteratorPrx>(completed);
            outAsync.invoke(
                _openServerStdErr_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                    ostr.writeInt(iceP_count);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ServerNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(FileNotAvailableException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    FileIteratorPrx ret;
                    ret = FileIteratorPrxHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<FileIteratorPrx> openServerStdOutAsync(string id, int count, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_openServerStdOutAsync(id, count, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<FileIteratorPrx> _iceI_openServerStdOutAsync(string iceP_id, int iceP_count, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_openServerStdOut_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<FileIteratorPrx>(progress, cancel);
            _iceI_openServerStdOut(iceP_id, iceP_count, context, synchronous, completed);
            return completed.Task;
        }

        private const string _openServerStdOut_name = "openServerStdOut";

        private void _iceI_openServerStdOut(string iceP_id, int iceP_count, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<FileIteratorPrx>(completed);
            outAsync.invoke(
                _openServerStdOut_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_id);
                    ostr.writeInt(iceP_count);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(ServerNotExistException)
                    {
                        throw;
                    }
                    catch(DeploymentException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(FileNotAvailableException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    FileIteratorPrx ret;
                    ret = FileIteratorPrxHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<FileIteratorPrx> openNodeStdErrAsync(string name, int count, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_openNodeStdErrAsync(name, count, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<FileIteratorPrx> _iceI_openNodeStdErrAsync(string iceP_name, int iceP_count, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_openNodeStdErr_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<FileIteratorPrx>(progress, cancel);
            _iceI_openNodeStdErr(iceP_name, iceP_count, context, synchronous, completed);
            return completed.Task;
        }

        private const string _openNodeStdErr_name = "openNodeStdErr";

        private void _iceI_openNodeStdErr(string iceP_name, int iceP_count, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<FileIteratorPrx>(completed);
            outAsync.invoke(
                _openNodeStdErr_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                    ostr.writeInt(iceP_count);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(NodeNotExistException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(FileNotAvailableException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    FileIteratorPrx ret;
                    ret = FileIteratorPrxHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<FileIteratorPrx> openNodeStdOutAsync(string name, int count, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_openNodeStdOutAsync(name, count, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<FileIteratorPrx> _iceI_openNodeStdOutAsync(string iceP_name, int iceP_count, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_openNodeStdOut_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<FileIteratorPrx>(progress, cancel);
            _iceI_openNodeStdOut(iceP_name, iceP_count, context, synchronous, completed);
            return completed.Task;
        }

        private const string _openNodeStdOut_name = "openNodeStdOut";

        private void _iceI_openNodeStdOut(string iceP_name, int iceP_count, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<FileIteratorPrx>(completed);
            outAsync.invoke(
                _openNodeStdOut_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                    ostr.writeInt(iceP_count);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(NodeNotExistException)
                    {
                        throw;
                    }
                    catch(NodeUnreachableException)
                    {
                        throw;
                    }
                    catch(FileNotAvailableException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    FileIteratorPrx ret;
                    ret = FileIteratorPrxHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<FileIteratorPrx> openRegistryStdErrAsync(string name, int count, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_openRegistryStdErrAsync(name, count, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<FileIteratorPrx> _iceI_openRegistryStdErrAsync(string iceP_name, int iceP_count, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_openRegistryStdErr_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<FileIteratorPrx>(progress, cancel);
            _iceI_openRegistryStdErr(iceP_name, iceP_count, context, synchronous, completed);
            return completed.Task;
        }

        private const string _openRegistryStdErr_name = "openRegistryStdErr";

        private void _iceI_openRegistryStdErr(string iceP_name, int iceP_count, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<FileIteratorPrx>(completed);
            outAsync.invoke(
                _openRegistryStdErr_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                    ostr.writeInt(iceP_count);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(RegistryNotExistException)
                    {
                        throw;
                    }
                    catch(RegistryUnreachableException)
                    {
                        throw;
                    }
                    catch(FileNotAvailableException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    FileIteratorPrx ret;
                    ret = FileIteratorPrxHelper.read(istr);
                    return ret;
                });
        }

        public global::System.Threading.Tasks.Task<FileIteratorPrx> openRegistryStdOutAsync(string name, int count, global::Ice.OptionalContext context = new global::Ice.OptionalContext(), global::System.IProgress<bool> progress = null, global::System.Threading.CancellationToken cancel = new global::System.Threading.CancellationToken())
        {
            return _iceI_openRegistryStdOutAsync(name, count, context, progress, cancel, false);
        }

        private global::System.Threading.Tasks.Task<FileIteratorPrx> _iceI_openRegistryStdOutAsync(string iceP_name, int iceP_count, global::Ice.OptionalContext context, global::System.IProgress<bool> progress, global::System.Threading.CancellationToken cancel, bool synchronous)
        {
            iceCheckTwowayOnly(_openRegistryStdOut_name);
            var completed = new global::IceInternal.OperationTaskCompletionCallback<FileIteratorPrx>(progress, cancel);
            _iceI_openRegistryStdOut(iceP_name, iceP_count, context, synchronous, completed);
            return completed.Task;
        }

        private const string _openRegistryStdOut_name = "openRegistryStdOut";

        private void _iceI_openRegistryStdOut(string iceP_name, int iceP_count, global::System.Collections.Generic.Dictionary<string, string> context, bool synchronous, global::IceInternal.OutgoingAsyncCompletionCallback completed)
        {
            var outAsync = getOutgoingAsync<FileIteratorPrx>(completed);
            outAsync.invoke(
                _openRegistryStdOut_name,
                global::Ice.OperationMode.Normal,
                global::Ice.FormatType.DefaultFormat,
                context,
                synchronous,
                write: (global::Ice.OutputStream ostr) =>
                {
                    ostr.writeString(iceP_name);
                    ostr.writeInt(iceP_count);
                },
                userException: (global::Ice.UserException ex) =>
                {
                    try
                    {
                        throw ex;
                    }
                    catch(RegistryNotExistException)
                    {
                        throw;
                    }
                    catch(RegistryUnreachableException)
                    {
                        throw;
                    }
                    catch(FileNotAvailableException)
                    {
                        throw;
                    }
                    catch(global::Ice.UserException)
                    {
                    }
                },
                read: (global::Ice.InputStream istr) =>
                {
                    FileIteratorPrx ret;
                    ret = FileIteratorPrxHelper.read(istr);
                    return ret;
                });
        }

        #endregion

        #region Checked and unchecked cast operations

        public static AdminSessionPrx checkedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            AdminSessionPrx r = b as AdminSessionPrx;
            if((r == null) && b.ice_isA(ice_staticId()))
            {
                AdminSessionPrxHelper h = new AdminSessionPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static AdminSessionPrx checkedCast(global::Ice.ObjectPrx b, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            AdminSessionPrx r = b as AdminSessionPrx;
            if((r == null) && b.ice_isA(ice_staticId(), ctx))
            {
                AdminSessionPrxHelper h = new AdminSessionPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static AdminSessionPrx checkedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId()))
                {
                    AdminSessionPrxHelper h = new AdminSessionPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static AdminSessionPrx checkedCast(global::Ice.ObjectPrx b, string f, global::System.Collections.Generic.Dictionary<string, string> ctx)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            try
            {
                if(bb.ice_isA(ice_staticId(), ctx))
                {
                    AdminSessionPrxHelper h = new AdminSessionPrxHelper();
                    h.iceCopyFrom(bb);
                    return h;
                }
            }
            catch(global::Ice.FacetNotExistException)
            {
            }
            return null;
        }

        public static AdminSessionPrx uncheckedCast(global::Ice.ObjectPrx b)
        {
            if(b == null)
            {
                return null;
            }
            AdminSessionPrx r = b as AdminSessionPrx;
            if(r == null)
            {
                AdminSessionPrxHelper h = new AdminSessionPrxHelper();
                h.iceCopyFrom(b);
                r = h;
            }
            return r;
        }

        public static AdminSessionPrx uncheckedCast(global::Ice.ObjectPrx b, string f)
        {
            if(b == null)
            {
                return null;
            }
            global::Ice.ObjectPrx bb = b.ice_facet(f);
            AdminSessionPrxHelper h = new AdminSessionPrxHelper();
            h.iceCopyFrom(bb);
            return h;
        }

        private static readonly string[] _ids =
        {
            "::Glacier2::Session",
            "::Ice::Object",
            "::IceGrid::AdminSession"
        };

        public static string ice_staticId() => "::IceGrid::AdminSession";

        #endregion

        #region Marshaling support

        public static void write(global::Ice.OutputStream ostr, AdminSessionPrx v)
        {
            ostr.writeProxy(v);
        }

        public static AdminSessionPrx read(global::Ice.InputStream istr)
        {
            global::Ice.ObjectPrx proxy = istr.readProxy();
            if(proxy != null)
            {
                AdminSessionPrxHelper result = new AdminSessionPrxHelper();
                result.iceCopyFrom(proxy);
                return result;
            }
            return null;
        }

        #endregion
    }
}

namespace IceGrid
{
    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public abstract class AdminDisp_ : global::Ice.ObjectImpl, Admin
    {
        #region Slice operations

        public abstract void addApplication(ApplicationDescriptor descriptor, global::Ice.Current current = null);

        public abstract void syncApplication(ApplicationDescriptor descriptor, global::Ice.Current current = null);

        public abstract void updateApplication(ApplicationUpdateDescriptor descriptor, global::Ice.Current current = null);

        public abstract void syncApplicationWithoutRestart(ApplicationDescriptor descriptor, global::Ice.Current current = null);

        public abstract void updateApplicationWithoutRestart(ApplicationUpdateDescriptor descriptor, global::Ice.Current current = null);

        public abstract void removeApplication(string name, global::Ice.Current current = null);

        public abstract void instantiateServer(string application, string node, ServerInstanceDescriptor desc, global::Ice.Current current = null);

        public abstract ApplicationInfo getApplicationInfo(string name, global::Ice.Current current = null);

        public abstract ApplicationDescriptor getDefaultApplicationDescriptor(global::Ice.Current current = null);

        public abstract string[] getAllApplicationNames(global::Ice.Current current = null);

        public abstract ServerInfo getServerInfo(string id, global::Ice.Current current = null);

        public abstract ServerState getServerState(string id, global::Ice.Current current = null);

        public abstract int getServerPid(string id, global::Ice.Current current = null);

        public abstract string getServerAdminCategory(global::Ice.Current current = null);

        public abstract global::Ice.ObjectPrx getServerAdmin(string id, global::Ice.Current current = null);

        public abstract void enableServer(string id, bool enabled, global::Ice.Current current = null);

        public abstract bool isServerEnabled(string id, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task startServerAsync(string id, global::Ice.Current current = null);

        public abstract global::System.Threading.Tasks.Task stopServerAsync(string id, global::Ice.Current current = null);

        public abstract void sendSignal(string id, string signal, global::Ice.Current current = null);

        public abstract string[] getAllServerIds(global::Ice.Current current = null);

        public abstract AdapterInfo[] getAdapterInfo(string id, global::Ice.Current current = null);

        public abstract void removeAdapter(string id, global::Ice.Current current = null);

        public abstract string[] getAllAdapterIds(global::Ice.Current current = null);

        public abstract void addObject(global::Ice.ObjectPrx obj, global::Ice.Current current = null);

        public abstract void updateObject(global::Ice.ObjectPrx obj, global::Ice.Current current = null);

        public abstract void addObjectWithType(global::Ice.ObjectPrx obj, string type, global::Ice.Current current = null);

        public abstract void removeObject(global::Ice.Identity id, global::Ice.Current current = null);

        public abstract ObjectInfo getObjectInfo(global::Ice.Identity id, global::Ice.Current current = null);

        public abstract ObjectInfo[] getObjectInfosByType(string type, global::Ice.Current current = null);

        public abstract ObjectInfo[] getAllObjectInfos(string expr, global::Ice.Current current = null);

        public abstract bool pingNode(string name, global::Ice.Current current = null);

        public abstract LoadInfo getNodeLoad(string name, global::Ice.Current current = null);

        public abstract NodeInfo getNodeInfo(string name, global::Ice.Current current = null);

        public abstract global::Ice.ObjectPrx getNodeAdmin(string name, global::Ice.Current current = null);

        public abstract int getNodeProcessorSocketCount(string name, global::Ice.Current current = null);

        public abstract void shutdownNode(string name, global::Ice.Current current = null);

        public abstract string getNodeHostname(string name, global::Ice.Current current = null);

        public abstract string[] getAllNodeNames(global::Ice.Current current = null);

        public abstract bool pingRegistry(string name, global::Ice.Current current = null);

        public abstract RegistryInfo getRegistryInfo(string name, global::Ice.Current current = null);

        public abstract global::Ice.ObjectPrx getRegistryAdmin(string name, global::Ice.Current current = null);

        public abstract void shutdownRegistry(string name, global::Ice.Current current = null);

        public abstract string[] getAllRegistryNames(global::Ice.Current current = null);

        public abstract void shutdown(global::Ice.Current current = null);

        #endregion

        #region Slice type-related members

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::Admin"
        };

        public override bool ice_isA(string s, global::Ice.Current current = null)
        {
            return global::System.Array.BinarySearch(_ids, s, IceUtilInternal.StringUtil.OrdinalStringComparer) >= 0;
        }

        public override string[] ice_ids(global::Ice.Current current = null)
        {
            return _ids;
        }

        public override string ice_id(global::Ice.Current current = null)
        {
            return ice_staticId();
        }

        public static new string ice_staticId()
        {
            return "::IceGrid::Admin";
        }

        #endregion

        #region Operation dispatch

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_addApplication(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            ApplicationDescriptor iceP_descriptor;
            iceP_descriptor = null;
            iceP_descriptor = ApplicationDescriptor.ice_read(istr);
            istr.readPendingValues();
            inS.endReadParams();
            obj.addApplication(iceP_descriptor, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_syncApplication(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            ApplicationDescriptor iceP_descriptor;
            iceP_descriptor = null;
            iceP_descriptor = ApplicationDescriptor.ice_read(istr);
            istr.readPendingValues();
            inS.endReadParams();
            obj.syncApplication(iceP_descriptor, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_updateApplication(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            ApplicationUpdateDescriptor iceP_descriptor;
            iceP_descriptor = null;
            iceP_descriptor = ApplicationUpdateDescriptor.ice_read(istr);
            istr.readPendingValues();
            inS.endReadParams();
            obj.updateApplication(iceP_descriptor, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_syncApplicationWithoutRestart(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            ApplicationDescriptor iceP_descriptor;
            iceP_descriptor = null;
            iceP_descriptor = ApplicationDescriptor.ice_read(istr);
            istr.readPendingValues();
            inS.endReadParams();
            obj.syncApplicationWithoutRestart(iceP_descriptor, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_updateApplicationWithoutRestart(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            ApplicationUpdateDescriptor iceP_descriptor;
            iceP_descriptor = null;
            iceP_descriptor = ApplicationUpdateDescriptor.ice_read(istr);
            istr.readPendingValues();
            inS.endReadParams();
            obj.updateApplicationWithoutRestart(iceP_descriptor, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_removeApplication(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            string iceP_name;
            iceP_name = istr.readString();
            inS.endReadParams();
            obj.removeApplication(iceP_name, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_instantiateServer(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            string iceP_application;
            string iceP_node;
            ServerInstanceDescriptor iceP_desc;
            iceP_desc = null;
            iceP_application = istr.readString();
            iceP_node = istr.readString();
            iceP_desc = ServerInstanceDescriptor.ice_read(istr);
            inS.endReadParams();
            obj.instantiateServer(iceP_application, iceP_node, iceP_desc, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getApplicationInfo(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_name;
            iceP_name = istr.readString();
            inS.endReadParams();
            var ret = obj.getApplicationInfo(iceP_name, current);
            var ostr = inS.startWriteParams();
            ApplicationInfo.ice_write(ostr, ret);
            ostr.writePendingValues();
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getDefaultApplicationDescriptor(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            inS.readEmptyParams();
            var ret = obj.getDefaultApplicationDescriptor(current);
            var ostr = inS.startWriteParams();
            ApplicationDescriptor.ice_write(ostr, ret);
            ostr.writePendingValues();
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getAllApplicationNames(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            inS.readEmptyParams();
            var ret = obj.getAllApplicationNames(current);
            var ostr = inS.startWriteParams();
            global::Ice.StringSeqHelper.write(ostr, ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getServerInfo(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_id;
            iceP_id = istr.readString();
            inS.endReadParams();
            var ret = obj.getServerInfo(iceP_id, current);
            var ostr = inS.startWriteParams();
            ServerInfo.ice_write(ostr, ret);
            ostr.writePendingValues();
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getServerState(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_id;
            iceP_id = istr.readString();
            inS.endReadParams();
            var ret = obj.getServerState(iceP_id, current);
            var ostr = inS.startWriteParams();
            ostr.writeEnum((int)ret, 6);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getServerPid(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_id;
            iceP_id = istr.readString();
            inS.endReadParams();
            var ret = obj.getServerPid(iceP_id, current);
            var ostr = inS.startWriteParams();
            ostr.writeInt(ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getServerAdminCategory(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            inS.readEmptyParams();
            var ret = obj.getServerAdminCategory(current);
            var ostr = inS.startWriteParams();
            ostr.writeString(ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getServerAdmin(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_id;
            iceP_id = istr.readString();
            inS.endReadParams();
            var ret = obj.getServerAdmin(iceP_id, current);
            var ostr = inS.startWriteParams();
            ostr.writeProxy(ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_enableServer(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_id;
            bool iceP_enabled;
            iceP_id = istr.readString();
            iceP_enabled = istr.readBool();
            inS.endReadParams();
            obj.enableServer(iceP_id, iceP_enabled, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_isServerEnabled(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_id;
            iceP_id = istr.readString();
            inS.endReadParams();
            var ret = obj.isServerEnabled(iceP_id, current);
            var ostr = inS.startWriteParams();
            ostr.writeBool(ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_startServer(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            string iceP_id;
            iceP_id = istr.readString();
            inS.endReadParams();
            return inS.setResultTask(obj.startServerAsync(iceP_id, current));
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_stopServer(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            string iceP_id;
            iceP_id = istr.readString();
            inS.endReadParams();
            return inS.setResultTask(obj.stopServerAsync(iceP_id, current));
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_sendSignal(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            string iceP_id;
            string iceP_signal;
            iceP_id = istr.readString();
            iceP_signal = istr.readString();
            inS.endReadParams();
            obj.sendSignal(iceP_id, iceP_signal, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getAllServerIds(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            inS.readEmptyParams();
            var ret = obj.getAllServerIds(current);
            var ostr = inS.startWriteParams();
            global::Ice.StringSeqHelper.write(ostr, ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getAdapterInfo(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_id;
            iceP_id = istr.readString();
            inS.endReadParams();
            var ret = obj.getAdapterInfo(iceP_id, current);
            var ostr = inS.startWriteParams();
            AdapterInfoSeqHelper.write(ostr, ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_removeAdapter(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            string iceP_id;
            iceP_id = istr.readString();
            inS.endReadParams();
            obj.removeAdapter(iceP_id, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getAllAdapterIds(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            inS.readEmptyParams();
            var ret = obj.getAllAdapterIds(current);
            var ostr = inS.startWriteParams();
            global::Ice.StringSeqHelper.write(ostr, ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_addObject(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            global::Ice.ObjectPrx iceP_obj;
            iceP_obj = istr.readProxy();
            inS.endReadParams();
            obj.addObject(iceP_obj, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_updateObject(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            global::Ice.ObjectPrx iceP_obj;
            iceP_obj = istr.readProxy();
            inS.endReadParams();
            obj.updateObject(iceP_obj, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_addObjectWithType(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            global::Ice.ObjectPrx iceP_obj;
            string iceP_type;
            iceP_obj = istr.readProxy();
            iceP_type = istr.readString();
            inS.endReadParams();
            obj.addObjectWithType(iceP_obj, iceP_type, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_removeObject(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            global::Ice.Identity iceP_id;
            iceP_id = null;
            iceP_id = global::Ice.Identity.ice_read(istr);
            inS.endReadParams();
            obj.removeObject(iceP_id, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getObjectInfo(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            global::Ice.Identity iceP_id;
            iceP_id = null;
            iceP_id = global::Ice.Identity.ice_read(istr);
            inS.endReadParams();
            var ret = obj.getObjectInfo(iceP_id, current);
            var ostr = inS.startWriteParams();
            ObjectInfo.ice_write(ostr, ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getObjectInfosByType(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_type;
            iceP_type = istr.readString();
            inS.endReadParams();
            var ret = obj.getObjectInfosByType(iceP_type, current);
            var ostr = inS.startWriteParams();
            ObjectInfoSeqHelper.write(ostr, ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getAllObjectInfos(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_expr;
            iceP_expr = istr.readString();
            inS.endReadParams();
            var ret = obj.getAllObjectInfos(iceP_expr, current);
            var ostr = inS.startWriteParams();
            ObjectInfoSeqHelper.write(ostr, ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_pingNode(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_name;
            iceP_name = istr.readString();
            inS.endReadParams();
            var ret = obj.pingNode(iceP_name, current);
            var ostr = inS.startWriteParams();
            ostr.writeBool(ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getNodeLoad(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_name;
            iceP_name = istr.readString();
            inS.endReadParams();
            var ret = obj.getNodeLoad(iceP_name, current);
            var ostr = inS.startWriteParams();
            ret.ice_writeMembers(ostr);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getNodeInfo(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_name;
            iceP_name = istr.readString();
            inS.endReadParams();
            var ret = obj.getNodeInfo(iceP_name, current);
            var ostr = inS.startWriteParams();
            NodeInfo.ice_write(ostr, ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getNodeAdmin(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_name;
            iceP_name = istr.readString();
            inS.endReadParams();
            var ret = obj.getNodeAdmin(iceP_name, current);
            var ostr = inS.startWriteParams();
            ostr.writeProxy(ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getNodeProcessorSocketCount(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_name;
            iceP_name = istr.readString();
            inS.endReadParams();
            var ret = obj.getNodeProcessorSocketCount(iceP_name, current);
            var ostr = inS.startWriteParams();
            ostr.writeInt(ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_shutdownNode(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            string iceP_name;
            iceP_name = istr.readString();
            inS.endReadParams();
            obj.shutdownNode(iceP_name, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getNodeHostname(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_name;
            iceP_name = istr.readString();
            inS.endReadParams();
            var ret = obj.getNodeHostname(iceP_name, current);
            var ostr = inS.startWriteParams();
            ostr.writeString(ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getAllNodeNames(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            inS.readEmptyParams();
            var ret = obj.getAllNodeNames(current);
            var ostr = inS.startWriteParams();
            global::Ice.StringSeqHelper.write(ostr, ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_pingRegistry(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_name;
            iceP_name = istr.readString();
            inS.endReadParams();
            var ret = obj.pingRegistry(iceP_name, current);
            var ostr = inS.startWriteParams();
            ostr.writeBool(ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getRegistryInfo(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_name;
            iceP_name = istr.readString();
            inS.endReadParams();
            var ret = obj.getRegistryInfo(iceP_name, current);
            var ostr = inS.startWriteParams();
            RegistryInfo.ice_write(ostr, ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getRegistryAdmin(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_name;
            iceP_name = istr.readString();
            inS.endReadParams();
            var ret = obj.getRegistryAdmin(iceP_name, current);
            var ostr = inS.startWriteParams();
            ostr.writeProxy(ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_shutdownRegistry(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            string iceP_name;
            iceP_name = istr.readString();
            inS.endReadParams();
            obj.shutdownRegistry(iceP_name, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getAllRegistryNames(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            inS.readEmptyParams();
            var ret = obj.getAllRegistryNames(current);
            var ostr = inS.startWriteParams();
            global::Ice.StringSeqHelper.write(ostr, ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_shutdown(Admin obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            inS.readEmptyParams();
            obj.shutdown(current);
            return inS.setResult(inS.writeEmptyParams());
        }

        private static readonly string[] _all =
        {
            "addApplication",
            "addObject",
            "addObjectWithType",
            "enableServer",
            "getAdapterInfo",
            "getAllAdapterIds",
            "getAllApplicationNames",
            "getAllNodeNames",
            "getAllObjectInfos",
            "getAllRegistryNames",
            "getAllServerIds",
            "getApplicationInfo",
            "getDefaultApplicationDescriptor",
            "getNodeAdmin",
            "getNodeHostname",
            "getNodeInfo",
            "getNodeLoad",
            "getNodeProcessorSocketCount",
            "getObjectInfo",
            "getObjectInfosByType",
            "getRegistryAdmin",
            "getRegistryInfo",
            "getServerAdmin",
            "getServerAdminCategory",
            "getServerInfo",
            "getServerPid",
            "getServerState",
            "ice_id",
            "ice_ids",
            "ice_isA",
            "ice_ping",
            "instantiateServer",
            "isServerEnabled",
            "pingNode",
            "pingRegistry",
            "removeAdapter",
            "removeApplication",
            "removeObject",
            "sendSignal",
            "shutdown",
            "shutdownNode",
            "shutdownRegistry",
            "startServer",
            "stopServer",
            "syncApplication",
            "syncApplicationWithoutRestart",
            "updateApplication",
            "updateApplicationWithoutRestart",
            "updateObject"
        };

        public override global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceDispatch(global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            int pos = global::System.Array.BinarySearch(_all, current.operation, global::IceUtilInternal.StringUtil.OrdinalStringComparer);
            if(pos < 0)
            {
                throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
            }

            switch(pos)
            {
                case 0:
                {
                    return iceD_addApplication(this, inS, current);
                }
                case 1:
                {
                    return iceD_addObject(this, inS, current);
                }
                case 2:
                {
                    return iceD_addObjectWithType(this, inS, current);
                }
                case 3:
                {
                    return iceD_enableServer(this, inS, current);
                }
                case 4:
                {
                    return iceD_getAdapterInfo(this, inS, current);
                }
                case 5:
                {
                    return iceD_getAllAdapterIds(this, inS, current);
                }
                case 6:
                {
                    return iceD_getAllApplicationNames(this, inS, current);
                }
                case 7:
                {
                    return iceD_getAllNodeNames(this, inS, current);
                }
                case 8:
                {
                    return iceD_getAllObjectInfos(this, inS, current);
                }
                case 9:
                {
                    return iceD_getAllRegistryNames(this, inS, current);
                }
                case 10:
                {
                    return iceD_getAllServerIds(this, inS, current);
                }
                case 11:
                {
                    return iceD_getApplicationInfo(this, inS, current);
                }
                case 12:
                {
                    return iceD_getDefaultApplicationDescriptor(this, inS, current);
                }
                case 13:
                {
                    return iceD_getNodeAdmin(this, inS, current);
                }
                case 14:
                {
                    return iceD_getNodeHostname(this, inS, current);
                }
                case 15:
                {
                    return iceD_getNodeInfo(this, inS, current);
                }
                case 16:
                {
                    return iceD_getNodeLoad(this, inS, current);
                }
                case 17:
                {
                    return iceD_getNodeProcessorSocketCount(this, inS, current);
                }
                case 18:
                {
                    return iceD_getObjectInfo(this, inS, current);
                }
                case 19:
                {
                    return iceD_getObjectInfosByType(this, inS, current);
                }
                case 20:
                {
                    return iceD_getRegistryAdmin(this, inS, current);
                }
                case 21:
                {
                    return iceD_getRegistryInfo(this, inS, current);
                }
                case 22:
                {
                    return iceD_getServerAdmin(this, inS, current);
                }
                case 23:
                {
                    return iceD_getServerAdminCategory(this, inS, current);
                }
                case 24:
                {
                    return iceD_getServerInfo(this, inS, current);
                }
                case 25:
                {
                    return iceD_getServerPid(this, inS, current);
                }
                case 26:
                {
                    return iceD_getServerState(this, inS, current);
                }
                case 27:
                {
                    return global::Ice.ObjectImpl.iceD_ice_id(this, inS, current);
                }
                case 28:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ids(this, inS, current);
                }
                case 29:
                {
                    return global::Ice.ObjectImpl.iceD_ice_isA(this, inS, current);
                }
                case 30:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ping(this, inS, current);
                }
                case 31:
                {
                    return iceD_instantiateServer(this, inS, current);
                }
                case 32:
                {
                    return iceD_isServerEnabled(this, inS, current);
                }
                case 33:
                {
                    return iceD_pingNode(this, inS, current);
                }
                case 34:
                {
                    return iceD_pingRegistry(this, inS, current);
                }
                case 35:
                {
                    return iceD_removeAdapter(this, inS, current);
                }
                case 36:
                {
                    return iceD_removeApplication(this, inS, current);
                }
                case 37:
                {
                    return iceD_removeObject(this, inS, current);
                }
                case 38:
                {
                    return iceD_sendSignal(this, inS, current);
                }
                case 39:
                {
                    return iceD_shutdown(this, inS, current);
                }
                case 40:
                {
                    return iceD_shutdownNode(this, inS, current);
                }
                case 41:
                {
                    return iceD_shutdownRegistry(this, inS, current);
                }
                case 42:
                {
                    return iceD_startServer(this, inS, current);
                }
                case 43:
                {
                    return iceD_stopServer(this, inS, current);
                }
                case 44:
                {
                    return iceD_syncApplication(this, inS, current);
                }
                case 45:
                {
                    return iceD_syncApplicationWithoutRestart(this, inS, current);
                }
                case 46:
                {
                    return iceD_updateApplication(this, inS, current);
                }
                case 47:
                {
                    return iceD_updateApplicationWithoutRestart(this, inS, current);
                }
                case 48:
                {
                    return iceD_updateObject(this, inS, current);
                }
            }

            global::System.Diagnostics.Debug.Assert(false);
            throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
        }

        #endregion
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public abstract class FileIteratorDisp_ : global::Ice.ObjectImpl, FileIterator
    {
        #region Slice operations

        public abstract bool read(int size, out string[] lines, global::Ice.Current current = null);

        public abstract void destroy(global::Ice.Current current = null);

        #endregion

        #region Slice type-related members

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::FileIterator"
        };

        public override bool ice_isA(string s, global::Ice.Current current = null)
        {
            return global::System.Array.BinarySearch(_ids, s, IceUtilInternal.StringUtil.OrdinalStringComparer) >= 0;
        }

        public override string[] ice_ids(global::Ice.Current current = null)
        {
            return _ids;
        }

        public override string ice_id(global::Ice.Current current = null)
        {
            return ice_staticId();
        }

        public static new string ice_staticId()
        {
            return "::IceGrid::FileIterator";
        }

        #endregion

        #region Operation dispatch

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_read(FileIterator obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            int iceP_size;
            iceP_size = istr.readInt();
            inS.endReadParams();
            string[] iceP_lines;
            var ret = obj.read(iceP_size, out iceP_lines, current);
            var ostr = inS.startWriteParams();
            global::Ice.StringSeqHelper.write(ostr, iceP_lines);
            ostr.writeBool(ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_destroy(FileIterator obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            inS.readEmptyParams();
            obj.destroy(current);
            return inS.setResult(inS.writeEmptyParams());
        }

        private static readonly string[] _all =
        {
            "destroy",
            "ice_id",
            "ice_ids",
            "ice_isA",
            "ice_ping",
            "read"
        };

        public override global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceDispatch(global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            int pos = global::System.Array.BinarySearch(_all, current.operation, global::IceUtilInternal.StringUtil.OrdinalStringComparer);
            if(pos < 0)
            {
                throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
            }

            switch(pos)
            {
                case 0:
                {
                    return iceD_destroy(this, inS, current);
                }
                case 1:
                {
                    return global::Ice.ObjectImpl.iceD_ice_id(this, inS, current);
                }
                case 2:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ids(this, inS, current);
                }
                case 3:
                {
                    return global::Ice.ObjectImpl.iceD_ice_isA(this, inS, current);
                }
                case 4:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ping(this, inS, current);
                }
                case 5:
                {
                    return iceD_read(this, inS, current);
                }
            }

            global::System.Diagnostics.Debug.Assert(false);
            throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
        }

        #endregion
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public abstract class RegistryObserverDisp_ : global::Ice.ObjectImpl, RegistryObserver
    {
        #region Slice operations

        public abstract void registryInit(RegistryInfo[] registries, global::Ice.Current current = null);

        public abstract void registryUp(RegistryInfo node, global::Ice.Current current = null);

        public abstract void registryDown(string name, global::Ice.Current current = null);

        #endregion

        #region Slice type-related members

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::RegistryObserver"
        };

        public override bool ice_isA(string s, global::Ice.Current current = null)
        {
            return global::System.Array.BinarySearch(_ids, s, IceUtilInternal.StringUtil.OrdinalStringComparer) >= 0;
        }

        public override string[] ice_ids(global::Ice.Current current = null)
        {
            return _ids;
        }

        public override string ice_id(global::Ice.Current current = null)
        {
            return ice_staticId();
        }

        public static new string ice_staticId()
        {
            return "::IceGrid::RegistryObserver";
        }

        #endregion

        #region Operation dispatch

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_registryInit(RegistryObserver obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            RegistryInfo[] iceP_registries;
            iceP_registries = RegistryInfoSeqHelper.read(istr);
            inS.endReadParams();
            obj.registryInit(iceP_registries, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_registryUp(RegistryObserver obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            RegistryInfo iceP_node;
            iceP_node = null;
            iceP_node = RegistryInfo.ice_read(istr);
            inS.endReadParams();
            obj.registryUp(iceP_node, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_registryDown(RegistryObserver obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            string iceP_name;
            iceP_name = istr.readString();
            inS.endReadParams();
            obj.registryDown(iceP_name, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        private static readonly string[] _all =
        {
            "ice_id",
            "ice_ids",
            "ice_isA",
            "ice_ping",
            "registryDown",
            "registryInit",
            "registryUp"
        };

        public override global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceDispatch(global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            int pos = global::System.Array.BinarySearch(_all, current.operation, global::IceUtilInternal.StringUtil.OrdinalStringComparer);
            if(pos < 0)
            {
                throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
            }

            switch(pos)
            {
                case 0:
                {
                    return global::Ice.ObjectImpl.iceD_ice_id(this, inS, current);
                }
                case 1:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ids(this, inS, current);
                }
                case 2:
                {
                    return global::Ice.ObjectImpl.iceD_ice_isA(this, inS, current);
                }
                case 3:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ping(this, inS, current);
                }
                case 4:
                {
                    return iceD_registryDown(this, inS, current);
                }
                case 5:
                {
                    return iceD_registryInit(this, inS, current);
                }
                case 6:
                {
                    return iceD_registryUp(this, inS, current);
                }
            }

            global::System.Diagnostics.Debug.Assert(false);
            throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
        }

        #endregion
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public abstract class NodeObserverDisp_ : global::Ice.ObjectImpl, NodeObserver
    {
        #region Slice operations

        public abstract void nodeInit(NodeDynamicInfo[] nodes, global::Ice.Current current = null);

        public abstract void nodeUp(NodeDynamicInfo node, global::Ice.Current current = null);

        public abstract void nodeDown(string name, global::Ice.Current current = null);

        public abstract void updateServer(string node, ServerDynamicInfo updatedInfo, global::Ice.Current current = null);

        public abstract void updateAdapter(string node, AdapterDynamicInfo updatedInfo, global::Ice.Current current = null);

        #endregion

        #region Slice type-related members

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::NodeObserver"
        };

        public override bool ice_isA(string s, global::Ice.Current current = null)
        {
            return global::System.Array.BinarySearch(_ids, s, IceUtilInternal.StringUtil.OrdinalStringComparer) >= 0;
        }

        public override string[] ice_ids(global::Ice.Current current = null)
        {
            return _ids;
        }

        public override string ice_id(global::Ice.Current current = null)
        {
            return ice_staticId();
        }

        public static new string ice_staticId()
        {
            return "::IceGrid::NodeObserver";
        }

        #endregion

        #region Operation dispatch

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_nodeInit(NodeObserver obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            NodeDynamicInfo[] iceP_nodes;
            iceP_nodes = NodeDynamicInfoSeqHelper.read(istr);
            inS.endReadParams();
            obj.nodeInit(iceP_nodes, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_nodeUp(NodeObserver obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            NodeDynamicInfo iceP_node;
            iceP_node = null;
            iceP_node = NodeDynamicInfo.ice_read(istr);
            inS.endReadParams();
            obj.nodeUp(iceP_node, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_nodeDown(NodeObserver obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            string iceP_name;
            iceP_name = istr.readString();
            inS.endReadParams();
            obj.nodeDown(iceP_name, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_updateServer(NodeObserver obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            string iceP_node;
            ServerDynamicInfo iceP_updatedInfo;
            iceP_updatedInfo = null;
            iceP_node = istr.readString();
            iceP_updatedInfo = ServerDynamicInfo.ice_read(istr);
            inS.endReadParams();
            obj.updateServer(iceP_node, iceP_updatedInfo, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_updateAdapter(NodeObserver obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            string iceP_node;
            AdapterDynamicInfo iceP_updatedInfo;
            iceP_updatedInfo = null;
            iceP_node = istr.readString();
            iceP_updatedInfo = AdapterDynamicInfo.ice_read(istr);
            inS.endReadParams();
            obj.updateAdapter(iceP_node, iceP_updatedInfo, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        private static readonly string[] _all =
        {
            "ice_id",
            "ice_ids",
            "ice_isA",
            "ice_ping",
            "nodeDown",
            "nodeInit",
            "nodeUp",
            "updateAdapter",
            "updateServer"
        };

        public override global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceDispatch(global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            int pos = global::System.Array.BinarySearch(_all, current.operation, global::IceUtilInternal.StringUtil.OrdinalStringComparer);
            if(pos < 0)
            {
                throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
            }

            switch(pos)
            {
                case 0:
                {
                    return global::Ice.ObjectImpl.iceD_ice_id(this, inS, current);
                }
                case 1:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ids(this, inS, current);
                }
                case 2:
                {
                    return global::Ice.ObjectImpl.iceD_ice_isA(this, inS, current);
                }
                case 3:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ping(this, inS, current);
                }
                case 4:
                {
                    return iceD_nodeDown(this, inS, current);
                }
                case 5:
                {
                    return iceD_nodeInit(this, inS, current);
                }
                case 6:
                {
                    return iceD_nodeUp(this, inS, current);
                }
                case 7:
                {
                    return iceD_updateAdapter(this, inS, current);
                }
                case 8:
                {
                    return iceD_updateServer(this, inS, current);
                }
            }

            global::System.Diagnostics.Debug.Assert(false);
            throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
        }

        #endregion
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public abstract class ApplicationObserverDisp_ : global::Ice.ObjectImpl, ApplicationObserver
    {
        #region Slice operations

        public abstract void applicationInit(int serial, ApplicationInfo[] applications, global::Ice.Current current = null);

        public abstract void applicationAdded(int serial, ApplicationInfo desc, global::Ice.Current current = null);

        public abstract void applicationRemoved(int serial, string name, global::Ice.Current current = null);

        public abstract void applicationUpdated(int serial, ApplicationUpdateInfo desc, global::Ice.Current current = null);

        #endregion

        #region Slice type-related members

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::ApplicationObserver"
        };

        public override bool ice_isA(string s, global::Ice.Current current = null)
        {
            return global::System.Array.BinarySearch(_ids, s, IceUtilInternal.StringUtil.OrdinalStringComparer) >= 0;
        }

        public override string[] ice_ids(global::Ice.Current current = null)
        {
            return _ids;
        }

        public override string ice_id(global::Ice.Current current = null)
        {
            return ice_staticId();
        }

        public static new string ice_staticId()
        {
            return "::IceGrid::ApplicationObserver";
        }

        #endregion

        #region Operation dispatch

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_applicationInit(ApplicationObserver obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            int iceP_serial;
            ApplicationInfo[] iceP_applications;
            iceP_serial = istr.readInt();
            iceP_applications = ApplicationInfoSeqHelper.read(istr);
            istr.readPendingValues();
            inS.endReadParams();
            obj.applicationInit(iceP_serial, iceP_applications, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_applicationAdded(ApplicationObserver obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            int iceP_serial;
            ApplicationInfo iceP_desc;
            iceP_desc = null;
            iceP_serial = istr.readInt();
            iceP_desc = ApplicationInfo.ice_read(istr);
            istr.readPendingValues();
            inS.endReadParams();
            obj.applicationAdded(iceP_serial, iceP_desc, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_applicationRemoved(ApplicationObserver obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            int iceP_serial;
            string iceP_name;
            iceP_serial = istr.readInt();
            iceP_name = istr.readString();
            inS.endReadParams();
            obj.applicationRemoved(iceP_serial, iceP_name, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_applicationUpdated(ApplicationObserver obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            int iceP_serial;
            ApplicationUpdateInfo iceP_desc;
            iceP_desc = null;
            iceP_serial = istr.readInt();
            iceP_desc = ApplicationUpdateInfo.ice_read(istr);
            istr.readPendingValues();
            inS.endReadParams();
            obj.applicationUpdated(iceP_serial, iceP_desc, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        private static readonly string[] _all =
        {
            "applicationAdded",
            "applicationInit",
            "applicationRemoved",
            "applicationUpdated",
            "ice_id",
            "ice_ids",
            "ice_isA",
            "ice_ping"
        };

        public override global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceDispatch(global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            int pos = global::System.Array.BinarySearch(_all, current.operation, global::IceUtilInternal.StringUtil.OrdinalStringComparer);
            if(pos < 0)
            {
                throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
            }

            switch(pos)
            {
                case 0:
                {
                    return iceD_applicationAdded(this, inS, current);
                }
                case 1:
                {
                    return iceD_applicationInit(this, inS, current);
                }
                case 2:
                {
                    return iceD_applicationRemoved(this, inS, current);
                }
                case 3:
                {
                    return iceD_applicationUpdated(this, inS, current);
                }
                case 4:
                {
                    return global::Ice.ObjectImpl.iceD_ice_id(this, inS, current);
                }
                case 5:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ids(this, inS, current);
                }
                case 6:
                {
                    return global::Ice.ObjectImpl.iceD_ice_isA(this, inS, current);
                }
                case 7:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ping(this, inS, current);
                }
            }

            global::System.Diagnostics.Debug.Assert(false);
            throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
        }

        #endregion
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public abstract class AdapterObserverDisp_ : global::Ice.ObjectImpl, AdapterObserver
    {
        #region Slice operations

        public abstract void adapterInit(AdapterInfo[] adpts, global::Ice.Current current = null);

        public abstract void adapterAdded(AdapterInfo info, global::Ice.Current current = null);

        public abstract void adapterUpdated(AdapterInfo info, global::Ice.Current current = null);

        public abstract void adapterRemoved(string id, global::Ice.Current current = null);

        #endregion

        #region Slice type-related members

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::AdapterObserver"
        };

        public override bool ice_isA(string s, global::Ice.Current current = null)
        {
            return global::System.Array.BinarySearch(_ids, s, IceUtilInternal.StringUtil.OrdinalStringComparer) >= 0;
        }

        public override string[] ice_ids(global::Ice.Current current = null)
        {
            return _ids;
        }

        public override string ice_id(global::Ice.Current current = null)
        {
            return ice_staticId();
        }

        public static new string ice_staticId()
        {
            return "::IceGrid::AdapterObserver";
        }

        #endregion

        #region Operation dispatch

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_adapterInit(AdapterObserver obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            AdapterInfo[] iceP_adpts;
            iceP_adpts = AdapterInfoSeqHelper.read(istr);
            inS.endReadParams();
            obj.adapterInit(iceP_adpts, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_adapterAdded(AdapterObserver obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            AdapterInfo iceP_info;
            iceP_info = null;
            iceP_info = AdapterInfo.ice_read(istr);
            inS.endReadParams();
            obj.adapterAdded(iceP_info, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_adapterUpdated(AdapterObserver obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            AdapterInfo iceP_info;
            iceP_info = null;
            iceP_info = AdapterInfo.ice_read(istr);
            inS.endReadParams();
            obj.adapterUpdated(iceP_info, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_adapterRemoved(AdapterObserver obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            string iceP_id;
            iceP_id = istr.readString();
            inS.endReadParams();
            obj.adapterRemoved(iceP_id, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        private static readonly string[] _all =
        {
            "adapterAdded",
            "adapterInit",
            "adapterRemoved",
            "adapterUpdated",
            "ice_id",
            "ice_ids",
            "ice_isA",
            "ice_ping"
        };

        public override global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceDispatch(global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            int pos = global::System.Array.BinarySearch(_all, current.operation, global::IceUtilInternal.StringUtil.OrdinalStringComparer);
            if(pos < 0)
            {
                throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
            }

            switch(pos)
            {
                case 0:
                {
                    return iceD_adapterAdded(this, inS, current);
                }
                case 1:
                {
                    return iceD_adapterInit(this, inS, current);
                }
                case 2:
                {
                    return iceD_adapterRemoved(this, inS, current);
                }
                case 3:
                {
                    return iceD_adapterUpdated(this, inS, current);
                }
                case 4:
                {
                    return global::Ice.ObjectImpl.iceD_ice_id(this, inS, current);
                }
                case 5:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ids(this, inS, current);
                }
                case 6:
                {
                    return global::Ice.ObjectImpl.iceD_ice_isA(this, inS, current);
                }
                case 7:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ping(this, inS, current);
                }
            }

            global::System.Diagnostics.Debug.Assert(false);
            throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
        }

        #endregion
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public abstract class ObjectObserverDisp_ : global::Ice.ObjectImpl, ObjectObserver
    {
        #region Slice operations

        public abstract void objectInit(ObjectInfo[] objects, global::Ice.Current current = null);

        public abstract void objectAdded(ObjectInfo info, global::Ice.Current current = null);

        public abstract void objectUpdated(ObjectInfo info, global::Ice.Current current = null);

        public abstract void objectRemoved(global::Ice.Identity id, global::Ice.Current current = null);

        #endregion

        #region Slice type-related members

        private static readonly string[] _ids =
        {
            "::Ice::Object",
            "::IceGrid::ObjectObserver"
        };

        public override bool ice_isA(string s, global::Ice.Current current = null)
        {
            return global::System.Array.BinarySearch(_ids, s, IceUtilInternal.StringUtil.OrdinalStringComparer) >= 0;
        }

        public override string[] ice_ids(global::Ice.Current current = null)
        {
            return _ids;
        }

        public override string ice_id(global::Ice.Current current = null)
        {
            return ice_staticId();
        }

        public static new string ice_staticId()
        {
            return "::IceGrid::ObjectObserver";
        }

        #endregion

        #region Operation dispatch

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_objectInit(ObjectObserver obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            ObjectInfo[] iceP_objects;
            iceP_objects = ObjectInfoSeqHelper.read(istr);
            inS.endReadParams();
            obj.objectInit(iceP_objects, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_objectAdded(ObjectObserver obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            ObjectInfo iceP_info;
            iceP_info = null;
            iceP_info = ObjectInfo.ice_read(istr);
            inS.endReadParams();
            obj.objectAdded(iceP_info, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_objectUpdated(ObjectObserver obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            ObjectInfo iceP_info;
            iceP_info = null;
            iceP_info = ObjectInfo.ice_read(istr);
            inS.endReadParams();
            obj.objectUpdated(iceP_info, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_objectRemoved(ObjectObserver obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            global::Ice.Identity iceP_id;
            iceP_id = null;
            iceP_id = global::Ice.Identity.ice_read(istr);
            inS.endReadParams();
            obj.objectRemoved(iceP_id, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        private static readonly string[] _all =
        {
            "ice_id",
            "ice_ids",
            "ice_isA",
            "ice_ping",
            "objectAdded",
            "objectInit",
            "objectRemoved",
            "objectUpdated"
        };

        public override global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceDispatch(global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            int pos = global::System.Array.BinarySearch(_all, current.operation, global::IceUtilInternal.StringUtil.OrdinalStringComparer);
            if(pos < 0)
            {
                throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
            }

            switch(pos)
            {
                case 0:
                {
                    return global::Ice.ObjectImpl.iceD_ice_id(this, inS, current);
                }
                case 1:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ids(this, inS, current);
                }
                case 2:
                {
                    return global::Ice.ObjectImpl.iceD_ice_isA(this, inS, current);
                }
                case 3:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ping(this, inS, current);
                }
                case 4:
                {
                    return iceD_objectAdded(this, inS, current);
                }
                case 5:
                {
                    return iceD_objectInit(this, inS, current);
                }
                case 6:
                {
                    return iceD_objectRemoved(this, inS, current);
                }
                case 7:
                {
                    return iceD_objectUpdated(this, inS, current);
                }
            }

            global::System.Diagnostics.Debug.Assert(false);
            throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
        }

        #endregion
    }

    [global::System.Runtime.InteropServices.ComVisible(false)]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("slice2cs", "3.8.0-alpha.0")]
    public abstract class AdminSessionDisp_ : global::Ice.ObjectImpl, AdminSession
    {
        #region Slice operations

        public abstract void keepAlive(global::Ice.Current current = null);

        public abstract AdminPrx getAdmin(global::Ice.Current current = null);

        public abstract global::Ice.ObjectPrx getAdminCallbackTemplate(global::Ice.Current current = null);

        public abstract void setObservers(RegistryObserverPrx registryObs, NodeObserverPrx nodeObs, ApplicationObserverPrx appObs, AdapterObserverPrx adptObs, ObjectObserverPrx objObs, global::Ice.Current current = null);

        public abstract void setObserversByIdentity(global::Ice.Identity registryObs, global::Ice.Identity nodeObs, global::Ice.Identity appObs, global::Ice.Identity adptObs, global::Ice.Identity objObs, global::Ice.Current current = null);

        public abstract int startUpdate(global::Ice.Current current = null);

        public abstract void finishUpdate(global::Ice.Current current = null);

        public abstract string getReplicaName(global::Ice.Current current = null);

        public abstract FileIteratorPrx openServerLog(string id, string path, int count, global::Ice.Current current = null);

        public abstract FileIteratorPrx openServerStdErr(string id, int count, global::Ice.Current current = null);

        public abstract FileIteratorPrx openServerStdOut(string id, int count, global::Ice.Current current = null);

        public abstract FileIteratorPrx openNodeStdErr(string name, int count, global::Ice.Current current = null);

        public abstract FileIteratorPrx openNodeStdOut(string name, int count, global::Ice.Current current = null);

        public abstract FileIteratorPrx openRegistryStdErr(string name, int count, global::Ice.Current current = null);

        public abstract FileIteratorPrx openRegistryStdOut(string name, int count, global::Ice.Current current = null);

        #endregion

        #region Inherited Slice operations

        public abstract void destroy(global::Ice.Current current = null);

        #endregion

        #region Slice type-related members

        private static readonly string[] _ids =
        {
            "::Glacier2::Session",
            "::Ice::Object",
            "::IceGrid::AdminSession"
        };

        public override bool ice_isA(string s, global::Ice.Current current = null)
        {
            return global::System.Array.BinarySearch(_ids, s, IceUtilInternal.StringUtil.OrdinalStringComparer) >= 0;
        }

        public override string[] ice_ids(global::Ice.Current current = null)
        {
            return _ids;
        }

        public override string ice_id(global::Ice.Current current = null)
        {
            return ice_staticId();
        }

        public static new string ice_staticId()
        {
            return "::IceGrid::AdminSession";
        }

        #endregion

        #region Operation dispatch

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_keepAlive(AdminSession obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            inS.readEmptyParams();
            obj.keepAlive(current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getAdmin(AdminSession obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            inS.readEmptyParams();
            var ret = obj.getAdmin(current);
            var ostr = inS.startWriteParams();
            AdminPrxHelper.write(ostr, ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getAdminCallbackTemplate(AdminSession obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            inS.readEmptyParams();
            var ret = obj.getAdminCallbackTemplate(current);
            var ostr = inS.startWriteParams();
            ostr.writeProxy(ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_setObservers(AdminSession obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            RegistryObserverPrx iceP_registryObs;
            NodeObserverPrx iceP_nodeObs;
            ApplicationObserverPrx iceP_appObs;
            AdapterObserverPrx iceP_adptObs;
            ObjectObserverPrx iceP_objObs;
            iceP_registryObs = RegistryObserverPrxHelper.read(istr);
            iceP_nodeObs = NodeObserverPrxHelper.read(istr);
            iceP_appObs = ApplicationObserverPrxHelper.read(istr);
            iceP_adptObs = AdapterObserverPrxHelper.read(istr);
            iceP_objObs = ObjectObserverPrxHelper.read(istr);
            inS.endReadParams();
            obj.setObservers(iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_setObserversByIdentity(AdminSession obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            var istr = inS.startReadParams();
            global::Ice.Identity iceP_registryObs;
            iceP_registryObs = null;
            global::Ice.Identity iceP_nodeObs;
            iceP_nodeObs = null;
            global::Ice.Identity iceP_appObs;
            iceP_appObs = null;
            global::Ice.Identity iceP_adptObs;
            iceP_adptObs = null;
            global::Ice.Identity iceP_objObs;
            iceP_objObs = null;
            iceP_registryObs = global::Ice.Identity.ice_read(istr);
            iceP_nodeObs = global::Ice.Identity.ice_read(istr);
            iceP_appObs = global::Ice.Identity.ice_read(istr);
            iceP_adptObs = global::Ice.Identity.ice_read(istr);
            iceP_objObs = global::Ice.Identity.ice_read(istr);
            inS.endReadParams();
            obj.setObserversByIdentity(iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs, current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_startUpdate(AdminSession obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            inS.readEmptyParams();
            var ret = obj.startUpdate(current);
            var ostr = inS.startWriteParams();
            ostr.writeInt(ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_finishUpdate(AdminSession obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            inS.readEmptyParams();
            obj.finishUpdate(current);
            return inS.setResult(inS.writeEmptyParams());
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_getReplicaName(AdminSession obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Idempotent, current.mode);
            inS.readEmptyParams();
            var ret = obj.getReplicaName(current);
            var ostr = inS.startWriteParams();
            ostr.writeString(ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_openServerLog(AdminSession obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            string iceP_id;
            string iceP_path;
            int iceP_count;
            iceP_id = istr.readString();
            iceP_path = istr.readString();
            iceP_count = istr.readInt();
            inS.endReadParams();
            var ret = obj.openServerLog(iceP_id, iceP_path, iceP_count, current);
            var ostr = inS.startWriteParams();
            FileIteratorPrxHelper.write(ostr, ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_openServerStdErr(AdminSession obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            string iceP_id;
            int iceP_count;
            iceP_id = istr.readString();
            iceP_count = istr.readInt();
            inS.endReadParams();
            var ret = obj.openServerStdErr(iceP_id, iceP_count, current);
            var ostr = inS.startWriteParams();
            FileIteratorPrxHelper.write(ostr, ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_openServerStdOut(AdminSession obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            string iceP_id;
            int iceP_count;
            iceP_id = istr.readString();
            iceP_count = istr.readInt();
            inS.endReadParams();
            var ret = obj.openServerStdOut(iceP_id, iceP_count, current);
            var ostr = inS.startWriteParams();
            FileIteratorPrxHelper.write(ostr, ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_openNodeStdErr(AdminSession obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            string iceP_name;
            int iceP_count;
            iceP_name = istr.readString();
            iceP_count = istr.readInt();
            inS.endReadParams();
            var ret = obj.openNodeStdErr(iceP_name, iceP_count, current);
            var ostr = inS.startWriteParams();
            FileIteratorPrxHelper.write(ostr, ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_openNodeStdOut(AdminSession obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            string iceP_name;
            int iceP_count;
            iceP_name = istr.readString();
            iceP_count = istr.readInt();
            inS.endReadParams();
            var ret = obj.openNodeStdOut(iceP_name, iceP_count, current);
            var ostr = inS.startWriteParams();
            FileIteratorPrxHelper.write(ostr, ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_openRegistryStdErr(AdminSession obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            string iceP_name;
            int iceP_count;
            iceP_name = istr.readString();
            iceP_count = istr.readInt();
            inS.endReadParams();
            var ret = obj.openRegistryStdErr(iceP_name, iceP_count, current);
            var ostr = inS.startWriteParams();
            FileIteratorPrxHelper.write(ostr, ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011")]
        public static global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceD_openRegistryStdOut(AdminSession obj, global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            global::Ice.ObjectImpl.iceCheckMode(global::Ice.OperationMode.Normal, current.mode);
            var istr = inS.startReadParams();
            string iceP_name;
            int iceP_count;
            iceP_name = istr.readString();
            iceP_count = istr.readInt();
            inS.endReadParams();
            var ret = obj.openRegistryStdOut(iceP_name, iceP_count, current);
            var ostr = inS.startWriteParams();
            FileIteratorPrxHelper.write(ostr, ret);
            inS.endWriteParams(ostr);
            return inS.setResult(ostr);
        }

        private static readonly string[] _all =
        {
            "destroy",
            "finishUpdate",
            "getAdmin",
            "getAdminCallbackTemplate",
            "getReplicaName",
            "ice_id",
            "ice_ids",
            "ice_isA",
            "ice_ping",
            "keepAlive",
            "openNodeStdErr",
            "openNodeStdOut",
            "openRegistryStdErr",
            "openRegistryStdOut",
            "openServerLog",
            "openServerStdErr",
            "openServerStdOut",
            "setObservers",
            "setObserversByIdentity",
            "startUpdate"
        };

        public override global::System.Threading.Tasks.Task<global::Ice.OutputStream>
        iceDispatch(global::IceInternal.Incoming inS, global::Ice.Current current)
        {
            int pos = global::System.Array.BinarySearch(_all, current.operation, global::IceUtilInternal.StringUtil.OrdinalStringComparer);
            if(pos < 0)
            {
                throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
            }

            switch(pos)
            {
                case 0:
                {
                    return global::Glacier2.SessionDisp_.iceD_destroy(this, inS, current);
                }
                case 1:
                {
                    return iceD_finishUpdate(this, inS, current);
                }
                case 2:
                {
                    return iceD_getAdmin(this, inS, current);
                }
                case 3:
                {
                    return iceD_getAdminCallbackTemplate(this, inS, current);
                }
                case 4:
                {
                    return iceD_getReplicaName(this, inS, current);
                }
                case 5:
                {
                    return global::Ice.ObjectImpl.iceD_ice_id(this, inS, current);
                }
                case 6:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ids(this, inS, current);
                }
                case 7:
                {
                    return global::Ice.ObjectImpl.iceD_ice_isA(this, inS, current);
                }
                case 8:
                {
                    return global::Ice.ObjectImpl.iceD_ice_ping(this, inS, current);
                }
                case 9:
                {
                    return iceD_keepAlive(this, inS, current);
                }
                case 10:
                {
                    return iceD_openNodeStdErr(this, inS, current);
                }
                case 11:
                {
                    return iceD_openNodeStdOut(this, inS, current);
                }
                case 12:
                {
                    return iceD_openRegistryStdErr(this, inS, current);
                }
                case 13:
                {
                    return iceD_openRegistryStdOut(this, inS, current);
                }
                case 14:
                {
                    return iceD_openServerLog(this, inS, current);
                }
                case 15:
                {
                    return iceD_openServerStdErr(this, inS, current);
                }
                case 16:
                {
                    return iceD_openServerStdOut(this, inS, current);
                }
                case 17:
                {
                    return iceD_setObservers(this, inS, current);
                }
                case 18:
                {
                    return iceD_setObserversByIdentity(this, inS, current);
                }
                case 19:
                {
                    return iceD_startUpdate(this, inS, current);
                }
            }

            global::System.Diagnostics.Debug.Assert(false);
            throw new global::Ice.OperationNotExistException(current.id, current.facet, current.operation);
        }

        #endregion
    }
}
