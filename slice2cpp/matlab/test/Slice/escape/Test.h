//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Test_h__
#define __Test_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace classdef
{


namespace _cpp_break
{


enum class _cpp_bitand : unsigned char
{
    _cpp_break,
    _cpp_case,
    _cpp_catch,
    classdef,
    _cpp_continue,
    _cpp_else,
    elseif,
    end,
    enumeration,
    events,
    _cpp_for,
    function,
    global,
    _cpp_if,
    methods,
    otherwise,
    parfor,
    persistent,
    properties,
    _cpp_return,
    spmd,
    _cpp_switch,
    _cpp_try,
    _cpp_while,
    abs,
    _cpp_and,
    _cpp_char,
    eq,
    length,
    size,
    _cpp_xor,
    LAST
};
struct _cpp_bitor;
class logical;

using logicalPtr = ::std::shared_ptr<logical>;
class _cpp_xor;

using xorPtr = ::std::shared_ptr<_cpp_xor>;

using parfor = ::std::vector<_cpp_bitor>;

using _cpp_switch = ::std::map<::std::int32_t, _cpp_bitor>;
class _cpp_try;

using tryPtr = ::std::shared_ptr<_cpp_try>;
class properties;

using propertiesPtr = ::std::shared_ptr<properties>;
class elseifPrx;

using elseifPrxPtr = ::std::optional<elseifPrx>;

constexpr ::std::int32_t methods = 1;

}

}

namespace classdef
{

namespace _cpp_break
{

class elseifPrx : public ::Ice::Proxy<elseifPrx, ::Ice::ObjectPrx>
{
public:

    void events(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> eventsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    eventsAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_events(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    void function(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> functionAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    functionAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_function(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    void _cpp_delete(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> deleteAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    deleteAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_delete(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    void checkedCast(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> checkedCastAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    checkedCastAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_checkedCast(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    explicit elseifPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    elseifPrx(const elseifPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    elseifPrx(elseifPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    elseifPrx(const ::std::shared_ptr<::Ice::Communicator>& communicator, std::string_view proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    elseifPrx& operator=(const elseifPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    elseifPrx& operator=(elseifPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static elseifPrx _fromReference(::IceInternal::ReferencePtr ref) { return elseifPrx(::std::move(ref)); }

protected:

    elseifPrx() = default;

    explicit elseifPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond
};

}

}

namespace classdef
{

namespace _cpp_break
{

struct _cpp_bitor
{
    ::classdef::_cpp_break::_cpp_bitand _cpp_case = ::classdef::_cpp_break::_cpp_bitand::_cpp_catch;
    ::std::int32_t _cpp_continue = 1;
    ::std::int32_t eq = 2;
    ::std::int32_t ne = 3;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::classdef::_cpp_break::_cpp_bitand&, const ::std::int32_t&, const ::std::int32_t&, const ::std::int32_t&> ice_tuple() const
    {
        return std::tie(_cpp_case, _cpp_continue, eq, ne);
    }
};

class logical : public ::Ice::ValueHelper<logical, ::Ice::Value>
{
public:

    logical() = default;
    logical(const logical&) = default;
    logical(logical&&) = default;
    logical& operator=(const logical&) = default;
    logical& operator=(logical&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    logical(::classdef::_cpp_break::_cpp_bitand _cpp_else, ::classdef::_cpp_break::_cpp_bitor _cpp_for, bool int64) :
        _cpp_else(_cpp_else),
        _cpp_for(::std::move(_cpp_for)),
        int64(int64)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::classdef::_cpp_break::_cpp_bitand&, const ::classdef::_cpp_break::_cpp_bitor&, const bool&> ice_tuple() const
    {
        return std::tie(_cpp_else, _cpp_for, int64);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::classdef::_cpp_break::_cpp_bitand _cpp_else = ::classdef::_cpp_break::_cpp_bitand::enumeration;
    ::classdef::_cpp_break::_cpp_bitor _cpp_for;
    bool int64 = true;
};

/// \cond INTERNAL
static logical _iceS_logical_init;
/// \endcond

class _cpp_xor : public ::Ice::ValueHelper<_cpp_xor, logical>
{
public:

    _cpp_xor() = default;
    _cpp_xor(const _cpp_xor&) = default;
    _cpp_xor(_cpp_xor&&) = default;
    _cpp_xor& operator=(const _cpp_xor&) = default;
    _cpp_xor& operator=(_cpp_xor&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    _cpp_xor(::classdef::_cpp_break::_cpp_bitand _cpp_else, ::classdef::_cpp_break::_cpp_bitor _cpp_for, bool int64, ::std::int32_t _cpp_return) :
        Ice::ValueHelper<_cpp_xor, logical>(_cpp_else, ::std::move(_cpp_for), int64),
        _cpp_return(_cpp_return)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::classdef::_cpp_break::_cpp_bitand&, const ::classdef::_cpp_break::_cpp_bitor&, const bool&, const ::std::int32_t&> ice_tuple() const
    {
        return std::tie(_cpp_else, _cpp_for, int64, _cpp_return);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::int32_t _cpp_return = 1;
};

class _cpp_try : public ::Ice::ValueHelper<_cpp_try, ::Ice::Value>
{
public:

    _cpp_try() = default;
    _cpp_try(const _cpp_try&) = default;
    _cpp_try(_cpp_try&&) = default;
    _cpp_try& operator=(const _cpp_try&) = default;
    _cpp_try& operator=(_cpp_try&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    _cpp_try(::std::int32_t _cpp_while, ::std::int32_t _cpp_delete) :
        _cpp_while(_cpp_while),
        _cpp_delete(_cpp_delete)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::int32_t&> ice_tuple() const
    {
        return std::tie(_cpp_while, _cpp_delete);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::int32_t _cpp_while = 1;
    ::std::int32_t _cpp_delete = 2;
};

class properties : public ::Ice::ValueHelper<properties, _cpp_try>
{
public:

    properties() = default;
    properties(const properties&) = default;
    properties(properties&&) = default;
    properties& operator=(const properties&) = default;
    properties& operator=(properties&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    properties(::std::int32_t _cpp_while, ::std::int32_t _cpp_delete, ::std::int32_t _cpp_if, ::std::shared_ptr<::classdef::break::xor> _cpp_catch, ::classdef::_cpp_break::parfor spmd, ::classdef::_cpp_break::_cpp_switch otherwise) :
        Ice::ValueHelper<properties, _cpp_try>(_cpp_while, _cpp_delete),
        _cpp_if(_cpp_if),
        _cpp_catch(::std::move(_cpp_catch)),
        spmd(::std::move(spmd)),
        otherwise(::std::move(otherwise))
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::int32_t&, const ::std::int32_t&, const ::std::shared_ptr<::classdef::break::xor>&, const ::classdef::_cpp_break::parfor&, const ::classdef::_cpp_break::_cpp_switch&> ice_tuple() const
    {
        return std::tie(_cpp_while, _cpp_delete, _cpp_if, _cpp_catch, spmd, otherwise);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::int32_t _cpp_if = 2;
    ::std::shared_ptr<::classdef::break::xor> _cpp_catch;
    ::classdef::_cpp_break::parfor spmd;
    ::classdef::_cpp_break::_cpp_switch otherwise;
};

class persistent : public ::Ice::UserExceptionHelper<persistent, ::Ice::UserException>
{
public:

    persistent() noexcept = default;

    persistent(const persistent&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    persistent(::std::string identifier, ::std::string message, ::std::string stack, ::std::string cause, ::std::string type, ::std::shared_ptr<::classdef::break::logical> end) noexcept :
        identifier(::std::move(identifier)),
        message(::std::move(message)),
        stack(::std::move(stack)),
        cause(::std::move(cause)),
        type(::std::move(type)),
        end(::std::move(end))
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::shared_ptr<::classdef::break::logical>&> ice_tuple() const
    {
        return std::tie(identifier, message, stack, cause, type, end);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    /// \cond STREAM
    virtual bool _usesClasses() const override;
    /// \endcond

    ::std::string identifier = "1";
    ::std::string message = "2";
    ::std::string stack = "3";
    ::std::string cause = "4";
    ::std::string type = "5";
    ::std::shared_ptr<::classdef::break::logical> end;
};

class global : public ::Ice::UserExceptionHelper<global, persistent>
{
public:

    global() noexcept = default;

    global(const global&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    global(::std::string identifier, ::std::string message, ::std::string stack, ::std::string cause, ::std::string type, ::std::shared_ptr<::classdef::break::logical> end, ::std::int32_t enumeration) noexcept :
        ::Ice::UserExceptionHelper<global, persistent>(::std::move(identifier), ::std::move(message), ::std::move(stack), ::std::move(cause), ::std::move(type), ::std::move(end)),
        enumeration(enumeration)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::shared_ptr<::classdef::break::logical>&, const ::std::int32_t&> ice_tuple() const
    {
        return std::tie(identifier, message, stack, cause, type, end, enumeration);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::int32_t enumeration = 1;
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace classdef
{

namespace _cpp_break
{

class elseif : public virtual ::Ice::Object
{
public:

    using ProxyType = elseifPrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    virtual void events(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_events(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void function(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_function(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void _cpp_delete(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_delete(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void checkedCast(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_checkedCast(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /// \cond INTERNAL
    void dispatch(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>) override;
    /// \endcond
};

using elseifPtr = ::std::shared_ptr<elseif>;

}

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::classdef::_cpp_break::_cpp_bitand>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 31;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::classdef::_cpp_break::_cpp_bitor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 13;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::classdef::_cpp_break::_cpp_bitor, S>
{
    static void read(S* istr, ::classdef::_cpp_break::_cpp_bitor& v)
    {
        istr->readAll(v._cpp_case, v._cpp_continue, v.eq, v.ne);
    }
};

template<typename S>
struct StreamReader<::classdef::_cpp_break::logical, S>
{
    static void read(S* istr, ::classdef::_cpp_break::logical& v)
    {
        istr->readAll(v._cpp_else, v._cpp_for, v.int64);
    }
};

template<typename S>
struct StreamWriter<::classdef::_cpp_break::_cpp_xor, S>
{
    static void write(S* ostr, const ::classdef::_cpp_break::_cpp_xor& v)
    {
        ostr->writeAll(v._cpp_return);
    }
};

template<typename S>
struct StreamReader<::classdef::_cpp_break::_cpp_xor, S>
{
    static void read(S* istr, ::classdef::_cpp_break::_cpp_xor& v)
    {
        istr->readAll(v._cpp_return);
    }
};

template<typename S>
struct StreamReader<::classdef::_cpp_break::_cpp_try, S>
{
    static void read(S* istr, ::classdef::_cpp_break::_cpp_try& v)
    {
        istr->readAll(v._cpp_while, v._cpp_delete);
    }
};

template<typename S>
struct StreamWriter<::classdef::_cpp_break::properties, S>
{
    static void write(S* ostr, const ::classdef::_cpp_break::properties& v)
    {
        ostr->writeAll(v._cpp_if, v._cpp_catch, v.spmd, v.otherwise);
    }
};

template<typename S>
struct StreamReader<::classdef::_cpp_break::properties, S>
{
    static void read(S* istr, ::classdef::_cpp_break::properties& v)
    {
        istr->readAll(v._cpp_if, v._cpp_catch, v.spmd, v.otherwise);
    }
};

template<typename S>
struct StreamReader<::classdef::_cpp_break::persistent, S>
{
    static void read(S* istr, ::classdef::_cpp_break::persistent& v)
    {
        istr->readAll(v.identifier, v.message, v.stack, v.cause, v.type, v.end);
    }
};

template<typename S>
struct StreamWriter<::classdef::_cpp_break::global, S>
{
    static void write(S* ostr, const ::classdef::_cpp_break::global& v)
    {
        ostr->writeAll(v.enumeration);
    }
};

template<typename S>
struct StreamReader<::classdef::_cpp_break::global, S>
{
    static void read(S* istr, ::classdef::_cpp_break::global& v)
    {
        istr->readAll(v.enumeration);
    }
};

}
/// \endcond

#include <IceUtil/PopDisableWarnings.h>
#endif
