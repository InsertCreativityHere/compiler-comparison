//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Test_h__
#define __Test_h__

#include <Ice/PushDisableWarnings.h>
#include <Ice/Ice.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace classdef
{

    namespace _cpp_break
    {
        enum class _cpp_bitand : ::std::uint8_t
        {
            _cpp_break,
            _cpp_case,
            _cpp_catch,
            classdef,
            _cpp_continue,
            _cpp_else,
            elseif,
            end,
            enumeration,
            events,
            _cpp_for,
            function,
            global,
            _cpp_if,
            methods,
            otherwise,
            parfor,
            persistent,
            properties,
            _cpp_return,
            spmd,
            _cpp_switch,
            _cpp_try,
            _cpp_while,
            abs,
            _cpp_and,
            _cpp_char,
            eq,
            length,
            size,
            _cpp_xor,
            LAST
        };

        struct _cpp_bitor;

        class logical;
        using logicalPtr = ::std::shared_ptr<logical>;

        class _cpp_xor;
        using xorPtr = ::std::shared_ptr<_cpp_xor>;

        using parfor = ::std::vector<_cpp_bitor>;

        using _cpp_switch = ::std::map<::std::int32_t, _cpp_bitor>;

        class _cpp_try;
        using tryPtr = ::std::shared_ptr<_cpp_try>;

        class properties;
        using propertiesPtr = ::std::shared_ptr<properties>;

        class elseifPrx;

        constexpr ::std::int32_t methods = 1;

    }
}

namespace classdef
{

namespace _cpp_break
{

class elseifPrx : public ::Ice::Proxy<elseifPrx, ::Ice::ObjectPrx>
{
public:

    void events(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<void> eventsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    eventsAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_events(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    void function(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<void> functionAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    functionAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_function(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    void _cpp_delete(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<void> deleteAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    deleteAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_delete(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    void checkedCast(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<void> checkedCastAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    checkedCastAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_checkedCast(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;
    elseifPrx(const elseifPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    elseifPrx(elseifPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    elseifPrx(const ::Ice::CommunicatorPtr& communicator, std::string_view proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    elseifPrx& operator=(const elseifPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    elseifPrx& operator=(elseifPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static elseifPrx _fromReference(::IceInternal::ReferencePtr ref) { return elseifPrx(::std::move(ref)); }

protected:

    elseifPrx() = default;

    explicit elseifPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond
};

}

}

namespace classdef
{

namespace _cpp_break
{

struct _cpp_bitor
{
    ::classdef::_cpp_break::_cpp_bitand _cpp_case = ::classdef::_cpp_break::_cpp_bitand::_cpp_catch;
    ::std::int32_t _cpp_continue = 1;
    ::std::int32_t eq = 2;
    ::std::int32_t ne = 3;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::classdef::_cpp_break::_cpp_bitand&, const ::std::int32_t&, const ::std::int32_t&, const ::std::int32_t&> ice_tuple() const
    {
        return std::tie(_cpp_case, _cpp_continue, eq, ne);
    }
};

class logical : public ::Ice::Value
{
public:
    /**
     * Default constructor.
     */
    logical() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    logical(::classdef::_cpp_break::_cpp_bitand _cpp_else, ::classdef::_cpp_break::_cpp_bitor _cpp_for, bool int64) noexcept :
        _cpp_else(_cpp_else),
        _cpp_for(::std::move(_cpp_for)),
        int64(int64)
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::classdef::_cpp_break::_cpp_bitand&, const ::classdef::_cpp_break::_cpp_bitor&, const bool&> ice_tuple() const
    {
        return std::tie(_cpp_else, _cpp_for, int64);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    logicalPtr ice_clone() const { return ::std::static_pointer_cast<logical>(_iceCloneImpl()); }

    ::classdef::_cpp_break::_cpp_bitand _cpp_else = ::classdef::_cpp_break::_cpp_bitand::enumeration;
    ::classdef::_cpp_break::_cpp_bitor _cpp_for;
    bool int64 = true;

protected:
    logical(const logical&) = default;

    ::Ice::ValuePtr _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class _cpp_xor : public logical
{
public:
    /**
     * Default constructor.
     */
    _cpp_xor() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    _cpp_xor(::classdef::_cpp_break::_cpp_bitand _cpp_else, ::classdef::_cpp_break::_cpp_bitor _cpp_for, bool int64, ::std::int32_t _cpp_return) noexcept :
        logical(_cpp_else, ::std::move(_cpp_for), int64),
        _cpp_return(_cpp_return)
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::classdef::_cpp_break::_cpp_bitand&, const ::classdef::_cpp_break::_cpp_bitor&, const bool&, const ::std::int32_t&> ice_tuple() const
    {
        return std::tie(_cpp_else, _cpp_for, int64, _cpp_return);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    xorPtr ice_clone() const { return ::std::static_pointer_cast<_cpp_xor>(_iceCloneImpl()); }

    ::std::int32_t _cpp_return = 1;

protected:
    _cpp_xor(const _cpp_xor&) = default;

    ::Ice::ValuePtr _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class _cpp_try : public ::Ice::Value
{
public:
    /**
     * Default constructor.
     */
    _cpp_try() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    _cpp_try(::std::int32_t _cpp_while, ::std::int32_t _cpp_delete) noexcept :
        _cpp_while(_cpp_while),
        _cpp_delete(_cpp_delete)
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::int32_t&> ice_tuple() const
    {
        return std::tie(_cpp_while, _cpp_delete);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    tryPtr ice_clone() const { return ::std::static_pointer_cast<_cpp_try>(_iceCloneImpl()); }

    ::std::int32_t _cpp_while = 1;
    ::std::int32_t _cpp_delete = 2;

protected:
    _cpp_try(const _cpp_try&) = default;

    ::Ice::ValuePtr _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class properties : public _cpp_try
{
public:
    /**
     * Default constructor.
     */
    properties() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    properties(::std::int32_t _cpp_while, ::std::int32_t _cpp_delete, ::std::int32_t _cpp_if, ::classdef::_cpp_break::xorPtr _cpp_catch, ::classdef::_cpp_break::parfor spmd, ::classdef::_cpp_break::_cpp_switch otherwise) noexcept :
        _cpp_try(_cpp_while, _cpp_delete),
        _cpp_if(_cpp_if),
        _cpp_catch(::std::move(_cpp_catch)),
        spmd(::std::move(spmd)),
        otherwise(::std::move(otherwise))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::int32_t&, const ::std::int32_t&, const ::classdef::_cpp_break::xorPtr&, const ::classdef::_cpp_break::parfor&, const ::classdef::_cpp_break::_cpp_switch&> ice_tuple() const
    {
        return std::tie(_cpp_while, _cpp_delete, _cpp_if, _cpp_catch, spmd, otherwise);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    propertiesPtr ice_clone() const { return ::std::static_pointer_cast<properties>(_iceCloneImpl()); }

    ::std::int32_t _cpp_if = 2;
    ::classdef::_cpp_break::xorPtr _cpp_catch;
    ::classdef::_cpp_break::parfor spmd;
    ::classdef::_cpp_break::_cpp_switch otherwise;

protected:
    properties(const properties&) = default;

    ::Ice::ValuePtr _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class persistent : public ::Ice::UserException
{
public:
    /**
     * Default constructor.
     */
    persistent() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    persistent(::std::string identifier, ::std::string message, ::std::string stack, ::std::string cause, ::std::string type, logicalPtr end) noexcept :
        identifier(::std::move(identifier)),
        message(::std::move(message)),
        stack(::std::move(stack)),
        cause(::std::move(cause)),
        type(::std::move(type)),
        end(::std::move(end))
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::classdef::_cpp_break::logicalPtr&> ice_tuple() const
    {
        return std::tie(identifier, message, stack, cause, type, end);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    void ice_throw() const override;

    /// \cond STREAM
    bool _usesClasses() const override;
    /// \endcond

    ::std::string identifier = "1";
    ::std::string message = "2";
    ::std::string stack = "3";
    ::std::string cause = "4";
    ::std::string type = "5";
    ::classdef::_cpp_break::logicalPtr end;

protected:
    void _writeImpl(::Ice::OutputStream*) const override;

    void _readImpl(::Ice::InputStream*) override;
};

class global : public persistent
{
public:
    /**
     * Default constructor.
     */
    global() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    global(::std::string identifier, ::std::string message, ::std::string stack, ::std::string cause, ::std::string type, logicalPtr end, ::std::int32_t enumeration) noexcept :
        persistent(::std::move(identifier), ::std::move(message), ::std::move(stack), ::std::move(cause), ::std::move(type), ::std::move(end)),
        enumeration(enumeration)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::classdef::_cpp_break::logicalPtr&, const ::std::int32_t&> ice_tuple() const
    {
        return std::tie(identifier, message, stack, cause, type, end, enumeration);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    void ice_throw() const override;

    ::std::int32_t enumeration = 1;

protected:
    void _writeImpl(::Ice::OutputStream*) const override;

    void _readImpl(::Ice::InputStream*) override;
};

using Ice::Tuple::operator<;
using Ice::Tuple::operator<=;
using Ice::Tuple::operator>;
using Ice::Tuple::operator>=;
using Ice::Tuple::operator==;
using Ice::Tuple::operator!=;

}

using Ice::Tuple::operator<;
using Ice::Tuple::operator<=;
using Ice::Tuple::operator>;
using Ice::Tuple::operator>=;
using Ice::Tuple::operator==;
using Ice::Tuple::operator!=;

}

namespace classdef
{

namespace _cpp_break
{

class elseif : public virtual ::Ice::Object
{
public:

    using ProxyType = elseifPrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    virtual void events(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_events(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void function(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_function(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void _cpp_delete(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_delete(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void checkedCast(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_checkedCast(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /// \cond INTERNAL
    void dispatch(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>) override;
    /// \endcond
};

using elseifPtr = ::std::shared_ptr<elseif>;

}

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::classdef::_cpp_break::_cpp_bitand>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 31;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::classdef::_cpp_break::_cpp_bitor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 13;
    static const bool fixedLength = false;
};

template<>
struct StreamReader<::classdef::_cpp_break::_cpp_bitor>
{
    static void read(InputStream* istr, ::classdef::_cpp_break::_cpp_bitor& v)
    {
        istr->readAll(v._cpp_case, v._cpp_continue, v.eq, v.ne);
    }
};

}
/// \endcond

#include <Ice/PopDisableWarnings.h>
#endif
