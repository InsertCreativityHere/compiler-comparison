//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Test_h__
#define __Test_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <Ice/ExceptionHelpers.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace classdef
{


namespace _cpp_break
{

class logical;
class _cpp_xor;
class _cpp_try;
class properties;
class elseif;
class elseifPrx;

}

}

namespace classdef
{

namespace _cpp_break
{

enum class _cpp_bitand : unsigned char
{
    _cpp_break,
    _cpp_case,
    _cpp_catch,
    classdef,
    _cpp_continue,
    _cpp_else,
    elseif,
    end,
    enumeration,
    events,
    _cpp_for,
    function,
    global,
    _cpp_if,
    methods,
    otherwise,
    parfor,
    persistent,
    properties,
    _cpp_return,
    spmd,
    _cpp_switch,
    _cpp_try,
    _cpp_while,
    abs,
    _cpp_and,
    _cpp_char,
    eq,
    length,
    size,
    _cpp_xor,
    LAST
};

struct _cpp_bitor
{
    ::classdef::_cpp_break::_cpp_bitand _cpp_case = ::classdef::_cpp_break::_cpp_bitand::_cpp_catch;
    int _cpp_continue = 1;
    int eq = 2;
    int ne = 3;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::classdef::_cpp_break::_cpp_bitand&, const int&, const int&, const int&> ice_tuple() const
    {
        return std::tie(_cpp_case, _cpp_continue, eq, ne);
    }
};

using parfor = ::std::vector<_cpp_bitor>;

using _cpp_switch = ::std::map<int, _cpp_bitor>;

class persistent : public ::Ice::UserExceptionHelper<persistent, ::Ice::UserException>
{
public:

    virtual ~persistent();

    persistent(const persistent&) = default;

    persistent() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    persistent(const ::std::string& identifier, const ::std::string& message, const ::std::string& stack, const ::std::string& cause, const ::std::string& type, const ::std::shared_ptr<logical>& end) :
        identifier(identifier),
        message(message),
        stack(stack),
        cause(cause),
        type(type),
        end(end)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::shared_ptr<::classdef::break::logical>&> ice_tuple() const
    {
        return std::tie(identifier, message, stack, cause, type, end);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /// \cond STREAM
    virtual bool _usesClasses() const override;
    /// \endcond

    ::std::string identifier = "1";
    ::std::string message = "2";
    ::std::string stack = "3";
    ::std::string cause = "4";
    ::std::string type = "5";
    ::std::shared_ptr<::classdef::break::logical> end;
};

/// \cond INTERNAL
static persistent _iceS_persistent_init;
/// \endcond

class global : public ::Ice::UserExceptionHelper<global, persistent>
{
public:

    virtual ~global();

    global(const global&) = default;

    global() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    global(const ::std::string& identifier, const ::std::string& message, const ::std::string& stack, const ::std::string& cause, const ::std::string& type, const ::std::shared_ptr<logical>& end, int enumeration) :
        ::Ice::UserExceptionHelper<global, persistent>(identifier, message, stack, cause, type, end),
        enumeration(enumeration)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::shared_ptr<::classdef::break::logical>&, const int&> ice_tuple() const
    {
        return std::tie(identifier, message, stack, cause, type, end, enumeration);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int enumeration = 1;
};

constexpr int methods = 1;

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace classdef
{

namespace _cpp_break
{

class elseif : public virtual ::Ice::Object
{
public:

    using ProxyType = elseifPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void events(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_events(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void function(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_function(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void _cpp_delete(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_delete(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void checkedCast(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_checkedCast(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

}

namespace classdef
{

namespace _cpp_break
{

class logical : public ::Ice::ValueHelper<logical, ::Ice::Value>
{
public:

    virtual ~logical();

    logical() = default;

    logical(const logical&) = default;
    logical(logical&&) = default;
    logical& operator=(const logical&) = default;
    logical& operator=(logical&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    logical(::classdef::_cpp_break::_cpp_bitand _cpp_else, const ::classdef::_cpp_break::_cpp_bitor& _cpp_for, bool int64) :
        _cpp_else(_cpp_else),
        _cpp_for(_cpp_for),
        int64(int64)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::classdef::_cpp_break::_cpp_bitand&, const ::classdef::_cpp_break::_cpp_bitor&, const bool&> ice_tuple() const
    {
        return std::tie(_cpp_else, _cpp_for, int64);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::classdef::_cpp_break::_cpp_bitand _cpp_else = ::classdef::_cpp_break::_cpp_bitand::enumeration;
    ::classdef::_cpp_break::_cpp_bitor _cpp_for;
    bool int64 = true;
};

/// \cond INTERNAL
static logical _iceS_logical_init;
/// \endcond

class _cpp_xor : public ::Ice::ValueHelper<_cpp_xor, logical>
{
public:

    virtual ~_cpp_xor();

    _cpp_xor() = default;

    _cpp_xor(const _cpp_xor&) = default;
    _cpp_xor(_cpp_xor&&) = default;
    _cpp_xor& operator=(const _cpp_xor&) = default;
    _cpp_xor& operator=(_cpp_xor&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    _cpp_xor(::classdef::_cpp_break::_cpp_bitand _cpp_else, const ::classdef::_cpp_break::_cpp_bitor& _cpp_for, bool int64, int _cpp_return) :
        Ice::ValueHelper<_cpp_xor, logical>(_cpp_else, _cpp_for, int64),
        _cpp_return(_cpp_return)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::classdef::_cpp_break::_cpp_bitand&, const ::classdef::_cpp_break::_cpp_bitor&, const bool&, const int&> ice_tuple() const
    {
        return std::tie(_cpp_else, _cpp_for, int64, _cpp_return);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int _cpp_return = 1;
};

class _cpp_try : public ::Ice::ValueHelper<_cpp_try, ::Ice::Value>
{
public:

    virtual ~_cpp_try();

    _cpp_try() = default;

    _cpp_try(const _cpp_try&) = default;
    _cpp_try(_cpp_try&&) = default;
    _cpp_try& operator=(const _cpp_try&) = default;
    _cpp_try& operator=(_cpp_try&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    _cpp_try(int _cpp_while, int _cpp_delete) :
        _cpp_while(_cpp_while),
        _cpp_delete(_cpp_delete)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&> ice_tuple() const
    {
        return std::tie(_cpp_while, _cpp_delete);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int _cpp_while = 1;
    int _cpp_delete = 2;
};

class properties : public ::Ice::ValueHelper<properties, _cpp_try>
{
public:

    virtual ~properties();

    properties() = default;

    properties(const properties&) = default;
    properties(properties&&) = default;
    properties& operator=(const properties&) = default;
    properties& operator=(properties&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    properties(int _cpp_while, int _cpp_delete, int _cpp_if, const ::std::shared_ptr<::classdef::_cpp_break::_cpp_xor>& _cpp_catch, const ::classdef::_cpp_break::parfor& spmd, const ::classdef::_cpp_break::_cpp_switch& otherwise) :
        Ice::ValueHelper<properties, _cpp_try>(_cpp_while, _cpp_delete),
        _cpp_if(_cpp_if),
        _cpp_catch(_cpp_catch),
        spmd(spmd),
        otherwise(otherwise)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&, const int&, const ::std::shared_ptr<::classdef::break::xor>&, const ::classdef::_cpp_break::parfor&, const ::classdef::_cpp_break::_cpp_switch&> ice_tuple() const
    {
        return std::tie(_cpp_while, _cpp_delete, _cpp_if, _cpp_catch, spmd, otherwise);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int _cpp_if = 2;
    ::std::shared_ptr<::classdef::break::xor> _cpp_catch;
    ::classdef::_cpp_break::parfor spmd;
    ::classdef::_cpp_break::_cpp_switch otherwise;
};

}

}

namespace classdef
{

namespace _cpp_break
{

class elseifPrx : public virtual ::Ice::Proxy<elseifPrx, ::Ice::ObjectPrx>
{
public:

    void events(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &elseifPrx::_iceI_events, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto eventsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &elseifPrx::_iceI_events, context);
    }

    ::std::function<void()>
    eventsAsync(::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &classdef::_cpp_break::elseifPrx::_iceI_events, context);
    }

    /// \cond INTERNAL
    void _iceI_events(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void function(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &elseifPrx::_iceI_function, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto functionAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &elseifPrx::_iceI_function, context);
    }

    ::std::function<void()>
    functionAsync(::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &classdef::_cpp_break::elseifPrx::_iceI_function, context);
    }

    /// \cond INTERNAL
    void _iceI_function(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void _cpp_delete(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &elseifPrx::_iceI_delete, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto deleteAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &elseifPrx::_iceI_delete, context);
    }

    ::std::function<void()>
    deleteAsync(::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &classdef::_cpp_break::elseifPrx::_iceI_delete, context);
    }

    /// \cond INTERNAL
    void _iceI_delete(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void checkedCast(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &elseifPrx::_iceI_checkedCast, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto checkedCastAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &elseifPrx::_iceI_checkedCast, context);
    }

    ::std::function<void()>
    checkedCastAsync(::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &classdef::_cpp_break::elseifPrx::_iceI_checkedCast, context);
    }

    /// \cond INTERNAL
    void _iceI_checkedCast(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    elseifPrx() = default;
    friend ::std::shared_ptr<elseifPrx> IceInternal::createProxy<elseifPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::classdef::_cpp_break::_cpp_bitand>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 31;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::classdef::_cpp_break::_cpp_bitor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 13;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::classdef::_cpp_break::_cpp_bitor, S>
{
    static void read(S* istr, ::classdef::_cpp_break::_cpp_bitor& v)
    {
        istr->readAll(v._cpp_case, v._cpp_continue, v.eq, v.ne);
    }
};

template<typename S>
struct StreamReader<::classdef::_cpp_break::logical, S>
{
    static void read(S* istr, ::classdef::_cpp_break::logical& v)
    {
        istr->readAll(v._cpp_else, v._cpp_for, v.int64);
    }
};

template<typename S>
struct StreamWriter<::classdef::_cpp_break::_cpp_xor, S>
{
    static void write(S* ostr, const ::classdef::_cpp_break::_cpp_xor& v)
    {
        ostr->writeAll(v._cpp_return);
    }
};

template<typename S>
struct StreamReader<::classdef::_cpp_break::_cpp_xor, S>
{
    static void read(S* istr, ::classdef::_cpp_break::_cpp_xor& v)
    {
        istr->readAll(v._cpp_return);
    }
};

template<typename S>
struct StreamReader<::classdef::_cpp_break::_cpp_try, S>
{
    static void read(S* istr, ::classdef::_cpp_break::_cpp_try& v)
    {
        istr->readAll(v._cpp_while, v._cpp_delete);
    }
};

template<typename S>
struct StreamWriter<::classdef::_cpp_break::properties, S>
{
    static void write(S* ostr, const ::classdef::_cpp_break::properties& v)
    {
        ostr->writeAll(v._cpp_if, v._cpp_catch, v.spmd, v.otherwise);
    }
};

template<typename S>
struct StreamReader<::classdef::_cpp_break::properties, S>
{
    static void read(S* istr, ::classdef::_cpp_break::properties& v)
    {
        istr->readAll(v._cpp_if, v._cpp_catch, v.spmd, v.otherwise);
    }
};

template<typename S>
struct StreamReader<::classdef::_cpp_break::persistent, S>
{
    static void read(S* istr, ::classdef::_cpp_break::persistent& v)
    {
        istr->readAll(v.identifier, v.message, v.stack, v.cause, v.type, v.end);
    }
};

template<typename S>
struct StreamWriter<::classdef::_cpp_break::global, S>
{
    static void write(S* ostr, const ::classdef::_cpp_break::global& v)
    {
        ostr->writeAll(v.enumeration);
    }
};

template<typename S>
struct StreamReader<::classdef::_cpp_break::global, S>
{
    static void read(S* istr, ::classdef::_cpp_break::global& v)
    {
        istr->readAll(v.enumeration);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace classdef
{

/// \cond INTERNAL
namespace _cpp_break
{

using logicalPtr = ::std::shared_ptr<logical>;

using xorPtr = ::std::shared_ptr<_cpp_xor>;

using tryPtr = ::std::shared_ptr<_cpp_try>;

using propertiesPtr = ::std::shared_ptr<properties>;

using elseifPtr = ::std::shared_ptr<elseif>;
using elseifPrxPtr = ::std::shared_ptr<elseifPrx>;

}
/// \endcond

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace classdef
{

namespace _cpp_break
{

class logical;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< logical>&);
::IceProxy::Ice::Object* upCast(logical*);
/// \endcond

class _cpp_xor;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< _cpp_xor>&);
::IceProxy::Ice::Object* upCast(_cpp_xor*);
/// \endcond

class _cpp_try;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< _cpp_try>&);
::IceProxy::Ice::Object* upCast(_cpp_try*);
/// \endcond

class properties;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< properties>&);
::IceProxy::Ice::Object* upCast(properties*);
/// \endcond

class elseif;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< elseif>&);
::IceProxy::Ice::Object* upCast(elseif*);
/// \endcond

}

}

}

namespace classdef
{

namespace _cpp_break
{

class logical;
/// \cond INTERNAL
::Ice::Object* upCast(logical*);
/// \endcond
typedef ::IceInternal::Handle< logical> logicalPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::classdef::_cpp_break::logical> logicalPrx;
typedef logicalPrx logicalPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(logicalPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class _cpp_xor;
/// \cond INTERNAL
::Ice::Object* upCast(_cpp_xor*);
/// \endcond
typedef ::IceInternal::Handle< _cpp_xor> xorPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::classdef::_cpp_break::_cpp_xor> xorPrx;
typedef xorPrx xorPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(xorPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class _cpp_try;
/// \cond INTERNAL
::Ice::Object* upCast(_cpp_try*);
/// \endcond
typedef ::IceInternal::Handle< _cpp_try> tryPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::classdef::_cpp_break::_cpp_try> tryPrx;
typedef tryPrx tryPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(tryPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class properties;
/// \cond INTERNAL
::Ice::Object* upCast(properties*);
/// \endcond
typedef ::IceInternal::Handle< properties> propertiesPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::classdef::_cpp_break::properties> propertiesPrx;
typedef propertiesPrx propertiesPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(propertiesPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class elseif;
/// \cond INTERNAL
::Ice::Object* upCast(elseif*);
/// \endcond
typedef ::IceInternal::Handle< elseif> elseifPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::classdef::_cpp_break::elseif> elseifPrx;
typedef elseifPrx elseifPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(elseifPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

}

namespace classdef
{

namespace _cpp_break
{

enum _cpp_bitand
{
    _cpp_break,
    _cpp_case,
    _cpp_catch,
    classdef,
    _cpp_continue,
    _cpp_else,
    elseif,
    end,
    enumeration,
    events,
    _cpp_for,
    function,
    global,
    _cpp_if,
    methods,
    otherwise,
    parfor,
    persistent,
    properties,
    _cpp_return,
    spmd,
    _cpp_switch,
    _cpp_try,
    _cpp_while,
    abs,
    _cpp_and,
    _cpp_char,
    eq,
    length,
    size,
    _cpp_xor,
    LAST
};

struct _cpp_bitor
{
    /** Default constructor that assigns default values to members as specified in the Slice definition. */
    _cpp_bitor() :
        _cpp_case(::classdef::_cpp_break::_cpp_catch),
        _cpp_continue(1),
        eq(2),
        ne(3)
    {
    }
    
    _cpp_bitor(_cpp_bitand _cpp_case, ::Ice::Int _cpp_continue, ::Ice::Int eq, ::Ice::Int ne) :
        _cpp_case(_cpp_case),
        _cpp_continue(_cpp_continue),
        eq(eq),
        ne(ne)
    {
    }
    

    ::classdef::_cpp_break::_cpp_bitand _cpp_case;
    ::Ice::Int _cpp_continue;
    ::Ice::Int eq;
    ::Ice::Int ne;

    bool operator==(const _cpp_bitor& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(_cpp_case != rhs_._cpp_case)
        {
            return false;
        }
        if(_cpp_continue != rhs_._cpp_continue)
        {
            return false;
        }
        if(eq != rhs_.eq)
        {
            return false;
        }
        if(ne != rhs_.ne)
        {
            return false;
        }
        return true;
    }

    bool operator<(const _cpp_bitor& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(_cpp_case < rhs_._cpp_case)
        {
            return true;
        }
        else if(rhs_._cpp_case < _cpp_case)
        {
            return false;
        }
        if(_cpp_continue < rhs_._cpp_continue)
        {
            return true;
        }
        else if(rhs_._cpp_continue < _cpp_continue)
        {
            return false;
        }
        if(eq < rhs_.eq)
        {
            return true;
        }
        else if(rhs_.eq < eq)
        {
            return false;
        }
        if(ne < rhs_.ne)
        {
            return true;
        }
        else if(rhs_.ne < ne)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const _cpp_bitor& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const _cpp_bitor& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const _cpp_bitor& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const _cpp_bitor& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<_cpp_bitor> parfor;

typedef ::std::map< ::Ice::Int, _cpp_bitor> _cpp_switch;

class persistent : public ::Ice::UserException
{
public:

    /** Default constructor that assigns default values to members as specified in the Slice definition. */
    persistent();
    /**
     * One-shot constructor to initialize all data members.
     */
    persistent(const ::std::string& identifier, const ::std::string& message, const ::std::string& stack, const ::std::string& cause, const ::std::string& type, const logicalPtr& end);

#ifdef ICE_CPP11_COMPILER
    persistent(const persistent&) = default;
    virtual ~persistent();
#else
    virtual ~persistent() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual persistent* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    /// \cond STREAM
    virtual bool _usesClasses() const;
    /// \endcond

    ::std::string identifier;
    ::std::string message;
    ::std::string stack;
    ::std::string cause;
    ::std::string type;
    ::classdef::break::logicalPtr end;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
static persistent _iceS_persistent_init;
/// \endcond

class global : public persistent
{
public:

    /** Default constructor that assigns default values to members as specified in the Slice definition. */
    global();
    /**
     * One-shot constructor to initialize all data members.
     */
    global(const ::std::string& identifier, const ::std::string& message, const ::std::string& stack, const ::std::string& cause, const ::std::string& type, const logicalPtr& end, ::Ice::Int enumeration);

#ifdef ICE_CPP11_COMPILER
    global(const global&) = default;
    virtual ~global();
#else
    virtual ~global() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual global* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::Ice::Int enumeration;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

const ::Ice::Int methods = 1;

}

}

namespace classdef
{

namespace _cpp_break
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::classdef::_cpp_break::elseif::begin_events.
 * Create a wrapper instance by calling ::classdef::_cpp_break::newCallback_elseif_events.
 */
class Callback_elseif_events_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_elseif_events_Base> Callback_elseif_eventsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::classdef::_cpp_break::elseif::begin_function.
 * Create a wrapper instance by calling ::classdef::_cpp_break::newCallback_elseif_function.
 */
class Callback_elseif_function_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_elseif_function_Base> Callback_elseif_functionPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::classdef::_cpp_break::elseif::begin_delete.
 * Create a wrapper instance by calling ::classdef::_cpp_break::newCallback_elseif_delete.
 */
class Callback_elseif_delete_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_elseif_delete_Base> Callback_elseif_deletePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::classdef::_cpp_break::elseif::begin_checkedCast.
 * Create a wrapper instance by calling ::classdef::_cpp_break::newCallback_elseif_checkedCast.
 */
class Callback_elseif_checkedCast_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_elseif_checkedCast_Base> Callback_elseif_checkedCastPtr;

}

}

namespace IceProxy
{

namespace classdef
{

namespace _cpp_break
{

class logical : public virtual ::Ice::Proxy<logical, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class _cpp_xor : public virtual ::Ice::Proxy<_cpp_xor, ::IceProxy::classdef::_cpp_break::logical>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class _cpp_try : public virtual ::Ice::Proxy<_cpp_try, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class properties : public virtual ::Ice::Proxy<properties, ::IceProxy::classdef::_cpp_break::_cpp_try>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class elseif : public virtual ::Ice::Proxy<elseif, ::IceProxy::Ice::Object>
{
public:

    void events(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_events(_iceI_begin_events(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_events(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_events(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_events(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_events(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_events(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_events(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_events(const ::classdef::_cpp_break::Callback_elseif_eventsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_events(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_events(const ::Ice::Context& context, const ::classdef::_cpp_break::Callback_elseif_eventsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_events(context, cb, cookie);
    }

    void end_events(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_events(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void function(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_function(_iceI_begin_function(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_function(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_function(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_function(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_function(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_function(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_function(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_function(const ::classdef::_cpp_break::Callback_elseif_functionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_function(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_function(const ::Ice::Context& context, const ::classdef::_cpp_break::Callback_elseif_functionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_function(context, cb, cookie);
    }

    void end_function(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_function(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void _cpp_delete(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_delete(_iceI_begin_delete(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_delete(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_delete(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_delete(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_delete(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_delete(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_delete(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_delete(const ::classdef::_cpp_break::Callback_elseif_deletePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_delete(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_delete(const ::Ice::Context& context, const ::classdef::_cpp_break::Callback_elseif_deletePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_delete(context, cb, cookie);
    }

    void end_delete(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_delete(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void checkedCast(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_checkedCast(_iceI_begin_checkedCast(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_checkedCast(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_checkedCast(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_checkedCast(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_checkedCast(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_checkedCast(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_checkedCast(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_checkedCast(const ::classdef::_cpp_break::Callback_elseif_checkedCastPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_checkedCast(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_checkedCast(const ::Ice::Context& context, const ::classdef::_cpp_break::Callback_elseif_checkedCastPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_checkedCast(context, cb, cookie);
    }

    void end_checkedCast(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_checkedCast(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

}

namespace classdef
{

namespace _cpp_break
{

class logical : public virtual ::Ice::Object
{
public:

    typedef logicalPrx ProxyType;
    typedef logicalPtr PointerType;

    virtual ~logical();

    /** Default constructor that assigns default values to members as specified in the Slice definition. */
    logical() :
        _cpp_else(::classdef::_cpp_break::enumeration),
        int64(true)
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    logical(::classdef::_cpp_break::_cpp_bitand _cpp_else, const ::classdef::_cpp_break::_cpp_bitor& _cpp_for, bool int64) :
        _cpp_else(_cpp_else),
        _cpp_for(_cpp_for),
        int64(int64)
    {
    }

#ifdef ICE_CPP11_COMPILER
    logical(const logical&) = default;
    logical& operator=(const logical&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::classdef::_cpp_break::_cpp_bitand _cpp_else;
    ::classdef::_cpp_break::_cpp_bitor _cpp_for;
    bool int64;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_logical_init = ::classdef::_cpp_break::logical::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const logical& lhs, const logical& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const logical& lhs, const logical& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class _cpp_xor : public logical
{
public:

    typedef xorPrx ProxyType;
    typedef xorPtr PointerType;

    virtual ~_cpp_xor();

    /** Default constructor that assigns default values to members as specified in the Slice definition. */
    _cpp_xor() :
        _cpp_return(1)
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    _cpp_xor(::classdef::_cpp_break::_cpp_bitand _cpp_else, const ::classdef::_cpp_break::_cpp_bitor& _cpp_for, bool int64, ::Ice::Int _cpp_return) :
        ::classdef::_cpp_break::logical(_cpp_else, _cpp_for, int64),
        _cpp_return(_cpp_return)
    {
    }

#ifdef ICE_CPP11_COMPILER
    _cpp_xor(const _cpp_xor&) = default;
    _cpp_xor& operator=(const _cpp_xor&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::Int _cpp_return;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_xor_init = ::classdef::_cpp_break::_cpp_xor::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const _cpp_xor& lhs, const _cpp_xor& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const _cpp_xor& lhs, const _cpp_xor& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class _cpp_try : public virtual ::Ice::Object
{
public:

    typedef tryPrx ProxyType;
    typedef tryPtr PointerType;

    virtual ~_cpp_try();

    /** Default constructor that assigns default values to members as specified in the Slice definition. */
    _cpp_try() :
        _cpp_while(1),
        _cpp_delete(2)
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    _cpp_try(::Ice::Int _cpp_while, ::Ice::Int _cpp_delete) :
        _cpp_while(_cpp_while),
        _cpp_delete(_cpp_delete)
    {
    }

#ifdef ICE_CPP11_COMPILER
    _cpp_try(const _cpp_try&) = default;
    _cpp_try& operator=(const _cpp_try&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::Int _cpp_while;
    ::Ice::Int _cpp_delete;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_try_init = ::classdef::_cpp_break::_cpp_try::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const _cpp_try& lhs, const _cpp_try& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const _cpp_try& lhs, const _cpp_try& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class properties : public _cpp_try, public ::IceInternal::GCObject
{
public:

    typedef propertiesPrx ProxyType;
    typedef propertiesPtr PointerType;

    virtual ~properties();

    /** Default constructor that assigns default values to members as specified in the Slice definition. */
    properties() :
        _cpp_if(2)
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    properties(::Ice::Int _cpp_while, ::Ice::Int _cpp_delete, ::Ice::Int _cpp_if, const ::classdef::_cpp_break::xorPtr& _cpp_catch, const ::classdef::_cpp_break::parfor& spmd, const ::classdef::_cpp_break::_cpp_switch& otherwise) :
        ::classdef::_cpp_break::_cpp_try(_cpp_while, _cpp_delete),
        _cpp_if(_cpp_if),
        _cpp_catch(_cpp_catch),
        spmd(spmd),
        otherwise(otherwise)
    {
    }

#ifdef ICE_CPP11_COMPILER
    properties(const properties&) = default;
    properties& operator=(const properties&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::Int _cpp_if;
    ::classdef::break::xorPtr _cpp_catch;
    ::classdef::_cpp_break::parfor spmd;
    ::classdef::_cpp_break::_cpp_switch otherwise;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_properties_init = ::classdef::_cpp_break::properties::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const properties& lhs, const properties& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const properties& lhs, const properties& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class elseif : public virtual ::Ice::Object
{
public:

    typedef elseifPrx ProxyType;
    typedef elseifPtr PointerType;

    virtual ~elseif();

#ifdef ICE_CPP11_COMPILER
    elseif() = default;
    elseif(const elseif&) = default;
    elseif& operator=(const elseif&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void events(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_events(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void function(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_function(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void _cpp_delete(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_delete(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void checkedCast(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_checkedCast(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const elseif& lhs, const elseif& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const elseif& lhs, const elseif& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::classdef::_cpp_break::_cpp_bitand>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 31;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::classdef::_cpp_break::_cpp_bitor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 13;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::classdef::_cpp_break::_cpp_bitor, S>
{
    static void write(S* ostr, const ::classdef::_cpp_break::_cpp_bitor& v)
    {
        ostr->write(v._cpp_case);
        ostr->write(v._cpp_continue);
        ostr->write(v.eq);
        ostr->write(v.ne);
    }
};

template<typename S>
struct StreamReader< ::classdef::_cpp_break::_cpp_bitor, S>
{
    static void read(S* istr, ::classdef::_cpp_break::_cpp_bitor& v)
    {
        istr->read(v._cpp_case);
        istr->read(v._cpp_continue);
        istr->read(v.eq);
        istr->read(v.ne);
    }
};

template<typename S>
struct StreamWriter< ::classdef::_cpp_break::logical, S>
{
    static void write(S* ostr, const ::classdef::_cpp_break::logical& v)
    {
        ostr->write(v._cpp_else);
        ostr->write(v._cpp_for);
        ostr->write(v.int64);
    }
};

template<typename S>
struct StreamReader< ::classdef::_cpp_break::logical, S>
{
    static void read(S* istr, ::classdef::_cpp_break::logical& v)
    {
        istr->read(v._cpp_else);
        istr->read(v._cpp_for);
        istr->read(v.int64);
    }
};

template<typename S>
struct StreamWriter< ::classdef::_cpp_break::_cpp_xor, S>
{
    static void write(S* ostr, const ::classdef::_cpp_break::_cpp_xor& v)
    {
        ostr->write(v._cpp_return);
    }
};

template<typename S>
struct StreamReader< ::classdef::_cpp_break::_cpp_xor, S>
{
    static void read(S* istr, ::classdef::_cpp_break::_cpp_xor& v)
    {
        istr->read(v._cpp_return);
    }
};

template<typename S>
struct StreamWriter< ::classdef::_cpp_break::_cpp_try, S>
{
    static void write(S* ostr, const ::classdef::_cpp_break::_cpp_try& v)
    {
        ostr->write(v._cpp_while);
        ostr->write(v._cpp_delete);
    }
};

template<typename S>
struct StreamReader< ::classdef::_cpp_break::_cpp_try, S>
{
    static void read(S* istr, ::classdef::_cpp_break::_cpp_try& v)
    {
        istr->read(v._cpp_while);
        istr->read(v._cpp_delete);
    }
};

template<typename S>
struct StreamWriter< ::classdef::_cpp_break::properties, S>
{
    static void write(S* ostr, const ::classdef::_cpp_break::properties& v)
    {
        ostr->write(v._cpp_if);
        ostr->write(v._cpp_catch);
        ostr->write(v.spmd);
        ostr->write(v.otherwise);
    }
};

template<typename S>
struct StreamReader< ::classdef::_cpp_break::properties, S>
{
    static void read(S* istr, ::classdef::_cpp_break::properties& v)
    {
        istr->read(v._cpp_if);
        istr->read(v._cpp_catch);
        istr->read(v.spmd);
        istr->read(v.otherwise);
    }
};

template<>
struct StreamableTraits< ::classdef::_cpp_break::persistent>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::classdef::_cpp_break::persistent, S>
{
    static void write(S* ostr, const ::classdef::_cpp_break::persistent& v)
    {
        ostr->write(v.identifier);
        ostr->write(v.message);
        ostr->write(v.stack);
        ostr->write(v.cause);
        ostr->write(v.type);
        ostr->write(v.end);
    }
};

template<typename S>
struct StreamReader< ::classdef::_cpp_break::persistent, S>
{
    static void read(S* istr, ::classdef::_cpp_break::persistent& v)
    {
        istr->read(v.identifier);
        istr->read(v.message);
        istr->read(v.stack);
        istr->read(v.cause);
        istr->read(v.type);
        istr->read(v.end);
    }
};

template<>
struct StreamableTraits< ::classdef::_cpp_break::global>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::classdef::_cpp_break::global, S>
{
    static void write(S* ostr, const ::classdef::_cpp_break::global& v)
    {
        ostr->write(v.enumeration);
    }
};

template<typename S>
struct StreamReader< ::classdef::_cpp_break::global, S>
{
    static void read(S* istr, ::classdef::_cpp_break::global& v)
    {
        istr->read(v.enumeration);
    }
};

}
/// \endcond

namespace classdef
{

namespace _cpp_break
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::classdef::_cpp_break::elseif::begin_events.
 * Create a wrapper instance by calling ::classdef::_cpp_break::newCallback_elseif_events.
 */
template<class T>
class CallbackNC_elseif_events : public Callback_elseif_events_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_elseif_events(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_events.
 */
template<class T> Callback_elseif_eventsPtr
newCallback_elseif_events(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_elseif_events<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_events.
 */
template<class T> Callback_elseif_eventsPtr
newCallback_elseif_events(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_elseif_events<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_events.
 */
template<class T> Callback_elseif_eventsPtr
newCallback_elseif_events(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_elseif_events<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_events.
 */
template<class T> Callback_elseif_eventsPtr
newCallback_elseif_events(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_elseif_events<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::classdef::_cpp_break::elseif::begin_events.
 * Create a wrapper instance by calling ::classdef::_cpp_break::newCallback_elseif_events.
 */
template<class T, typename CT>
class Callback_elseif_events : public Callback_elseif_events_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_elseif_events(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_events.
 */
template<class T, typename CT> Callback_elseif_eventsPtr
newCallback_elseif_events(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_elseif_events<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_events.
 */
template<class T, typename CT> Callback_elseif_eventsPtr
newCallback_elseif_events(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_elseif_events<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_events.
 */
template<class T, typename CT> Callback_elseif_eventsPtr
newCallback_elseif_events(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_elseif_events<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_events.
 */
template<class T, typename CT> Callback_elseif_eventsPtr
newCallback_elseif_events(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_elseif_events<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::classdef::_cpp_break::elseif::begin_function.
 * Create a wrapper instance by calling ::classdef::_cpp_break::newCallback_elseif_function.
 */
template<class T>
class CallbackNC_elseif_function : public Callback_elseif_function_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_elseif_function(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_function.
 */
template<class T> Callback_elseif_functionPtr
newCallback_elseif_function(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_elseif_function<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_function.
 */
template<class T> Callback_elseif_functionPtr
newCallback_elseif_function(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_elseif_function<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_function.
 */
template<class T> Callback_elseif_functionPtr
newCallback_elseif_function(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_elseif_function<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_function.
 */
template<class T> Callback_elseif_functionPtr
newCallback_elseif_function(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_elseif_function<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::classdef::_cpp_break::elseif::begin_function.
 * Create a wrapper instance by calling ::classdef::_cpp_break::newCallback_elseif_function.
 */
template<class T, typename CT>
class Callback_elseif_function : public Callback_elseif_function_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_elseif_function(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_function.
 */
template<class T, typename CT> Callback_elseif_functionPtr
newCallback_elseif_function(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_elseif_function<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_function.
 */
template<class T, typename CT> Callback_elseif_functionPtr
newCallback_elseif_function(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_elseif_function<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_function.
 */
template<class T, typename CT> Callback_elseif_functionPtr
newCallback_elseif_function(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_elseif_function<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_function.
 */
template<class T, typename CT> Callback_elseif_functionPtr
newCallback_elseif_function(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_elseif_function<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::classdef::_cpp_break::elseif::begin_delete.
 * Create a wrapper instance by calling ::classdef::_cpp_break::newCallback_elseif_delete.
 */
template<class T>
class CallbackNC_elseif_delete : public Callback_elseif_delete_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_elseif_delete(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_delete.
 */
template<class T> Callback_elseif_deletePtr
newCallback_elseif_delete(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_elseif_delete<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_delete.
 */
template<class T> Callback_elseif_deletePtr
newCallback_elseif_delete(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_elseif_delete<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_delete.
 */
template<class T> Callback_elseif_deletePtr
newCallback_elseif_delete(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_elseif_delete<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_delete.
 */
template<class T> Callback_elseif_deletePtr
newCallback_elseif_delete(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_elseif_delete<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::classdef::_cpp_break::elseif::begin_delete.
 * Create a wrapper instance by calling ::classdef::_cpp_break::newCallback_elseif_delete.
 */
template<class T, typename CT>
class Callback_elseif_delete : public Callback_elseif_delete_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_elseif_delete(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_delete.
 */
template<class T, typename CT> Callback_elseif_deletePtr
newCallback_elseif_delete(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_elseif_delete<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_delete.
 */
template<class T, typename CT> Callback_elseif_deletePtr
newCallback_elseif_delete(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_elseif_delete<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_delete.
 */
template<class T, typename CT> Callback_elseif_deletePtr
newCallback_elseif_delete(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_elseif_delete<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_delete.
 */
template<class T, typename CT> Callback_elseif_deletePtr
newCallback_elseif_delete(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_elseif_delete<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::classdef::_cpp_break::elseif::begin_checkedCast.
 * Create a wrapper instance by calling ::classdef::_cpp_break::newCallback_elseif_checkedCast.
 */
template<class T>
class CallbackNC_elseif_checkedCast : public Callback_elseif_checkedCast_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_elseif_checkedCast(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_checkedCast.
 */
template<class T> Callback_elseif_checkedCastPtr
newCallback_elseif_checkedCast(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_elseif_checkedCast<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_checkedCast.
 */
template<class T> Callback_elseif_checkedCastPtr
newCallback_elseif_checkedCast(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_elseif_checkedCast<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_checkedCast.
 */
template<class T> Callback_elseif_checkedCastPtr
newCallback_elseif_checkedCast(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_elseif_checkedCast<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_checkedCast.
 */
template<class T> Callback_elseif_checkedCastPtr
newCallback_elseif_checkedCast(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_elseif_checkedCast<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::classdef::_cpp_break::elseif::begin_checkedCast.
 * Create a wrapper instance by calling ::classdef::_cpp_break::newCallback_elseif_checkedCast.
 */
template<class T, typename CT>
class Callback_elseif_checkedCast : public Callback_elseif_checkedCast_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_elseif_checkedCast(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_checkedCast.
 */
template<class T, typename CT> Callback_elseif_checkedCastPtr
newCallback_elseif_checkedCast(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_elseif_checkedCast<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_checkedCast.
 */
template<class T, typename CT> Callback_elseif_checkedCastPtr
newCallback_elseif_checkedCast(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_elseif_checkedCast<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_checkedCast.
 */
template<class T, typename CT> Callback_elseif_checkedCastPtr
newCallback_elseif_checkedCast(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_elseif_checkedCast<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::classdef::_cpp_break::elseif::begin_checkedCast.
 */
template<class T, typename CT> Callback_elseif_checkedCastPtr
newCallback_elseif_checkedCast(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_elseif_checkedCast<T, CT>(instance, 0, excb, sentcb);
}

}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
