//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `LocalTest.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __LocalTest_h__
#define __LocalTest_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace LocalTest
{

class C1;
class CB1;
class CB2;
class CB3;
class CB4;
class CB5;
class CB6;
class CB7;
class CB8;
class Opt;

}

namespace LocalTest
{

struct S1
{
    ::std::shared_ptr<::LocalTest::C1> c1;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::LocalTest::C1>&> ice_tuple() const
    {
        return std::tie(c1);
    }
};

using C1Seq = ::std::vector<::std::shared_ptr<C1>>;

using S1Seq = ::std::vector<S1>;

using C1Dict = ::std::map<int, ::std::shared_ptr<C1>>;

using S1Dict = ::std::map<int, S1>;

using C1SeqSeq = ::std::vector<C1Seq>;

using S1SeqSeq = ::std::vector<S1Seq>;

struct S2
{
    ::LocalTest::S1 s1;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::S1&> ice_tuple() const
    {
        return std::tie(s1);
    }
};

struct S3
{
    ::LocalTest::C1Seq c1seq;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::C1Seq&> ice_tuple() const
    {
        return std::tie(c1seq);
    }
};

struct S4
{
    ::LocalTest::S1Seq s1seq;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::S1Seq&> ice_tuple() const
    {
        return std::tie(s1seq);
    }
};

struct S5
{
    ::LocalTest::C1Dict c1dict;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::C1Dict&> ice_tuple() const
    {
        return std::tie(c1dict);
    }
};

struct S6
{
    ::LocalTest::S1Dict s1dict;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::S1Dict&> ice_tuple() const
    {
        return std::tie(s1dict);
    }
};

struct S7
{
    ::LocalTest::C1SeqSeq c1seqseq;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::C1SeqSeq&> ice_tuple() const
    {
        return std::tie(c1seqseq);
    }
};

struct S8
{
    ::LocalTest::S1SeqSeq s1seqseq;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::S1SeqSeq&> ice_tuple() const
    {
        return std::tie(s1seqseq);
    }
};

struct StructKey
{
    int i;
    int j;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&> ice_tuple() const
    {
        return std::tie(i, j);
    }
};

using StructDict1 = ::std::map<StructKey, ::std::shared_ptr<C1>>;

using StructDict2 = ::std::map<StructKey, S1>;

using C1DictDict = ::std::map<int, C1Dict>;

using S1DictDict = ::std::map<int, S1Dict>;

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace LocalTest
{

class C1 : public ::Ice::ValueHelper<C1, ::Ice::Value>
{
public:

    virtual ~C1();

    C1() = default;

    C1(const C1&) = default;
    C1(C1&&) = default;
    C1& operator=(const C1&) = default;
    C1& operator=(C1&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit C1(int i) :
        i(i)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(i);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int i;
};

/// \cond INTERNAL
static C1 _iceS_C1_init;
/// \endcond

class CB1 : public ::Ice::ValueHelper<CB1, ::Ice::Value>
{
public:

    virtual ~CB1();

    CB1() = default;

    CB1(const CB1&) = default;
    CB1(CB1&&) = default;
    CB1& operator=(const CB1&) = default;
    CB1& operator=(CB1&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CB1(const ::LocalTest::S1& s1) :
        s1(s1)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::S1&> ice_tuple() const
    {
        return std::tie(s1);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::LocalTest::S1 s1;
};

class CB2 : public ::Ice::ValueHelper<CB2, ::Ice::Value>
{
public:

    virtual ~CB2();

    CB2() = default;

    CB2(const CB2&) = default;
    CB2(CB2&&) = default;
    CB2& operator=(const CB2&) = default;
    CB2& operator=(CB2&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CB2(const ::LocalTest::C1Seq& c1seq) :
        c1seq(c1seq)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::C1Seq&> ice_tuple() const
    {
        return std::tie(c1seq);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::LocalTest::C1Seq c1seq;
};

class CB3 : public ::Ice::ValueHelper<CB3, ::Ice::Value>
{
public:

    virtual ~CB3();

    CB3() = default;

    CB3(const CB3&) = default;
    CB3(CB3&&) = default;
    CB3& operator=(const CB3&) = default;
    CB3& operator=(CB3&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CB3(const ::LocalTest::S1Seq& s1seq) :
        s1seq(s1seq)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::S1Seq&> ice_tuple() const
    {
        return std::tie(s1seq);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::LocalTest::S1Seq s1seq;
};

class CB4 : public ::Ice::ValueHelper<CB4, ::Ice::Value>
{
public:

    virtual ~CB4();

    CB4() = default;

    CB4(const CB4&) = default;
    CB4(CB4&&) = default;
    CB4& operator=(const CB4&) = default;
    CB4& operator=(CB4&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CB4(const ::LocalTest::C1Dict& c1dict) :
        c1dict(c1dict)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::C1Dict&> ice_tuple() const
    {
        return std::tie(c1dict);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::LocalTest::C1Dict c1dict;
};

class CB5 : public ::Ice::ValueHelper<CB5, ::Ice::Value>
{
public:

    virtual ~CB5();

    CB5() = default;

    CB5(const CB5&) = default;
    CB5(CB5&&) = default;
    CB5& operator=(const CB5&) = default;
    CB5& operator=(CB5&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CB5(const ::LocalTest::S1Dict& s1dict) :
        s1dict(s1dict)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::S1Dict&> ice_tuple() const
    {
        return std::tie(s1dict);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::LocalTest::S1Dict s1dict;
};

class CB6 : public ::Ice::ValueHelper<CB6, ::Ice::Value>
{
public:

    virtual ~CB6();

    CB6() = default;

    CB6(const CB6&) = default;
    CB6(CB6&&) = default;
    CB6& operator=(const CB6&) = default;
    CB6& operator=(CB6&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CB6(const ::LocalTest::C1SeqSeq& c1seqseq) :
        c1seqseq(c1seqseq)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::C1SeqSeq&> ice_tuple() const
    {
        return std::tie(c1seqseq);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::LocalTest::C1SeqSeq c1seqseq;
};

class CB7 : public ::Ice::ValueHelper<CB7, ::Ice::Value>
{
public:

    virtual ~CB7();

    CB7() = default;

    CB7(const CB7&) = default;
    CB7(CB7&&) = default;
    CB7& operator=(const CB7&) = default;
    CB7& operator=(CB7&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CB7(const ::LocalTest::S1SeqSeq& s1seqseq) :
        s1seqseq(s1seqseq)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::S1SeqSeq&> ice_tuple() const
    {
        return std::tie(s1seqseq);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::LocalTest::S1SeqSeq s1seqseq;
};

class CB8 : public ::Ice::ValueHelper<CB8, ::Ice::Value>
{
public:

    virtual ~CB8();

    CB8() = default;

    CB8(const CB8&) = default;
    CB8(CB8&&) = default;
    CB8& operator=(const CB8&) = default;
    CB8& operator=(CB8&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    CB8(const ::LocalTest::S1& s1, const ::LocalTest::C1Seq& c1seq, const ::LocalTest::S1Dict& s1dict) :
        s1(s1),
        c1seq(c1seq),
        s1dict(s1dict)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::S1&, const ::LocalTest::C1Seq&, const ::LocalTest::S1Dict&> ice_tuple() const
    {
        return std::tie(s1, c1seq, s1dict);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::LocalTest::S1 s1;
    ::LocalTest::C1Seq c1seq;
    ::LocalTest::S1Dict s1dict;
};

class Opt : public ::Ice::ValueHelper<Opt, ::Ice::Value>
{
public:

    virtual ~Opt();

    Opt() = default;

    Opt(const Opt&) = default;
    Opt(Opt&&) = default;
    Opt& operator=(const Opt&) = default;
    Opt& operator=(Opt&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Opt(const std::optional<::LocalTest::S1>& s1, const std::optional<::LocalTest::C1Seq>& c1seq, const std::optional<::LocalTest::S1Dict>& s1dict) :
        s1(s1),
        c1seq(c1seq),
        s1dict(s1dict)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const std::optional<::LocalTest::S1>&, const std::optional<::LocalTest::C1Seq>&, const std::optional<::LocalTest::S1Dict>&> ice_tuple() const
    {
        return std::tie(s1, c1seq, s1dict);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    std::optional<::LocalTest::S1> s1;
    std::optional<::LocalTest::C1Seq> c1seq;
    std::optional<::LocalTest::S1Dict> s1dict;
};

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamReader<::LocalTest::C1, S>
{
    static void read(S* istr, ::LocalTest::C1& v)
    {
        istr->readAll(v.i);
    }
};

template<>
struct StreamableTraits<::LocalTest::S1>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::LocalTest::S1, S>
{
    static void read(S* istr, ::LocalTest::S1& v)
    {
        istr->readAll(v.c1);
    }
};

template<>
struct StreamableTraits<::LocalTest::S2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::LocalTest::S2, S>
{
    static void read(S* istr, ::LocalTest::S2& v)
    {
        istr->readAll(v.s1);
    }
};

template<>
struct StreamableTraits<::LocalTest::S3>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::LocalTest::S3, S>
{
    static void read(S* istr, ::LocalTest::S3& v)
    {
        istr->readAll(v.c1seq);
    }
};

template<>
struct StreamableTraits<::LocalTest::S4>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::LocalTest::S4, S>
{
    static void read(S* istr, ::LocalTest::S4& v)
    {
        istr->readAll(v.s1seq);
    }
};

template<>
struct StreamableTraits<::LocalTest::S5>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::LocalTest::S5, S>
{
    static void read(S* istr, ::LocalTest::S5& v)
    {
        istr->readAll(v.c1dict);
    }
};

template<>
struct StreamableTraits<::LocalTest::S6>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::LocalTest::S6, S>
{
    static void read(S* istr, ::LocalTest::S6& v)
    {
        istr->readAll(v.s1dict);
    }
};

template<>
struct StreamableTraits<::LocalTest::S7>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::LocalTest::S7, S>
{
    static void read(S* istr, ::LocalTest::S7& v)
    {
        istr->readAll(v.c1seqseq);
    }
};

template<>
struct StreamableTraits<::LocalTest::S8>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::LocalTest::S8, S>
{
    static void read(S* istr, ::LocalTest::S8& v)
    {
        istr->readAll(v.s1seqseq);
    }
};

template<typename S>
struct StreamReader<::LocalTest::CB1, S>
{
    static void read(S* istr, ::LocalTest::CB1& v)
    {
        istr->readAll(v.s1);
    }
};

template<typename S>
struct StreamReader<::LocalTest::CB2, S>
{
    static void read(S* istr, ::LocalTest::CB2& v)
    {
        istr->readAll(v.c1seq);
    }
};

template<typename S>
struct StreamReader<::LocalTest::CB3, S>
{
    static void read(S* istr, ::LocalTest::CB3& v)
    {
        istr->readAll(v.s1seq);
    }
};

template<typename S>
struct StreamReader<::LocalTest::CB4, S>
{
    static void read(S* istr, ::LocalTest::CB4& v)
    {
        istr->readAll(v.c1dict);
    }
};

template<typename S>
struct StreamReader<::LocalTest::CB5, S>
{
    static void read(S* istr, ::LocalTest::CB5& v)
    {
        istr->readAll(v.s1dict);
    }
};

template<typename S>
struct StreamReader<::LocalTest::CB6, S>
{
    static void read(S* istr, ::LocalTest::CB6& v)
    {
        istr->readAll(v.c1seqseq);
    }
};

template<typename S>
struct StreamReader<::LocalTest::CB7, S>
{
    static void read(S* istr, ::LocalTest::CB7& v)
    {
        istr->readAll(v.s1seqseq);
    }
};

template<typename S>
struct StreamReader<::LocalTest::CB8, S>
{
    static void read(S* istr, ::LocalTest::CB8& v)
    {
        istr->readAll(v.s1, v.c1seq, v.s1dict);
    }
};

template<>
struct StreamableTraits<::LocalTest::StructKey>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 8;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::LocalTest::StructKey, S>
{
    static void read(S* istr, ::LocalTest::StructKey& v)
    {
        istr->readAll(v.i, v.j);
    }
};

template<typename S>
struct StreamWriter<::LocalTest::Opt, S>
{
    static void write(S* ostr, const ::LocalTest::Opt& v)
    {
        ostr->writeAll({1, 2, 3}, v.s1, v.c1seq, v.s1dict);
    }
};

template<typename S>
struct StreamReader<::LocalTest::Opt, S>
{
    static void read(S* istr, ::LocalTest::Opt& v)
    {
        istr->readAll({1, 2, 3}, v.s1, v.c1seq, v.s1dict);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace LocalTest
{

using C1Ptr = ::std::shared_ptr<C1>;

using CB1Ptr = ::std::shared_ptr<CB1>;

using CB2Ptr = ::std::shared_ptr<CB2>;

using CB3Ptr = ::std::shared_ptr<CB3>;

using CB4Ptr = ::std::shared_ptr<CB4>;

using CB5Ptr = ::std::shared_ptr<CB5>;

using CB6Ptr = ::std::shared_ptr<CB6>;

using CB7Ptr = ::std::shared_ptr<CB7>;

using CB8Ptr = ::std::shared_ptr<CB8>;

using OptPtr = ::std::shared_ptr<Opt>;

}
/// \endcond

#else // C++98 mapping

namespace LocalTest
{

class C1;
/// \cond INTERNAL
::Ice::Value* upCast(C1*);
/// \endcond
typedef ::IceInternal::Handle< C1> C1Ptr;
/// \cond INTERNAL
void _icePatchValuePtr(C1Ptr&, const ::Ice::ValuePtr&);
/// \endcond

class CB1;
/// \cond INTERNAL
::Ice::Value* upCast(CB1*);
/// \endcond
typedef ::IceInternal::Handle< CB1> CB1Ptr;
/// \cond INTERNAL
void _icePatchValuePtr(CB1Ptr&, const ::Ice::ValuePtr&);
/// \endcond

class CB2;
/// \cond INTERNAL
::Ice::Value* upCast(CB2*);
/// \endcond
typedef ::IceInternal::Handle< CB2> CB2Ptr;
/// \cond INTERNAL
void _icePatchValuePtr(CB2Ptr&, const ::Ice::ValuePtr&);
/// \endcond

class CB3;
/// \cond INTERNAL
::Ice::Value* upCast(CB3*);
/// \endcond
typedef ::IceInternal::Handle< CB3> CB3Ptr;
/// \cond INTERNAL
void _icePatchValuePtr(CB3Ptr&, const ::Ice::ValuePtr&);
/// \endcond

class CB4;
/// \cond INTERNAL
::Ice::Value* upCast(CB4*);
/// \endcond
typedef ::IceInternal::Handle< CB4> CB4Ptr;
/// \cond INTERNAL
void _icePatchValuePtr(CB4Ptr&, const ::Ice::ValuePtr&);
/// \endcond

class CB5;
/// \cond INTERNAL
::Ice::Value* upCast(CB5*);
/// \endcond
typedef ::IceInternal::Handle< CB5> CB5Ptr;
/// \cond INTERNAL
void _icePatchValuePtr(CB5Ptr&, const ::Ice::ValuePtr&);
/// \endcond

class CB6;
/// \cond INTERNAL
::Ice::Value* upCast(CB6*);
/// \endcond
typedef ::IceInternal::Handle< CB6> CB6Ptr;
/// \cond INTERNAL
void _icePatchValuePtr(CB6Ptr&, const ::Ice::ValuePtr&);
/// \endcond

class CB7;
/// \cond INTERNAL
::Ice::Value* upCast(CB7*);
/// \endcond
typedef ::IceInternal::Handle< CB7> CB7Ptr;
/// \cond INTERNAL
void _icePatchValuePtr(CB7Ptr&, const ::Ice::ValuePtr&);
/// \endcond

class CB8;
/// \cond INTERNAL
::Ice::Value* upCast(CB8*);
/// \endcond
typedef ::IceInternal::Handle< CB8> CB8Ptr;
/// \cond INTERNAL
void _icePatchValuePtr(CB8Ptr&, const ::Ice::ValuePtr&);
/// \endcond

class Opt;
/// \cond INTERNAL
::Ice::Value* upCast(Opt*);
/// \endcond
typedef ::IceInternal::Handle< Opt> OptPtr;
/// \cond INTERNAL
void _icePatchValuePtr(OptPtr&, const ::Ice::ValuePtr&);
/// \endcond

}

namespace LocalTest
{

struct S1
{
    ::LocalTest::C1Ptr c1;
};

typedef ::std::vector<C1Ptr> C1Seq;

typedef ::std::vector<S1> S1Seq;

typedef ::std::map< ::Ice::Int, C1Ptr> C1Dict;

typedef ::std::map< ::Ice::Int, S1> S1Dict;

typedef ::std::vector<C1Seq> C1SeqSeq;

typedef ::std::vector<S1Seq> S1SeqSeq;

struct S2
{
    ::LocalTest::S1 s1;
};

struct S3
{
    ::LocalTest::C1Seq c1seq;
};

struct S4
{
    ::LocalTest::S1Seq s1seq;
};

struct S5
{
    ::LocalTest::C1Dict c1dict;
};

struct S6
{
    ::LocalTest::S1Dict s1dict;
};

struct S7
{
    ::LocalTest::C1SeqSeq c1seqseq;
};

struct S8
{
    ::LocalTest::S1SeqSeq s1seqseq;
};

struct StructKey
{
    ::Ice::Int i;
    ::Ice::Int j;

    bool operator==(const StructKey& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(i != rhs_.i)
        {
            return false;
        }
        if(j != rhs_.j)
        {
            return false;
        }
        return true;
    }

    bool operator<(const StructKey& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(i < rhs_.i)
        {
            return true;
        }
        else if(rhs_.i < i)
        {
            return false;
        }
        if(j < rhs_.j)
        {
            return true;
        }
        else if(rhs_.j < j)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const StructKey& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const StructKey& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const StructKey& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const StructKey& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::map<StructKey, C1Ptr> StructDict1;

typedef ::std::map<StructKey, S1> StructDict2;

typedef ::std::map< ::Ice::Int, C1Dict> C1DictDict;

typedef ::std::map< ::Ice::Int, S1Dict> S1DictDict;

}

namespace LocalTest
{

class C1 : public virtual ::Ice::Value
{
public:

    typedef C1Ptr PointerType;

    virtual ~C1();

    C1()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit C1(::Ice::Int i) :
        i(i)
    {
    }
    C1(const C1&) = default;
    C1& operator=(const C1&) = default;

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ValuePtr ice_clone() const;

    /**
     * Obtains the Slice type ID of the most-derived class implemented by this instance.
     * @return The type ID.
     */
    virtual ::std::string ice_id() const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return The type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::Int i;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_C1_init = ::LocalTest::C1::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const C1& lhs, const C1& rhs)
{
    return static_cast<const ::Ice::Value&>(lhs) == static_cast<const ::Ice::Value&>(rhs);
}

inline bool operator<(const C1& lhs, const C1& rhs)
{
    return static_cast<const ::Ice::Value&>(lhs) < static_cast<const ::Ice::Value&>(rhs);
}
/// \endcond

class CB1 : public virtual ::Ice::Value, public ::IceInternal::GCValue
{
public:

    typedef CB1Ptr PointerType;

    virtual ~CB1();

    CB1()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CB1(const ::LocalTest::S1& s1) :
        s1(s1)
    {
    }
    CB1(const CB1&) = default;
    CB1& operator=(const CB1&) = default;

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ValuePtr ice_clone() const;

    /**
     * Obtains the Slice type ID of the most-derived class implemented by this instance.
     * @return The type ID.
     */
    virtual ::std::string ice_id() const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return The type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::LocalTest::S1 s1;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_CB1_init = ::LocalTest::CB1::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const CB1& lhs, const CB1& rhs)
{
    return static_cast<const ::Ice::Value&>(lhs) == static_cast<const ::Ice::Value&>(rhs);
}

inline bool operator<(const CB1& lhs, const CB1& rhs)
{
    return static_cast<const ::Ice::Value&>(lhs) < static_cast<const ::Ice::Value&>(rhs);
}
/// \endcond

class CB2 : public virtual ::Ice::Value, public ::IceInternal::GCValue
{
public:

    typedef CB2Ptr PointerType;

    virtual ~CB2();

    CB2()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CB2(const ::LocalTest::C1Seq& c1seq) :
        c1seq(c1seq)
    {
    }
    CB2(const CB2&) = default;
    CB2& operator=(const CB2&) = default;

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ValuePtr ice_clone() const;

    /**
     * Obtains the Slice type ID of the most-derived class implemented by this instance.
     * @return The type ID.
     */
    virtual ::std::string ice_id() const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return The type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::LocalTest::C1Seq c1seq;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_CB2_init = ::LocalTest::CB2::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const CB2& lhs, const CB2& rhs)
{
    return static_cast<const ::Ice::Value&>(lhs) == static_cast<const ::Ice::Value&>(rhs);
}

inline bool operator<(const CB2& lhs, const CB2& rhs)
{
    return static_cast<const ::Ice::Value&>(lhs) < static_cast<const ::Ice::Value&>(rhs);
}
/// \endcond

class CB3 : public virtual ::Ice::Value, public ::IceInternal::GCValue
{
public:

    typedef CB3Ptr PointerType;

    virtual ~CB3();

    CB3()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CB3(const ::LocalTest::S1Seq& s1seq) :
        s1seq(s1seq)
    {
    }
    CB3(const CB3&) = default;
    CB3& operator=(const CB3&) = default;

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ValuePtr ice_clone() const;

    /**
     * Obtains the Slice type ID of the most-derived class implemented by this instance.
     * @return The type ID.
     */
    virtual ::std::string ice_id() const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return The type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::LocalTest::S1Seq s1seq;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_CB3_init = ::LocalTest::CB3::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const CB3& lhs, const CB3& rhs)
{
    return static_cast<const ::Ice::Value&>(lhs) == static_cast<const ::Ice::Value&>(rhs);
}

inline bool operator<(const CB3& lhs, const CB3& rhs)
{
    return static_cast<const ::Ice::Value&>(lhs) < static_cast<const ::Ice::Value&>(rhs);
}
/// \endcond

class CB4 : public virtual ::Ice::Value, public ::IceInternal::GCValue
{
public:

    typedef CB4Ptr PointerType;

    virtual ~CB4();

    CB4()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CB4(const ::LocalTest::C1Dict& c1dict) :
        c1dict(c1dict)
    {
    }
    CB4(const CB4&) = default;
    CB4& operator=(const CB4&) = default;

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ValuePtr ice_clone() const;

    /**
     * Obtains the Slice type ID of the most-derived class implemented by this instance.
     * @return The type ID.
     */
    virtual ::std::string ice_id() const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return The type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::LocalTest::C1Dict c1dict;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_CB4_init = ::LocalTest::CB4::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const CB4& lhs, const CB4& rhs)
{
    return static_cast<const ::Ice::Value&>(lhs) == static_cast<const ::Ice::Value&>(rhs);
}

inline bool operator<(const CB4& lhs, const CB4& rhs)
{
    return static_cast<const ::Ice::Value&>(lhs) < static_cast<const ::Ice::Value&>(rhs);
}
/// \endcond

class CB5 : public virtual ::Ice::Value, public ::IceInternal::GCValue
{
public:

    typedef CB5Ptr PointerType;

    virtual ~CB5();

    CB5()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CB5(const ::LocalTest::S1Dict& s1dict) :
        s1dict(s1dict)
    {
    }
    CB5(const CB5&) = default;
    CB5& operator=(const CB5&) = default;

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ValuePtr ice_clone() const;

    /**
     * Obtains the Slice type ID of the most-derived class implemented by this instance.
     * @return The type ID.
     */
    virtual ::std::string ice_id() const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return The type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::LocalTest::S1Dict s1dict;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_CB5_init = ::LocalTest::CB5::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const CB5& lhs, const CB5& rhs)
{
    return static_cast<const ::Ice::Value&>(lhs) == static_cast<const ::Ice::Value&>(rhs);
}

inline bool operator<(const CB5& lhs, const CB5& rhs)
{
    return static_cast<const ::Ice::Value&>(lhs) < static_cast<const ::Ice::Value&>(rhs);
}
/// \endcond

class CB6 : public virtual ::Ice::Value, public ::IceInternal::GCValue
{
public:

    typedef CB6Ptr PointerType;

    virtual ~CB6();

    CB6()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CB6(const ::LocalTest::C1SeqSeq& c1seqseq) :
        c1seqseq(c1seqseq)
    {
    }
    CB6(const CB6&) = default;
    CB6& operator=(const CB6&) = default;

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ValuePtr ice_clone() const;

    /**
     * Obtains the Slice type ID of the most-derived class implemented by this instance.
     * @return The type ID.
     */
    virtual ::std::string ice_id() const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return The type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::LocalTest::C1SeqSeq c1seqseq;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_CB6_init = ::LocalTest::CB6::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const CB6& lhs, const CB6& rhs)
{
    return static_cast<const ::Ice::Value&>(lhs) == static_cast<const ::Ice::Value&>(rhs);
}

inline bool operator<(const CB6& lhs, const CB6& rhs)
{
    return static_cast<const ::Ice::Value&>(lhs) < static_cast<const ::Ice::Value&>(rhs);
}
/// \endcond

class CB7 : public virtual ::Ice::Value, public ::IceInternal::GCValue
{
public:

    typedef CB7Ptr PointerType;

    virtual ~CB7();

    CB7()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CB7(const ::LocalTest::S1SeqSeq& s1seqseq) :
        s1seqseq(s1seqseq)
    {
    }
    CB7(const CB7&) = default;
    CB7& operator=(const CB7&) = default;

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ValuePtr ice_clone() const;

    /**
     * Obtains the Slice type ID of the most-derived class implemented by this instance.
     * @return The type ID.
     */
    virtual ::std::string ice_id() const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return The type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::LocalTest::S1SeqSeq s1seqseq;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_CB7_init = ::LocalTest::CB7::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const CB7& lhs, const CB7& rhs)
{
    return static_cast<const ::Ice::Value&>(lhs) == static_cast<const ::Ice::Value&>(rhs);
}

inline bool operator<(const CB7& lhs, const CB7& rhs)
{
    return static_cast<const ::Ice::Value&>(lhs) < static_cast<const ::Ice::Value&>(rhs);
}
/// \endcond

class CB8 : public virtual ::Ice::Value, public ::IceInternal::GCValue
{
public:

    typedef CB8Ptr PointerType;

    virtual ~CB8();

    CB8()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    CB8(const ::LocalTest::S1& s1, const ::LocalTest::C1Seq& c1seq, const ::LocalTest::S1Dict& s1dict) :
        s1(s1),
        c1seq(c1seq),
        s1dict(s1dict)
    {
    }
    CB8(const CB8&) = default;
    CB8& operator=(const CB8&) = default;

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ValuePtr ice_clone() const;

    /**
     * Obtains the Slice type ID of the most-derived class implemented by this instance.
     * @return The type ID.
     */
    virtual ::std::string ice_id() const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return The type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::LocalTest::S1 s1;
    ::LocalTest::C1Seq c1seq;
    ::LocalTest::S1Dict s1dict;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_CB8_init = ::LocalTest::CB8::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const CB8& lhs, const CB8& rhs)
{
    return static_cast<const ::Ice::Value&>(lhs) == static_cast<const ::Ice::Value&>(rhs);
}

inline bool operator<(const CB8& lhs, const CB8& rhs)
{
    return static_cast<const ::Ice::Value&>(lhs) < static_cast<const ::Ice::Value&>(rhs);
}
/// \endcond

class Opt : public virtual ::Ice::Value, public ::IceInternal::GCValue
{
public:

    typedef OptPtr PointerType;

    virtual ~Opt();

    Opt()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    Opt(const std::optional< ::LocalTest::S1>& s1, const std::optional< ::LocalTest::C1Seq>& c1seq, const std::optional< ::LocalTest::S1Dict>& s1dict) :
        s1(s1),
        c1seq(c1seq),
        s1dict(s1dict)
    {
    }
    Opt(const Opt&) = default;
    Opt& operator=(const Opt&) = default;

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ValuePtr ice_clone() const;

    /**
     * Obtains the Slice type ID of the most-derived class implemented by this instance.
     * @return The type ID.
     */
    virtual ::std::string ice_id() const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return The type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    std::optional< ::LocalTest::S1> s1;
    std::optional< ::LocalTest::C1Seq> c1seq;
    std::optional< ::LocalTest::S1Dict> s1dict;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_Opt_init = ::LocalTest::Opt::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const Opt& lhs, const Opt& rhs)
{
    return static_cast<const ::Ice::Value&>(lhs) == static_cast<const ::Ice::Value&>(rhs);
}

inline bool operator<(const Opt& lhs, const Opt& rhs)
{
    return static_cast<const ::Ice::Value&>(lhs) < static_cast<const ::Ice::Value&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamWriter< ::LocalTest::C1, S>
{
    static void write(S* ostr, const ::LocalTest::C1& v)
    {
        ostr->write(v.i);
    }
};

template<typename S>
struct StreamReader< ::LocalTest::C1, S>
{
    static void read(S* istr, ::LocalTest::C1& v)
    {
        istr->read(v.i);
    }
};

template<>
struct StreamableTraits< ::LocalTest::S1>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::LocalTest::S1, S>
{
    static void write(S* ostr, const ::LocalTest::S1& v)
    {
        ostr->write(v.c1);
    }
};

template<typename S>
struct StreamReader< ::LocalTest::S1, S>
{
    static void read(S* istr, ::LocalTest::S1& v)
    {
        istr->read(v.c1);
    }
};

template<>
struct StreamableTraits< ::LocalTest::S2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::LocalTest::S2, S>
{
    static void write(S* ostr, const ::LocalTest::S2& v)
    {
        ostr->write(v.s1);
    }
};

template<typename S>
struct StreamReader< ::LocalTest::S2, S>
{
    static void read(S* istr, ::LocalTest::S2& v)
    {
        istr->read(v.s1);
    }
};

template<>
struct StreamableTraits< ::LocalTest::S3>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::LocalTest::S3, S>
{
    static void write(S* ostr, const ::LocalTest::S3& v)
    {
        ostr->write(v.c1seq);
    }
};

template<typename S>
struct StreamReader< ::LocalTest::S3, S>
{
    static void read(S* istr, ::LocalTest::S3& v)
    {
        istr->read(v.c1seq);
    }
};

template<>
struct StreamableTraits< ::LocalTest::S4>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::LocalTest::S4, S>
{
    static void write(S* ostr, const ::LocalTest::S4& v)
    {
        ostr->write(v.s1seq);
    }
};

template<typename S>
struct StreamReader< ::LocalTest::S4, S>
{
    static void read(S* istr, ::LocalTest::S4& v)
    {
        istr->read(v.s1seq);
    }
};

template<>
struct StreamableTraits< ::LocalTest::S5>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::LocalTest::S5, S>
{
    static void write(S* ostr, const ::LocalTest::S5& v)
    {
        ostr->write(v.c1dict);
    }
};

template<typename S>
struct StreamReader< ::LocalTest::S5, S>
{
    static void read(S* istr, ::LocalTest::S5& v)
    {
        istr->read(v.c1dict);
    }
};

template<>
struct StreamableTraits< ::LocalTest::S6>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::LocalTest::S6, S>
{
    static void write(S* ostr, const ::LocalTest::S6& v)
    {
        ostr->write(v.s1dict);
    }
};

template<typename S>
struct StreamReader< ::LocalTest::S6, S>
{
    static void read(S* istr, ::LocalTest::S6& v)
    {
        istr->read(v.s1dict);
    }
};

template<>
struct StreamableTraits< ::LocalTest::S7>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::LocalTest::S7, S>
{
    static void write(S* ostr, const ::LocalTest::S7& v)
    {
        ostr->write(v.c1seqseq);
    }
};

template<typename S>
struct StreamReader< ::LocalTest::S7, S>
{
    static void read(S* istr, ::LocalTest::S7& v)
    {
        istr->read(v.c1seqseq);
    }
};

template<>
struct StreamableTraits< ::LocalTest::S8>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::LocalTest::S8, S>
{
    static void write(S* ostr, const ::LocalTest::S8& v)
    {
        ostr->write(v.s1seqseq);
    }
};

template<typename S>
struct StreamReader< ::LocalTest::S8, S>
{
    static void read(S* istr, ::LocalTest::S8& v)
    {
        istr->read(v.s1seqseq);
    }
};

template<typename S>
struct StreamWriter< ::LocalTest::CB1, S>
{
    static void write(S* ostr, const ::LocalTest::CB1& v)
    {
        ostr->write(v.s1);
    }
};

template<typename S>
struct StreamReader< ::LocalTest::CB1, S>
{
    static void read(S* istr, ::LocalTest::CB1& v)
    {
        istr->read(v.s1);
    }
};

template<typename S>
struct StreamWriter< ::LocalTest::CB2, S>
{
    static void write(S* ostr, const ::LocalTest::CB2& v)
    {
        ostr->write(v.c1seq);
    }
};

template<typename S>
struct StreamReader< ::LocalTest::CB2, S>
{
    static void read(S* istr, ::LocalTest::CB2& v)
    {
        istr->read(v.c1seq);
    }
};

template<typename S>
struct StreamWriter< ::LocalTest::CB3, S>
{
    static void write(S* ostr, const ::LocalTest::CB3& v)
    {
        ostr->write(v.s1seq);
    }
};

template<typename S>
struct StreamReader< ::LocalTest::CB3, S>
{
    static void read(S* istr, ::LocalTest::CB3& v)
    {
        istr->read(v.s1seq);
    }
};

template<typename S>
struct StreamWriter< ::LocalTest::CB4, S>
{
    static void write(S* ostr, const ::LocalTest::CB4& v)
    {
        ostr->write(v.c1dict);
    }
};

template<typename S>
struct StreamReader< ::LocalTest::CB4, S>
{
    static void read(S* istr, ::LocalTest::CB4& v)
    {
        istr->read(v.c1dict);
    }
};

template<typename S>
struct StreamWriter< ::LocalTest::CB5, S>
{
    static void write(S* ostr, const ::LocalTest::CB5& v)
    {
        ostr->write(v.s1dict);
    }
};

template<typename S>
struct StreamReader< ::LocalTest::CB5, S>
{
    static void read(S* istr, ::LocalTest::CB5& v)
    {
        istr->read(v.s1dict);
    }
};

template<typename S>
struct StreamWriter< ::LocalTest::CB6, S>
{
    static void write(S* ostr, const ::LocalTest::CB6& v)
    {
        ostr->write(v.c1seqseq);
    }
};

template<typename S>
struct StreamReader< ::LocalTest::CB6, S>
{
    static void read(S* istr, ::LocalTest::CB6& v)
    {
        istr->read(v.c1seqseq);
    }
};

template<typename S>
struct StreamWriter< ::LocalTest::CB7, S>
{
    static void write(S* ostr, const ::LocalTest::CB7& v)
    {
        ostr->write(v.s1seqseq);
    }
};

template<typename S>
struct StreamReader< ::LocalTest::CB7, S>
{
    static void read(S* istr, ::LocalTest::CB7& v)
    {
        istr->read(v.s1seqseq);
    }
};

template<typename S>
struct StreamWriter< ::LocalTest::CB8, S>
{
    static void write(S* ostr, const ::LocalTest::CB8& v)
    {
        ostr->write(v.s1);
        ostr->write(v.c1seq);
        ostr->write(v.s1dict);
    }
};

template<typename S>
struct StreamReader< ::LocalTest::CB8, S>
{
    static void read(S* istr, ::LocalTest::CB8& v)
    {
        istr->read(v.s1);
        istr->read(v.c1seq);
        istr->read(v.s1dict);
    }
};

template<>
struct StreamableTraits< ::LocalTest::StructKey>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 8;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::LocalTest::StructKey, S>
{
    static void write(S* ostr, const ::LocalTest::StructKey& v)
    {
        ostr->write(v.i);
        ostr->write(v.j);
    }
};

template<typename S>
struct StreamReader< ::LocalTest::StructKey, S>
{
    static void read(S* istr, ::LocalTest::StructKey& v)
    {
        istr->read(v.i);
        istr->read(v.j);
    }
};

template<typename S>
struct StreamWriter< ::LocalTest::Opt, S>
{
    static void write(S* ostr, const ::LocalTest::Opt& v)
    {
        ostr->write(1, v.s1);
        ostr->write(2, v.c1seq);
        ostr->write(3, v.s1dict);
    }
};

template<typename S>
struct StreamReader< ::LocalTest::Opt, S>
{
    static void read(S* istr, ::LocalTest::Opt& v)
    {
        istr->read(1, v.s1);
        istr->read(2, v.c1seq);
        istr->read(3, v.s1dict);
    }
};

}
/// \endcond

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
