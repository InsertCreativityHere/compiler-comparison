//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `LocalTest.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __LocalTest_h__
#define __LocalTest_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace LocalTest
{

class C1;

using C1Ptr = ::std::shared_ptr<C1>;
struct S1;

using C1Seq = ::std::vector<::std::shared_ptr<C1>>;

using S1Seq = ::std::vector<S1>;

using C1Dict = ::std::map<::std::int32_t, ::std::shared_ptr<C1>>;

using S1Dict = ::std::map<::std::int32_t, S1>;

using C1SeqSeq = ::std::vector<C1Seq>;

using S1SeqSeq = ::std::vector<S1Seq>;
struct S2;
struct S3;
struct S4;
struct S5;
struct S6;
struct S7;
struct S8;
class CB1;

using CB1Ptr = ::std::shared_ptr<CB1>;
class CB2;

using CB2Ptr = ::std::shared_ptr<CB2>;
class CB3;

using CB3Ptr = ::std::shared_ptr<CB3>;
class CB4;

using CB4Ptr = ::std::shared_ptr<CB4>;
class CB5;

using CB5Ptr = ::std::shared_ptr<CB5>;
class CB6;

using CB6Ptr = ::std::shared_ptr<CB6>;
class CB7;

using CB7Ptr = ::std::shared_ptr<CB7>;
class CB8;

using CB8Ptr = ::std::shared_ptr<CB8>;
struct StructKey;

using StructDict1 = ::std::map<StructKey, ::std::shared_ptr<C1>>;

using StructDict2 = ::std::map<StructKey, S1>;

using C1DictDict = ::std::map<::std::int32_t, C1Dict>;

using S1DictDict = ::std::map<::std::int32_t, S1Dict>;
class Opt;

using OptPtr = ::std::shared_ptr<Opt>;

}

namespace LocalTest
{

class C1 : public ::Ice::Value
{
public:

    C1() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit C1(::std::int32_t i) :
        i(i)
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string ice_id() const override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&> ice_tuple() const
    {
        return std::tie(i);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    ::std::shared_ptr<C1> ice_clone() const { return ::std::static_pointer_cast <C1>(_iceCloneImpl()); }

    ::std::int32_t i;

protected:

    C1(const C1&) = default;

    ::std::shared_ptr<::Ice::Value> _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

/// \cond INTERNAL
static C1 _iceS_C1_init;
/// \endcond

struct S1
{
    ::std::shared_ptr<::LocalTest::C1> c1;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::LocalTest::C1>&> ice_tuple() const
    {
        return std::tie(c1);
    }
};

struct S2
{
    ::LocalTest::S1 s1;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::S1&> ice_tuple() const
    {
        return std::tie(s1);
    }
};

struct S3
{
    ::LocalTest::C1Seq c1seq;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::C1Seq&> ice_tuple() const
    {
        return std::tie(c1seq);
    }
};

struct S4
{
    ::LocalTest::S1Seq s1seq;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::S1Seq&> ice_tuple() const
    {
        return std::tie(s1seq);
    }
};

struct S5
{
    ::LocalTest::C1Dict c1dict;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::C1Dict&> ice_tuple() const
    {
        return std::tie(c1dict);
    }
};

struct S6
{
    ::LocalTest::S1Dict s1dict;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::S1Dict&> ice_tuple() const
    {
        return std::tie(s1dict);
    }
};

struct S7
{
    ::LocalTest::C1SeqSeq c1seqseq;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::C1SeqSeq&> ice_tuple() const
    {
        return std::tie(c1seqseq);
    }
};

struct S8
{
    ::LocalTest::S1SeqSeq s1seqseq;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::S1SeqSeq&> ice_tuple() const
    {
        return std::tie(s1seqseq);
    }
};

class CB1 : public ::Ice::Value
{
public:

    CB1() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CB1(::LocalTest::S1 s1) :
        s1(::std::move(s1))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string ice_id() const override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::S1&> ice_tuple() const
    {
        return std::tie(s1);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    ::std::shared_ptr<CB1> ice_clone() const { return ::std::static_pointer_cast <CB1>(_iceCloneImpl()); }

    ::LocalTest::S1 s1;

protected:

    CB1(const CB1&) = default;

    ::std::shared_ptr<::Ice::Value> _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class CB2 : public ::Ice::Value
{
public:

    CB2() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CB2(::LocalTest::C1Seq c1seq) :
        c1seq(::std::move(c1seq))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string ice_id() const override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::C1Seq&> ice_tuple() const
    {
        return std::tie(c1seq);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    ::std::shared_ptr<CB2> ice_clone() const { return ::std::static_pointer_cast <CB2>(_iceCloneImpl()); }

    ::LocalTest::C1Seq c1seq;

protected:

    CB2(const CB2&) = default;

    ::std::shared_ptr<::Ice::Value> _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class CB3 : public ::Ice::Value
{
public:

    CB3() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CB3(::LocalTest::S1Seq s1seq) :
        s1seq(::std::move(s1seq))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string ice_id() const override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::S1Seq&> ice_tuple() const
    {
        return std::tie(s1seq);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    ::std::shared_ptr<CB3> ice_clone() const { return ::std::static_pointer_cast <CB3>(_iceCloneImpl()); }

    ::LocalTest::S1Seq s1seq;

protected:

    CB3(const CB3&) = default;

    ::std::shared_ptr<::Ice::Value> _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class CB4 : public ::Ice::Value
{
public:

    CB4() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CB4(::LocalTest::C1Dict c1dict) :
        c1dict(::std::move(c1dict))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string ice_id() const override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::C1Dict&> ice_tuple() const
    {
        return std::tie(c1dict);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    ::std::shared_ptr<CB4> ice_clone() const { return ::std::static_pointer_cast <CB4>(_iceCloneImpl()); }

    ::LocalTest::C1Dict c1dict;

protected:

    CB4(const CB4&) = default;

    ::std::shared_ptr<::Ice::Value> _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class CB5 : public ::Ice::Value
{
public:

    CB5() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CB5(::LocalTest::S1Dict s1dict) :
        s1dict(::std::move(s1dict))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string ice_id() const override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::S1Dict&> ice_tuple() const
    {
        return std::tie(s1dict);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    ::std::shared_ptr<CB5> ice_clone() const { return ::std::static_pointer_cast <CB5>(_iceCloneImpl()); }

    ::LocalTest::S1Dict s1dict;

protected:

    CB5(const CB5&) = default;

    ::std::shared_ptr<::Ice::Value> _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class CB6 : public ::Ice::Value
{
public:

    CB6() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CB6(::LocalTest::C1SeqSeq c1seqseq) :
        c1seqseq(::std::move(c1seqseq))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string ice_id() const override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::C1SeqSeq&> ice_tuple() const
    {
        return std::tie(c1seqseq);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    ::std::shared_ptr<CB6> ice_clone() const { return ::std::static_pointer_cast <CB6>(_iceCloneImpl()); }

    ::LocalTest::C1SeqSeq c1seqseq;

protected:

    CB6(const CB6&) = default;

    ::std::shared_ptr<::Ice::Value> _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class CB7 : public ::Ice::Value
{
public:

    CB7() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CB7(::LocalTest::S1SeqSeq s1seqseq) :
        s1seqseq(::std::move(s1seqseq))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string ice_id() const override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::S1SeqSeq&> ice_tuple() const
    {
        return std::tie(s1seqseq);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    ::std::shared_ptr<CB7> ice_clone() const { return ::std::static_pointer_cast <CB7>(_iceCloneImpl()); }

    ::LocalTest::S1SeqSeq s1seqseq;

protected:

    CB7(const CB7&) = default;

    ::std::shared_ptr<::Ice::Value> _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class CB8 : public ::Ice::Value
{
public:

    CB8() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    CB8(::LocalTest::S1 s1, ::LocalTest::C1Seq c1seq, ::LocalTest::S1Dict s1dict) :
        s1(::std::move(s1)),
        c1seq(::std::move(c1seq)),
        s1dict(::std::move(s1dict))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string ice_id() const override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::S1&, const ::LocalTest::C1Seq&, const ::LocalTest::S1Dict&> ice_tuple() const
    {
        return std::tie(s1, c1seq, s1dict);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    ::std::shared_ptr<CB8> ice_clone() const { return ::std::static_pointer_cast <CB8>(_iceCloneImpl()); }

    ::LocalTest::S1 s1;
    ::LocalTest::C1Seq c1seq;
    ::LocalTest::S1Dict s1dict;

protected:

    CB8(const CB8&) = default;

    ::std::shared_ptr<::Ice::Value> _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

struct StructKey
{
    ::std::int32_t i;
    ::std::int32_t j;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::int32_t&> ice_tuple() const
    {
        return std::tie(i, j);
    }
};

class Opt : public ::Ice::Value
{
public:

    Opt() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Opt(::std::optional<::LocalTest::S1> s1, ::std::optional<::LocalTest::C1Seq> c1seq, ::std::optional<::LocalTest::S1Dict> s1dict) :
        s1(::std::move(s1)),
        c1seq(::std::move(c1seq)),
        s1dict(::std::move(s1dict))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string ice_id() const override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::optional<::LocalTest::S1>&, const ::std::optional<::LocalTest::C1Seq>&, const ::std::optional<::LocalTest::S1Dict>&> ice_tuple() const
    {
        return std::tie(s1, c1seq, s1dict);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    ::std::shared_ptr<Opt> ice_clone() const { return ::std::static_pointer_cast <Opt>(_iceCloneImpl()); }

    ::std::optional<::LocalTest::S1> s1;
    ::std::optional<::LocalTest::C1Seq> c1seq;
    ::std::optional<::LocalTest::S1Dict> s1dict;

protected:

    Opt(const Opt&) = default;

    ::std::shared_ptr<::Ice::Value> _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamReader<::LocalTest::C1, S>
{
    static void read(S* istr, ::LocalTest::C1& v)
    {
        istr->readAll(v.i);
    }
};

template<>
struct StreamableTraits<::LocalTest::S1>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::LocalTest::S1, S>
{
    static void read(S* istr, ::LocalTest::S1& v)
    {
        istr->readAll(v.c1);
    }
};

template<>
struct StreamableTraits<::LocalTest::S2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::LocalTest::S2, S>
{
    static void read(S* istr, ::LocalTest::S2& v)
    {
        istr->readAll(v.s1);
    }
};

template<>
struct StreamableTraits<::LocalTest::S3>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::LocalTest::S3, S>
{
    static void read(S* istr, ::LocalTest::S3& v)
    {
        istr->readAll(v.c1seq);
    }
};

template<>
struct StreamableTraits<::LocalTest::S4>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::LocalTest::S4, S>
{
    static void read(S* istr, ::LocalTest::S4& v)
    {
        istr->readAll(v.s1seq);
    }
};

template<>
struct StreamableTraits<::LocalTest::S5>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::LocalTest::S5, S>
{
    static void read(S* istr, ::LocalTest::S5& v)
    {
        istr->readAll(v.c1dict);
    }
};

template<>
struct StreamableTraits<::LocalTest::S6>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::LocalTest::S6, S>
{
    static void read(S* istr, ::LocalTest::S6& v)
    {
        istr->readAll(v.s1dict);
    }
};

template<>
struct StreamableTraits<::LocalTest::S7>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::LocalTest::S7, S>
{
    static void read(S* istr, ::LocalTest::S7& v)
    {
        istr->readAll(v.c1seqseq);
    }
};

template<>
struct StreamableTraits<::LocalTest::S8>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::LocalTest::S8, S>
{
    static void read(S* istr, ::LocalTest::S8& v)
    {
        istr->readAll(v.s1seqseq);
    }
};

template<typename S>
struct StreamReader<::LocalTest::CB1, S>
{
    static void read(S* istr, ::LocalTest::CB1& v)
    {
        istr->readAll(v.s1);
    }
};

template<typename S>
struct StreamReader<::LocalTest::CB2, S>
{
    static void read(S* istr, ::LocalTest::CB2& v)
    {
        istr->readAll(v.c1seq);
    }
};

template<typename S>
struct StreamReader<::LocalTest::CB3, S>
{
    static void read(S* istr, ::LocalTest::CB3& v)
    {
        istr->readAll(v.s1seq);
    }
};

template<typename S>
struct StreamReader<::LocalTest::CB4, S>
{
    static void read(S* istr, ::LocalTest::CB4& v)
    {
        istr->readAll(v.c1dict);
    }
};

template<typename S>
struct StreamReader<::LocalTest::CB5, S>
{
    static void read(S* istr, ::LocalTest::CB5& v)
    {
        istr->readAll(v.s1dict);
    }
};

template<typename S>
struct StreamReader<::LocalTest::CB6, S>
{
    static void read(S* istr, ::LocalTest::CB6& v)
    {
        istr->readAll(v.c1seqseq);
    }
};

template<typename S>
struct StreamReader<::LocalTest::CB7, S>
{
    static void read(S* istr, ::LocalTest::CB7& v)
    {
        istr->readAll(v.s1seqseq);
    }
};

template<typename S>
struct StreamReader<::LocalTest::CB8, S>
{
    static void read(S* istr, ::LocalTest::CB8& v)
    {
        istr->readAll(v.s1, v.c1seq, v.s1dict);
    }
};

template<>
struct StreamableTraits<::LocalTest::StructKey>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 8;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::LocalTest::StructKey, S>
{
    static void read(S* istr, ::LocalTest::StructKey& v)
    {
        istr->readAll(v.i, v.j);
    }
};

template<typename S>
struct StreamWriter<::LocalTest::Opt, S>
{
    static void write(S* ostr, const ::LocalTest::Opt& v)
    {
        ostr->writeAll({1, 2, 3}, v.s1, v.c1seq, v.s1dict);
    }
};

template<typename S>
struct StreamReader<::LocalTest::Opt, S>
{
    static void read(S* istr, ::LocalTest::Opt& v)
    {
        istr->readAll({1, 2, 3}, v.s1, v.c1seq, v.s1dict);
    }
};

}
/// \endcond

#include <IceUtil/PopDisableWarnings.h>
#endif
