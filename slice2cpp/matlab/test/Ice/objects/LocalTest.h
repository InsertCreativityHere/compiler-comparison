//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `LocalTest.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __LocalTest_h__
#define __LocalTest_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace LocalTest
{

class C1;

using C1Ptr = ::std::shared_ptr<C1>;
struct S1;

using C1Seq = ::std::vector<::std::shared_ptr<C1>>;

using S1Seq = ::std::vector<S1>;

using C1Dict = ::std::map<::std::int32_t, ::std::shared_ptr<C1>>;

using S1Dict = ::std::map<::std::int32_t, S1>;

using C1SeqSeq = ::std::vector<C1Seq>;

using S1SeqSeq = ::std::vector<S1Seq>;
struct S2;
struct S3;
struct S4;
struct S5;
struct S6;
struct S7;
struct S8;
class CB1;

using CB1Ptr = ::std::shared_ptr<CB1>;
class CB2;

using CB2Ptr = ::std::shared_ptr<CB2>;
class CB3;

using CB3Ptr = ::std::shared_ptr<CB3>;
class CB4;

using CB4Ptr = ::std::shared_ptr<CB4>;
class CB5;

using CB5Ptr = ::std::shared_ptr<CB5>;
class CB6;

using CB6Ptr = ::std::shared_ptr<CB6>;
class CB7;

using CB7Ptr = ::std::shared_ptr<CB7>;
class CB8;

using CB8Ptr = ::std::shared_ptr<CB8>;
struct StructKey;

using StructDict1 = ::std::map<StructKey, ::std::shared_ptr<C1>>;

using StructDict2 = ::std::map<StructKey, S1>;

using C1DictDict = ::std::map<::std::int32_t, C1Dict>;

using S1DictDict = ::std::map<::std::int32_t, S1Dict>;
class Opt;

using OptPtr = ::std::shared_ptr<Opt>;

}

namespace LocalTest
{

class C1 : public ::Ice::ValueHelper<C1, ::Ice::Value>
{
public:

    virtual ~C1();

    C1() = default;

    C1(const C1&) = default;
    C1(C1&&) = default;
    C1& operator=(const C1&) = default;
    C1& operator=(C1&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit C1(::std::int32_t i) :
        i(i)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&> ice_tuple() const
    {
        return std::tie(i);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::int32_t i;
};

/// \cond INTERNAL
static C1 _iceS_C1_init;
/// \endcond

struct S1
{
    ::std::shared_ptr<::LocalTest::C1> c1;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::LocalTest::C1>&> ice_tuple() const
    {
        return std::tie(c1);
    }
};

struct S2
{
    ::LocalTest::S1 s1;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::S1&> ice_tuple() const
    {
        return std::tie(s1);
    }
};

struct S3
{
    ::LocalTest::C1Seq c1seq;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::C1Seq&> ice_tuple() const
    {
        return std::tie(c1seq);
    }
};

struct S4
{
    ::LocalTest::S1Seq s1seq;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::S1Seq&> ice_tuple() const
    {
        return std::tie(s1seq);
    }
};

struct S5
{
    ::LocalTest::C1Dict c1dict;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::C1Dict&> ice_tuple() const
    {
        return std::tie(c1dict);
    }
};

struct S6
{
    ::LocalTest::S1Dict s1dict;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::S1Dict&> ice_tuple() const
    {
        return std::tie(s1dict);
    }
};

struct S7
{
    ::LocalTest::C1SeqSeq c1seqseq;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::C1SeqSeq&> ice_tuple() const
    {
        return std::tie(c1seqseq);
    }
};

struct S8
{
    ::LocalTest::S1SeqSeq s1seqseq;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::S1SeqSeq&> ice_tuple() const
    {
        return std::tie(s1seqseq);
    }
};

class CB1 : public ::Ice::ValueHelper<CB1, ::Ice::Value>
{
public:

    virtual ~CB1();

    CB1() = default;

    CB1(const CB1&) = default;
    CB1(CB1&&) = default;
    CB1& operator=(const CB1&) = default;
    CB1& operator=(CB1&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CB1(const ::LocalTest::S1& s1) :
        s1(s1)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::S1&> ice_tuple() const
    {
        return std::tie(s1);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::LocalTest::S1 s1;
};

class CB2 : public ::Ice::ValueHelper<CB2, ::Ice::Value>
{
public:

    virtual ~CB2();

    CB2() = default;

    CB2(const CB2&) = default;
    CB2(CB2&&) = default;
    CB2& operator=(const CB2&) = default;
    CB2& operator=(CB2&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CB2(const ::LocalTest::C1Seq& c1seq) :
        c1seq(c1seq)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::C1Seq&> ice_tuple() const
    {
        return std::tie(c1seq);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::LocalTest::C1Seq c1seq;
};

class CB3 : public ::Ice::ValueHelper<CB3, ::Ice::Value>
{
public:

    virtual ~CB3();

    CB3() = default;

    CB3(const CB3&) = default;
    CB3(CB3&&) = default;
    CB3& operator=(const CB3&) = default;
    CB3& operator=(CB3&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CB3(const ::LocalTest::S1Seq& s1seq) :
        s1seq(s1seq)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::S1Seq&> ice_tuple() const
    {
        return std::tie(s1seq);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::LocalTest::S1Seq s1seq;
};

class CB4 : public ::Ice::ValueHelper<CB4, ::Ice::Value>
{
public:

    virtual ~CB4();

    CB4() = default;

    CB4(const CB4&) = default;
    CB4(CB4&&) = default;
    CB4& operator=(const CB4&) = default;
    CB4& operator=(CB4&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CB4(const ::LocalTest::C1Dict& c1dict) :
        c1dict(c1dict)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::C1Dict&> ice_tuple() const
    {
        return std::tie(c1dict);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::LocalTest::C1Dict c1dict;
};

class CB5 : public ::Ice::ValueHelper<CB5, ::Ice::Value>
{
public:

    virtual ~CB5();

    CB5() = default;

    CB5(const CB5&) = default;
    CB5(CB5&&) = default;
    CB5& operator=(const CB5&) = default;
    CB5& operator=(CB5&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CB5(const ::LocalTest::S1Dict& s1dict) :
        s1dict(s1dict)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::S1Dict&> ice_tuple() const
    {
        return std::tie(s1dict);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::LocalTest::S1Dict s1dict;
};

class CB6 : public ::Ice::ValueHelper<CB6, ::Ice::Value>
{
public:

    virtual ~CB6();

    CB6() = default;

    CB6(const CB6&) = default;
    CB6(CB6&&) = default;
    CB6& operator=(const CB6&) = default;
    CB6& operator=(CB6&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CB6(const ::LocalTest::C1SeqSeq& c1seqseq) :
        c1seqseq(c1seqseq)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::C1SeqSeq&> ice_tuple() const
    {
        return std::tie(c1seqseq);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::LocalTest::C1SeqSeq c1seqseq;
};

class CB7 : public ::Ice::ValueHelper<CB7, ::Ice::Value>
{
public:

    virtual ~CB7();

    CB7() = default;

    CB7(const CB7&) = default;
    CB7(CB7&&) = default;
    CB7& operator=(const CB7&) = default;
    CB7& operator=(CB7&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit CB7(const ::LocalTest::S1SeqSeq& s1seqseq) :
        s1seqseq(s1seqseq)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::S1SeqSeq&> ice_tuple() const
    {
        return std::tie(s1seqseq);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::LocalTest::S1SeqSeq s1seqseq;
};

class CB8 : public ::Ice::ValueHelper<CB8, ::Ice::Value>
{
public:

    virtual ~CB8();

    CB8() = default;

    CB8(const CB8&) = default;
    CB8(CB8&&) = default;
    CB8& operator=(const CB8&) = default;
    CB8& operator=(CB8&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    CB8(const ::LocalTest::S1& s1, const ::LocalTest::C1Seq& c1seq, const ::LocalTest::S1Dict& s1dict) :
        s1(s1),
        c1seq(c1seq),
        s1dict(s1dict)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::LocalTest::S1&, const ::LocalTest::C1Seq&, const ::LocalTest::S1Dict&> ice_tuple() const
    {
        return std::tie(s1, c1seq, s1dict);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::LocalTest::S1 s1;
    ::LocalTest::C1Seq c1seq;
    ::LocalTest::S1Dict s1dict;
};

struct StructKey
{
    ::std::int32_t i;
    ::std::int32_t j;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::int32_t&> ice_tuple() const
    {
        return std::tie(i, j);
    }
};

class Opt : public ::Ice::ValueHelper<Opt, ::Ice::Value>
{
public:

    virtual ~Opt();

    Opt() = default;

    Opt(const Opt&) = default;
    Opt(Opt&&) = default;
    Opt& operator=(const Opt&) = default;
    Opt& operator=(Opt&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Opt(const ::std::optional<::LocalTest::S1>& s1, const ::std::optional<::LocalTest::C1Seq>& c1seq, const ::std::optional<::LocalTest::S1Dict>& s1dict) :
        s1(s1),
        c1seq(c1seq),
        s1dict(s1dict)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::optional<::LocalTest::S1>&, const ::std::optional<::LocalTest::C1Seq>&, const ::std::optional<::LocalTest::S1Dict>&> ice_tuple() const
    {
        return std::tie(s1, c1seq, s1dict);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::optional<::LocalTest::S1> s1;
    ::std::optional<::LocalTest::C1Seq> c1seq;
    ::std::optional<::LocalTest::S1Dict> s1dict;
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamReader<::LocalTest::C1, S>
{
    static void read(S* istr, ::LocalTest::C1& v)
    {
        istr->readAll(v.i);
    }
};

template<>
struct StreamableTraits<::LocalTest::S1>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::LocalTest::S1, S>
{
    static void read(S* istr, ::LocalTest::S1& v)
    {
        istr->readAll(v.c1);
    }
};

template<>
struct StreamableTraits<::LocalTest::S2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::LocalTest::S2, S>
{
    static void read(S* istr, ::LocalTest::S2& v)
    {
        istr->readAll(v.s1);
    }
};

template<>
struct StreamableTraits<::LocalTest::S3>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::LocalTest::S3, S>
{
    static void read(S* istr, ::LocalTest::S3& v)
    {
        istr->readAll(v.c1seq);
    }
};

template<>
struct StreamableTraits<::LocalTest::S4>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::LocalTest::S4, S>
{
    static void read(S* istr, ::LocalTest::S4& v)
    {
        istr->readAll(v.s1seq);
    }
};

template<>
struct StreamableTraits<::LocalTest::S5>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::LocalTest::S5, S>
{
    static void read(S* istr, ::LocalTest::S5& v)
    {
        istr->readAll(v.c1dict);
    }
};

template<>
struct StreamableTraits<::LocalTest::S6>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::LocalTest::S6, S>
{
    static void read(S* istr, ::LocalTest::S6& v)
    {
        istr->readAll(v.s1dict);
    }
};

template<>
struct StreamableTraits<::LocalTest::S7>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::LocalTest::S7, S>
{
    static void read(S* istr, ::LocalTest::S7& v)
    {
        istr->readAll(v.c1seqseq);
    }
};

template<>
struct StreamableTraits<::LocalTest::S8>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::LocalTest::S8, S>
{
    static void read(S* istr, ::LocalTest::S8& v)
    {
        istr->readAll(v.s1seqseq);
    }
};

template<typename S>
struct StreamReader<::LocalTest::CB1, S>
{
    static void read(S* istr, ::LocalTest::CB1& v)
    {
        istr->readAll(v.s1);
    }
};

template<typename S>
struct StreamReader<::LocalTest::CB2, S>
{
    static void read(S* istr, ::LocalTest::CB2& v)
    {
        istr->readAll(v.c1seq);
    }
};

template<typename S>
struct StreamReader<::LocalTest::CB3, S>
{
    static void read(S* istr, ::LocalTest::CB3& v)
    {
        istr->readAll(v.s1seq);
    }
};

template<typename S>
struct StreamReader<::LocalTest::CB4, S>
{
    static void read(S* istr, ::LocalTest::CB4& v)
    {
        istr->readAll(v.c1dict);
    }
};

template<typename S>
struct StreamReader<::LocalTest::CB5, S>
{
    static void read(S* istr, ::LocalTest::CB5& v)
    {
        istr->readAll(v.s1dict);
    }
};

template<typename S>
struct StreamReader<::LocalTest::CB6, S>
{
    static void read(S* istr, ::LocalTest::CB6& v)
    {
        istr->readAll(v.c1seqseq);
    }
};

template<typename S>
struct StreamReader<::LocalTest::CB7, S>
{
    static void read(S* istr, ::LocalTest::CB7& v)
    {
        istr->readAll(v.s1seqseq);
    }
};

template<typename S>
struct StreamReader<::LocalTest::CB8, S>
{
    static void read(S* istr, ::LocalTest::CB8& v)
    {
        istr->readAll(v.s1, v.c1seq, v.s1dict);
    }
};

template<>
struct StreamableTraits<::LocalTest::StructKey>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 8;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::LocalTest::StructKey, S>
{
    static void read(S* istr, ::LocalTest::StructKey& v)
    {
        istr->readAll(v.i, v.j);
    }
};

template<typename S>
struct StreamWriter<::LocalTest::Opt, S>
{
    static void write(S* ostr, const ::LocalTest::Opt& v)
    {
        ostr->writeAll({1, 2, 3}, v.s1, v.c1seq, v.s1dict);
    }
};

template<typename S>
struct StreamReader<::LocalTest::Opt, S>
{
    static void read(S* istr, ::LocalTest::Opt& v)
    {
        istr->readAll({1, 2, 3}, v.s1, v.c1seq, v.s1dict);
    }
};

}
/// \endcond

#include <IceUtil/PopDisableWarnings.h>
#endif
