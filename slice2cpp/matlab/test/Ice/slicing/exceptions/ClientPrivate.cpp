//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `ClientPrivate.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#define ICE_BUILDING_GENERATED_CODE
#include <ClientPrivate.h>
#include <IceUtil/PushDisableWarnings.h>
#include <IceUtil/PopDisableWarnings.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::Base> iceC_Test_Base_init("::Test::Base");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::KnownDerived> iceC_Test_KnownDerived_init("::Test::KnownDerived");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::KnownIntermediate> iceC_Test_KnownIntermediate_init("::Test::KnownIntermediate");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::KnownMostDerived> iceC_Test_KnownMostDerived_init("::Test::KnownMostDerived");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::KnownPreserved> iceC_Test_KnownPreserved_init("::Test::KnownPreserved");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::KnownPreservedDerived> iceC_Test_KnownPreservedDerived_init("::Test::KnownPreservedDerived");

const ::IceInternal::DefaultValueFactoryInit<::Test::BaseClass> iceC_Test_BaseClass_init("::Test::BaseClass");

const ::std::string iceC_Test_Relay_ids[2] =
{
    "::Ice::Object",
    "::Test::Relay"
};
const ::std::string iceC_Test_Relay_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "knownPreservedAsBase",
    "knownPreservedAsKnownPreserved",
    "unknownPreservedAsBase",
    "unknownPreservedAsKnownPreserved"
};
const ::std::string iceC_Test_Relay_knownPreservedAsBase_name = "knownPreservedAsBase";
const ::std::string iceC_Test_Relay_knownPreservedAsKnownPreserved_name = "knownPreservedAsKnownPreserved";
const ::std::string iceC_Test_Relay_unknownPreservedAsBase_name = "unknownPreservedAsBase";
const ::std::string iceC_Test_Relay_unknownPreservedAsKnownPreserved_name = "unknownPreservedAsKnownPreserved";

const ::std::string iceC_Test_TestIntf_ids[2] =
{
    "::Ice::Object",
    "::Test::TestIntf"
};
const ::std::string iceC_Test_TestIntf_ops[] =
{
    "baseAsBase",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "knownDerivedAsBase",
    "knownDerivedAsKnownDerived",
    "knownIntermediateAsBase",
    "knownIntermediateAsKnownIntermediate",
    "knownMostDerivedAsBase",
    "knownMostDerivedAsKnownIntermediate",
    "knownMostDerivedAsKnownMostDerived",
    "knownPreservedAsBase",
    "knownPreservedAsKnownPreserved",
    "relayKnownPreservedAsBase",
    "relayKnownPreservedAsKnownPreserved",
    "relayUnknownPreservedAsBase",
    "relayUnknownPreservedAsKnownPreserved",
    "shutdown",
    "unknownDerivedAsBase",
    "unknownIntermediateAsBase",
    "unknownMostDerived1AsBase",
    "unknownMostDerived1AsKnownIntermediate",
    "unknownMostDerived2AsBase",
    "unknownMostDerived2AsBaseCompact",
    "unknownPreservedAsBase",
    "unknownPreservedAsKnownPreserved"
};
const ::std::string iceC_Test_TestIntf_baseAsBase_name = "baseAsBase";
const ::std::string iceC_Test_TestIntf_unknownDerivedAsBase_name = "unknownDerivedAsBase";
const ::std::string iceC_Test_TestIntf_knownDerivedAsBase_name = "knownDerivedAsBase";
const ::std::string iceC_Test_TestIntf_knownDerivedAsKnownDerived_name = "knownDerivedAsKnownDerived";
const ::std::string iceC_Test_TestIntf_unknownIntermediateAsBase_name = "unknownIntermediateAsBase";
const ::std::string iceC_Test_TestIntf_knownIntermediateAsBase_name = "knownIntermediateAsBase";
const ::std::string iceC_Test_TestIntf_knownMostDerivedAsBase_name = "knownMostDerivedAsBase";
const ::std::string iceC_Test_TestIntf_knownIntermediateAsKnownIntermediate_name = "knownIntermediateAsKnownIntermediate";
const ::std::string iceC_Test_TestIntf_knownMostDerivedAsKnownIntermediate_name = "knownMostDerivedAsKnownIntermediate";
const ::std::string iceC_Test_TestIntf_knownMostDerivedAsKnownMostDerived_name = "knownMostDerivedAsKnownMostDerived";
const ::std::string iceC_Test_TestIntf_unknownMostDerived1AsBase_name = "unknownMostDerived1AsBase";
const ::std::string iceC_Test_TestIntf_unknownMostDerived1AsKnownIntermediate_name = "unknownMostDerived1AsKnownIntermediate";
const ::std::string iceC_Test_TestIntf_unknownMostDerived2AsBase_name = "unknownMostDerived2AsBase";
const ::std::string iceC_Test_TestIntf_unknownMostDerived2AsBaseCompact_name = "unknownMostDerived2AsBaseCompact";
const ::std::string iceC_Test_TestIntf_knownPreservedAsBase_name = "knownPreservedAsBase";
const ::std::string iceC_Test_TestIntf_knownPreservedAsKnownPreserved_name = "knownPreservedAsKnownPreserved";
const ::std::string iceC_Test_TestIntf_relayKnownPreservedAsBase_name = "relayKnownPreservedAsBase";
const ::std::string iceC_Test_TestIntf_relayKnownPreservedAsKnownPreserved_name = "relayKnownPreservedAsKnownPreserved";
const ::std::string iceC_Test_TestIntf_unknownPreservedAsBase_name = "unknownPreservedAsBase";
const ::std::string iceC_Test_TestIntf_unknownPreservedAsKnownPreserved_name = "unknownPreservedAsKnownPreserved";
const ::std::string iceC_Test_TestIntf_relayUnknownPreservedAsBase_name = "relayUnknownPreservedAsBase";
const ::std::string iceC_Test_TestIntf_relayUnknownPreservedAsKnownPreserved_name = "relayUnknownPreservedAsKnownPreserved";
const ::std::string iceC_Test_TestIntf_shutdown_name = "shutdown";

const ::IceInternal::DefaultValueFactoryInit<::Test::PreservedClass> iceC_Test_PreservedClass_init("::Test::PreservedClass");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::Preserved1> iceC_Test_Preserved1_init("::Test::Preserved1");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::Preserved2> iceC_Test_Preserved2_init("::Test::Preserved2");

}

Test::Base::~Base()
{
}

const ::std::string&
Test::Base::ice_staticId()
{
    static const ::std::string typeId = "::Test::Base";
    return typeId;
}

Test::KnownDerived::~KnownDerived()
{
}

const ::std::string&
Test::KnownDerived::ice_staticId()
{
    static const ::std::string typeId = "::Test::KnownDerived";
    return typeId;
}

Test::KnownIntermediate::~KnownIntermediate()
{
}

const ::std::string&
Test::KnownIntermediate::ice_staticId()
{
    static const ::std::string typeId = "::Test::KnownIntermediate";
    return typeId;
}

Test::KnownMostDerived::~KnownMostDerived()
{
}

const ::std::string&
Test::KnownMostDerived::ice_staticId()
{
    static const ::std::string typeId = "::Test::KnownMostDerived";
    return typeId;
}

Test::KnownPreserved::~KnownPreserved()
{
}

const ::std::string&
Test::KnownPreserved::ice_staticId()
{
    static const ::std::string typeId = "::Test::KnownPreserved";
    return typeId;
}

::std::shared_ptr<::Ice::SlicedData>
Test::KnownPreserved::ice_getSlicedData() const
{
    return _slicedData;
}

/// \cond STREAM
void
Test::KnownPreserved::_write(::Ice::OutputStream* ostr) const
{
    ostr->startException(_slicedData);
    _writeImpl(ostr);
    ostr->endException();
}

void
Test::KnownPreserved::_read(::Ice::InputStream* istr)
{
    istr->startException();
    _readImpl(istr);
    _slicedData = istr->endException(true);
}
/// \endcond

Test::KnownPreservedDerived::~KnownPreservedDerived()
{
}

const ::std::string&
Test::KnownPreservedDerived::ice_staticId()
{
    static const ::std::string typeId = "::Test::KnownPreservedDerived";
    return typeId;
}

Test::Preserved1::~Preserved1()
{
}

const ::std::string&
Test::Preserved1::ice_staticId()
{
    static const ::std::string typeId = "::Test::Preserved1";
    return typeId;
}

/// \cond STREAM
bool
Test::Preserved1::_usesClasses() const
{
    return true;
}
/// \endcond

Test::Preserved2::~Preserved2()
{
}

const ::std::string&
Test::Preserved2::ice_staticId()
{
    static const ::std::string typeId = "::Test::Preserved2";
    return typeId;
}

bool
Test::Relay::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_Relay_ids, iceC_Test_Relay_ids + 2, s);
}

::std::vector<::std::string>
Test::Relay::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_Relay_ids[0], &iceC_Test_Relay_ids[2]);
}

::std::string
Test::Relay::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::Relay::ice_staticId()
{
    static const ::std::string typeId = "::Test::Relay";
    return typeId;
}

/// \cond INTERNAL
bool
Test::Relay::_iceD_knownPreservedAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->knownPreservedAsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::Relay::_iceD_knownPreservedAsKnownPreserved(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->knownPreservedAsKnownPreserved(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::Relay::_iceD_unknownPreservedAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->unknownPreservedAsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::Relay::_iceD_unknownPreservedAsKnownPreserved(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->unknownPreservedAsKnownPreserved(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::Relay::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_Relay_ops, iceC_Test_Relay_ops + 8, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_Relay_ops)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_knownPreservedAsBase(in, current);
        }
        case 5:
        {
            return _iceD_knownPreservedAsKnownPreserved(in, current);
        }
        case 6:
        {
            return _iceD_unknownPreservedAsBase(in, current);
        }
        case 7:
        {
            return _iceD_unknownPreservedAsKnownPreserved(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Test::TestIntf::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_TestIntf_ids, iceC_Test_TestIntf_ids + 2, s);
}

::std::vector<::std::string>
Test::TestIntf::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_TestIntf_ids[0], &iceC_Test_TestIntf_ids[2]);
}

::std::string
Test::TestIntf::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::TestIntf::ice_staticId()
{
    static const ::std::string typeId = "::Test::TestIntf";
    return typeId;
}

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_baseAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->baseAsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_unknownDerivedAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->unknownDerivedAsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_knownDerivedAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->knownDerivedAsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_knownDerivedAsKnownDerived(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->knownDerivedAsKnownDerived(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_unknownIntermediateAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->unknownIntermediateAsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_knownIntermediateAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->knownIntermediateAsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_knownMostDerivedAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->knownMostDerivedAsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_knownIntermediateAsKnownIntermediate(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->knownIntermediateAsKnownIntermediate(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_knownMostDerivedAsKnownIntermediate(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->knownMostDerivedAsKnownIntermediate(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_knownMostDerivedAsKnownMostDerived(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->knownMostDerivedAsKnownMostDerived(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_unknownMostDerived1AsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->unknownMostDerived1AsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_unknownMostDerived1AsKnownIntermediate(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->unknownMostDerived1AsKnownIntermediate(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_unknownMostDerived2AsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->unknownMostDerived2AsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_unknownMostDerived2AsBaseCompact(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::CompactFormat);
    this->unknownMostDerived2AsBaseCompact(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_knownPreservedAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->knownPreservedAsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_knownPreservedAsKnownPreserved(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->knownPreservedAsKnownPreserved(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_relayKnownPreservedAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<RelayPrx> iceP_r;
    istr->readAll(iceP_r);
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->relayKnownPreservedAsBase(::std::move(iceP_r), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_relayKnownPreservedAsKnownPreserved(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<RelayPrx> iceP_r;
    istr->readAll(iceP_r);
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->relayKnownPreservedAsKnownPreserved(::std::move(iceP_r), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_unknownPreservedAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->unknownPreservedAsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_unknownPreservedAsKnownPreserved(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->unknownPreservedAsKnownPreserved(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_relayUnknownPreservedAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<RelayPrx> iceP_r;
    istr->readAll(iceP_r);
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->relayUnknownPreservedAsBase(::std::move(iceP_r), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_relayUnknownPreservedAsKnownPreserved(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<RelayPrx> iceP_r;
    istr->readAll(iceP_r);
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->relayUnknownPreservedAsKnownPreserved(::std::move(iceP_r), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_shutdown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->shutdown(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_TestIntf_ops, iceC_Test_TestIntf_ops + 27, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_TestIntf_ops)
    {
        case 0:
        {
            return _iceD_baseAsBase(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        case 5:
        {
            return _iceD_knownDerivedAsBase(in, current);
        }
        case 6:
        {
            return _iceD_knownDerivedAsKnownDerived(in, current);
        }
        case 7:
        {
            return _iceD_knownIntermediateAsBase(in, current);
        }
        case 8:
        {
            return _iceD_knownIntermediateAsKnownIntermediate(in, current);
        }
        case 9:
        {
            return _iceD_knownMostDerivedAsBase(in, current);
        }
        case 10:
        {
            return _iceD_knownMostDerivedAsKnownIntermediate(in, current);
        }
        case 11:
        {
            return _iceD_knownMostDerivedAsKnownMostDerived(in, current);
        }
        case 12:
        {
            return _iceD_knownPreservedAsBase(in, current);
        }
        case 13:
        {
            return _iceD_knownPreservedAsKnownPreserved(in, current);
        }
        case 14:
        {
            return _iceD_relayKnownPreservedAsBase(in, current);
        }
        case 15:
        {
            return _iceD_relayKnownPreservedAsKnownPreserved(in, current);
        }
        case 16:
        {
            return _iceD_relayUnknownPreservedAsBase(in, current);
        }
        case 17:
        {
            return _iceD_relayUnknownPreservedAsKnownPreserved(in, current);
        }
        case 18:
        {
            return _iceD_shutdown(in, current);
        }
        case 19:
        {
            return _iceD_unknownDerivedAsBase(in, current);
        }
        case 20:
        {
            return _iceD_unknownIntermediateAsBase(in, current);
        }
        case 21:
        {
            return _iceD_unknownMostDerived1AsBase(in, current);
        }
        case 22:
        {
            return _iceD_unknownMostDerived1AsKnownIntermediate(in, current);
        }
        case 23:
        {
            return _iceD_unknownMostDerived2AsBase(in, current);
        }
        case 24:
        {
            return _iceD_unknownMostDerived2AsBaseCompact(in, current);
        }
        case 25:
        {
            return _iceD_unknownPreservedAsBase(in, current);
        }
        case 26:
        {
            return _iceD_unknownPreservedAsKnownPreserved(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

Test::BaseClass::~BaseClass()
{
}

::std::shared_ptr<::Ice::SlicedData>
Test::BaseClass::ice_getSlicedData() const
{
    return _iceSlicedData;
}

/// \cond STREAM
void
Test::BaseClass::_iceWrite(::Ice::OutputStream* ostr) const
{
    ostr->startValue(_iceSlicedData);
    _iceWriteImpl(ostr);
    ostr->endValue();
}

void
Test::BaseClass::_iceRead(::Ice::InputStream* istr)
{
    istr->startValue();
    _iceReadImpl(istr);
    _iceSlicedData = istr->endValue(true);
}
/// \endcond

const ::std::string&
Test::BaseClass::ice_staticId()
{
    static const ::std::string typeId = "::Test::BaseClass";
    return typeId;
}

Test::PreservedClass::~PreservedClass()
{
}

const ::std::string&
Test::PreservedClass::ice_staticId()
{
    static const ::std::string typeId = "::Test::PreservedClass";
    return typeId;
}

/// \cond INTERNAL
void
Test::RelayPrx::_iceI_knownPreservedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_Relay_knownPreservedAsBase_name);
    outAsync->invoke(iceC_Test_Relay_knownPreservedAsBase_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::RelayPrx::_iceI_knownPreservedAsKnownPreserved(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_Relay_knownPreservedAsKnownPreserved_name);
    outAsync->invoke(iceC_Test_Relay_knownPreservedAsKnownPreserved_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const KnownPreserved&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::RelayPrx::_iceI_unknownPreservedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_Relay_unknownPreservedAsBase_name);
    outAsync->invoke(iceC_Test_Relay_unknownPreservedAsBase_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::RelayPrx::_iceI_unknownPreservedAsKnownPreserved(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_Relay_unknownPreservedAsKnownPreserved_name);
    outAsync->invoke(iceC_Test_Relay_unknownPreservedAsKnownPreserved_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const KnownPreserved&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::RelayPrx::_newInstance() const
{
    return ::IceInternal::createProxy<RelayPrx>();
}
/// \endcond

const ::std::string&
Test::RelayPrx::ice_staticId()
{
    return Relay::ice_staticId();
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_baseAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_baseAsBase_name);
    outAsync->invoke(iceC_Test_TestIntf_baseAsBase_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_unknownDerivedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_unknownDerivedAsBase_name);
    outAsync->invoke(iceC_Test_TestIntf_unknownDerivedAsBase_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_knownDerivedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_knownDerivedAsBase_name);
    outAsync->invoke(iceC_Test_TestIntf_knownDerivedAsBase_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_knownDerivedAsKnownDerived(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_knownDerivedAsKnownDerived_name);
    outAsync->invoke(iceC_Test_TestIntf_knownDerivedAsKnownDerived_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const KnownDerived&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_unknownIntermediateAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_unknownIntermediateAsBase_name);
    outAsync->invoke(iceC_Test_TestIntf_unknownIntermediateAsBase_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_knownIntermediateAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_knownIntermediateAsBase_name);
    outAsync->invoke(iceC_Test_TestIntf_knownIntermediateAsBase_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_knownMostDerivedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_knownMostDerivedAsBase_name);
    outAsync->invoke(iceC_Test_TestIntf_knownMostDerivedAsBase_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_knownIntermediateAsKnownIntermediate(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_knownIntermediateAsKnownIntermediate_name);
    outAsync->invoke(iceC_Test_TestIntf_knownIntermediateAsKnownIntermediate_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const KnownIntermediate&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_knownMostDerivedAsKnownIntermediate(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_knownMostDerivedAsKnownIntermediate_name);
    outAsync->invoke(iceC_Test_TestIntf_knownMostDerivedAsKnownIntermediate_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const KnownIntermediate&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_knownMostDerivedAsKnownMostDerived(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_knownMostDerivedAsKnownMostDerived_name);
    outAsync->invoke(iceC_Test_TestIntf_knownMostDerivedAsKnownMostDerived_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const KnownMostDerived&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_unknownMostDerived1AsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_unknownMostDerived1AsBase_name);
    outAsync->invoke(iceC_Test_TestIntf_unknownMostDerived1AsBase_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_unknownMostDerived1AsKnownIntermediate(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_unknownMostDerived1AsKnownIntermediate_name);
    outAsync->invoke(iceC_Test_TestIntf_unknownMostDerived1AsKnownIntermediate_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const KnownIntermediate&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_unknownMostDerived2AsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_unknownMostDerived2AsBase_name);
    outAsync->invoke(iceC_Test_TestIntf_unknownMostDerived2AsBase_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_unknownMostDerived2AsBaseCompact(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_unknownMostDerived2AsBaseCompact_name);
    outAsync->invoke(iceC_Test_TestIntf_unknownMostDerived2AsBaseCompact_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::CompactFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_knownPreservedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_knownPreservedAsBase_name);
    outAsync->invoke(iceC_Test_TestIntf_knownPreservedAsBase_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_knownPreservedAsKnownPreserved(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_knownPreservedAsKnownPreserved_name);
    outAsync->invoke(iceC_Test_TestIntf_knownPreservedAsKnownPreserved_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const KnownPreserved&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_relayKnownPreservedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<RelayPrx>& iceP_r, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_relayKnownPreservedAsBase_name);
    outAsync->invoke(iceC_Test_TestIntf_relayKnownPreservedAsBase_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_r);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_relayKnownPreservedAsKnownPreserved(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<RelayPrx>& iceP_r, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_relayKnownPreservedAsKnownPreserved_name);
    outAsync->invoke(iceC_Test_TestIntf_relayKnownPreservedAsKnownPreserved_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_r);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const KnownPreserved&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_unknownPreservedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_unknownPreservedAsBase_name);
    outAsync->invoke(iceC_Test_TestIntf_unknownPreservedAsBase_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_unknownPreservedAsKnownPreserved(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_unknownPreservedAsKnownPreserved_name);
    outAsync->invoke(iceC_Test_TestIntf_unknownPreservedAsKnownPreserved_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const KnownPreserved&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_relayUnknownPreservedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<RelayPrx>& iceP_r, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_relayUnknownPreservedAsBase_name);
    outAsync->invoke(iceC_Test_TestIntf_relayUnknownPreservedAsBase_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_r);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const Base&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_relayUnknownPreservedAsKnownPreserved(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<RelayPrx>& iceP_r, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_relayUnknownPreservedAsKnownPreserved_name);
    outAsync->invoke(iceC_Test_TestIntf_relayUnknownPreservedAsKnownPreserved_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_r);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const KnownPreserved&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_TestIntf_shutdown_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::TestIntfPrx::_newInstance() const
{
    return ::IceInternal::createProxy<TestIntfPrx>();
}
/// \endcond

const ::std::string&
Test::TestIntfPrx::ice_staticId()
{
    return TestIntf::ice_staticId();
}

#else // C++98 mapping

namespace
{

const ::std::string iceC_Test_Relay_knownPreservedAsBase_name = "knownPreservedAsBase";

const ::std::string iceC_Test_Relay_knownPreservedAsKnownPreserved_name = "knownPreservedAsKnownPreserved";

const ::std::string iceC_Test_Relay_unknownPreservedAsBase_name = "unknownPreservedAsBase";

const ::std::string iceC_Test_Relay_unknownPreservedAsKnownPreserved_name = "unknownPreservedAsKnownPreserved";

const ::std::string iceC_Test_TestIntf_baseAsBase_name = "baseAsBase";

const ::std::string iceC_Test_TestIntf_unknownDerivedAsBase_name = "unknownDerivedAsBase";

const ::std::string iceC_Test_TestIntf_knownDerivedAsBase_name = "knownDerivedAsBase";

const ::std::string iceC_Test_TestIntf_knownDerivedAsKnownDerived_name = "knownDerivedAsKnownDerived";

const ::std::string iceC_Test_TestIntf_unknownIntermediateAsBase_name = "unknownIntermediateAsBase";

const ::std::string iceC_Test_TestIntf_knownIntermediateAsBase_name = "knownIntermediateAsBase";

const ::std::string iceC_Test_TestIntf_knownMostDerivedAsBase_name = "knownMostDerivedAsBase";

const ::std::string iceC_Test_TestIntf_knownIntermediateAsKnownIntermediate_name = "knownIntermediateAsKnownIntermediate";

const ::std::string iceC_Test_TestIntf_knownMostDerivedAsKnownIntermediate_name = "knownMostDerivedAsKnownIntermediate";

const ::std::string iceC_Test_TestIntf_knownMostDerivedAsKnownMostDerived_name = "knownMostDerivedAsKnownMostDerived";

const ::std::string iceC_Test_TestIntf_unknownMostDerived1AsBase_name = "unknownMostDerived1AsBase";

const ::std::string iceC_Test_TestIntf_unknownMostDerived1AsKnownIntermediate_name = "unknownMostDerived1AsKnownIntermediate";

const ::std::string iceC_Test_TestIntf_unknownMostDerived2AsBase_name = "unknownMostDerived2AsBase";

const ::std::string iceC_Test_TestIntf_unknownMostDerived2AsBaseCompact_name = "unknownMostDerived2AsBaseCompact";

const ::std::string iceC_Test_TestIntf_knownPreservedAsBase_name = "knownPreservedAsBase";

const ::std::string iceC_Test_TestIntf_knownPreservedAsKnownPreserved_name = "knownPreservedAsKnownPreserved";

const ::std::string iceC_Test_TestIntf_relayKnownPreservedAsBase_name = "relayKnownPreservedAsBase";

const ::std::string iceC_Test_TestIntf_relayKnownPreservedAsKnownPreserved_name = "relayKnownPreservedAsKnownPreserved";

const ::std::string iceC_Test_TestIntf_unknownPreservedAsBase_name = "unknownPreservedAsBase";

const ::std::string iceC_Test_TestIntf_unknownPreservedAsKnownPreserved_name = "unknownPreservedAsKnownPreserved";

const ::std::string iceC_Test_TestIntf_relayUnknownPreservedAsBase_name = "relayUnknownPreservedAsBase";

const ::std::string iceC_Test_TestIntf_relayUnknownPreservedAsKnownPreserved_name = "relayUnknownPreservedAsKnownPreserved";

const ::std::string iceC_Test_TestIntf_shutdown_name = "shutdown";

}

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Test::Base> iceC_Test_Base_init("::Test::Base");

}

Test::Base::Base(const ::std::string& b) :
    ::Ice::UserException(),
    b(b)
{
}
Test::Base::~Base()
{
}

::std::string
Test::Base::ice_id() const
{
    return "::Test::Base";
}

Test::Base*
Test::Base::ice_clone() const
{
    return new Base(*this);
}

void
Test::Base::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Test::Base::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Test::Base", -1, true);
    ::Ice::StreamWriter< Base, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::Base::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Base, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Test::KnownDerived> iceC_Test_KnownDerived_init("::Test::KnownDerived");

}

Test::KnownDerived::KnownDerived(const ::std::string& b, const ::std::string& kd) :
    Base(b),
    kd(kd)
{
}
Test::KnownDerived::~KnownDerived()
{
}

::std::string
Test::KnownDerived::ice_id() const
{
    return "::Test::KnownDerived";
}

Test::KnownDerived*
Test::KnownDerived::ice_clone() const
{
    return new KnownDerived(*this);
}

void
Test::KnownDerived::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Test::KnownDerived::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Test::KnownDerived", -1, false);
    ::Ice::StreamWriter< KnownDerived, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    Base::_writeImpl(ostr);
}

void
Test::KnownDerived::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< KnownDerived, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    Base::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Test::KnownIntermediate> iceC_Test_KnownIntermediate_init("::Test::KnownIntermediate");

}

Test::KnownIntermediate::KnownIntermediate(const ::std::string& b, const ::std::string& ki) :
    Base(b),
    ki(ki)
{
}
Test::KnownIntermediate::~KnownIntermediate()
{
}

::std::string
Test::KnownIntermediate::ice_id() const
{
    return "::Test::KnownIntermediate";
}

Test::KnownIntermediate*
Test::KnownIntermediate::ice_clone() const
{
    return new KnownIntermediate(*this);
}

void
Test::KnownIntermediate::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Test::KnownIntermediate::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Test::KnownIntermediate", -1, false);
    ::Ice::StreamWriter< KnownIntermediate, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    Base::_writeImpl(ostr);
}

void
Test::KnownIntermediate::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< KnownIntermediate, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    Base::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Test::KnownMostDerived> iceC_Test_KnownMostDerived_init("::Test::KnownMostDerived");

}

Test::KnownMostDerived::KnownMostDerived(const ::std::string& b, const ::std::string& ki, const ::std::string& kmd) :
    KnownIntermediate(b, ki),
    kmd(kmd)
{
}
Test::KnownMostDerived::~KnownMostDerived()
{
}

::std::string
Test::KnownMostDerived::ice_id() const
{
    return "::Test::KnownMostDerived";
}

Test::KnownMostDerived*
Test::KnownMostDerived::ice_clone() const
{
    return new KnownMostDerived(*this);
}

void
Test::KnownMostDerived::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Test::KnownMostDerived::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Test::KnownMostDerived", -1, false);
    ::Ice::StreamWriter< KnownMostDerived, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    KnownIntermediate::_writeImpl(ostr);
}

void
Test::KnownMostDerived::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< KnownMostDerived, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    KnownIntermediate::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Test::KnownPreserved> iceC_Test_KnownPreserved_init("::Test::KnownPreserved");

}

Test::KnownPreserved::KnownPreserved(const ::std::string& b, const ::std::string& kp) :
    Base(b),
    kp(kp)
{
}
Test::KnownPreserved::~KnownPreserved()
{
}

::std::string
Test::KnownPreserved::ice_id() const
{
    return "::Test::KnownPreserved";
}

Test::KnownPreserved*
Test::KnownPreserved::ice_clone() const
{
    return new KnownPreserved(*this);
}

void
Test::KnownPreserved::ice_throw() const
{
    throw *this;
}

::Ice::SlicedDataPtr
Test::KnownPreserved::ice_getSlicedData() const
{
    return _slicedData;
}

void
Test::KnownPreserved::_write(::Ice::OutputStream* ostr) const
{
    ostr->startException(_slicedData);
    _writeImpl(ostr);
    ostr->endException();
}

void
Test::KnownPreserved::_read(::Ice::InputStream* istr)
{
    istr->startException();
    _readImpl(istr);
    _slicedData = istr->endException(true);
}

/// \cond STREAM
void
Test::KnownPreserved::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Test::KnownPreserved", -1, false);
    ::Ice::StreamWriter< KnownPreserved, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    Base::_writeImpl(ostr);
}

void
Test::KnownPreserved::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< KnownPreserved, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    Base::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Test::KnownPreservedDerived> iceC_Test_KnownPreservedDerived_init("::Test::KnownPreservedDerived");

}

Test::KnownPreservedDerived::KnownPreservedDerived(const ::std::string& b, const ::std::string& kp, const ::std::string& kpd) :
    KnownPreserved(b, kp),
    kpd(kpd)
{
}
Test::KnownPreservedDerived::~KnownPreservedDerived()
{
}

::std::string
Test::KnownPreservedDerived::ice_id() const
{
    return "::Test::KnownPreservedDerived";
}

Test::KnownPreservedDerived*
Test::KnownPreservedDerived::ice_clone() const
{
    return new KnownPreservedDerived(*this);
}

void
Test::KnownPreservedDerived::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Test::KnownPreservedDerived::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Test::KnownPreservedDerived", -1, false);
    ::Ice::StreamWriter< KnownPreservedDerived, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    KnownPreserved::_writeImpl(ostr);
}

void
Test::KnownPreservedDerived::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< KnownPreservedDerived, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    KnownPreserved::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Test::Preserved1> iceC_Test_Preserved1_init("::Test::Preserved1");

}

Test::Preserved1::Preserved1(const ::std::string& b, const ::std::string& kp, const ::std::string& kpd, const BaseClassPtr& p1) :
    KnownPreservedDerived(b, kp, kpd),
    p1(p1)
{
}
Test::Preserved1::~Preserved1()
{
}

::std::string
Test::Preserved1::ice_id() const
{
    return "::Test::Preserved1";
}

Test::Preserved1*
Test::Preserved1::ice_clone() const
{
    return new Preserved1(*this);
}

void
Test::Preserved1::ice_throw() const
{
    throw *this;
}

bool
Test::Preserved1::_usesClasses() const
{
    return true;
}

/// \cond STREAM
void
Test::Preserved1::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Test::Preserved1", -1, false);
    ::Ice::StreamWriter< Preserved1, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    KnownPreservedDerived::_writeImpl(ostr);
}

void
Test::Preserved1::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Preserved1, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    KnownPreservedDerived::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Test::Preserved2> iceC_Test_Preserved2_init("::Test::Preserved2");

}

Test::Preserved2::Preserved2(const ::std::string& b, const ::std::string& kp, const ::std::string& kpd, const BaseClassPtr& p1, const BaseClassPtr& p2) :
    Preserved1(b, kp, kpd, p1),
    p2(p2)
{
}
Test::Preserved2::~Preserved2()
{
}

::std::string
Test::Preserved2::ice_id() const
{
    return "::Test::Preserved2";
}

Test::Preserved2*
Test::Preserved2::ice_clone() const
{
    return new Preserved2(*this);
}

void
Test::Preserved2::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Test::Preserved2::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Test::Preserved2", -1, false);
    ::Ice::StreamWriter< Preserved2, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    Preserved1::_writeImpl(ostr);
}

void
Test::Preserved2::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Preserved2, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    Preserved1::_readImpl(istr);
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(Relay* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Relay>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Relay;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Test::Relay::_iceI_begin_knownPreservedAsBase(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_Relay_knownPreservedAsBase_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_Relay_knownPreservedAsBase_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_Relay_knownPreservedAsBase_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_Relay_knownPreservedAsBase_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::Relay::end_knownPreservedAsBase(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_Relay_knownPreservedAsBase_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Base&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::Relay::_iceI_begin_knownPreservedAsKnownPreserved(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_Relay_knownPreservedAsKnownPreserved_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_Relay_knownPreservedAsKnownPreserved_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_Relay_knownPreservedAsKnownPreserved_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_Relay_knownPreservedAsKnownPreserved_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::Relay::end_knownPreservedAsKnownPreserved(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_Relay_knownPreservedAsKnownPreserved_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::KnownPreserved&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::Relay::_iceI_begin_unknownPreservedAsBase(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_Relay_unknownPreservedAsBase_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_Relay_unknownPreservedAsBase_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_Relay_unknownPreservedAsBase_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_Relay_unknownPreservedAsBase_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::Relay::end_unknownPreservedAsBase(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_Relay_unknownPreservedAsBase_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Base&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::Relay::_iceI_begin_unknownPreservedAsKnownPreserved(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_Relay_unknownPreservedAsKnownPreserved_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_Relay_unknownPreservedAsKnownPreserved_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_Relay_unknownPreservedAsKnownPreserved_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_Relay_unknownPreservedAsKnownPreserved_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::Relay::end_unknownPreservedAsKnownPreserved(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_Relay_unknownPreservedAsKnownPreserved_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::KnownPreserved&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::Relay::_newInstance() const
{
    return new Relay;
}
/// \endcond

const ::std::string&
IceProxy::Test::Relay::ice_staticId()
{
    return ::Test::Relay::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(TestIntf* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< TestIntf>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new TestIntf;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_baseAsBase(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_baseAsBase_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_baseAsBase_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_baseAsBase_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_baseAsBase_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_baseAsBase(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_baseAsBase_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Base&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_unknownDerivedAsBase(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_unknownDerivedAsBase_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_unknownDerivedAsBase_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_unknownDerivedAsBase_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_unknownDerivedAsBase_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_unknownDerivedAsBase(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_unknownDerivedAsBase_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Base&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_knownDerivedAsBase(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_knownDerivedAsBase_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_knownDerivedAsBase_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_knownDerivedAsBase_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_knownDerivedAsBase_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_knownDerivedAsBase(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_knownDerivedAsBase_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Base&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_knownDerivedAsKnownDerived(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_knownDerivedAsKnownDerived_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_knownDerivedAsKnownDerived_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_knownDerivedAsKnownDerived_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_knownDerivedAsKnownDerived_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_knownDerivedAsKnownDerived(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_knownDerivedAsKnownDerived_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::KnownDerived&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_unknownIntermediateAsBase(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_unknownIntermediateAsBase_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_unknownIntermediateAsBase_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_unknownIntermediateAsBase_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_unknownIntermediateAsBase_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_unknownIntermediateAsBase(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_unknownIntermediateAsBase_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Base&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_knownIntermediateAsBase(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_knownIntermediateAsBase_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_knownIntermediateAsBase_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_knownIntermediateAsBase_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_knownIntermediateAsBase_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_knownIntermediateAsBase(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_knownIntermediateAsBase_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Base&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_knownMostDerivedAsBase(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_knownMostDerivedAsBase_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_knownMostDerivedAsBase_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_knownMostDerivedAsBase_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_knownMostDerivedAsBase_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_knownMostDerivedAsBase(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_knownMostDerivedAsBase_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Base&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_knownIntermediateAsKnownIntermediate(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_knownIntermediateAsKnownIntermediate_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_knownIntermediateAsKnownIntermediate_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_knownIntermediateAsKnownIntermediate_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_knownIntermediateAsKnownIntermediate_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_knownIntermediateAsKnownIntermediate(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_knownIntermediateAsKnownIntermediate_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::KnownIntermediate&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_knownMostDerivedAsKnownIntermediate(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_knownMostDerivedAsKnownIntermediate_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_knownMostDerivedAsKnownIntermediate_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_knownMostDerivedAsKnownIntermediate_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_knownMostDerivedAsKnownIntermediate_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_knownMostDerivedAsKnownIntermediate(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_knownMostDerivedAsKnownIntermediate_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::KnownIntermediate&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_knownMostDerivedAsKnownMostDerived(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_knownMostDerivedAsKnownMostDerived_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_knownMostDerivedAsKnownMostDerived_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_knownMostDerivedAsKnownMostDerived_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_knownMostDerivedAsKnownMostDerived_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_knownMostDerivedAsKnownMostDerived(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_knownMostDerivedAsKnownMostDerived_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::KnownMostDerived&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_unknownMostDerived1AsBase(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_unknownMostDerived1AsBase_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_unknownMostDerived1AsBase_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_unknownMostDerived1AsBase_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_unknownMostDerived1AsBase_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_unknownMostDerived1AsBase(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_unknownMostDerived1AsBase_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Base&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_unknownMostDerived1AsKnownIntermediate(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_unknownMostDerived1AsKnownIntermediate_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_unknownMostDerived1AsKnownIntermediate_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_unknownMostDerived1AsKnownIntermediate_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_unknownMostDerived1AsKnownIntermediate_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_unknownMostDerived1AsKnownIntermediate(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_unknownMostDerived1AsKnownIntermediate_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::KnownIntermediate&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_unknownMostDerived2AsBase(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_unknownMostDerived2AsBase_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_unknownMostDerived2AsBase_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_unknownMostDerived2AsBase_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_unknownMostDerived2AsBase_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_unknownMostDerived2AsBase(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_unknownMostDerived2AsBase_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Base&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_unknownMostDerived2AsBaseCompact(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_unknownMostDerived2AsBaseCompact_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_unknownMostDerived2AsBaseCompact_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_unknownMostDerived2AsBaseCompact_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_unknownMostDerived2AsBaseCompact_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_unknownMostDerived2AsBaseCompact(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_unknownMostDerived2AsBaseCompact_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Base&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_knownPreservedAsBase(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_knownPreservedAsBase_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_knownPreservedAsBase_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_knownPreservedAsBase_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_knownPreservedAsBase_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_knownPreservedAsBase(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_knownPreservedAsBase_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Base&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_knownPreservedAsKnownPreserved(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_knownPreservedAsKnownPreserved_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_knownPreservedAsKnownPreserved_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_knownPreservedAsKnownPreserved_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_knownPreservedAsKnownPreserved_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_knownPreservedAsKnownPreserved(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_knownPreservedAsKnownPreserved_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::KnownPreserved&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_relayKnownPreservedAsBase(const ::Test::RelayPrx& iceP_r, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_relayKnownPreservedAsBase_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_relayKnownPreservedAsBase_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_relayKnownPreservedAsBase_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::SlicedFormat);
        ostr->write(iceP_r);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_relayKnownPreservedAsBase_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_relayKnownPreservedAsBase(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_relayKnownPreservedAsBase_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Base&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_relayKnownPreservedAsKnownPreserved(const ::Test::RelayPrx& iceP_r, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_relayKnownPreservedAsKnownPreserved_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_relayKnownPreservedAsKnownPreserved_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_relayKnownPreservedAsKnownPreserved_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::SlicedFormat);
        ostr->write(iceP_r);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_relayKnownPreservedAsKnownPreserved_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_relayKnownPreservedAsKnownPreserved(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_relayKnownPreservedAsKnownPreserved_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::KnownPreserved&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_unknownPreservedAsBase(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_unknownPreservedAsBase_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_unknownPreservedAsBase_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_unknownPreservedAsBase_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_unknownPreservedAsBase_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_unknownPreservedAsBase(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_unknownPreservedAsBase_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Base&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_unknownPreservedAsKnownPreserved(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_unknownPreservedAsKnownPreserved_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_unknownPreservedAsKnownPreserved_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_unknownPreservedAsKnownPreserved_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_unknownPreservedAsKnownPreserved_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_unknownPreservedAsKnownPreserved(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_unknownPreservedAsKnownPreserved_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::KnownPreserved&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_relayUnknownPreservedAsBase(const ::Test::RelayPrx& iceP_r, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_relayUnknownPreservedAsBase_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_relayUnknownPreservedAsBase_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_relayUnknownPreservedAsBase_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::SlicedFormat);
        ostr->write(iceP_r);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_relayUnknownPreservedAsBase_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_relayUnknownPreservedAsBase(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_relayUnknownPreservedAsBase_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Base&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_relayUnknownPreservedAsKnownPreserved(const ::Test::RelayPrx& iceP_r, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_relayUnknownPreservedAsKnownPreserved_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_relayUnknownPreservedAsKnownPreserved_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_relayUnknownPreservedAsKnownPreserved_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::SlicedFormat);
        ostr->write(iceP_r);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_relayUnknownPreservedAsKnownPreserved_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_relayUnknownPreservedAsKnownPreserved(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_relayUnknownPreservedAsKnownPreserved_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::KnownPreserved&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_shutdown(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_shutdown_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_shutdown_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_shutdown_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_shutdown(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_TestIntf_shutdown_name);
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::TestIntf::_newInstance() const
{
    return new TestIntf;
}
/// \endcond

const ::std::string&
IceProxy::Test::TestIntf::ice_staticId()
{
    return ::Test::TestIntf::ice_staticId();
}

Test::Relay::~Relay()
{
}

namespace
{
const ::std::string iceC_Test_Relay_ids[2] =
{
    "::Ice::Object",
    "::Test::Relay"
};

}

bool
Test::Relay::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_Relay_ids, iceC_Test_Relay_ids + 2, s);
}

::std::vector< ::std::string>
Test::Relay::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_Relay_ids[0], &iceC_Test_Relay_ids[2]);
}

const ::std::string&
Test::Relay::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::Relay::ice_staticId()
{
    static const ::std::string typeId = "::Test::Relay";
    return typeId;
}

/// \cond INTERNAL
bool
Test::Relay::_iceD_knownPreservedAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->knownPreservedAsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::Relay::_iceD_knownPreservedAsKnownPreserved(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->knownPreservedAsKnownPreserved(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::Relay::_iceD_unknownPreservedAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->unknownPreservedAsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::Relay::_iceD_unknownPreservedAsKnownPreserved(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->unknownPreservedAsKnownPreserved(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Test_Relay_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "knownPreservedAsBase",
    "knownPreservedAsKnownPreserved",
    "unknownPreservedAsBase",
    "unknownPreservedAsKnownPreserved"
};

}

/// \cond INTERNAL
bool
Test::Relay::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_Relay_all, iceC_Test_Relay_all + 8, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_Relay_all)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_knownPreservedAsBase(in, current);
        }
        case 5:
        {
            return _iceD_knownPreservedAsKnownPreserved(in, current);
        }
        case 6:
        {
            return _iceD_unknownPreservedAsBase(in, current);
        }
        case 7:
        {
            return _iceD_unknownPreservedAsKnownPreserved(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

Test::TestIntf::~TestIntf()
{
}

namespace
{
const ::std::string iceC_Test_TestIntf_ids[2] =
{
    "::Ice::Object",
    "::Test::TestIntf"
};

}

bool
Test::TestIntf::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_TestIntf_ids, iceC_Test_TestIntf_ids + 2, s);
}

::std::vector< ::std::string>
Test::TestIntf::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_TestIntf_ids[0], &iceC_Test_TestIntf_ids[2]);
}

const ::std::string&
Test::TestIntf::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::TestIntf::ice_staticId()
{
    static const ::std::string typeId = "::Test::TestIntf";
    return typeId;
}

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_baseAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->baseAsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_unknownDerivedAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->unknownDerivedAsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_knownDerivedAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->knownDerivedAsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_knownDerivedAsKnownDerived(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->knownDerivedAsKnownDerived(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_unknownIntermediateAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->unknownIntermediateAsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_knownIntermediateAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->knownIntermediateAsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_knownMostDerivedAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->knownMostDerivedAsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_knownIntermediateAsKnownIntermediate(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->knownIntermediateAsKnownIntermediate(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_knownMostDerivedAsKnownIntermediate(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->knownMostDerivedAsKnownIntermediate(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_knownMostDerivedAsKnownMostDerived(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->knownMostDerivedAsKnownMostDerived(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_unknownMostDerived1AsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->unknownMostDerived1AsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_unknownMostDerived1AsKnownIntermediate(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->unknownMostDerived1AsKnownIntermediate(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_unknownMostDerived2AsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->unknownMostDerived2AsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_unknownMostDerived2AsBaseCompact(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::CompactFormat);
    this->unknownMostDerived2AsBaseCompact(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_knownPreservedAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->knownPreservedAsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_knownPreservedAsKnownPreserved(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->knownPreservedAsKnownPreserved(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_relayKnownPreservedAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    RelayPrx iceP_r;
    istr->read(iceP_r);
    inS.endReadParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->relayKnownPreservedAsBase(iceP_r, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_relayKnownPreservedAsKnownPreserved(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    RelayPrx iceP_r;
    istr->read(iceP_r);
    inS.endReadParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->relayKnownPreservedAsKnownPreserved(iceP_r, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_unknownPreservedAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->unknownPreservedAsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_unknownPreservedAsKnownPreserved(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->unknownPreservedAsKnownPreserved(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_relayUnknownPreservedAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    RelayPrx iceP_r;
    istr->read(iceP_r);
    inS.endReadParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->relayUnknownPreservedAsBase(iceP_r, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_relayUnknownPreservedAsKnownPreserved(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    RelayPrx iceP_r;
    istr->read(iceP_r);
    inS.endReadParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->relayUnknownPreservedAsKnownPreserved(iceP_r, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_shutdown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->shutdown(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Test_TestIntf_all[] =
{
    "baseAsBase",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "knownDerivedAsBase",
    "knownDerivedAsKnownDerived",
    "knownIntermediateAsBase",
    "knownIntermediateAsKnownIntermediate",
    "knownMostDerivedAsBase",
    "knownMostDerivedAsKnownIntermediate",
    "knownMostDerivedAsKnownMostDerived",
    "knownPreservedAsBase",
    "knownPreservedAsKnownPreserved",
    "relayKnownPreservedAsBase",
    "relayKnownPreservedAsKnownPreserved",
    "relayUnknownPreservedAsBase",
    "relayUnknownPreservedAsKnownPreserved",
    "shutdown",
    "unknownDerivedAsBase",
    "unknownIntermediateAsBase",
    "unknownMostDerived1AsBase",
    "unknownMostDerived1AsKnownIntermediate",
    "unknownMostDerived2AsBase",
    "unknownMostDerived2AsBaseCompact",
    "unknownPreservedAsBase",
    "unknownPreservedAsKnownPreserved"
};

}

/// \cond INTERNAL
bool
Test::TestIntf::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_TestIntf_all, iceC_Test_TestIntf_all + 27, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_TestIntf_all)
    {
        case 0:
        {
            return _iceD_baseAsBase(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        case 5:
        {
            return _iceD_knownDerivedAsBase(in, current);
        }
        case 6:
        {
            return _iceD_knownDerivedAsKnownDerived(in, current);
        }
        case 7:
        {
            return _iceD_knownIntermediateAsBase(in, current);
        }
        case 8:
        {
            return _iceD_knownIntermediateAsKnownIntermediate(in, current);
        }
        case 9:
        {
            return _iceD_knownMostDerivedAsBase(in, current);
        }
        case 10:
        {
            return _iceD_knownMostDerivedAsKnownIntermediate(in, current);
        }
        case 11:
        {
            return _iceD_knownMostDerivedAsKnownMostDerived(in, current);
        }
        case 12:
        {
            return _iceD_knownPreservedAsBase(in, current);
        }
        case 13:
        {
            return _iceD_knownPreservedAsKnownPreserved(in, current);
        }
        case 14:
        {
            return _iceD_relayKnownPreservedAsBase(in, current);
        }
        case 15:
        {
            return _iceD_relayKnownPreservedAsKnownPreserved(in, current);
        }
        case 16:
        {
            return _iceD_relayUnknownPreservedAsBase(in, current);
        }
        case 17:
        {
            return _iceD_relayUnknownPreservedAsKnownPreserved(in, current);
        }
        case 18:
        {
            return _iceD_shutdown(in, current);
        }
        case 19:
        {
            return _iceD_unknownDerivedAsBase(in, current);
        }
        case 20:
        {
            return _iceD_unknownIntermediateAsBase(in, current);
        }
        case 21:
        {
            return _iceD_unknownMostDerived1AsBase(in, current);
        }
        case 22:
        {
            return _iceD_unknownMostDerived1AsKnownIntermediate(in, current);
        }
        case 23:
        {
            return _iceD_unknownMostDerived2AsBase(in, current);
        }
        case 24:
        {
            return _iceD_unknownMostDerived2AsBaseCompact(in, current);
        }
        case 25:
        {
            return _iceD_unknownPreservedAsBase(in, current);
        }
        case 26:
        {
            return _iceD_unknownPreservedAsKnownPreserved(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

Test::BaseClass::~BaseClass()
{
}

/// \cond INTERNAL
::Ice::Value* Test::upCast(BaseClass* p) { return p; }

/// \endcond

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4589)
#endif
::Ice::ValuePtr
Test::BaseClass::ice_clone() const
{
    ::Ice::Value* p = new BaseClass(*this);
    return p;
}
#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

std::string
Test::BaseClass::ice_id() const
{
    return ice_staticId();
}

const ::std::string&
Test::BaseClass::ice_staticId()
{
    static const ::std::string typeId = "::Test::BaseClass";
    return typeId;
}

void
Test::BaseClass::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    if(_iceSlicedData)
    {
        _iceSlicedData->_iceGcVisitMembers(v_);
    }
}

::Ice::SlicedDataPtr
Test::BaseClass::ice_getSlicedData() const
{
    return _iceSlicedData;
}

void
Test::BaseClass::_iceWrite(::Ice::OutputStream*ostr) const
{
    ostr->startValue(_iceSlicedData);
    _iceWriteImpl(ostr);
    ostr->endValue();
}

void
Test::BaseClass::_iceRead(::Ice::InputStream* istr)
{
    istr->startValue();
    _iceReadImpl(istr);
    _iceSlicedData = istr->endValue(true);
}

/// \cond STREAM
void
Test::BaseClass::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< BaseClass, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::BaseClass::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< BaseClass, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::BaseClass> iceC_Test_BaseClass_init("::Test::BaseClass");
}

::Ice::ValueFactoryPtr
Test::BaseClass::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::BaseClass::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchValuePtr(BaseClassPtr& handle, const ::Ice::ValuePtr& v)
{
    handle = BaseClassPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(BaseClass::ice_staticId(), v);
    }
}
/// \endcond

Test::PreservedClass::~PreservedClass()
{
}

/// \cond INTERNAL
::Ice::Value* Test::upCast(PreservedClass* p) { return p; }

/// \endcond

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4589)
#endif
::Ice::ValuePtr
Test::PreservedClass::ice_clone() const
{
    ::Ice::Value* p = new PreservedClass(*this);
    return p;
}
#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

std::string
Test::PreservedClass::ice_id() const
{
    return ice_staticId();
}

const ::std::string&
Test::PreservedClass::ice_staticId()
{
    static const ::std::string typeId = "::Test::PreservedClass";
    return typeId;
}

/// \cond STREAM
void
Test::PreservedClass::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, false);
    ::Ice::StreamWriter< PreservedClass, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    BaseClass::_iceWriteImpl(ostr);
}

void
Test::PreservedClass::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< PreservedClass, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    BaseClass::_iceReadImpl(istr);
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::PreservedClass> iceC_Test_PreservedClass_init("::Test::PreservedClass");
}

::Ice::ValueFactoryPtr
Test::PreservedClass::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::PreservedClass::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchValuePtr(PreservedClassPtr& handle, const ::Ice::ValuePtr& v)
{
    handle = PreservedClassPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(PreservedClass::ice_staticId(), v);
    }
}
/// \endcond

namespace Ice
{
}

#endif
