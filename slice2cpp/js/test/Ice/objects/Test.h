//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.9
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Test_h__
#define __Test_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/IncomingAsync.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <Ice/ExceptionHelpers.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 9
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace Test
{

class Base;
class AbstractBase;
class AbstractBasePrx;
class B;
class C;
class A;
class D;
class E;
class F;
class G;
class I;
class IPrx;
class J;
class JPrx;
class H;
class HPrx;
class N;
class CompactExt;
class Compact;
class A1;
class B1;
class D1;

namespace Inner
{

class A;

namespace Sub
{

class A;

}

}
class Recursive;
class K;
class L;
class M;
class F1;
class F2;
class F2Prx;
class F3;
class Initial;
class InitialPrx;
class Empty;
class AlsoEmpty;
class UnexpectedObjectExceptionTest;
class UnexpectedObjectExceptionTestPrx;
class COneMember;
class CTwoMembers;
class Echo;
class EchoPrx;

}

namespace Test
{

struct S
{
    ::std::string str;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(str);
    }
};

using BaseSeq = ::std::vector<::std::shared_ptr<Base>>;

constexpr int CompactExtId = 789;

class EBase : public ::Ice::UserExceptionHelper<EBase, ::Ice::UserException>
{
public:

    virtual ~EBase();

    EBase(const EBase&) = default;

    EBase() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    EBase(const ::std::shared_ptr<A1>& a1, const ::std::shared_ptr<A1>& a2) :
        a1(a1),
        a2(a2)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::A1>&, const ::std::shared_ptr<::Test::A1>&> ice_tuple() const
    {
        return std::tie(a1, a2);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /// \cond STREAM
    virtual bool _usesClasses() const override;
    /// \endcond

    ::std::shared_ptr<::Test::A1> a1;
    ::std::shared_ptr<::Test::A1> a2;
};

/// \cond INTERNAL
static EBase _iceS_EBase_init;
/// \endcond

class EDerived : public ::Ice::UserExceptionHelper<EDerived, EBase>
{
public:

    virtual ~EDerived();

    EDerived(const EDerived&) = default;

    EDerived() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    EDerived(const ::std::shared_ptr<A1>& a1, const ::std::shared_ptr<A1>& a2, const ::std::shared_ptr<A1>& a3, const ::std::shared_ptr<A1>& a4) :
        ::Ice::UserExceptionHelper<EDerived, EBase>(a1, a2),
        a3(a3),
        a4(a4)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::A1>&, const ::std::shared_ptr<::Test::A1>&, const ::std::shared_ptr<::Test::A1>&, const ::std::shared_ptr<::Test::A1>&> ice_tuple() const
    {
        return std::tie(a1, a2, a3, a4);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::A1> a3;
    ::std::shared_ptr<::Test::A1> a4;
};

namespace Inner
{

class Ex : public ::Ice::UserExceptionHelper<Ex, ::Ice::UserException>
{
public:

    virtual ~Ex();

    Ex(const Ex&) = default;

    Ex() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Ex(const ::std::string& reason) :
        reason(reason)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(reason);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string reason;
};

namespace Sub
{

class Ex : public ::Ice::UserExceptionHelper<Ex, ::Ice::UserException>
{
public:

    virtual ~Ex();

    Ex(const Ex&) = default;

    Ex() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Ex(const ::std::string& reason) :
        reason(reason)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(reason);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string reason;
};

}

}

using ValueSeq = ::std::vector<::std::shared_ptr<::Ice::Value>>;

using ValueMap = ::std::map<::std::string, ::std::shared_ptr<::Ice::Value>>;

struct StructKey
{
    int i;
    ::std::string s;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::std::string&> ice_tuple() const
    {
        return std::tie(i, s);
    }
};

using LMap = ::std::map<StructKey, ::std::shared_ptr<L>>;

class EOneMember : public ::Ice::UserExceptionHelper<EOneMember, ::Ice::UserException>
{
public:

    virtual ~EOneMember();

    EOneMember(const EOneMember&) = default;

    EOneMember() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    EOneMember(const ::std::shared_ptr<Empty>& e) :
        e(e)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::Empty>&> ice_tuple() const
    {
        return std::tie(e);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /// \cond STREAM
    virtual bool _usesClasses() const override;
    /// \endcond

    ::std::shared_ptr<::Test::Empty> e;
};

class ETwoMembers : public ::Ice::UserExceptionHelper<ETwoMembers, ::Ice::UserException>
{
public:

    virtual ~ETwoMembers();

    ETwoMembers(const ETwoMembers&) = default;

    ETwoMembers() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    ETwoMembers(const ::std::shared_ptr<Empty>& e1, const ::std::shared_ptr<Empty>& e2) :
        e1(e1),
        e2(e2)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::Empty>&, const ::std::shared_ptr<::Test::Empty>&> ice_tuple() const
    {
        return std::tie(e1, e2);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /// \cond STREAM
    virtual bool _usesClasses() const override;
    /// \endcond

    ::std::shared_ptr<::Test::Empty> e1;
    ::std::shared_ptr<::Test::Empty> e2;
};

struct SOneMember
{
    ::std::shared_ptr<::Test::Empty> e;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::Empty>&> ice_tuple() const
    {
        return std::tie(e);
    }
};

struct STwoMembers
{
    ::std::shared_ptr<::Test::Empty> e1;
    ::std::shared_ptr<::Test::Empty> e2;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::Empty>&, const ::std::shared_ptr<::Test::Empty>&> ice_tuple() const
    {
        return std::tie(e1, e2);
    }
};

using DOneMember = ::std::map<int, ::std::shared_ptr<COneMember>>;

using DTwoMembers = ::std::map<int, ::std::shared_ptr<CTwoMembers>>;

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace Test
{

class AbstractBaseDisp : public virtual ::Ice::Object
{
public:

    using ProxyType = AbstractBasePrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void op(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_op(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class I : public virtual ::Ice::Object
{
public:

    using ProxyType = IPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void doI(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_doI(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class J : public virtual I
{
public:

    using ProxyType = JPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void doJ(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_doJ(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class HDisp : public virtual I
{
public:

    using ProxyType = HPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void doH(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_doH(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void doH2(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_doH2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class Initial : public virtual ::Ice::Object
{
public:

    using ProxyType = InitialPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void shutdown(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<B> getB1(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getB1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<B> getB2(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getB2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<C> getC(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getC(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<D> getD(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<E> getE(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getE(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<F> getF(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getF(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setRecursive(::std::shared_ptr<Recursive> p, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setRecursive(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool supportsClassGraphDepthMax(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_supportsClassGraphDepthMax(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setCycle(::std::shared_ptr<Recursive> r, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setCycle(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool acceptsClassCycles(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_acceptsClassCycles(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Marshaled result structure for operation getMB.
     */
    class GetMBMarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        GetMBMarshaledResult(const ::std::shared_ptr<B>& returnValue, const ::Ice::Current& current);
    };

    virtual GetMBMarshaledResult getMB(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getMB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Marshaled result structure for operation getAMDMBAsync.
     */
    class GetAMDMBMarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        GetAMDMBMarshaledResult(const ::std::shared_ptr<B>& returnValue, const ::Ice::Current& current);
    };

    virtual void getAMDMBAsync(::std::function<void(const GetAMDMBMarshaledResult&)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getAMDMB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to getAll.
     */
    struct GetAllResult
    {
        ::std::shared_ptr<B> b1;
        ::std::shared_ptr<B> b2;
        ::std::shared_ptr<C> theC;
        ::std::shared_ptr<D> theD;
    };

    virtual void getAll(::std::shared_ptr<B>& b1, ::std::shared_ptr<B>& b2, ::std::shared_ptr<C>& theC, ::std::shared_ptr<D>& theD, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getAll(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<::Ice::Value> getH(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getH(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<::Ice::Value> getI(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getI(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<::Ice::Value> getJ(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getJ(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<K> getK(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getK(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opValue.
     */
    struct OpValueResult
    {
        ::std::shared_ptr<::Ice::Value> returnValue;
        ::std::shared_ptr<::Ice::Value> v2;
    };

    virtual ::std::shared_ptr<::Ice::Value> opValue(::std::shared_ptr<::Ice::Value> v1, ::std::shared_ptr<::Ice::Value>& v2, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opValue(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opValueSeq.
     */
    struct OpValueSeqResult
    {
        ValueSeq returnValue;
        ValueSeq v2;
    };

    virtual ValueSeq opValueSeq(ValueSeq v1, ValueSeq& v2, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opValueSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opValueMap.
     */
    struct OpValueMapResult
    {
        ValueMap returnValue;
        ValueMap v2;
    };

    virtual ValueMap opValueMap(ValueMap v1, ValueMap& v2, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opValueMap(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<D1> getD1(::std::shared_ptr<D1> d1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getD1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwEDerived(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwEDerived(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setG(::std::shared_ptr<G> theG, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setG(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setI(::std::shared_ptr<::Ice::Value> theI, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setI(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBaseSeq.
     */
    struct OpBaseSeqResult
    {
        BaseSeq returnValue;
        BaseSeq outSeq;
    };

    virtual BaseSeq opBaseSeq(BaseSeq inSeq, BaseSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBaseSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<Compact> getCompact(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getCompact(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<::Test::Inner::A> getInnerA(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getInnerA(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<::Test::Inner::Sub::A> getInnerSubA(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getInnerSubA(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwInnerEx(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwInnerEx(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwInnerSubEx(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwInnerSubEx(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opM.
     */
    struct OpMResult
    {
        ::std::shared_ptr<M> returnValue;
        ::std::shared_ptr<M> v2;
    };

    virtual ::std::shared_ptr<M> opM(::std::shared_ptr<M> v1, ::std::shared_ptr<M>& v2, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opM(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opF1.
     */
    struct OpF1Result
    {
        ::std::shared_ptr<F1> returnValue;
        ::std::shared_ptr<F1> f12;
    };

    virtual ::std::shared_ptr<F1> opF1(::std::shared_ptr<F1> f11, ::std::shared_ptr<F1>& f12, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opF1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opF2.
     */
    struct OpF2Result
    {
        ::std::shared_ptr<F2Prx> returnValue;
        ::std::shared_ptr<F2Prx> f22;
    };

    virtual ::std::shared_ptr<F2Prx> opF2(::std::shared_ptr<F2Prx> f21, ::std::shared_ptr<F2Prx>& f22, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opF2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opF3.
     */
    struct OpF3Result
    {
        ::std::shared_ptr<F3> returnValue;
        ::std::shared_ptr<F3> f32;
    };

    virtual ::std::shared_ptr<F3> opF3(::std::shared_ptr<F3> f31, ::std::shared_ptr<F3>& f32, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opF3(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool hasF3(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_hasF3(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<N> opN(::std::shared_ptr<N> p1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opN(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class UnexpectedObjectExceptionTest : public virtual ::Ice::Object
{
public:

    using ProxyType = UnexpectedObjectExceptionTestPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ::std::shared_ptr<Empty> op(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_op(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class Echo : public virtual ::Ice::Object
{
public:

    using ProxyType = EchoPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void setConnection(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setConnection(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void shutdown(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace Test
{

class Base : public ::Ice::ValueHelper<Base, ::Ice::Value>
{
public:

    virtual ~Base();

    Base() = default;

    Base(const Base&) = default;
    Base(Base&&) = default;
    Base& operator=(const Base&) = default;
    Base& operator=(Base&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Base(const ::Test::S& theS, const ::std::string& str) :
        theS(theS),
        str(str)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::S&, const ::std::string&> ice_tuple() const
    {
        return std::tie(theS, str);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::Test::S theS;
    ::std::string str;
};

/// \cond INTERNAL
static Base _iceS_Base_init;
/// \endcond

class AbstractBase : public ::Ice::ValueHelper<AbstractBase, Base>
{
public:

    virtual ~AbstractBase();

    AbstractBase() = default;

    AbstractBase(const AbstractBase&) = default;
    AbstractBase(AbstractBase&&) = default;
    AbstractBase& operator=(const AbstractBase&) = default;
    AbstractBase& operator=(AbstractBase&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    AbstractBase(const ::Test::S& theS, const ::std::string& str) :
        Ice::ValueHelper<AbstractBase, Base>(theS, str)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::S&, const ::std::string&> ice_tuple() const
    {
        return std::tie(theS, str);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

class A : public ::Ice::ValueHelper<A, ::Ice::Value>
{
public:

    virtual ~A();

    A() = default;

    A(const A&) = default;
    A(A&&) = default;
    A& operator=(const A&) = default;
    A& operator=(A&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    A(const ::std::shared_ptr<::Test::B>& theB, const ::std::shared_ptr<::Test::C>& theC, bool preMarshalInvoked, bool postUnmarshalInvoked) :
        theB(theB),
        theC(theC),
        preMarshalInvoked(preMarshalInvoked),
        postUnmarshalInvoked(postUnmarshalInvoked)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::B>&, const ::std::shared_ptr<::Test::C>&, const bool&, const bool&> ice_tuple() const
    {
        return std::tie(theB, theC, preMarshalInvoked, postUnmarshalInvoked);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::B> theB;
    ::std::shared_ptr<::Test::C> theC;
    bool preMarshalInvoked;
    bool postUnmarshalInvoked;
};

class B : public ::Ice::ValueHelper<B, A>
{
public:

    virtual ~B();

    B() = default;

    B(const B&) = default;
    B(B&&) = default;
    B& operator=(const B&) = default;
    B& operator=(B&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    B(const ::std::shared_ptr<::Test::B>& theB, const ::std::shared_ptr<::Test::C>& theC, bool preMarshalInvoked, bool postUnmarshalInvoked, const ::std::shared_ptr<::Test::A>& theA) :
        Ice::ValueHelper<B, A>(theB, theC, preMarshalInvoked, postUnmarshalInvoked),
        theA(theA)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::B>&, const ::std::shared_ptr<::Test::C>&, const bool&, const bool&, const ::std::shared_ptr<::Test::A>&> ice_tuple() const
    {
        return std::tie(theB, theC, preMarshalInvoked, postUnmarshalInvoked, theA);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::A> theA;
};

class C : public ::Ice::ValueHelper<C, ::Ice::Value>
{
public:

    virtual ~C();

    C() = default;

    C(const C&) = default;
    C(C&&) = default;
    C& operator=(const C&) = default;
    C& operator=(C&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    C(const ::std::shared_ptr<::Test::B>& theB, bool preMarshalInvoked, bool postUnmarshalInvoked) :
        theB(theB),
        preMarshalInvoked(preMarshalInvoked),
        postUnmarshalInvoked(postUnmarshalInvoked)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::B>&, const bool&, const bool&> ice_tuple() const
    {
        return std::tie(theB, preMarshalInvoked, postUnmarshalInvoked);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::B> theB;
    bool preMarshalInvoked;
    bool postUnmarshalInvoked;
};

class D : public ::Ice::ValueHelper<D, ::Ice::Value>
{
public:

    virtual ~D();

    D() = default;

    D(const D&) = default;
    D(D&&) = default;
    D& operator=(const D&) = default;
    D& operator=(D&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    D(const ::std::shared_ptr<::Test::A>& theA, const ::std::shared_ptr<::Test::B>& theB, const ::std::shared_ptr<::Test::C>& theC, bool preMarshalInvoked, bool postUnmarshalInvoked) :
        theA(theA),
        theB(theB),
        theC(theC),
        preMarshalInvoked(preMarshalInvoked),
        postUnmarshalInvoked(postUnmarshalInvoked)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::A>&, const ::std::shared_ptr<::Test::B>&, const ::std::shared_ptr<::Test::C>&, const bool&, const bool&> ice_tuple() const
    {
        return std::tie(theA, theB, theC, preMarshalInvoked, postUnmarshalInvoked);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::A> theA;
    ::std::shared_ptr<::Test::B> theB;
    ::std::shared_ptr<::Test::C> theC;
    bool preMarshalInvoked;
    bool postUnmarshalInvoked;
};

class E : public ::Ice::ValueHelper<E, ::Ice::Value>
{
public:

    virtual ~E();

    E() = default;

    E(const E&) = default;
    E(E&&) = default;
    E& operator=(const E&) = default;
    E& operator=(E&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    E(int i, const ::std::string& s) :
        i(i),
        s(s)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::std::string&> ice_tuple() const
    {
        return std::tie(i, s);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    int i;
    ::std::string s;

    template<typename T, typename S>
    friend struct Ice::StreamWriter;
    template<typename T, typename S>
    friend struct Ice::StreamReader;
};

class F : public ::Ice::ValueHelper<F, ::Ice::Value>
{
public:

    virtual ~F();

    F() = default;

    F(const F&) = default;
    F(F&&) = default;
    F& operator=(const F&) = default;
    F& operator=(F&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    F(const ::std::shared_ptr<::Test::E>& e1, const ::std::shared_ptr<::Test::E>& e2) :
        e1(e1),
        e2(e2)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::E>&, const ::std::shared_ptr<::Test::E>&> ice_tuple() const
    {
        return std::tie(e1, e2);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    ::std::shared_ptr<::Test::E> e1;

public:

    ::std::shared_ptr<::Test::E> e2;

protected:

    template<typename T, typename S>
    friend struct Ice::StreamWriter;
    template<typename T, typename S>
    friend struct Ice::StreamReader;
};

class G : public ::Ice::ValueHelper<G, Base>
{
public:

    virtual ~G();

    G() = default;

    G(const G&) = default;
    G(G&&) = default;
    G& operator=(const G&) = default;
    G& operator=(G&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    G(const ::Test::S& theS, const ::std::string& str) :
        Ice::ValueHelper<G, Base>(theS, str)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::S&, const ::std::string&> ice_tuple() const
    {
        return std::tie(theS, str);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

class H : public ::Ice::ValueHelper<H, ::Ice::Value>
{
public:

    virtual ~H();

    H() = default;

    H(const H&) = default;
    H(H&&) = default;
    H& operator=(const H&) = default;
    H& operator=(H&&) = default;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

class N : public ::Ice::ValueHelper<N, ::Ice::Value>
{
public:

    virtual ~N();

    N() = default;

    N(const N&) = default;
    N(N&&) = default;
    N& operator=(const N&) = default;
    N& operator=(N&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit N(const ::std::shared_ptr<::Ice::Value>& i) :
        i(i)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Ice::Value>&> ice_tuple() const
    {
        return std::tie(i);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Ice::Value> i;
};

class Compact : public ::Ice::ValueHelper<Compact, ::Ice::Value>
{
public:

    virtual ~Compact();

    Compact() = default;

    Compact(const Compact&) = default;
    Compact(Compact&&) = default;
    Compact& operator=(const Compact&) = default;
    Compact& operator=(Compact&&) = default;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

class CompactExt : public ::Ice::ValueHelper<CompactExt, Compact>
{
public:

    virtual ~CompactExt();

    CompactExt() = default;

    CompactExt(const CompactExt&) = default;
    CompactExt(CompactExt&&) = default;
    CompactExt& operator=(const CompactExt&) = default;
    CompactExt& operator=(CompactExt&&) = default;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

class A1 : public ::Ice::ValueHelper<A1, ::Ice::Value>
{
public:

    virtual ~A1();

    A1() = default;

    A1(const A1&) = default;
    A1(A1&&) = default;
    A1& operator=(const A1&) = default;
    A1& operator=(A1&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit A1(const ::std::string& name) :
        name(name)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(name);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string name;
};

class B1 : public ::Ice::ValueHelper<B1, ::Ice::Value>
{
public:

    virtual ~B1();

    B1() = default;

    B1(const B1&) = default;
    B1(B1&&) = default;
    B1& operator=(const B1&) = default;
    B1& operator=(B1&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    B1(const ::std::shared_ptr<::Test::A1>& a1, const ::std::shared_ptr<::Test::A1>& a2) :
        a1(a1),
        a2(a2)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::A1>&, const ::std::shared_ptr<::Test::A1>&> ice_tuple() const
    {
        return std::tie(a1, a2);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::A1> a1;
    ::std::shared_ptr<::Test::A1> a2;
};

class D1 : public ::Ice::ValueHelper<D1, B1>
{
public:

    virtual ~D1();

    D1() = default;

    D1(const D1&) = default;
    D1(D1&&) = default;
    D1& operator=(const D1&) = default;
    D1& operator=(D1&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    D1(const ::std::shared_ptr<::Test::A1>& a1, const ::std::shared_ptr<::Test::A1>& a2, const ::std::shared_ptr<::Test::A1>& a3, const ::std::shared_ptr<::Test::A1>& a4) :
        Ice::ValueHelper<D1, B1>(a1, a2),
        a3(a3),
        a4(a4)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::A1>&, const ::std::shared_ptr<::Test::A1>&, const ::std::shared_ptr<::Test::A1>&, const ::std::shared_ptr<::Test::A1>&> ice_tuple() const
    {
        return std::tie(a1, a2, a3, a4);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::A1> a3;
    ::std::shared_ptr<::Test::A1> a4;
};

namespace Inner
{

class A : public ::Ice::ValueHelper<A, ::Ice::Value>
{
public:

    virtual ~A();

    A() = default;

    A(const A&) = default;
    A(A&&) = default;
    A& operator=(const A&) = default;
    A& operator=(A&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit A(const ::std::shared_ptr<::Test::A>& theA) :
        theA(theA)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::A>&> ice_tuple() const
    {
        return std::tie(theA);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::A> theA;
};

namespace Sub
{

class A : public ::Ice::ValueHelper<A, ::Ice::Value>
{
public:

    virtual ~A();

    A() = default;

    A(const A&) = default;
    A(A&&) = default;
    A& operator=(const A&) = default;
    A& operator=(A&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit A(const ::std::shared_ptr<::Test::Inner::A>& theA) :
        theA(theA)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::Inner::A>&> ice_tuple() const
    {
        return std::tie(theA);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::Inner::A> theA;
};

}

}

class Recursive : public ::Ice::ValueHelper<Recursive, ::Ice::Value>
{
public:

    virtual ~Recursive();

    Recursive() = default;

    Recursive(const Recursive&) = default;
    Recursive(Recursive&&) = default;
    Recursive& operator=(const Recursive&) = default;
    Recursive& operator=(Recursive&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit Recursive(const ::std::shared_ptr<::Test::Recursive>& v) :
        v(v)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::Recursive>&> ice_tuple() const
    {
        return std::tie(v);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::Recursive> v;
};

class K : public ::Ice::ValueHelper<K, ::Ice::Value>
{
public:

    virtual ~K();

    K() = default;

    K(const K&) = default;
    K(K&&) = default;
    K& operator=(const K&) = default;
    K& operator=(K&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit K(const ::std::shared_ptr<::Ice::Value>& value) :
        value(value)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Ice::Value>&> ice_tuple() const
    {
        return std::tie(value);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Ice::Value> value;
};

class L : public ::Ice::ValueHelper<L, ::Ice::Value>
{
public:

    virtual ~L();

    L() = default;

    L(const L&) = default;
    L(L&&) = default;
    L& operator=(const L&) = default;
    L& operator=(L&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit L(const ::std::string& data) :
        data(data)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(data);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string data;
};

class M : public ::Ice::ValueHelper<M, ::Ice::Value>
{
public:

    virtual ~M();

    M() = default;

    M(const M&) = default;
    M(M&&) = default;
    M& operator=(const M&) = default;
    M& operator=(M&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit M(const ::Test::LMap& v) :
        v(v)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::LMap&> ice_tuple() const
    {
        return std::tie(v);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::Test::LMap v;
};

class F3 : public ::Ice::ValueHelper<F3, ::Ice::Value>
{
public:

    virtual ~F3();

    F3() = default;

    F3(const F3&) = default;
    F3(F3&&) = default;
    F3& operator=(const F3&) = default;
    F3& operator=(F3&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    F3(const ::std::shared_ptr<::Test::F1>& f1, const ::std::shared_ptr<::Test::F2Prx>& f2) :
        f1(f1),
        f2(f2)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::F1>&, const ::std::shared_ptr<::Test::F2Prx>&> ice_tuple() const
    {
        return std::tie(f1, f2);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::F1> f1;
    ::std::shared_ptr<::Test::F2Prx> f2;
};

class Empty : public ::Ice::ValueHelper<Empty, ::Ice::Value>
{
public:

    virtual ~Empty();

    Empty() = default;

    Empty(const Empty&) = default;
    Empty(Empty&&) = default;
    Empty& operator=(const Empty&) = default;
    Empty& operator=(Empty&&) = default;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

class AlsoEmpty : public ::Ice::ValueHelper<AlsoEmpty, ::Ice::Value>
{
public:

    virtual ~AlsoEmpty();

    AlsoEmpty() = default;

    AlsoEmpty(const AlsoEmpty&) = default;
    AlsoEmpty(AlsoEmpty&&) = default;
    AlsoEmpty& operator=(const AlsoEmpty&) = default;
    AlsoEmpty& operator=(AlsoEmpty&&) = default;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

class COneMember : public ::Ice::ValueHelper<COneMember, ::Ice::Value>
{
public:

    virtual ~COneMember();

    COneMember() = default;

    COneMember(const COneMember&) = default;
    COneMember(COneMember&&) = default;
    COneMember& operator=(const COneMember&) = default;
    COneMember& operator=(COneMember&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit COneMember(const ::std::shared_ptr<::Test::Empty>& e) :
        e(e)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::Empty>&> ice_tuple() const
    {
        return std::tie(e);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::Empty> e;
};

class CTwoMembers : public ::Ice::ValueHelper<CTwoMembers, ::Ice::Value>
{
public:

    virtual ~CTwoMembers();

    CTwoMembers() = default;

    CTwoMembers(const CTwoMembers&) = default;
    CTwoMembers(CTwoMembers&&) = default;
    CTwoMembers& operator=(const CTwoMembers&) = default;
    CTwoMembers& operator=(CTwoMembers&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    CTwoMembers(const ::std::shared_ptr<::Test::Empty>& e1, const ::std::shared_ptr<::Test::Empty>& e2) :
        e1(e1),
        e2(e2)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::Empty>&, const ::std::shared_ptr<::Test::Empty>&> ice_tuple() const
    {
        return std::tie(e1, e2);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::Empty> e1;
    ::std::shared_ptr<::Test::Empty> e2;
};

}

namespace Test
{

class AbstractBasePrx : public virtual ::Ice::Proxy<AbstractBasePrx, ::Ice::ObjectPrx>
{
public:

    void op(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &AbstractBasePrx::_iceI_op, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &AbstractBasePrx::_iceI_op, context);
    }

    ::std::function<void()>
    opAsync(::std::function<void()> response,
            ::std::function<void(::std::exception_ptr)> ex = nullptr,
            ::std::function<void(bool)> sent = nullptr,
            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::AbstractBasePrx::_iceI_op, context);
    }

    /// \cond INTERNAL
    void _iceI_op(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this class.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    AbstractBasePrx() = default;
    friend ::std::shared_ptr<AbstractBasePrx> IceInternal::createProxy<AbstractBasePrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class IPrx : public virtual ::Ice::Proxy<IPrx, ::Ice::ObjectPrx>
{
public:

    void doI(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IPrx::_iceI_doI, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto doIAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IPrx::_iceI_doI, context);
    }

    ::std::function<void()>
    doIAsync(::std::function<void()> response,
             ::std::function<void(::std::exception_ptr)> ex = nullptr,
             ::std::function<void(bool)> sent = nullptr,
             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::IPrx::_iceI_doI, context);
    }

    /// \cond INTERNAL
    void _iceI_doI(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    IPrx() = default;
    friend ::std::shared_ptr<IPrx> IceInternal::createProxy<IPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class JPrx : public virtual ::Ice::Proxy<JPrx, IPrx>
{
public:

    void doJ(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &JPrx::_iceI_doJ, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto doJAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &JPrx::_iceI_doJ, context);
    }

    ::std::function<void()>
    doJAsync(::std::function<void()> response,
             ::std::function<void(::std::exception_ptr)> ex = nullptr,
             ::std::function<void(bool)> sent = nullptr,
             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::JPrx::_iceI_doJ, context);
    }

    /// \cond INTERNAL
    void _iceI_doJ(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    JPrx() = default;
    friend ::std::shared_ptr<JPrx> IceInternal::createProxy<JPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class HPrx : public virtual ::Ice::Proxy<HPrx, IPrx>
{
public:

    void doH(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &HPrx::_iceI_doH, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto doHAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &HPrx::_iceI_doH, context);
    }

    ::std::function<void()>
    doHAsync(::std::function<void()> response,
             ::std::function<void(::std::exception_ptr)> ex = nullptr,
             ::std::function<void(bool)> sent = nullptr,
             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::HPrx::_iceI_doH, context);
    }

    /// \cond INTERNAL
    void _iceI_doH(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void doH2(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &HPrx::_iceI_doH2, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto doH2Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &HPrx::_iceI_doH2, context);
    }

    ::std::function<void()>
    doH2Async(::std::function<void()> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::HPrx::_iceI_doH2, context);
    }

    /// \cond INTERNAL
    void _iceI_doH2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this class.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    HPrx() = default;
    friend ::std::shared_ptr<HPrx> IceInternal::createProxy<HPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

namespace Inner
{

namespace Sub
{

}

}

class InitialPrx : public virtual ::Ice::Proxy<InitialPrx, ::Ice::ObjectPrx>
{
public:

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &InitialPrx::_iceI_shutdown, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto shutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &InitialPrx::_iceI_shutdown, context);
    }

    ::std::function<void()>
    shutdownAsync(::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_shutdown, context);
    }

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<B> getB1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::B>>(true, this, &InitialPrx::_iceI_getB1, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getB1Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::B>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::B>, P>(false, this, &InitialPrx::_iceI_getB1, context);
    }

    ::std::function<void()>
    getB1Async(::std::function<void(::std::shared_ptr<::Test::B>)> response,
               ::std::function<void(::std::exception_ptr)> ex = nullptr,
               ::std::function<void(bool)> sent = nullptr,
               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::Test::B>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_getB1, context);
    }

    /// \cond INTERNAL
    void _iceI_getB1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::B>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<B> getB2(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::B>>(true, this, &InitialPrx::_iceI_getB2, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getB2Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::B>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::B>, P>(false, this, &InitialPrx::_iceI_getB2, context);
    }

    ::std::function<void()>
    getB2Async(::std::function<void(::std::shared_ptr<::Test::B>)> response,
               ::std::function<void(::std::exception_ptr)> ex = nullptr,
               ::std::function<void(bool)> sent = nullptr,
               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::Test::B>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_getB2, context);
    }

    /// \cond INTERNAL
    void _iceI_getB2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::B>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<C> getC(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::C>>(true, this, &InitialPrx::_iceI_getC, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getCAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::C>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::C>, P>(false, this, &InitialPrx::_iceI_getC, context);
    }

    ::std::function<void()>
    getCAsync(::std::function<void(::std::shared_ptr<::Test::C>)> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::Test::C>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_getC, context);
    }

    /// \cond INTERNAL
    void _iceI_getC(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::C>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<D> getD(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::D>>(true, this, &InitialPrx::_iceI_getD, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getDAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::D>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::D>, P>(false, this, &InitialPrx::_iceI_getD, context);
    }

    ::std::function<void()>
    getDAsync(::std::function<void(::std::shared_ptr<::Test::D>)> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::Test::D>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_getD, context);
    }

    /// \cond INTERNAL
    void _iceI_getD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::D>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<E> getE(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::E>>(true, this, &InitialPrx::_iceI_getE, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getEAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::E>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::E>, P>(false, this, &InitialPrx::_iceI_getE, context);
    }

    ::std::function<void()>
    getEAsync(::std::function<void(::std::shared_ptr<::Test::E>)> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::Test::E>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_getE, context);
    }

    /// \cond INTERNAL
    void _iceI_getE(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::E>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<F> getF(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::F>>(true, this, &InitialPrx::_iceI_getF, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getFAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::F>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::F>, P>(false, this, &InitialPrx::_iceI_getF, context);
    }

    ::std::function<void()>
    getFAsync(::std::function<void(::std::shared_ptr<::Test::F>)> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::Test::F>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_getF, context);
    }

    /// \cond INTERNAL
    void _iceI_getF(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::F>>>&, const ::Ice::Context&);
    /// \endcond

    void setRecursive(const ::std::shared_ptr<Recursive>& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &InitialPrx::_iceI_setRecursive, p, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setRecursiveAsync(const ::std::shared_ptr<Recursive>& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &InitialPrx::_iceI_setRecursive, p, context);
    }

    ::std::function<void()>
    setRecursiveAsync(const ::std::shared_ptr<Recursive>& p,
                      ::std::function<void()> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_setRecursive, p, context);
    }

    /// \cond INTERNAL
    void _iceI_setRecursive(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<Recursive>&, const ::Ice::Context&);
    /// \endcond

    bool supportsClassGraphDepthMax(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &InitialPrx::_iceI_supportsClassGraphDepthMax, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto supportsClassGraphDepthMaxAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &InitialPrx::_iceI_supportsClassGraphDepthMax, context);
    }

    ::std::function<void()>
    supportsClassGraphDepthMaxAsync(::std::function<void(bool)> response,
                                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                    ::std::function<void(bool)> sent = nullptr,
                                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_supportsClassGraphDepthMax, context);
    }

    /// \cond INTERNAL
    void _iceI_supportsClassGraphDepthMax(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    void setCycle(const ::std::shared_ptr<Recursive>& r, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &InitialPrx::_iceI_setCycle, r, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setCycleAsync(const ::std::shared_ptr<Recursive>& r, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &InitialPrx::_iceI_setCycle, r, context);
    }

    ::std::function<void()>
    setCycleAsync(const ::std::shared_ptr<Recursive>& r,
                  ::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_setCycle, r, context);
    }

    /// \cond INTERNAL
    void _iceI_setCycle(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<Recursive>&, const ::Ice::Context&);
    /// \endcond

    bool acceptsClassCycles(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &InitialPrx::_iceI_acceptsClassCycles, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto acceptsClassCyclesAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &InitialPrx::_iceI_acceptsClassCycles, context);
    }

    ::std::function<void()>
    acceptsClassCyclesAsync(::std::function<void(bool)> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_acceptsClassCycles, context);
    }

    /// \cond INTERNAL
    void _iceI_acceptsClassCycles(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<B> getMB(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::B>>(true, this, &InitialPrx::_iceI_getMB, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getMBAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::B>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::B>, P>(false, this, &InitialPrx::_iceI_getMB, context);
    }

    ::std::function<void()>
    getMBAsync(::std::function<void(::std::shared_ptr<::Test::B>)> response,
               ::std::function<void(::std::exception_ptr)> ex = nullptr,
               ::std::function<void(bool)> sent = nullptr,
               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::Test::B>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_getMB, context);
    }

    /// \cond INTERNAL
    void _iceI_getMB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::B>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<B> getAMDMB(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::B>>(true, this, &InitialPrx::_iceI_getAMDMB, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getAMDMBAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::B>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::B>, P>(false, this, &InitialPrx::_iceI_getAMDMB, context);
    }

    ::std::function<void()>
    getAMDMBAsync(::std::function<void(::std::shared_ptr<::Test::B>)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::Test::B>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_getAMDMB, context);
    }

    /// \cond INTERNAL
    void _iceI_getAMDMB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::B>>>&, const ::Ice::Context&);
    /// \endcond

    void getAll(::std::shared_ptr<B>& b1, ::std::shared_ptr<B>& b2, ::std::shared_ptr<C>& theC, ::std::shared_ptr<D>& theD, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::GetAllResult>(true, this, &InitialPrx::_iceI_getAll, context).get();
        b1 = ::std::move(_result.b1);
        b2 = ::std::move(_result.b2);
        theC = ::std::move(_result.theC);
        theD = ::std::move(_result.theD);
    }

    template<template<typename> class P = ::std::promise>
    auto getAllAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::GetAllResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::GetAllResult, P>(false, this, &InitialPrx::_iceI_getAll, context);
    }

    ::std::function<void()>
    getAllAsync(::std::function<void(::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::C>, ::std::shared_ptr<::Test::D>)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::GetAllResult&& _result)
        {
            response(::std::move(_result.b1), ::std::move(_result.b2), ::std::move(_result.theC), ::std::move(_result.theD));
        };
        return _makeLamdaOutgoing<Initial::GetAllResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_getAll, context);
    }

    /// \cond INTERNAL
    void _iceI_getAll(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::GetAllResult>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<::Ice::Value> getH(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::Value>>(true, this, &InitialPrx::_iceI_getH, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getHAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Ice::Value>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::Value>, P>(false, this, &InitialPrx::_iceI_getH, context);
    }

    ::std::function<void()>
    getHAsync(::std::function<void(::std::shared_ptr<::Ice::Value>)> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::Ice::Value>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_getH, context);
    }

    /// \cond INTERNAL
    void _iceI_getH(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Ice::Value>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<::Ice::Value> getI(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::Value>>(true, this, &InitialPrx::_iceI_getI, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getIAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Ice::Value>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::Value>, P>(false, this, &InitialPrx::_iceI_getI, context);
    }

    ::std::function<void()>
    getIAsync(::std::function<void(::std::shared_ptr<::Ice::Value>)> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::Ice::Value>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_getI, context);
    }

    /// \cond INTERNAL
    void _iceI_getI(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Ice::Value>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<::Ice::Value> getJ(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::Value>>(true, this, &InitialPrx::_iceI_getJ, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getJAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Ice::Value>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::Value>, P>(false, this, &InitialPrx::_iceI_getJ, context);
    }

    ::std::function<void()>
    getJAsync(::std::function<void(::std::shared_ptr<::Ice::Value>)> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::Ice::Value>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_getJ, context);
    }

    /// \cond INTERNAL
    void _iceI_getJ(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Ice::Value>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<K> getK(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::K>>(true, this, &InitialPrx::_iceI_getK, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getKAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::K>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::K>, P>(false, this, &InitialPrx::_iceI_getK, context);
    }

    ::std::function<void()>
    getKAsync(::std::function<void(::std::shared_ptr<::Test::K>)> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::Test::K>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_getK, context);
    }

    /// \cond INTERNAL
    void _iceI_getK(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::K>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<::Ice::Value> opValue(const ::std::shared_ptr<::Ice::Value>& v1, ::std::shared_ptr<::Ice::Value>& v2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpValueResult>(true, this, &InitialPrx::_iceI_opValue, v1, context).get();
        v2 = ::std::move(_result.v2);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opValueAsync(const ::std::shared_ptr<::Ice::Value>& v1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpValueResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpValueResult, P>(false, this, &InitialPrx::_iceI_opValue, v1, context);
    }

    ::std::function<void()>
    opValueAsync(const ::std::shared_ptr<::Ice::Value>& v1,
                 ::std::function<void(::std::shared_ptr<::Ice::Value>, ::std::shared_ptr<::Ice::Value>)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpValueResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.v2));
        };
        return _makeLamdaOutgoing<Initial::OpValueResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opValue, v1, context);
    }

    /// \cond INTERNAL
    void _iceI_opValue(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpValueResult>>&, const ::std::shared_ptr<::Ice::Value>&, const ::Ice::Context&);
    /// \endcond

    ValueSeq opValueSeq(const ValueSeq& v1, ValueSeq& v2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpValueSeqResult>(true, this, &InitialPrx::_iceI_opValueSeq, v1, context).get();
        v2 = ::std::move(_result.v2);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opValueSeqAsync(const ValueSeq& v1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpValueSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpValueSeqResult, P>(false, this, &InitialPrx::_iceI_opValueSeq, v1, context);
    }

    ::std::function<void()>
    opValueSeqAsync(const ValueSeq& v1,
                    ::std::function<void(::Test::ValueSeq, ::Test::ValueSeq)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpValueSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.v2));
        };
        return _makeLamdaOutgoing<Initial::OpValueSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opValueSeq, v1, context);
    }

    /// \cond INTERNAL
    void _iceI_opValueSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpValueSeqResult>>&, const ValueSeq&, const ::Ice::Context&);
    /// \endcond

    ValueMap opValueMap(const ValueMap& v1, ValueMap& v2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpValueMapResult>(true, this, &InitialPrx::_iceI_opValueMap, v1, context).get();
        v2 = ::std::move(_result.v2);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opValueMapAsync(const ValueMap& v1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpValueMapResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpValueMapResult, P>(false, this, &InitialPrx::_iceI_opValueMap, v1, context);
    }

    ::std::function<void()>
    opValueMapAsync(const ValueMap& v1,
                    ::std::function<void(::Test::ValueMap, ::Test::ValueMap)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpValueMapResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.v2));
        };
        return _makeLamdaOutgoing<Initial::OpValueMapResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opValueMap, v1, context);
    }

    /// \cond INTERNAL
    void _iceI_opValueMap(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpValueMapResult>>&, const ValueMap&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<D1> getD1(const ::std::shared_ptr<D1>& d1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::D1>>(true, this, &InitialPrx::_iceI_getD1, d1, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getD1Async(const ::std::shared_ptr<D1>& d1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::D1>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::D1>, P>(false, this, &InitialPrx::_iceI_getD1, d1, context);
    }

    ::std::function<void()>
    getD1Async(const ::std::shared_ptr<D1>& d1,
               ::std::function<void(::std::shared_ptr<::Test::D1>)> response,
               ::std::function<void(::std::exception_ptr)> ex = nullptr,
               ::std::function<void(bool)> sent = nullptr,
               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::Test::D1>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_getD1, d1, context);
    }

    /// \cond INTERNAL
    void _iceI_getD1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::D1>>>&, const ::std::shared_ptr<D1>&, const ::Ice::Context&);
    /// \endcond

    void throwEDerived(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &InitialPrx::_iceI_throwEDerived, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwEDerivedAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &InitialPrx::_iceI_throwEDerived, context);
    }

    ::std::function<void()>
    throwEDerivedAsync(::std::function<void()> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_throwEDerived, context);
    }

    /// \cond INTERNAL
    void _iceI_throwEDerived(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void setG(const ::std::shared_ptr<G>& theG, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &InitialPrx::_iceI_setG, theG, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setGAsync(const ::std::shared_ptr<G>& theG, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &InitialPrx::_iceI_setG, theG, context);
    }

    ::std::function<void()>
    setGAsync(const ::std::shared_ptr<G>& theG,
              ::std::function<void()> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_setG, theG, context);
    }

    /// \cond INTERNAL
    void _iceI_setG(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<G>&, const ::Ice::Context&);
    /// \endcond

    void setI(const ::std::shared_ptr<::Ice::Value>& theI, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &InitialPrx::_iceI_setI, theI, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setIAsync(const ::std::shared_ptr<::Ice::Value>& theI, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &InitialPrx::_iceI_setI, theI, context);
    }

    ::std::function<void()>
    setIAsync(const ::std::shared_ptr<::Ice::Value>& theI,
              ::std::function<void()> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_setI, theI, context);
    }

    /// \cond INTERNAL
    void _iceI_setI(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<::Ice::Value>&, const ::Ice::Context&);
    /// \endcond

    BaseSeq opBaseSeq(const BaseSeq& inSeq, BaseSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpBaseSeqResult>(true, this, &InitialPrx::_iceI_opBaseSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opBaseSeqAsync(const BaseSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpBaseSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpBaseSeqResult, P>(false, this, &InitialPrx::_iceI_opBaseSeq, inSeq, context);
    }

    ::std::function<void()>
    opBaseSeqAsync(const BaseSeq& inSeq,
                   ::std::function<void(::Test::BaseSeq, ::Test::BaseSeq)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpBaseSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLamdaOutgoing<Initial::OpBaseSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opBaseSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opBaseSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpBaseSeqResult>>&, const BaseSeq&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<Compact> getCompact(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::Compact>>(true, this, &InitialPrx::_iceI_getCompact, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getCompactAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::Compact>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::Compact>, P>(false, this, &InitialPrx::_iceI_getCompact, context);
    }

    ::std::function<void()>
    getCompactAsync(::std::function<void(::std::shared_ptr<::Test::Compact>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::Test::Compact>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_getCompact, context);
    }

    /// \cond INTERNAL
    void _iceI_getCompact(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::Compact>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<::Test::Inner::A> getInnerA(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::Inner::A>>(true, this, &InitialPrx::_iceI_getInnerA, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getInnerAAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::Inner::A>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::Inner::A>, P>(false, this, &InitialPrx::_iceI_getInnerA, context);
    }

    ::std::function<void()>
    getInnerAAsync(::std::function<void(::std::shared_ptr<::Test::Inner::A>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::Test::Inner::A>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_getInnerA, context);
    }

    /// \cond INTERNAL
    void _iceI_getInnerA(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::Inner::A>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<::Test::Inner::Sub::A> getInnerSubA(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::Inner::Sub::A>>(true, this, &InitialPrx::_iceI_getInnerSubA, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getInnerSubAAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::Inner::Sub::A>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::Inner::Sub::A>, P>(false, this, &InitialPrx::_iceI_getInnerSubA, context);
    }

    ::std::function<void()>
    getInnerSubAAsync(::std::function<void(::std::shared_ptr<::Test::Inner::Sub::A>)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::Test::Inner::Sub::A>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_getInnerSubA, context);
    }

    /// \cond INTERNAL
    void _iceI_getInnerSubA(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::Inner::Sub::A>>>&, const ::Ice::Context&);
    /// \endcond

    void throwInnerEx(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &InitialPrx::_iceI_throwInnerEx, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwInnerExAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &InitialPrx::_iceI_throwInnerEx, context);
    }

    ::std::function<void()>
    throwInnerExAsync(::std::function<void()> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_throwInnerEx, context);
    }

    /// \cond INTERNAL
    void _iceI_throwInnerEx(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void throwInnerSubEx(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &InitialPrx::_iceI_throwInnerSubEx, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwInnerSubExAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &InitialPrx::_iceI_throwInnerSubEx, context);
    }

    ::std::function<void()>
    throwInnerSubExAsync(::std::function<void()> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_throwInnerSubEx, context);
    }

    /// \cond INTERNAL
    void _iceI_throwInnerSubEx(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<M> opM(const ::std::shared_ptr<M>& v1, ::std::shared_ptr<M>& v2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpMResult>(true, this, &InitialPrx::_iceI_opM, v1, context).get();
        v2 = ::std::move(_result.v2);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opMAsync(const ::std::shared_ptr<M>& v1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpMResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpMResult, P>(false, this, &InitialPrx::_iceI_opM, v1, context);
    }

    ::std::function<void()>
    opMAsync(const ::std::shared_ptr<M>& v1,
             ::std::function<void(::std::shared_ptr<::Test::M>, ::std::shared_ptr<::Test::M>)> response,
             ::std::function<void(::std::exception_ptr)> ex = nullptr,
             ::std::function<void(bool)> sent = nullptr,
             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpMResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.v2));
        };
        return _makeLamdaOutgoing<Initial::OpMResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opM, v1, context);
    }

    /// \cond INTERNAL
    void _iceI_opM(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpMResult>>&, const ::std::shared_ptr<M>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<F1> opF1(const ::std::shared_ptr<F1>& f11, ::std::shared_ptr<F1>& f12, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpF1Result>(true, this, &InitialPrx::_iceI_opF1, f11, context).get();
        f12 = ::std::move(_result.f12);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opF1Async(const ::std::shared_ptr<F1>& f11, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpF1Result>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpF1Result, P>(false, this, &InitialPrx::_iceI_opF1, f11, context);
    }

    ::std::function<void()>
    opF1Async(const ::std::shared_ptr<F1>& f11,
              ::std::function<void(::std::shared_ptr<::Test::F1>, ::std::shared_ptr<::Test::F1>)> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpF1Result&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.f12));
        };
        return _makeLamdaOutgoing<Initial::OpF1Result>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opF1, f11, context);
    }

    /// \cond INTERNAL
    void _iceI_opF1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpF1Result>>&, const ::std::shared_ptr<F1>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<F2Prx> opF2(const ::std::shared_ptr<F2Prx>& f21, ::std::shared_ptr<F2Prx>& f22, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpF2Result>(true, this, &InitialPrx::_iceI_opF2, f21, context).get();
        f22 = ::std::move(_result.f22);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opF2Async(const ::std::shared_ptr<F2Prx>& f21, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpF2Result>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpF2Result, P>(false, this, &InitialPrx::_iceI_opF2, f21, context);
    }

    ::std::function<void()>
    opF2Async(const ::std::shared_ptr<F2Prx>& f21,
              ::std::function<void(::std::shared_ptr<::Test::F2Prx>, ::std::shared_ptr<::Test::F2Prx>)> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpF2Result&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.f22));
        };
        return _makeLamdaOutgoing<Initial::OpF2Result>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opF2, f21, context);
    }

    /// \cond INTERNAL
    void _iceI_opF2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpF2Result>>&, const ::std::shared_ptr<F2Prx>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<F3> opF3(const ::std::shared_ptr<F3>& f31, ::std::shared_ptr<F3>& f32, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpF3Result>(true, this, &InitialPrx::_iceI_opF3, f31, context).get();
        f32 = ::std::move(_result.f32);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opF3Async(const ::std::shared_ptr<F3>& f31, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpF3Result>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpF3Result, P>(false, this, &InitialPrx::_iceI_opF3, f31, context);
    }

    ::std::function<void()>
    opF3Async(const ::std::shared_ptr<F3>& f31,
              ::std::function<void(::std::shared_ptr<::Test::F3>, ::std::shared_ptr<::Test::F3>)> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpF3Result&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.f32));
        };
        return _makeLamdaOutgoing<Initial::OpF3Result>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opF3, f31, context);
    }

    /// \cond INTERNAL
    void _iceI_opF3(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpF3Result>>&, const ::std::shared_ptr<F3>&, const ::Ice::Context&);
    /// \endcond

    bool hasF3(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &InitialPrx::_iceI_hasF3, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto hasF3Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &InitialPrx::_iceI_hasF3, context);
    }

    ::std::function<void()>
    hasF3Async(::std::function<void(bool)> response,
               ::std::function<void(::std::exception_ptr)> ex = nullptr,
               ::std::function<void(bool)> sent = nullptr,
               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_hasF3, context);
    }

    /// \cond INTERNAL
    void _iceI_hasF3(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<N> opN(const ::std::shared_ptr<N>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::N>>(true, this, &InitialPrx::_iceI_opN, p1, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opNAsync(const ::std::shared_ptr<N>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::N>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::N>, P>(false, this, &InitialPrx::_iceI_opN, p1, context);
    }

    ::std::function<void()>
    opNAsync(const ::std::shared_ptr<N>& p1,
             ::std::function<void(::std::shared_ptr<::Test::N>)> response,
             ::std::function<void(::std::exception_ptr)> ex = nullptr,
             ::std::function<void(bool)> sent = nullptr,
             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::Test::N>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opN, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opN(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::N>>>&, const ::std::shared_ptr<N>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    InitialPrx() = default;
    friend ::std::shared_ptr<InitialPrx> IceInternal::createProxy<InitialPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class UnexpectedObjectExceptionTestPrx : public virtual ::Ice::Proxy<UnexpectedObjectExceptionTestPrx, ::Ice::ObjectPrx>
{
public:

    ::std::shared_ptr<Empty> op(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::Empty>>(true, this, &UnexpectedObjectExceptionTestPrx::_iceI_op, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::Empty>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::Empty>, P>(false, this, &UnexpectedObjectExceptionTestPrx::_iceI_op, context);
    }

    ::std::function<void()>
    opAsync(::std::function<void(::std::shared_ptr<::Test::Empty>)> response,
            ::std::function<void(::std::exception_ptr)> ex = nullptr,
            ::std::function<void(bool)> sent = nullptr,
            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::Test::Empty>>(std::move(response), std::move(ex), std::move(sent), this, &Test::UnexpectedObjectExceptionTestPrx::_iceI_op, context);
    }

    /// \cond INTERNAL
    void _iceI_op(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::Empty>>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    UnexpectedObjectExceptionTestPrx() = default;
    friend ::std::shared_ptr<UnexpectedObjectExceptionTestPrx> IceInternal::createProxy<UnexpectedObjectExceptionTestPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class EchoPrx : public virtual ::Ice::Proxy<EchoPrx, ::Ice::ObjectPrx>
{
public:

    void setConnection(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &EchoPrx::_iceI_setConnection, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setConnectionAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &EchoPrx::_iceI_setConnection, context);
    }

    ::std::function<void()>
    setConnectionAsync(::std::function<void()> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::EchoPrx::_iceI_setConnection, context);
    }

    /// \cond INTERNAL
    void _iceI_setConnection(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &EchoPrx::_iceI_shutdown, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto shutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &EchoPrx::_iceI_shutdown, context);
    }

    ::std::function<void()>
    shutdownAsync(::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::EchoPrx::_iceI_shutdown, context);
    }

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    EchoPrx() = default;
    friend ::std::shared_ptr<EchoPrx> IceInternal::createProxy<EchoPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::Test::S>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::S, S>
{
    static void read(S* istr, ::Test::S& v)
    {
        istr->readAll(v.str);
    }
};

template<typename S>
struct StreamReader<::Test::Base, S>
{
    static void read(S* istr, ::Test::Base& v)
    {
        istr->readAll(v.theS, v.str);
    }
};

template<typename S>
struct StreamWriter<::Test::AbstractBase, S>
{
    static void write(S*, const ::Test::AbstractBase&)
    {
    }
};

template<typename S>
struct StreamReader<::Test::AbstractBase, S>
{
    static void read(S*, ::Test::AbstractBase&)
    {
    }
};

template<typename S>
struct StreamReader<::Test::A, S>
{
    static void read(S* istr, ::Test::A& v)
    {
        istr->readAll(v.theB, v.theC, v.preMarshalInvoked, v.postUnmarshalInvoked);
    }
};

template<typename S>
struct StreamWriter<::Test::B, S>
{
    static void write(S* ostr, const ::Test::B& v)
    {
        ostr->writeAll(v.theA);
    }
};

template<typename S>
struct StreamReader<::Test::B, S>
{
    static void read(S* istr, ::Test::B& v)
    {
        istr->readAll(v.theA);
    }
};

template<typename S>
struct StreamReader<::Test::C, S>
{
    static void read(S* istr, ::Test::C& v)
    {
        istr->readAll(v.theB, v.preMarshalInvoked, v.postUnmarshalInvoked);
    }
};

template<typename S>
struct StreamReader<::Test::D, S>
{
    static void read(S* istr, ::Test::D& v)
    {
        istr->readAll(v.theA, v.theB, v.theC, v.preMarshalInvoked, v.postUnmarshalInvoked);
    }
};

template<typename S>
struct StreamReader<::Test::E, S>
{
    static void read(S* istr, ::Test::E& v)
    {
        istr->readAll(v.i, v.s);
    }
};

template<typename S>
struct StreamReader<::Test::F, S>
{
    static void read(S* istr, ::Test::F& v)
    {
        istr->readAll(v.e1, v.e2);
    }
};

template<typename S>
struct StreamWriter<::Test::G, S>
{
    static void write(S*, const ::Test::G&)
    {
    }
};

template<typename S>
struct StreamReader<::Test::G, S>
{
    static void read(S*, ::Test::G&)
    {
    }
};

template<typename S>
struct StreamReader<::Test::N, S>
{
    static void read(S* istr, ::Test::N& v)
    {
        istr->readAll(v.i);
    }
};

template<typename S>
struct StreamReader<::Test::A1, S>
{
    static void read(S* istr, ::Test::A1& v)
    {
        istr->readAll(v.name);
    }
};

template<typename S>
struct StreamReader<::Test::B1, S>
{
    static void read(S* istr, ::Test::B1& v)
    {
        istr->readAll(v.a1, v.a2);
    }
};

template<typename S>
struct StreamWriter<::Test::D1, S>
{
    static void write(S* ostr, const ::Test::D1& v)
    {
        ostr->writeAll(v.a3, v.a4);
    }
};

template<typename S>
struct StreamReader<::Test::D1, S>
{
    static void read(S* istr, ::Test::D1& v)
    {
        istr->readAll(v.a3, v.a4);
    }
};

template<typename S>
struct StreamReader<::Test::EBase, S>
{
    static void read(S* istr, ::Test::EBase& v)
    {
        istr->readAll(v.a1, v.a2);
    }
};

template<typename S>
struct StreamWriter<::Test::EDerived, S>
{
    static void write(S* ostr, const ::Test::EDerived& v)
    {
        ostr->writeAll(v.a3, v.a4);
    }
};

template<typename S>
struct StreamReader<::Test::EDerived, S>
{
    static void read(S* istr, ::Test::EDerived& v)
    {
        istr->readAll(v.a3, v.a4);
    }
};

template<typename S>
struct StreamReader<::Test::Inner::A, S>
{
    static void read(S* istr, ::Test::Inner::A& v)
    {
        istr->readAll(v.theA);
    }
};

template<typename S>
struct StreamReader<::Test::Inner::Ex, S>
{
    static void read(S* istr, ::Test::Inner::Ex& v)
    {
        istr->readAll(v.reason);
    }
};

template<typename S>
struct StreamReader<::Test::Inner::Sub::A, S>
{
    static void read(S* istr, ::Test::Inner::Sub::A& v)
    {
        istr->readAll(v.theA);
    }
};

template<typename S>
struct StreamReader<::Test::Inner::Sub::Ex, S>
{
    static void read(S* istr, ::Test::Inner::Sub::Ex& v)
    {
        istr->readAll(v.reason);
    }
};

template<typename S>
struct StreamReader<::Test::Recursive, S>
{
    static void read(S* istr, ::Test::Recursive& v)
    {
        istr->readAll(v.v);
    }
};

template<typename S>
struct StreamReader<::Test::K, S>
{
    static void read(S* istr, ::Test::K& v)
    {
        istr->readAll(v.value);
    }
};

template<typename S>
struct StreamReader<::Test::L, S>
{
    static void read(S* istr, ::Test::L& v)
    {
        istr->readAll(v.data);
    }
};

template<>
struct StreamableTraits<::Test::StructKey>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::StructKey, S>
{
    static void read(S* istr, ::Test::StructKey& v)
    {
        istr->readAll(v.i, v.s);
    }
};

template<typename S>
struct StreamReader<::Test::M, S>
{
    static void read(S* istr, ::Test::M& v)
    {
        istr->readAll(v.v);
    }
};

template<typename S>
struct StreamReader<::Test::F3, S>
{
    static void read(S* istr, ::Test::F3& v)
    {
        istr->readAll(v.f1, v.f2);
    }
};

template<typename S>
struct StreamReader<::Test::COneMember, S>
{
    static void read(S* istr, ::Test::COneMember& v)
    {
        istr->readAll(v.e);
    }
};

template<typename S>
struct StreamReader<::Test::CTwoMembers, S>
{
    static void read(S* istr, ::Test::CTwoMembers& v)
    {
        istr->readAll(v.e1, v.e2);
    }
};

template<typename S>
struct StreamReader<::Test::EOneMember, S>
{
    static void read(S* istr, ::Test::EOneMember& v)
    {
        istr->readAll(v.e);
    }
};

template<typename S>
struct StreamReader<::Test::ETwoMembers, S>
{
    static void read(S* istr, ::Test::ETwoMembers& v)
    {
        istr->readAll(v.e1, v.e2);
    }
};

template<>
struct StreamableTraits<::Test::SOneMember>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::SOneMember, S>
{
    static void read(S* istr, ::Test::SOneMember& v)
    {
        istr->readAll(v.e);
    }
};

template<>
struct StreamableTraits<::Test::STwoMembers>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::STwoMembers, S>
{
    static void read(S* istr, ::Test::STwoMembers& v)
    {
        istr->readAll(v.e1, v.e2);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace Test
{

using BasePtr = ::std::shared_ptr<Base>;

using AbstractBasePtr = ::std::shared_ptr<AbstractBase>;
using AbstractBasePrxPtr = ::std::shared_ptr<AbstractBasePrx>;

using BPtr = ::std::shared_ptr<B>;

using CPtr = ::std::shared_ptr<C>;

using APtr = ::std::shared_ptr<A>;

using DPtr = ::std::shared_ptr<D>;

using EPtr = ::std::shared_ptr<E>;

using FPtr = ::std::shared_ptr<F>;

using GPtr = ::std::shared_ptr<G>;

using IPtr = ::std::shared_ptr<I>;
using IPrxPtr = ::std::shared_ptr<IPrx>;

using JPtr = ::std::shared_ptr<J>;
using JPrxPtr = ::std::shared_ptr<JPrx>;

using HPtr = ::std::shared_ptr<H>;
using HPrxPtr = ::std::shared_ptr<HPrx>;

using NPtr = ::std::shared_ptr<N>;

using CompactExtPtr = ::std::shared_ptr<CompactExt>;

using CompactPtr = ::std::shared_ptr<Compact>;

using A1Ptr = ::std::shared_ptr<A1>;

using B1Ptr = ::std::shared_ptr<B1>;

using D1Ptr = ::std::shared_ptr<D1>;

/// \cond INTERNAL
namespace Inner
{

using APtr = ::std::shared_ptr<A>;

/// \cond INTERNAL
namespace Sub
{

using APtr = ::std::shared_ptr<A>;

}
/// \endcond

}
/// \endcond

using RecursivePtr = ::std::shared_ptr<Recursive>;

using KPtr = ::std::shared_ptr<K>;

using LPtr = ::std::shared_ptr<L>;

using MPtr = ::std::shared_ptr<M>;

using F1Ptr = ::std::shared_ptr<F1>;

using F2Ptr = ::std::shared_ptr<F2>;
using F2PrxPtr = ::std::shared_ptr<F2Prx>;

using F3Ptr = ::std::shared_ptr<F3>;

using InitialPtr = ::std::shared_ptr<Initial>;
using InitialPrxPtr = ::std::shared_ptr<InitialPrx>;

using EmptyPtr = ::std::shared_ptr<Empty>;

using AlsoEmptyPtr = ::std::shared_ptr<AlsoEmpty>;

using UnexpectedObjectExceptionTestPtr = ::std::shared_ptr<UnexpectedObjectExceptionTest>;
using UnexpectedObjectExceptionTestPrxPtr = ::std::shared_ptr<UnexpectedObjectExceptionTestPrx>;

using COneMemberPtr = ::std::shared_ptr<COneMember>;

using CTwoMembersPtr = ::std::shared_ptr<CTwoMembers>;

using EchoPtr = ::std::shared_ptr<Echo>;
using EchoPrxPtr = ::std::shared_ptr<EchoPrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace Test
{

class Base;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Base>&);
::IceProxy::Ice::Object* upCast(Base*);
/// \endcond

class AbstractBase;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< AbstractBase>&);
::IceProxy::Ice::Object* upCast(AbstractBase*);
/// \endcond

class B;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< B>&);
::IceProxy::Ice::Object* upCast(B*);
/// \endcond

class C;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< C>&);
::IceProxy::Ice::Object* upCast(C*);
/// \endcond

class A;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< A>&);
::IceProxy::Ice::Object* upCast(A*);
/// \endcond

class D;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< D>&);
::IceProxy::Ice::Object* upCast(D*);
/// \endcond

class E;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< E>&);
::IceProxy::Ice::Object* upCast(E*);
/// \endcond

class F;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< F>&);
::IceProxy::Ice::Object* upCast(F*);
/// \endcond

class G;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< G>&);
::IceProxy::Ice::Object* upCast(G*);
/// \endcond

class I;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< I>&);
::IceProxy::Ice::Object* upCast(I*);
/// \endcond

class J;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< J>&);
::IceProxy::Ice::Object* upCast(J*);
/// \endcond

class H;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< H>&);
::IceProxy::Ice::Object* upCast(H*);
/// \endcond

class N;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< N>&);
::IceProxy::Ice::Object* upCast(N*);
/// \endcond

class CompactExt;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< CompactExt>&);
::IceProxy::Ice::Object* upCast(CompactExt*);
/// \endcond

class Compact;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Compact>&);
::IceProxy::Ice::Object* upCast(Compact*);
/// \endcond

class A1;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< A1>&);
::IceProxy::Ice::Object* upCast(A1*);
/// \endcond

class B1;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< B1>&);
::IceProxy::Ice::Object* upCast(B1*);
/// \endcond

class D1;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< D1>&);
::IceProxy::Ice::Object* upCast(D1*);
/// \endcond

namespace Inner
{

class A;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< A>&);
::IceProxy::Ice::Object* upCast(A*);
/// \endcond

namespace Sub
{

class A;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< A>&);
::IceProxy::Ice::Object* upCast(A*);
/// \endcond

}

}

class Recursive;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Recursive>&);
::IceProxy::Ice::Object* upCast(Recursive*);
/// \endcond

class K;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< K>&);
::IceProxy::Ice::Object* upCast(K*);
/// \endcond

class L;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< L>&);
::IceProxy::Ice::Object* upCast(L*);
/// \endcond

class M;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< M>&);
::IceProxy::Ice::Object* upCast(M*);
/// \endcond

class F1;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< F1>&);
::IceProxy::Ice::Object* upCast(F1*);
/// \endcond

class F2;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< F2>&);
::IceProxy::Ice::Object* upCast(F2*);
/// \endcond

class F3;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< F3>&);
::IceProxy::Ice::Object* upCast(F3*);
/// \endcond

class Initial;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Initial>&);
::IceProxy::Ice::Object* upCast(Initial*);
/// \endcond

class Empty;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Empty>&);
::IceProxy::Ice::Object* upCast(Empty*);
/// \endcond

class AlsoEmpty;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< AlsoEmpty>&);
::IceProxy::Ice::Object* upCast(AlsoEmpty*);
/// \endcond

class UnexpectedObjectExceptionTest;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< UnexpectedObjectExceptionTest>&);
::IceProxy::Ice::Object* upCast(UnexpectedObjectExceptionTest*);
/// \endcond

class COneMember;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< COneMember>&);
::IceProxy::Ice::Object* upCast(COneMember*);
/// \endcond

class CTwoMembers;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< CTwoMembers>&);
::IceProxy::Ice::Object* upCast(CTwoMembers*);
/// \endcond

class Echo;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Echo>&);
::IceProxy::Ice::Object* upCast(Echo*);
/// \endcond

}

}

namespace Test
{

class Base;
/// \cond INTERNAL
::Ice::Object* upCast(Base*);
/// \endcond
typedef ::IceInternal::Handle< Base> BasePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Base> BasePrx;
typedef BasePrx BasePrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(BasePtr&, const ::Ice::ObjectPtr&);
/// \endcond

class AbstractBase;
/// \cond INTERNAL
::Ice::Object* upCast(AbstractBase*);
/// \endcond
typedef ::IceInternal::Handle< AbstractBase> AbstractBasePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::AbstractBase> AbstractBasePrx;
typedef AbstractBasePrx AbstractBasePrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(AbstractBasePtr&, const ::Ice::ObjectPtr&);
/// \endcond

class B;
/// \cond INTERNAL
::Ice::Object* upCast(B*);
/// \endcond
typedef ::IceInternal::Handle< B> BPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::B> BPrx;
typedef BPrx BPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(BPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class C;
/// \cond INTERNAL
::Ice::Object* upCast(C*);
/// \endcond
typedef ::IceInternal::Handle< C> CPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::C> CPrx;
typedef CPrx CPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(CPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class A;
/// \cond INTERNAL
::Ice::Object* upCast(A*);
/// \endcond
typedef ::IceInternal::Handle< A> APtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::A> APrx;
typedef APrx APrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(APtr&, const ::Ice::ObjectPtr&);
/// \endcond

class D;
/// \cond INTERNAL
::Ice::Object* upCast(D*);
/// \endcond
typedef ::IceInternal::Handle< D> DPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::D> DPrx;
typedef DPrx DPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(DPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class E;
/// \cond INTERNAL
::Ice::Object* upCast(E*);
/// \endcond
typedef ::IceInternal::Handle< E> EPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::E> EPrx;
typedef EPrx EPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(EPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class F;
/// \cond INTERNAL
::Ice::Object* upCast(F*);
/// \endcond
typedef ::IceInternal::Handle< F> FPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::F> FPrx;
typedef FPrx FPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(FPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class G;
/// \cond INTERNAL
::Ice::Object* upCast(G*);
/// \endcond
typedef ::IceInternal::Handle< G> GPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::G> GPrx;
typedef GPrx GPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(GPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class I;
/// \cond INTERNAL
::Ice::Object* upCast(I*);
/// \endcond
typedef ::IceInternal::Handle< I> IPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::I> IPrx;
typedef IPrx IPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(IPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class J;
/// \cond INTERNAL
::Ice::Object* upCast(J*);
/// \endcond
typedef ::IceInternal::Handle< J> JPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::J> JPrx;
typedef JPrx JPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(JPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class H;
/// \cond INTERNAL
::Ice::Object* upCast(H*);
/// \endcond
typedef ::IceInternal::Handle< H> HPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::H> HPrx;
typedef HPrx HPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(HPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class N;
/// \cond INTERNAL
::Ice::Object* upCast(N*);
/// \endcond
typedef ::IceInternal::Handle< N> NPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::N> NPrx;
typedef NPrx NPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(NPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class CompactExt;
/// \cond INTERNAL
::Ice::Object* upCast(CompactExt*);
/// \endcond
typedef ::IceInternal::Handle< CompactExt> CompactExtPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::CompactExt> CompactExtPrx;
typedef CompactExtPrx CompactExtPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(CompactExtPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class Compact;
/// \cond INTERNAL
::Ice::Object* upCast(Compact*);
/// \endcond
typedef ::IceInternal::Handle< Compact> CompactPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Compact> CompactPrx;
typedef CompactPrx CompactPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(CompactPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class A1;
/// \cond INTERNAL
::Ice::Object* upCast(A1*);
/// \endcond
typedef ::IceInternal::Handle< A1> A1Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::A1> A1Prx;
typedef A1Prx A1PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(A1Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class B1;
/// \cond INTERNAL
::Ice::Object* upCast(B1*);
/// \endcond
typedef ::IceInternal::Handle< B1> B1Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::B1> B1Prx;
typedef B1Prx B1PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(B1Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class D1;
/// \cond INTERNAL
::Ice::Object* upCast(D1*);
/// \endcond
typedef ::IceInternal::Handle< D1> D1Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::D1> D1Prx;
typedef D1Prx D1PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(D1Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

namespace Inner
{

class A;
/// \cond INTERNAL
::Ice::Object* upCast(A*);
/// \endcond
typedef ::IceInternal::Handle< A> APtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Inner::A> APrx;
typedef APrx APrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(APtr&, const ::Ice::ObjectPtr&);
/// \endcond

namespace Sub
{

class A;
/// \cond INTERNAL
::Ice::Object* upCast(A*);
/// \endcond
typedef ::IceInternal::Handle< A> APtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Inner::Sub::A> APrx;
typedef APrx APrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(APtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

}

class Recursive;
/// \cond INTERNAL
::Ice::Object* upCast(Recursive*);
/// \endcond
typedef ::IceInternal::Handle< Recursive> RecursivePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Recursive> RecursivePrx;
typedef RecursivePrx RecursivePrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(RecursivePtr&, const ::Ice::ObjectPtr&);
/// \endcond

class K;
/// \cond INTERNAL
::Ice::Object* upCast(K*);
/// \endcond
typedef ::IceInternal::Handle< K> KPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::K> KPrx;
typedef KPrx KPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(KPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class L;
/// \cond INTERNAL
::Ice::Object* upCast(L*);
/// \endcond
typedef ::IceInternal::Handle< L> LPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::L> LPrx;
typedef LPrx LPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(LPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class M;
/// \cond INTERNAL
::Ice::Object* upCast(M*);
/// \endcond
typedef ::IceInternal::Handle< M> MPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::M> MPrx;
typedef MPrx MPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(MPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class F1;
/// \cond INTERNAL
::Ice::Object* upCast(F1*);
/// \endcond
typedef ::IceInternal::Handle< F1> F1Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::F1> F1Prx;
typedef F1Prx F1PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(F1Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class F2;
/// \cond INTERNAL
::Ice::Object* upCast(F2*);
/// \endcond
typedef ::IceInternal::Handle< F2> F2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::F2> F2Prx;
typedef F2Prx F2PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(F2Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class F3;
/// \cond INTERNAL
::Ice::Object* upCast(F3*);
/// \endcond
typedef ::IceInternal::Handle< F3> F3Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::F3> F3Prx;
typedef F3Prx F3PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(F3Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class Initial;
/// \cond INTERNAL
::Ice::Object* upCast(Initial*);
/// \endcond
typedef ::IceInternal::Handle< Initial> InitialPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Initial> InitialPrx;
typedef InitialPrx InitialPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(InitialPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class Empty;
/// \cond INTERNAL
::Ice::Object* upCast(Empty*);
/// \endcond
typedef ::IceInternal::Handle< Empty> EmptyPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Empty> EmptyPrx;
typedef EmptyPrx EmptyPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(EmptyPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class AlsoEmpty;
/// \cond INTERNAL
::Ice::Object* upCast(AlsoEmpty*);
/// \endcond
typedef ::IceInternal::Handle< AlsoEmpty> AlsoEmptyPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::AlsoEmpty> AlsoEmptyPrx;
typedef AlsoEmptyPrx AlsoEmptyPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(AlsoEmptyPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class UnexpectedObjectExceptionTest;
/// \cond INTERNAL
::Ice::Object* upCast(UnexpectedObjectExceptionTest*);
/// \endcond
typedef ::IceInternal::Handle< UnexpectedObjectExceptionTest> UnexpectedObjectExceptionTestPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::UnexpectedObjectExceptionTest> UnexpectedObjectExceptionTestPrx;
typedef UnexpectedObjectExceptionTestPrx UnexpectedObjectExceptionTestPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(UnexpectedObjectExceptionTestPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class COneMember;
/// \cond INTERNAL
::Ice::Object* upCast(COneMember*);
/// \endcond
typedef ::IceInternal::Handle< COneMember> COneMemberPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::COneMember> COneMemberPrx;
typedef COneMemberPrx COneMemberPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(COneMemberPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class CTwoMembers;
/// \cond INTERNAL
::Ice::Object* upCast(CTwoMembers*);
/// \endcond
typedef ::IceInternal::Handle< CTwoMembers> CTwoMembersPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::CTwoMembers> CTwoMembersPrx;
typedef CTwoMembersPrx CTwoMembersPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(CTwoMembersPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class Echo;
/// \cond INTERNAL
::Ice::Object* upCast(Echo*);
/// \endcond
typedef ::IceInternal::Handle< Echo> EchoPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Echo> EchoPrx;
typedef EchoPrx EchoPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(EchoPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace Test
{

struct S
{
    ::std::string str;

    bool operator==(const S& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(str != rhs_.str)
        {
            return false;
        }
        return true;
    }

    bool operator<(const S& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(str < rhs_.str)
        {
            return true;
        }
        else if(rhs_.str < str)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const S& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const S& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const S& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const S& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<BasePtr> BaseSeq;

const ::Ice::Int CompactExtId = 789;

class EBase : public ::Ice::UserException
{
public:

    EBase() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    EBase(const A1Ptr& a1, const A1Ptr& a2);

#ifdef ICE_CPP11_COMPILER
    EBase(const EBase&) = default;
    virtual ~EBase();
#else
    virtual ~EBase() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual EBase* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    /// \cond STREAM
    virtual bool _usesClasses() const;
    /// \endcond

    ::Test::A1Ptr a1;
    ::Test::A1Ptr a2;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
static EBase _iceS_EBase_init;
/// \endcond

class EDerived : public EBase
{
public:

    EDerived() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    EDerived(const A1Ptr& a1, const A1Ptr& a2, const A1Ptr& a3, const A1Ptr& a4);

#ifdef ICE_CPP11_COMPILER
    EDerived(const EDerived&) = default;
    virtual ~EDerived();
#else
    virtual ~EDerived() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual EDerived* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::Test::A1Ptr a3;
    ::Test::A1Ptr a4;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

namespace Inner
{

class Ex : public ::Ice::UserException
{
public:

    Ex() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    explicit Ex(const ::std::string& reason);

#ifdef ICE_CPP11_COMPILER
    Ex(const Ex&) = default;
    virtual ~Ex();
#else
    virtual ~Ex() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual Ex* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::std::string reason;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

namespace Sub
{

class Ex : public ::Ice::UserException
{
public:

    Ex() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    explicit Ex(const ::std::string& reason);

#ifdef ICE_CPP11_COMPILER
    Ex(const Ex&) = default;
    virtual ~Ex();
#else
    virtual ~Ex() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual Ex* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::std::string reason;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

}

}

typedef ::std::vector< ::Ice::ValuePtr> ValueSeq;

typedef ::std::map< ::std::string, ::Ice::ValuePtr> ValueMap;

struct StructKey
{
    ::Ice::Int i;
    ::std::string s;

    bool operator==(const StructKey& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(i != rhs_.i)
        {
            return false;
        }
        if(s != rhs_.s)
        {
            return false;
        }
        return true;
    }

    bool operator<(const StructKey& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(i < rhs_.i)
        {
            return true;
        }
        else if(rhs_.i < i)
        {
            return false;
        }
        if(s < rhs_.s)
        {
            return true;
        }
        else if(rhs_.s < s)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const StructKey& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const StructKey& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const StructKey& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const StructKey& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::map<StructKey, LPtr> LMap;

class EOneMember : public ::Ice::UserException
{
public:

    EOneMember() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    explicit EOneMember(const EmptyPtr& e);

#ifdef ICE_CPP11_COMPILER
    EOneMember(const EOneMember&) = default;
    virtual ~EOneMember();
#else
    virtual ~EOneMember() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual EOneMember* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    /// \cond STREAM
    virtual bool _usesClasses() const;
    /// \endcond

    ::Test::EmptyPtr e;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

class ETwoMembers : public ::Ice::UserException
{
public:

    ETwoMembers() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    ETwoMembers(const EmptyPtr& e1, const EmptyPtr& e2);

#ifdef ICE_CPP11_COMPILER
    ETwoMembers(const ETwoMembers&) = default;
    virtual ~ETwoMembers();
#else
    virtual ~ETwoMembers() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual ETwoMembers* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    /// \cond STREAM
    virtual bool _usesClasses() const;
    /// \endcond

    ::Test::EmptyPtr e1;
    ::Test::EmptyPtr e2;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

struct SOneMember
{
    ::Test::EmptyPtr e;
};

struct STwoMembers
{
    ::Test::EmptyPtr e1;
    ::Test::EmptyPtr e2;
};

typedef ::std::map< ::Ice::Int, COneMemberPtr> DOneMember;

typedef ::std::map< ::Ice::Int, CTwoMembersPtr> DTwoMembers;

}

namespace Test
{

/**
 * AMD callback class for Test::Initial::getAMDMB_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_Initial_getAMDMB : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_Initial_getAMDMB();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const BPtr& result) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_Initial_getAMDMB> AMD_Initial_getAMDMBPtr;

}

/// \cond INTERNAL
namespace IceAsync
{

namespace Test
{

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_Initial_getAMDMB : public ::Test::AMD_Initial_getAMDMB, public ::IceInternal::IncomingAsync
{
public:

    AMD_Initial_getAMDMB(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::BPtr&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

}

}
/// \endcond

namespace Test
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::AbstractBase::begin_op.
 * Create a wrapper instance by calling ::Test::newCallback_AbstractBase_op.
 */
class Callback_AbstractBase_op_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_AbstractBase_op_Base> Callback_AbstractBase_opPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::I::begin_doI.
 * Create a wrapper instance by calling ::Test::newCallback_I_doI.
 */
class Callback_I_doI_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_I_doI_Base> Callback_I_doIPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::J::begin_doJ.
 * Create a wrapper instance by calling ::Test::newCallback_J_doJ.
 */
class Callback_J_doJ_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_J_doJ_Base> Callback_J_doJPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::H::begin_doH.
 * Create a wrapper instance by calling ::Test::newCallback_H_doH.
 */
class Callback_H_doH_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_H_doH_Base> Callback_H_doHPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::H::begin_doH2.
 * Create a wrapper instance by calling ::Test::newCallback_H_doH2.
 */
class Callback_H_doH2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_H_doH2_Base> Callback_H_doH2Ptr;

namespace Inner
{

namespace Sub
{

}

}

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_shutdown.
 */
class Callback_Initial_shutdown_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_shutdown_Base> Callback_Initial_shutdownPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_getB1.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getB1.
 */
class Callback_Initial_getB1_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_getB1_Base> Callback_Initial_getB1Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_getB2.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getB2.
 */
class Callback_Initial_getB2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_getB2_Base> Callback_Initial_getB2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_getC.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getC.
 */
class Callback_Initial_getC_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_getC_Base> Callback_Initial_getCPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_getD.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getD.
 */
class Callback_Initial_getD_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_getD_Base> Callback_Initial_getDPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_getE.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getE.
 */
class Callback_Initial_getE_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_getE_Base> Callback_Initial_getEPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_getF.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getF.
 */
class Callback_Initial_getF_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_getF_Base> Callback_Initial_getFPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_setRecursive.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_setRecursive.
 */
class Callback_Initial_setRecursive_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_setRecursive_Base> Callback_Initial_setRecursivePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_supportsClassGraphDepthMax.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_supportsClassGraphDepthMax.
 */
class Callback_Initial_supportsClassGraphDepthMax_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_supportsClassGraphDepthMax_Base> Callback_Initial_supportsClassGraphDepthMaxPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_setCycle.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_setCycle.
 */
class Callback_Initial_setCycle_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_setCycle_Base> Callback_Initial_setCyclePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_acceptsClassCycles.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_acceptsClassCycles.
 */
class Callback_Initial_acceptsClassCycles_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_acceptsClassCycles_Base> Callback_Initial_acceptsClassCyclesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_getMB.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getMB.
 */
class Callback_Initial_getMB_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_getMB_Base> Callback_Initial_getMBPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_getAMDMB.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getAMDMB.
 */
class Callback_Initial_getAMDMB_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_getAMDMB_Base> Callback_Initial_getAMDMBPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_getAll.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getAll.
 */
class Callback_Initial_getAll_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_getAll_Base> Callback_Initial_getAllPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_getH.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getH.
 */
class Callback_Initial_getH_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_getH_Base> Callback_Initial_getHPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_getI.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getI.
 */
class Callback_Initial_getI_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_getI_Base> Callback_Initial_getIPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_getJ.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getJ.
 */
class Callback_Initial_getJ_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_getJ_Base> Callback_Initial_getJPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_getK.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getK.
 */
class Callback_Initial_getK_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_getK_Base> Callback_Initial_getKPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opValue.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opValue.
 */
class Callback_Initial_opValue_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opValue_Base> Callback_Initial_opValuePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opValueSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opValueSeq.
 */
class Callback_Initial_opValueSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opValueSeq_Base> Callback_Initial_opValueSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opValueMap.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opValueMap.
 */
class Callback_Initial_opValueMap_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opValueMap_Base> Callback_Initial_opValueMapPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_getD1.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getD1.
 */
class Callback_Initial_getD1_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_getD1_Base> Callback_Initial_getD1Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_throwEDerived.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_throwEDerived.
 */
class Callback_Initial_throwEDerived_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_throwEDerived_Base> Callback_Initial_throwEDerivedPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_setG.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_setG.
 */
class Callback_Initial_setG_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_setG_Base> Callback_Initial_setGPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_setI.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_setI.
 */
class Callback_Initial_setI_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_setI_Base> Callback_Initial_setIPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opBaseSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opBaseSeq.
 */
class Callback_Initial_opBaseSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opBaseSeq_Base> Callback_Initial_opBaseSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_getCompact.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getCompact.
 */
class Callback_Initial_getCompact_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_getCompact_Base> Callback_Initial_getCompactPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_getInnerA.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getInnerA.
 */
class Callback_Initial_getInnerA_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_getInnerA_Base> Callback_Initial_getInnerAPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_getInnerSubA.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getInnerSubA.
 */
class Callback_Initial_getInnerSubA_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_getInnerSubA_Base> Callback_Initial_getInnerSubAPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_throwInnerEx.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_throwInnerEx.
 */
class Callback_Initial_throwInnerEx_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_throwInnerEx_Base> Callback_Initial_throwInnerExPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_throwInnerSubEx.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_throwInnerSubEx.
 */
class Callback_Initial_throwInnerSubEx_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_throwInnerSubEx_Base> Callback_Initial_throwInnerSubExPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opM.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opM.
 */
class Callback_Initial_opM_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opM_Base> Callback_Initial_opMPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opF1.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opF1.
 */
class Callback_Initial_opF1_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opF1_Base> Callback_Initial_opF1Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opF2.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opF2.
 */
class Callback_Initial_opF2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opF2_Base> Callback_Initial_opF2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opF3.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opF3.
 */
class Callback_Initial_opF3_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opF3_Base> Callback_Initial_opF3Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_hasF3.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_hasF3.
 */
class Callback_Initial_hasF3_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_hasF3_Base> Callback_Initial_hasF3Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Initial::begin_opN.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opN.
 */
class Callback_Initial_opN_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Initial_opN_Base> Callback_Initial_opNPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::UnexpectedObjectExceptionTest::begin_op.
 * Create a wrapper instance by calling ::Test::newCallback_UnexpectedObjectExceptionTest_op.
 */
class Callback_UnexpectedObjectExceptionTest_op_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_UnexpectedObjectExceptionTest_op_Base> Callback_UnexpectedObjectExceptionTest_opPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Echo::begin_setConnection.
 * Create a wrapper instance by calling ::Test::newCallback_Echo_setConnection.
 */
class Callback_Echo_setConnection_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Echo_setConnection_Base> Callback_Echo_setConnectionPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Echo::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_Echo_shutdown.
 */
class Callback_Echo_shutdown_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Echo_shutdown_Base> Callback_Echo_shutdownPtr;

}

namespace IceProxy
{

namespace Test
{

class Base : public virtual ::Ice::Proxy<Base, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class AbstractBase : public virtual ::Ice::Proxy<AbstractBase, ::IceProxy::Test::Base>
{
public:

    void op(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_op(_iceI_begin_op(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_op(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Test::Callback_AbstractBase_opPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& context, const ::Test::Callback_AbstractBase_opPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op(context, cb, cookie);
    }

    void end_op(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_op(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class A : public virtual ::Ice::Proxy<A, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class B : public virtual ::Ice::Proxy<B, ::IceProxy::Test::A>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class C : public virtual ::Ice::Proxy<C, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class D : public virtual ::Ice::Proxy<D, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class E : public virtual ::Ice::Proxy<E, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class F : public virtual ::Ice::Proxy<F, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class G : public virtual ::Ice::Proxy<G, ::IceProxy::Test::Base>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class I : public virtual ::Ice::Proxy<I, ::IceProxy::Ice::Object>
{
public:

    void doI(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_doI(_iceI_begin_doI(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_doI(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_doI(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_doI(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_doI(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_doI(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_doI(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_doI(const ::Test::Callback_I_doIPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_doI(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_doI(const ::Ice::Context& context, const ::Test::Callback_I_doIPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_doI(context, cb, cookie);
    }

    void end_doI(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_doI(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class J : public virtual ::Ice::Proxy<J, ::IceProxy::Test::I>
{
public:

    void doJ(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_doJ(_iceI_begin_doJ(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_doJ(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_doJ(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_doJ(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_doJ(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_doJ(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_doJ(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_doJ(const ::Test::Callback_J_doJPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_doJ(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_doJ(const ::Ice::Context& context, const ::Test::Callback_J_doJPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_doJ(context, cb, cookie);
    }

    void end_doJ(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_doJ(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class H : public virtual ::Ice::Proxy<H, ::IceProxy::Test::I>
{
public:

    void doH(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_doH(_iceI_begin_doH(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_doH(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_doH(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_doH(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_doH(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_doH(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_doH(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_doH(const ::Test::Callback_H_doHPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_doH(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_doH(const ::Ice::Context& context, const ::Test::Callback_H_doHPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_doH(context, cb, cookie);
    }

    void end_doH(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_doH(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void doH2(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_doH2(_iceI_begin_doH2(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_doH2(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_doH2(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_doH2(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_doH2(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_doH2(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_doH2(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_doH2(const ::Test::Callback_H_doH2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_doH2(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_doH2(const ::Ice::Context& context, const ::Test::Callback_H_doH2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_doH2(context, cb, cookie);
    }

    void end_doH2(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_doH2(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class N : public virtual ::Ice::Proxy<N, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Compact : public virtual ::Ice::Proxy<Compact, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class CompactExt : public virtual ::Ice::Proxy<CompactExt, ::IceProxy::Test::Compact>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class A1 : public virtual ::Ice::Proxy<A1, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class B1 : public virtual ::Ice::Proxy<B1, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class D1 : public virtual ::Ice::Proxy<D1, ::IceProxy::Test::B1>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

namespace Inner
{

class A : public virtual ::Ice::Proxy<A, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

namespace Sub
{

class A : public virtual ::Ice::Proxy<A, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

class Recursive : public virtual ::Ice::Proxy<Recursive, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class K : public virtual ::Ice::Proxy<K, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class L : public virtual ::Ice::Proxy<L, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class M : public virtual ::Ice::Proxy<M, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class F3 : public virtual ::Ice::Proxy<F3, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Initial : public virtual ::Ice::Proxy<Initial, ::IceProxy::Ice::Object>
{
public:

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_shutdown(_iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Test::Callback_Initial_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Test::Callback_Initial_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    void end_shutdown(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_shutdown(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BPtr getB1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getB1(_iceI_begin_getB1(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getB1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getB1(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getB1(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getB1(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getB1(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getB1(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getB1(const ::Test::Callback_Initial_getB1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getB1(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getB1(const ::Ice::Context& context, const ::Test::Callback_Initial_getB1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getB1(context, cb, cookie);
    }

    ::Test::BPtr end_getB1(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getB1(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BPtr getB2(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getB2(_iceI_begin_getB2(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getB2(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getB2(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getB2(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getB2(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getB2(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getB2(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getB2(const ::Test::Callback_Initial_getB2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getB2(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getB2(const ::Ice::Context& context, const ::Test::Callback_Initial_getB2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getB2(context, cb, cookie);
    }

    ::Test::BPtr end_getB2(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getB2(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::CPtr getC(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getC(_iceI_begin_getC(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getC(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getC(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getC(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getC(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getC(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getC(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getC(const ::Test::Callback_Initial_getCPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getC(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getC(const ::Ice::Context& context, const ::Test::Callback_Initial_getCPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getC(context, cb, cookie);
    }

    ::Test::CPtr end_getC(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getC(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::DPtr getD(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getD(_iceI_begin_getD(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getD(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getD(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getD(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getD(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getD(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getD(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getD(const ::Test::Callback_Initial_getDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getD(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getD(const ::Ice::Context& context, const ::Test::Callback_Initial_getDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getD(context, cb, cookie);
    }

    ::Test::DPtr end_getD(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getD(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::EPtr getE(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getE(_iceI_begin_getE(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getE(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getE(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getE(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getE(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getE(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getE(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getE(const ::Test::Callback_Initial_getEPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getE(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getE(const ::Ice::Context& context, const ::Test::Callback_Initial_getEPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getE(context, cb, cookie);
    }

    ::Test::EPtr end_getE(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getE(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::FPtr getF(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getF(_iceI_begin_getF(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getF(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getF(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getF(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getF(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getF(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getF(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getF(const ::Test::Callback_Initial_getFPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getF(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getF(const ::Ice::Context& context, const ::Test::Callback_Initial_getFPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getF(context, cb, cookie);
    }

    ::Test::FPtr end_getF(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getF(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void setRecursive(const ::Test::RecursivePtr& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_setRecursive(_iceI_begin_setRecursive(p, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setRecursive(const ::Test::RecursivePtr& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setRecursive(p, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setRecursive(const ::Test::RecursivePtr& p, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setRecursive(p, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setRecursive(const ::Test::RecursivePtr& p, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setRecursive(p, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setRecursive(const ::Test::RecursivePtr& p, const ::Test::Callback_Initial_setRecursivePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setRecursive(p, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setRecursive(const ::Test::RecursivePtr& p, const ::Ice::Context& context, const ::Test::Callback_Initial_setRecursivePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setRecursive(p, context, cb, cookie);
    }

    void end_setRecursive(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setRecursive(const ::Test::RecursivePtr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool supportsClassGraphDepthMax(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_supportsClassGraphDepthMax(_iceI_begin_supportsClassGraphDepthMax(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_supportsClassGraphDepthMax(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_supportsClassGraphDepthMax(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_supportsClassGraphDepthMax(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsClassGraphDepthMax(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsClassGraphDepthMax(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsClassGraphDepthMax(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsClassGraphDepthMax(const ::Test::Callback_Initial_supportsClassGraphDepthMaxPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsClassGraphDepthMax(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsClassGraphDepthMax(const ::Ice::Context& context, const ::Test::Callback_Initial_supportsClassGraphDepthMaxPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsClassGraphDepthMax(context, cb, cookie);
    }

    bool end_supportsClassGraphDepthMax(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_supportsClassGraphDepthMax(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void setCycle(const ::Test::RecursivePtr& r, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_setCycle(_iceI_begin_setCycle(r, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setCycle(const ::Test::RecursivePtr& r, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setCycle(r, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setCycle(const ::Test::RecursivePtr& r, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setCycle(r, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setCycle(const ::Test::RecursivePtr& r, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setCycle(r, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setCycle(const ::Test::RecursivePtr& r, const ::Test::Callback_Initial_setCyclePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setCycle(r, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setCycle(const ::Test::RecursivePtr& r, const ::Ice::Context& context, const ::Test::Callback_Initial_setCyclePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setCycle(r, context, cb, cookie);
    }

    void end_setCycle(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setCycle(const ::Test::RecursivePtr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool acceptsClassCycles(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_acceptsClassCycles(_iceI_begin_acceptsClassCycles(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_acceptsClassCycles(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_acceptsClassCycles(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_acceptsClassCycles(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_acceptsClassCycles(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_acceptsClassCycles(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_acceptsClassCycles(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_acceptsClassCycles(const ::Test::Callback_Initial_acceptsClassCyclesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_acceptsClassCycles(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_acceptsClassCycles(const ::Ice::Context& context, const ::Test::Callback_Initial_acceptsClassCyclesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_acceptsClassCycles(context, cb, cookie);
    }

    bool end_acceptsClassCycles(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_acceptsClassCycles(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BPtr getMB(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getMB(_iceI_begin_getMB(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getMB(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getMB(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getMB(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getMB(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getMB(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getMB(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getMB(const ::Test::Callback_Initial_getMBPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getMB(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getMB(const ::Ice::Context& context, const ::Test::Callback_Initial_getMBPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getMB(context, cb, cookie);
    }

    ::Test::BPtr end_getMB(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getMB(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BPtr getAMDMB(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getAMDMB(_iceI_begin_getAMDMB(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getAMDMB(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getAMDMB(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAMDMB(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAMDMB(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAMDMB(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAMDMB(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAMDMB(const ::Test::Callback_Initial_getAMDMBPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAMDMB(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAMDMB(const ::Ice::Context& context, const ::Test::Callback_Initial_getAMDMBPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAMDMB(context, cb, cookie);
    }

    ::Test::BPtr end_getAMDMB(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getAMDMB(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void getAll(::Test::BPtr& b1, ::Test::BPtr& b2, ::Test::CPtr& theC, ::Test::DPtr& theD, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_getAll(b1, b2, theC, theD, _iceI_begin_getAll(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getAll(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getAll(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAll(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAll(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAll(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAll(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAll(const ::Test::Callback_Initial_getAllPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAll(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAll(const ::Ice::Context& context, const ::Test::Callback_Initial_getAllPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAll(context, cb, cookie);
    }

    void end_getAll(::Test::BPtr& b1, ::Test::BPtr& b2, ::Test::CPtr& theC, ::Test::DPtr& theD, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_getAll(::Test::BPtr& iceP_b1, ::Test::BPtr& iceP_b2, ::Test::CPtr& iceP_theC, ::Test::DPtr& iceP_theD, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_getAll(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::IPtr getH(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getH(_iceI_begin_getH(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getH(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getH(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getH(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getH(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getH(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getH(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getH(const ::Test::Callback_Initial_getHPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getH(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getH(const ::Ice::Context& context, const ::Test::Callback_Initial_getHPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getH(context, cb, cookie);
    }

    ::Test::IPtr end_getH(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getH(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::IPtr getI(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getI(_iceI_begin_getI(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getI(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getI(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getI(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getI(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getI(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getI(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getI(const ::Test::Callback_Initial_getIPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getI(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getI(const ::Ice::Context& context, const ::Test::Callback_Initial_getIPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getI(context, cb, cookie);
    }

    ::Test::IPtr end_getI(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getI(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::IPtr getJ(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getJ(_iceI_begin_getJ(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getJ(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getJ(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getJ(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getJ(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getJ(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getJ(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getJ(const ::Test::Callback_Initial_getJPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getJ(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getJ(const ::Ice::Context& context, const ::Test::Callback_Initial_getJPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getJ(context, cb, cookie);
    }

    ::Test::IPtr end_getJ(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getJ(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::KPtr getK(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getK(_iceI_begin_getK(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getK(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getK(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getK(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getK(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getK(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getK(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getK(const ::Test::Callback_Initial_getKPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getK(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getK(const ::Ice::Context& context, const ::Test::Callback_Initial_getKPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getK(context, cb, cookie);
    }

    ::Test::KPtr end_getK(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getK(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::ValuePtr opValue(const ::Ice::ValuePtr& v1, ::Ice::ValuePtr& v2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opValue(v2, _iceI_begin_opValue(v1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opValue(const ::Ice::ValuePtr& v1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opValue(v1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opValue(const ::Ice::ValuePtr& v1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opValue(v1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opValue(const ::Ice::ValuePtr& v1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opValue(v1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opValue(const ::Ice::ValuePtr& v1, const ::Test::Callback_Initial_opValuePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opValue(v1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opValue(const ::Ice::ValuePtr& v1, const ::Ice::Context& context, const ::Test::Callback_Initial_opValuePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opValue(v1, context, cb, cookie);
    }

    ::Ice::ValuePtr end_opValue(::Ice::ValuePtr& v2, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opValue(::Ice::ValuePtr& iceP_v2, ::Ice::ValuePtr& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opValue(const ::Ice::ValuePtr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ValueSeq opValueSeq(const ::Test::ValueSeq& v1, ::Test::ValueSeq& v2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opValueSeq(v2, _iceI_begin_opValueSeq(v1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opValueSeq(const ::Test::ValueSeq& v1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opValueSeq(v1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opValueSeq(const ::Test::ValueSeq& v1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opValueSeq(v1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opValueSeq(const ::Test::ValueSeq& v1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opValueSeq(v1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opValueSeq(const ::Test::ValueSeq& v1, const ::Test::Callback_Initial_opValueSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opValueSeq(v1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opValueSeq(const ::Test::ValueSeq& v1, const ::Ice::Context& context, const ::Test::Callback_Initial_opValueSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opValueSeq(v1, context, cb, cookie);
    }

    ::Test::ValueSeq end_opValueSeq(::Test::ValueSeq& v2, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opValueSeq(::Test::ValueSeq& iceP_v2, ::Test::ValueSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opValueSeq(const ::Test::ValueSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ValueMap opValueMap(const ::Test::ValueMap& v1, ::Test::ValueMap& v2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opValueMap(v2, _iceI_begin_opValueMap(v1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opValueMap(const ::Test::ValueMap& v1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opValueMap(v1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opValueMap(const ::Test::ValueMap& v1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opValueMap(v1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opValueMap(const ::Test::ValueMap& v1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opValueMap(v1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opValueMap(const ::Test::ValueMap& v1, const ::Test::Callback_Initial_opValueMapPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opValueMap(v1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opValueMap(const ::Test::ValueMap& v1, const ::Ice::Context& context, const ::Test::Callback_Initial_opValueMapPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opValueMap(v1, context, cb, cookie);
    }

    ::Test::ValueMap end_opValueMap(::Test::ValueMap& v2, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opValueMap(::Test::ValueMap& iceP_v2, ::Test::ValueMap& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opValueMap(const ::Test::ValueMap&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::D1Ptr getD1(const ::Test::D1Ptr& d1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getD1(_iceI_begin_getD1(d1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getD1(const ::Test::D1Ptr& d1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getD1(d1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getD1(const ::Test::D1Ptr& d1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getD1(d1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getD1(const ::Test::D1Ptr& d1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getD1(d1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getD1(const ::Test::D1Ptr& d1, const ::Test::Callback_Initial_getD1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getD1(d1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getD1(const ::Test::D1Ptr& d1, const ::Ice::Context& context, const ::Test::Callback_Initial_getD1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getD1(d1, context, cb, cookie);
    }

    ::Test::D1Ptr end_getD1(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getD1(const ::Test::D1Ptr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwEDerived(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwEDerived(_iceI_begin_throwEDerived(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwEDerived(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwEDerived(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwEDerived(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwEDerived(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwEDerived(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwEDerived(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwEDerived(const ::Test::Callback_Initial_throwEDerivedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwEDerived(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwEDerived(const ::Ice::Context& context, const ::Test::Callback_Initial_throwEDerivedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwEDerived(context, cb, cookie);
    }

    void end_throwEDerived(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwEDerived(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void setG(const ::Test::GPtr& theG, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_setG(_iceI_begin_setG(theG, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setG(const ::Test::GPtr& theG, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setG(theG, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setG(const ::Test::GPtr& theG, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setG(theG, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setG(const ::Test::GPtr& theG, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setG(theG, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setG(const ::Test::GPtr& theG, const ::Test::Callback_Initial_setGPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setG(theG, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setG(const ::Test::GPtr& theG, const ::Ice::Context& context, const ::Test::Callback_Initial_setGPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setG(theG, context, cb, cookie);
    }

    void end_setG(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setG(const ::Test::GPtr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void setI(const ::Test::IPtr& theI, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_setI(_iceI_begin_setI(theI, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setI(const ::Test::IPtr& theI, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setI(theI, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setI(const ::Test::IPtr& theI, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setI(theI, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setI(const ::Test::IPtr& theI, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setI(theI, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setI(const ::Test::IPtr& theI, const ::Test::Callback_Initial_setIPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setI(theI, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setI(const ::Test::IPtr& theI, const ::Ice::Context& context, const ::Test::Callback_Initial_setIPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setI(theI, context, cb, cookie);
    }

    void end_setI(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setI(const ::Test::IPtr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BaseSeq opBaseSeq(const ::Test::BaseSeq& inSeq, ::Test::BaseSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opBaseSeq(outSeq, _iceI_begin_opBaseSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opBaseSeq(const ::Test::BaseSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opBaseSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBaseSeq(const ::Test::BaseSeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBaseSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBaseSeq(const ::Test::BaseSeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBaseSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBaseSeq(const ::Test::BaseSeq& inSeq, const ::Test::Callback_Initial_opBaseSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBaseSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBaseSeq(const ::Test::BaseSeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_Initial_opBaseSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBaseSeq(inSeq, context, cb, cookie);
    }

    ::Test::BaseSeq end_opBaseSeq(::Test::BaseSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opBaseSeq(::Test::BaseSeq& iceP_outSeq, ::Test::BaseSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opBaseSeq(const ::Test::BaseSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::CompactPtr getCompact(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getCompact(_iceI_begin_getCompact(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getCompact(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getCompact(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getCompact(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getCompact(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getCompact(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getCompact(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getCompact(const ::Test::Callback_Initial_getCompactPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getCompact(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getCompact(const ::Ice::Context& context, const ::Test::Callback_Initial_getCompactPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getCompact(context, cb, cookie);
    }

    ::Test::CompactPtr end_getCompact(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getCompact(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::Inner::APtr getInnerA(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getInnerA(_iceI_begin_getInnerA(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getInnerA(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getInnerA(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getInnerA(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getInnerA(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getInnerA(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getInnerA(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getInnerA(const ::Test::Callback_Initial_getInnerAPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getInnerA(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getInnerA(const ::Ice::Context& context, const ::Test::Callback_Initial_getInnerAPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getInnerA(context, cb, cookie);
    }

    ::Test::Inner::APtr end_getInnerA(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getInnerA(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::Inner::Sub::APtr getInnerSubA(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getInnerSubA(_iceI_begin_getInnerSubA(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getInnerSubA(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getInnerSubA(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getInnerSubA(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getInnerSubA(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getInnerSubA(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getInnerSubA(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getInnerSubA(const ::Test::Callback_Initial_getInnerSubAPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getInnerSubA(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getInnerSubA(const ::Ice::Context& context, const ::Test::Callback_Initial_getInnerSubAPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getInnerSubA(context, cb, cookie);
    }

    ::Test::Inner::Sub::APtr end_getInnerSubA(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getInnerSubA(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwInnerEx(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwInnerEx(_iceI_begin_throwInnerEx(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwInnerEx(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwInnerEx(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwInnerEx(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwInnerEx(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwInnerEx(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwInnerEx(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwInnerEx(const ::Test::Callback_Initial_throwInnerExPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwInnerEx(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwInnerEx(const ::Ice::Context& context, const ::Test::Callback_Initial_throwInnerExPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwInnerEx(context, cb, cookie);
    }

    void end_throwInnerEx(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwInnerEx(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwInnerSubEx(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwInnerSubEx(_iceI_begin_throwInnerSubEx(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwInnerSubEx(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwInnerSubEx(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwInnerSubEx(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwInnerSubEx(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwInnerSubEx(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwInnerSubEx(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwInnerSubEx(const ::Test::Callback_Initial_throwInnerSubExPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwInnerSubEx(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwInnerSubEx(const ::Ice::Context& context, const ::Test::Callback_Initial_throwInnerSubExPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwInnerSubEx(context, cb, cookie);
    }

    void end_throwInnerSubEx(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwInnerSubEx(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::MPtr opM(const ::Test::MPtr& v1, ::Test::MPtr& v2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opM(v2, _iceI_begin_opM(v1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opM(const ::Test::MPtr& v1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opM(v1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opM(const ::Test::MPtr& v1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opM(v1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opM(const ::Test::MPtr& v1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opM(v1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opM(const ::Test::MPtr& v1, const ::Test::Callback_Initial_opMPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opM(v1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opM(const ::Test::MPtr& v1, const ::Ice::Context& context, const ::Test::Callback_Initial_opMPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opM(v1, context, cb, cookie);
    }

    ::Test::MPtr end_opM(::Test::MPtr& v2, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opM(::Test::MPtr& iceP_v2, ::Test::MPtr& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opM(const ::Test::MPtr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::F1Ptr opF1(const ::Test::F1Ptr& f11, ::Test::F1Ptr& f12, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opF1(f12, _iceI_begin_opF1(f11, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opF1(const ::Test::F1Ptr& f11, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opF1(f11, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opF1(const ::Test::F1Ptr& f11, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opF1(f11, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opF1(const ::Test::F1Ptr& f11, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opF1(f11, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opF1(const ::Test::F1Ptr& f11, const ::Test::Callback_Initial_opF1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opF1(f11, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opF1(const ::Test::F1Ptr& f11, const ::Ice::Context& context, const ::Test::Callback_Initial_opF1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opF1(f11, context, cb, cookie);
    }

    ::Test::F1Ptr end_opF1(::Test::F1Ptr& f12, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opF1(::Test::F1Ptr& iceP_f12, ::Test::F1Ptr& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opF1(const ::Test::F1Ptr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::F2Prx opF2(const ::Test::F2Prx& f21, ::Test::F2Prx& f22, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opF2(f22, _iceI_begin_opF2(f21, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opF2(const ::Test::F2Prx& f21, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opF2(f21, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opF2(const ::Test::F2Prx& f21, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opF2(f21, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opF2(const ::Test::F2Prx& f21, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opF2(f21, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opF2(const ::Test::F2Prx& f21, const ::Test::Callback_Initial_opF2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opF2(f21, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opF2(const ::Test::F2Prx& f21, const ::Ice::Context& context, const ::Test::Callback_Initial_opF2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opF2(f21, context, cb, cookie);
    }

    ::Test::F2Prx end_opF2(::Test::F2Prx& f22, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opF2(::Test::F2Prx& iceP_f22, ::Test::F2Prx& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opF2(const ::Test::F2Prx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::F3Ptr opF3(const ::Test::F3Ptr& f31, ::Test::F3Ptr& f32, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opF3(f32, _iceI_begin_opF3(f31, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opF3(const ::Test::F3Ptr& f31, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opF3(f31, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opF3(const ::Test::F3Ptr& f31, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opF3(f31, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opF3(const ::Test::F3Ptr& f31, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opF3(f31, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opF3(const ::Test::F3Ptr& f31, const ::Test::Callback_Initial_opF3Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opF3(f31, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opF3(const ::Test::F3Ptr& f31, const ::Ice::Context& context, const ::Test::Callback_Initial_opF3Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opF3(f31, context, cb, cookie);
    }

    ::Test::F3Ptr end_opF3(::Test::F3Ptr& f32, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opF3(::Test::F3Ptr& iceP_f32, ::Test::F3Ptr& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opF3(const ::Test::F3Ptr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool hasF3(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_hasF3(_iceI_begin_hasF3(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_hasF3(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_hasF3(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_hasF3(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_hasF3(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_hasF3(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_hasF3(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_hasF3(const ::Test::Callback_Initial_hasF3Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_hasF3(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_hasF3(const ::Ice::Context& context, const ::Test::Callback_Initial_hasF3Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_hasF3(context, cb, cookie);
    }

    bool end_hasF3(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_hasF3(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::NPtr opN(const ::Test::NPtr& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opN(_iceI_begin_opN(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opN(const ::Test::NPtr& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opN(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opN(const ::Test::NPtr& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opN(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opN(const ::Test::NPtr& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opN(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opN(const ::Test::NPtr& p1, const ::Test::Callback_Initial_opNPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opN(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opN(const ::Test::NPtr& p1, const ::Ice::Context& context, const ::Test::Callback_Initial_opNPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opN(p1, context, cb, cookie);
    }

    ::Test::NPtr end_opN(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opN(const ::Test::NPtr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Empty : public virtual ::Ice::Proxy<Empty, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class AlsoEmpty : public virtual ::Ice::Proxy<AlsoEmpty, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class UnexpectedObjectExceptionTest : public virtual ::Ice::Proxy<UnexpectedObjectExceptionTest, ::IceProxy::Ice::Object>
{
public:

    ::Test::EmptyPtr op(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_op(_iceI_begin_op(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_op(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Test::Callback_UnexpectedObjectExceptionTest_opPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& context, const ::Test::Callback_UnexpectedObjectExceptionTest_opPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op(context, cb, cookie);
    }

    ::Test::EmptyPtr end_op(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_op(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class COneMember : public virtual ::Ice::Proxy<COneMember, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class CTwoMembers : public virtual ::Ice::Proxy<CTwoMembers, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Echo : public virtual ::Ice::Proxy<Echo, ::IceProxy::Ice::Object>
{
public:

    void setConnection(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_setConnection(_iceI_begin_setConnection(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setConnection(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setConnection(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setConnection(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setConnection(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setConnection(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setConnection(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setConnection(const ::Test::Callback_Echo_setConnectionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setConnection(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setConnection(const ::Ice::Context& context, const ::Test::Callback_Echo_setConnectionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setConnection(context, cb, cookie);
    }

    void end_setConnection(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setConnection(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_shutdown(_iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Test::Callback_Echo_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Test::Callback_Echo_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    void end_shutdown(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_shutdown(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace Test
{

class Base : public virtual ::Ice::Object
{
public:

    typedef BasePrx ProxyType;
    typedef BasePtr PointerType;

    virtual ~Base();

    Base()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    Base(const ::Test::S& theS, const ::std::string& str) :
        theS(theS),
        str(str)
    {
    }

#ifdef ICE_CPP11_COMPILER
    Base(const Base&) = default;
    Base& operator=(const Base&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::S theS;
    ::std::string str;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_Base_init = ::Test::Base::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const Base& lhs, const Base& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Base& lhs, const Base& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class AbstractBase : public Base
{
public:

    typedef AbstractBasePrx ProxyType;
    typedef AbstractBasePtr PointerType;

    virtual ~AbstractBase();

    AbstractBase()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    AbstractBase(const ::Test::S& theS, const ::std::string& str) :
        ::Test::Base(theS, str)
    {
    }

#ifdef ICE_CPP11_COMPILER
    AbstractBase(const AbstractBase&) = default;
    AbstractBase& operator=(const AbstractBase&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void op(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_op(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const AbstractBase& lhs, const AbstractBase& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const AbstractBase& lhs, const AbstractBase& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class A : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef APrx ProxyType;
    typedef APtr PointerType;

    virtual ~A();

    A()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    A(const ::Test::BPtr& theB, const ::Test::CPtr& theC, bool preMarshalInvoked, bool postUnmarshalInvoked) :
        theB(theB),
        theC(theC),
        preMarshalInvoked(preMarshalInvoked),
        postUnmarshalInvoked(postUnmarshalInvoked)
    {
    }

#ifdef ICE_CPP11_COMPILER
    A(const A&) = default;
    A& operator=(const A&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::BPtr theB;
    ::Test::CPtr theC;
    bool preMarshalInvoked;
    bool postUnmarshalInvoked;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_A_init = ::Test::A::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const A& lhs, const A& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const A& lhs, const A& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class B : public A
{
public:

    typedef BPrx ProxyType;
    typedef BPtr PointerType;

    virtual ~B();

    B()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    B(const ::Test::BPtr& theB, const ::Test::CPtr& theC, bool preMarshalInvoked, bool postUnmarshalInvoked, const ::Test::APtr& theA) :
        ::Test::A(theB, theC, preMarshalInvoked, postUnmarshalInvoked),
        theA(theA)
    {
    }

#ifdef ICE_CPP11_COMPILER
    B(const B&) = default;
    B& operator=(const B&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::APtr theA;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_B_init = ::Test::B::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const B& lhs, const B& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const B& lhs, const B& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class C : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef CPrx ProxyType;
    typedef CPtr PointerType;

    virtual ~C();

    C()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    C(const ::Test::BPtr& theB, bool preMarshalInvoked, bool postUnmarshalInvoked) :
        theB(theB),
        preMarshalInvoked(preMarshalInvoked),
        postUnmarshalInvoked(postUnmarshalInvoked)
    {
    }

#ifdef ICE_CPP11_COMPILER
    C(const C&) = default;
    C& operator=(const C&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::BPtr theB;
    bool preMarshalInvoked;
    bool postUnmarshalInvoked;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_C_init = ::Test::C::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const C& lhs, const C& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const C& lhs, const C& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class D : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef DPrx ProxyType;
    typedef DPtr PointerType;

    virtual ~D();

    D()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    D(const ::Test::APtr& theA, const ::Test::BPtr& theB, const ::Test::CPtr& theC, bool preMarshalInvoked, bool postUnmarshalInvoked) :
        theA(theA),
        theB(theB),
        theC(theC),
        preMarshalInvoked(preMarshalInvoked),
        postUnmarshalInvoked(postUnmarshalInvoked)
    {
    }

#ifdef ICE_CPP11_COMPILER
    D(const D&) = default;
    D& operator=(const D&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::APtr theA;
    ::Test::BPtr theB;
    ::Test::CPtr theC;
    bool preMarshalInvoked;
    bool postUnmarshalInvoked;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_D_init = ::Test::D::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const D& lhs, const D& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const D& lhs, const D& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class E : public virtual ::Ice::Object
{
public:

    typedef EPrx ProxyType;
    typedef EPtr PointerType;

    virtual ~E();

    E()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    E(::Ice::Int i, const ::std::string& s) :
        i(i),
        s(s)
    {
    }

#ifdef ICE_CPP11_COMPILER
    E(const E&) = default;
    E& operator=(const E&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

    ::Ice::Int i;
    ::std::string s;

    template<typename T, typename S>
    friend struct Ice::StreamWriter;
    template<typename T, typename S>
    friend struct Ice::StreamReader;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_E_init = ::Test::E::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const E& lhs, const E& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const E& lhs, const E& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class F : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef FPrx ProxyType;
    typedef FPtr PointerType;

    virtual ~F();

    F()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    F(const ::Test::EPtr& e1, const ::Test::EPtr& e2) :
        e1(e1),
        e2(e2)
    {
    }

#ifdef ICE_CPP11_COMPILER
    F(const F&) = default;
    F& operator=(const F&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

    ::Test::EPtr e1;

public:

    ::Test::EPtr e2;

protected:

    template<typename T, typename S>
    friend struct Ice::StreamWriter;
    template<typename T, typename S>
    friend struct Ice::StreamReader;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_F_init = ::Test::F::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const F& lhs, const F& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const F& lhs, const F& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class G : public Base
{
public:

    typedef GPrx ProxyType;
    typedef GPtr PointerType;

    virtual ~G();

    G()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    G(const ::Test::S& theS, const ::std::string& str) :
        ::Test::Base(theS, str)
    {
    }

#ifdef ICE_CPP11_COMPILER
    G(const G&) = default;
    G& operator=(const G&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_G_init = ::Test::G::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const G& lhs, const G& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const G& lhs, const G& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class I : public virtual ::Ice::Object
{
public:

    typedef IPrx ProxyType;
    typedef IPtr PointerType;

    virtual ~I();

#ifdef ICE_CPP11_COMPILER
    I() = default;
    I(const I&) = default;
    I& operator=(const I&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void doI(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_doI(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const I& lhs, const I& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const I& lhs, const I& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class J : virtual public I
{
public:

    typedef JPrx ProxyType;
    typedef JPtr PointerType;

    virtual ~J();

#ifdef ICE_CPP11_COMPILER
    J() = default;
    J(const J&) = default;
    J& operator=(const J&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void doJ(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_doJ(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const J& lhs, const J& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const J& lhs, const J& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class H : virtual public I
{
public:

    typedef HPrx ProxyType;
    typedef HPtr PointerType;

    virtual ~H();

    H()
    {
    }

#ifdef ICE_CPP11_COMPILER
    H(const H&) = default;
    H& operator=(const H&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void doH(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_doH(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void doH2(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_doH2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const H& lhs, const H& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const H& lhs, const H& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class N : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef NPrx ProxyType;
    typedef NPtr PointerType;

    virtual ~N();

    N()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit N(const ::Test::IPtr& i) :
        i(i)
    {
    }

#ifdef ICE_CPP11_COMPILER
    N(const N&) = default;
    N& operator=(const N&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::IPtr i;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_N_init = ::Test::N::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const N& lhs, const N& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const N& lhs, const N& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Compact : public virtual ::Ice::Object
{
public:

    typedef CompactPrx ProxyType;
    typedef CompactPtr PointerType;

    virtual ~Compact();

    Compact()
    {
    }

#ifdef ICE_CPP11_COMPILER
    Compact(const Compact&) = default;
    Compact& operator=(const Compact&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_Compact_init = ::Test::Compact::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const Compact& lhs, const Compact& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Compact& lhs, const Compact& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class CompactExt : public Compact
{
public:

    typedef CompactExtPrx ProxyType;
    typedef CompactExtPtr PointerType;

    virtual ~CompactExt();

    CompactExt()
    {
    }

#ifdef ICE_CPP11_COMPILER
    CompactExt(const CompactExt&) = default;
    CompactExt& operator=(const CompactExt&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_CompactExt_init = ::Test::CompactExt::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const CompactExt& lhs, const CompactExt& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const CompactExt& lhs, const CompactExt& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class A1 : public virtual ::Ice::Object
{
public:

    typedef A1Prx ProxyType;
    typedef A1Ptr PointerType;

    virtual ~A1();

    A1()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit A1(const ::std::string& name) :
        name(name)
    {
    }

#ifdef ICE_CPP11_COMPILER
    A1(const A1&) = default;
    A1& operator=(const A1&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string name;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_A1_init = ::Test::A1::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const A1& lhs, const A1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const A1& lhs, const A1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class B1 : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef B1Prx ProxyType;
    typedef B1Ptr PointerType;

    virtual ~B1();

    B1()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    B1(const ::Test::A1Ptr& a1, const ::Test::A1Ptr& a2) :
        a1(a1),
        a2(a2)
    {
    }

#ifdef ICE_CPP11_COMPILER
    B1(const B1&) = default;
    B1& operator=(const B1&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::A1Ptr a1;
    ::Test::A1Ptr a2;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_B1_init = ::Test::B1::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const B1& lhs, const B1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const B1& lhs, const B1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class D1 : public B1
{
public:

    typedef D1Prx ProxyType;
    typedef D1Ptr PointerType;

    virtual ~D1();

    D1()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    D1(const ::Test::A1Ptr& a1, const ::Test::A1Ptr& a2, const ::Test::A1Ptr& a3, const ::Test::A1Ptr& a4) :
        ::Test::B1(a1, a2),
        a3(a3),
        a4(a4)
    {
    }

#ifdef ICE_CPP11_COMPILER
    D1(const D1&) = default;
    D1& operator=(const D1&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::A1Ptr a3;
    ::Test::A1Ptr a4;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_D1_init = ::Test::D1::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const D1& lhs, const D1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const D1& lhs, const D1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

namespace Inner
{

class A : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef APrx ProxyType;
    typedef APtr PointerType;

    virtual ~A();

    A()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit A(const ::Test::APtr& theA) :
        theA(theA)
    {
    }

#ifdef ICE_CPP11_COMPILER
    A(const A&) = default;
    A& operator=(const A&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::APtr theA;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_A_init = ::Test::Inner::A::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const A& lhs, const A& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const A& lhs, const A& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

namespace Sub
{

class A : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef APrx ProxyType;
    typedef APtr PointerType;

    virtual ~A();

    A()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit A(const ::Test::Inner::APtr& theA) :
        theA(theA)
    {
    }

#ifdef ICE_CPP11_COMPILER
    A(const A&) = default;
    A& operator=(const A&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::Inner::APtr theA;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_A_init = ::Test::Inner::Sub::A::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const A& lhs, const A& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const A& lhs, const A& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

}

class Recursive : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef RecursivePrx ProxyType;
    typedef RecursivePtr PointerType;

    virtual ~Recursive();

    Recursive()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit Recursive(const ::Test::RecursivePtr& v) :
        v(v)
    {
    }

#ifdef ICE_CPP11_COMPILER
    Recursive(const Recursive&) = default;
    Recursive& operator=(const Recursive&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::RecursivePtr v;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_Recursive_init = ::Test::Recursive::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const Recursive& lhs, const Recursive& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Recursive& lhs, const Recursive& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class K : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef KPrx ProxyType;
    typedef KPtr PointerType;

    virtual ~K();

    K()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit K(const ::Ice::ValuePtr& value) :
        value(value)
    {
    }

#ifdef ICE_CPP11_COMPILER
    K(const K&) = default;
    K& operator=(const K&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::ValuePtr value;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_K_init = ::Test::K::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const K& lhs, const K& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const K& lhs, const K& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class L : public virtual ::Ice::Object
{
public:

    typedef LPrx ProxyType;
    typedef LPtr PointerType;

    virtual ~L();

    L()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit L(const ::std::string& data) :
        data(data)
    {
    }

#ifdef ICE_CPP11_COMPILER
    L(const L&) = default;
    L& operator=(const L&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string data;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_L_init = ::Test::L::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const L& lhs, const L& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const L& lhs, const L& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class M : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef MPrx ProxyType;
    typedef MPtr PointerType;

    virtual ~M();

    M()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit M(const ::Test::LMap& v) :
        v(v)
    {
    }

#ifdef ICE_CPP11_COMPILER
    M(const M&) = default;
    M& operator=(const M&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::LMap v;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_M_init = ::Test::M::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const M& lhs, const M& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const M& lhs, const M& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class F3 : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef F3Prx ProxyType;
    typedef F3Ptr PointerType;

    virtual ~F3();

    F3()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    F3(const ::Test::F1Ptr& f1, const ::Test::F2Prx& f2) :
        f1(f1),
        f2(f2)
    {
    }

#ifdef ICE_CPP11_COMPILER
    F3(const F3&) = default;
    F3& operator=(const F3&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::F1Ptr f1;
    ::Test::F2Prx f2;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_F3_init = ::Test::F3::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const F3& lhs, const F3& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const F3& lhs, const F3& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Initial : public virtual ::Ice::Object
{
public:

    typedef InitialPrx ProxyType;
    typedef InitialPtr PointerType;

    virtual ~Initial();

#ifdef ICE_CPP11_COMPILER
    Initial() = default;
    Initial(const Initial&) = default;
    Initial& operator=(const Initial&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void shutdown(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual BPtr getB1(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getB1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual BPtr getB2(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getB2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual CPtr getC(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getC(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual DPtr getD(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual EPtr getE(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getE(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual FPtr getF(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getF(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setRecursive(const RecursivePtr& p, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setRecursive(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool supportsClassGraphDepthMax(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_supportsClassGraphDepthMax(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setCycle(const RecursivePtr& r, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setCycle(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool acceptsClassCycles(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_acceptsClassCycles(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual BPtr getMB(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getMB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void getAMDMB_async(const ::Test::AMD_Initial_getAMDMBPtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getAMDMB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void getAll(BPtr& b1, BPtr& b2, CPtr& theC, DPtr& theD, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getAll(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual IPtr getH(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getH(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual IPtr getI(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getI(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual IPtr getJ(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getJ(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual KPtr getK(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getK(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::ValuePtr opValue(const ::Ice::ValuePtr& v1, ::Ice::ValuePtr& v2, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opValue(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ValueSeq opValueSeq(const ValueSeq& v1, ValueSeq& v2, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opValueSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ValueMap opValueMap(const ValueMap& v1, ValueMap& v2, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opValueMap(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual D1Ptr getD1(const D1Ptr& d1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getD1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwEDerived(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwEDerived(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setG(const GPtr& theG, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setG(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setI(const IPtr& theI, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setI(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual BaseSeq opBaseSeq(const BaseSeq& inSeq, BaseSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opBaseSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual CompactPtr getCompact(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getCompact(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Test::Inner::APtr getInnerA(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getInnerA(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Test::Inner::Sub::APtr getInnerSubA(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getInnerSubA(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwInnerEx(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwInnerEx(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwInnerSubEx(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwInnerSubEx(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual MPtr opM(const MPtr& v1, MPtr& v2, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opM(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual F1Ptr opF1(const F1Ptr& f11, F1Ptr& f12, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opF1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual F2Prx opF2(const F2Prx& f21, F2Prx& f22, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opF2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual F3Ptr opF3(const F3Ptr& f31, F3Ptr& f32, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opF3(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool hasF3(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_hasF3(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual NPtr opN(const NPtr& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opN(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const Initial& lhs, const Initial& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Initial& lhs, const Initial& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Empty : public virtual ::Ice::Object
{
public:

    typedef EmptyPrx ProxyType;
    typedef EmptyPtr PointerType;

    virtual ~Empty();

    Empty()
    {
    }

#ifdef ICE_CPP11_COMPILER
    Empty(const Empty&) = default;
    Empty& operator=(const Empty&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_Empty_init = ::Test::Empty::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const Empty& lhs, const Empty& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Empty& lhs, const Empty& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class AlsoEmpty : public virtual ::Ice::Object
{
public:

    typedef AlsoEmptyPrx ProxyType;
    typedef AlsoEmptyPtr PointerType;

    virtual ~AlsoEmpty();

    AlsoEmpty()
    {
    }

#ifdef ICE_CPP11_COMPILER
    AlsoEmpty(const AlsoEmpty&) = default;
    AlsoEmpty& operator=(const AlsoEmpty&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_AlsoEmpty_init = ::Test::AlsoEmpty::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const AlsoEmpty& lhs, const AlsoEmpty& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const AlsoEmpty& lhs, const AlsoEmpty& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class UnexpectedObjectExceptionTest : public virtual ::Ice::Object
{
public:

    typedef UnexpectedObjectExceptionTestPrx ProxyType;
    typedef UnexpectedObjectExceptionTestPtr PointerType;

    virtual ~UnexpectedObjectExceptionTest();

#ifdef ICE_CPP11_COMPILER
    UnexpectedObjectExceptionTest() = default;
    UnexpectedObjectExceptionTest(const UnexpectedObjectExceptionTest&) = default;
    UnexpectedObjectExceptionTest& operator=(const UnexpectedObjectExceptionTest&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual EmptyPtr op(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_op(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const UnexpectedObjectExceptionTest& lhs, const UnexpectedObjectExceptionTest& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const UnexpectedObjectExceptionTest& lhs, const UnexpectedObjectExceptionTest& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class COneMember : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef COneMemberPrx ProxyType;
    typedef COneMemberPtr PointerType;

    virtual ~COneMember();

    COneMember()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit COneMember(const ::Test::EmptyPtr& e) :
        e(e)
    {
    }

#ifdef ICE_CPP11_COMPILER
    COneMember(const COneMember&) = default;
    COneMember& operator=(const COneMember&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::EmptyPtr e;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_COneMember_init = ::Test::COneMember::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const COneMember& lhs, const COneMember& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const COneMember& lhs, const COneMember& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class CTwoMembers : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef CTwoMembersPrx ProxyType;
    typedef CTwoMembersPtr PointerType;

    virtual ~CTwoMembers();

    CTwoMembers()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    CTwoMembers(const ::Test::EmptyPtr& e1, const ::Test::EmptyPtr& e2) :
        e1(e1),
        e2(e2)
    {
    }

#ifdef ICE_CPP11_COMPILER
    CTwoMembers(const CTwoMembers&) = default;
    CTwoMembers& operator=(const CTwoMembers&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::EmptyPtr e1;
    ::Test::EmptyPtr e2;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_CTwoMembers_init = ::Test::CTwoMembers::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const CTwoMembers& lhs, const CTwoMembers& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const CTwoMembers& lhs, const CTwoMembers& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Echo : public virtual ::Ice::Object
{
public:

    typedef EchoPrx ProxyType;
    typedef EchoPtr PointerType;

    virtual ~Echo();

#ifdef ICE_CPP11_COMPILER
    Echo() = default;
    Echo(const Echo&) = default;
    Echo& operator=(const Echo&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void setConnection(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setConnection(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void shutdown(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const Echo& lhs, const Echo& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Echo& lhs, const Echo& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::Test::S>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Test::S, S>
{
    static void write(S* ostr, const ::Test::S& v)
    {
        ostr->write(v.str);
    }
};

template<typename S>
struct StreamReader< ::Test::S, S>
{
    static void read(S* istr, ::Test::S& v)
    {
        istr->read(v.str);
    }
};

template<typename S>
struct StreamWriter< ::Test::Base, S>
{
    static void write(S* ostr, const ::Test::Base& v)
    {
        ostr->write(v.theS);
        ostr->write(v.str);
    }
};

template<typename S>
struct StreamReader< ::Test::Base, S>
{
    static void read(S* istr, ::Test::Base& v)
    {
        istr->read(v.theS);
        istr->read(v.str);
    }
};

template<typename S>
struct StreamWriter< ::Test::A, S>
{
    static void write(S* ostr, const ::Test::A& v)
    {
        ostr->write(v.theB);
        ostr->write(v.theC);
        ostr->write(v.preMarshalInvoked);
        ostr->write(v.postUnmarshalInvoked);
    }
};

template<typename S>
struct StreamReader< ::Test::A, S>
{
    static void read(S* istr, ::Test::A& v)
    {
        istr->read(v.theB);
        istr->read(v.theC);
        istr->read(v.preMarshalInvoked);
        istr->read(v.postUnmarshalInvoked);
    }
};

template<typename S>
struct StreamWriter< ::Test::B, S>
{
    static void write(S* ostr, const ::Test::B& v)
    {
        ostr->write(v.theA);
    }
};

template<typename S>
struct StreamReader< ::Test::B, S>
{
    static void read(S* istr, ::Test::B& v)
    {
        istr->read(v.theA);
    }
};

template<typename S>
struct StreamWriter< ::Test::C, S>
{
    static void write(S* ostr, const ::Test::C& v)
    {
        ostr->write(v.theB);
        ostr->write(v.preMarshalInvoked);
        ostr->write(v.postUnmarshalInvoked);
    }
};

template<typename S>
struct StreamReader< ::Test::C, S>
{
    static void read(S* istr, ::Test::C& v)
    {
        istr->read(v.theB);
        istr->read(v.preMarshalInvoked);
        istr->read(v.postUnmarshalInvoked);
    }
};

template<typename S>
struct StreamWriter< ::Test::D, S>
{
    static void write(S* ostr, const ::Test::D& v)
    {
        ostr->write(v.theA);
        ostr->write(v.theB);
        ostr->write(v.theC);
        ostr->write(v.preMarshalInvoked);
        ostr->write(v.postUnmarshalInvoked);
    }
};

template<typename S>
struct StreamReader< ::Test::D, S>
{
    static void read(S* istr, ::Test::D& v)
    {
        istr->read(v.theA);
        istr->read(v.theB);
        istr->read(v.theC);
        istr->read(v.preMarshalInvoked);
        istr->read(v.postUnmarshalInvoked);
    }
};

template<typename S>
struct StreamWriter< ::Test::E, S>
{
    static void write(S* ostr, const ::Test::E& v)
    {
        ostr->write(v.i);
        ostr->write(v.s);
    }
};

template<typename S>
struct StreamReader< ::Test::E, S>
{
    static void read(S* istr, ::Test::E& v)
    {
        istr->read(v.i);
        istr->read(v.s);
    }
};

template<typename S>
struct StreamWriter< ::Test::F, S>
{
    static void write(S* ostr, const ::Test::F& v)
    {
        ostr->write(v.e1);
        ostr->write(v.e2);
    }
};

template<typename S>
struct StreamReader< ::Test::F, S>
{
    static void read(S* istr, ::Test::F& v)
    {
        istr->read(v.e1);
        istr->read(v.e2);
    }
};

template<typename S>
struct StreamWriter< ::Test::N, S>
{
    static void write(S* ostr, const ::Test::N& v)
    {
        ostr->write(v.i);
    }
};

template<typename S>
struct StreamReader< ::Test::N, S>
{
    static void read(S* istr, ::Test::N& v)
    {
        istr->read(v.i);
    }
};

template<typename S>
struct StreamWriter< ::Test::A1, S>
{
    static void write(S* ostr, const ::Test::A1& v)
    {
        ostr->write(v.name);
    }
};

template<typename S>
struct StreamReader< ::Test::A1, S>
{
    static void read(S* istr, ::Test::A1& v)
    {
        istr->read(v.name);
    }
};

template<typename S>
struct StreamWriter< ::Test::B1, S>
{
    static void write(S* ostr, const ::Test::B1& v)
    {
        ostr->write(v.a1);
        ostr->write(v.a2);
    }
};

template<typename S>
struct StreamReader< ::Test::B1, S>
{
    static void read(S* istr, ::Test::B1& v)
    {
        istr->read(v.a1);
        istr->read(v.a2);
    }
};

template<typename S>
struct StreamWriter< ::Test::D1, S>
{
    static void write(S* ostr, const ::Test::D1& v)
    {
        ostr->write(v.a3);
        ostr->write(v.a4);
    }
};

template<typename S>
struct StreamReader< ::Test::D1, S>
{
    static void read(S* istr, ::Test::D1& v)
    {
        istr->read(v.a3);
        istr->read(v.a4);
    }
};

template<>
struct StreamableTraits< ::Test::EBase>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::EBase, S>
{
    static void write(S* ostr, const ::Test::EBase& v)
    {
        ostr->write(v.a1);
        ostr->write(v.a2);
    }
};

template<typename S>
struct StreamReader< ::Test::EBase, S>
{
    static void read(S* istr, ::Test::EBase& v)
    {
        istr->read(v.a1);
        istr->read(v.a2);
    }
};

template<>
struct StreamableTraits< ::Test::EDerived>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::EDerived, S>
{
    static void write(S* ostr, const ::Test::EDerived& v)
    {
        ostr->write(v.a3);
        ostr->write(v.a4);
    }
};

template<typename S>
struct StreamReader< ::Test::EDerived, S>
{
    static void read(S* istr, ::Test::EDerived& v)
    {
        istr->read(v.a3);
        istr->read(v.a4);
    }
};

template<typename S>
struct StreamWriter< ::Test::Inner::A, S>
{
    static void write(S* ostr, const ::Test::Inner::A& v)
    {
        ostr->write(v.theA);
    }
};

template<typename S>
struct StreamReader< ::Test::Inner::A, S>
{
    static void read(S* istr, ::Test::Inner::A& v)
    {
        istr->read(v.theA);
    }
};

template<>
struct StreamableTraits< ::Test::Inner::Ex>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::Inner::Ex, S>
{
    static void write(S* ostr, const ::Test::Inner::Ex& v)
    {
        ostr->write(v.reason);
    }
};

template<typename S>
struct StreamReader< ::Test::Inner::Ex, S>
{
    static void read(S* istr, ::Test::Inner::Ex& v)
    {
        istr->read(v.reason);
    }
};

template<typename S>
struct StreamWriter< ::Test::Inner::Sub::A, S>
{
    static void write(S* ostr, const ::Test::Inner::Sub::A& v)
    {
        ostr->write(v.theA);
    }
};

template<typename S>
struct StreamReader< ::Test::Inner::Sub::A, S>
{
    static void read(S* istr, ::Test::Inner::Sub::A& v)
    {
        istr->read(v.theA);
    }
};

template<>
struct StreamableTraits< ::Test::Inner::Sub::Ex>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::Inner::Sub::Ex, S>
{
    static void write(S* ostr, const ::Test::Inner::Sub::Ex& v)
    {
        ostr->write(v.reason);
    }
};

template<typename S>
struct StreamReader< ::Test::Inner::Sub::Ex, S>
{
    static void read(S* istr, ::Test::Inner::Sub::Ex& v)
    {
        istr->read(v.reason);
    }
};

template<typename S>
struct StreamWriter< ::Test::Recursive, S>
{
    static void write(S* ostr, const ::Test::Recursive& v)
    {
        ostr->write(v.v);
    }
};

template<typename S>
struct StreamReader< ::Test::Recursive, S>
{
    static void read(S* istr, ::Test::Recursive& v)
    {
        istr->read(v.v);
    }
};

template<typename S>
struct StreamWriter< ::Test::K, S>
{
    static void write(S* ostr, const ::Test::K& v)
    {
        ostr->write(v.value);
    }
};

template<typename S>
struct StreamReader< ::Test::K, S>
{
    static void read(S* istr, ::Test::K& v)
    {
        istr->read(v.value);
    }
};

template<typename S>
struct StreamWriter< ::Test::L, S>
{
    static void write(S* ostr, const ::Test::L& v)
    {
        ostr->write(v.data);
    }
};

template<typename S>
struct StreamReader< ::Test::L, S>
{
    static void read(S* istr, ::Test::L& v)
    {
        istr->read(v.data);
    }
};

template<>
struct StreamableTraits< ::Test::StructKey>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Test::StructKey, S>
{
    static void write(S* ostr, const ::Test::StructKey& v)
    {
        ostr->write(v.i);
        ostr->write(v.s);
    }
};

template<typename S>
struct StreamReader< ::Test::StructKey, S>
{
    static void read(S* istr, ::Test::StructKey& v)
    {
        istr->read(v.i);
        istr->read(v.s);
    }
};

template<typename S>
struct StreamWriter< ::Test::M, S>
{
    static void write(S* ostr, const ::Test::M& v)
    {
        ostr->write(v.v);
    }
};

template<typename S>
struct StreamReader< ::Test::M, S>
{
    static void read(S* istr, ::Test::M& v)
    {
        istr->read(v.v);
    }
};

template<typename S>
struct StreamWriter< ::Test::F3, S>
{
    static void write(S* ostr, const ::Test::F3& v)
    {
        ostr->write(v.f1);
        ostr->write(v.f2);
    }
};

template<typename S>
struct StreamReader< ::Test::F3, S>
{
    static void read(S* istr, ::Test::F3& v)
    {
        istr->read(v.f1);
        istr->read(v.f2);
    }
};

template<typename S>
struct StreamWriter< ::Test::COneMember, S>
{
    static void write(S* ostr, const ::Test::COneMember& v)
    {
        ostr->write(v.e);
    }
};

template<typename S>
struct StreamReader< ::Test::COneMember, S>
{
    static void read(S* istr, ::Test::COneMember& v)
    {
        istr->read(v.e);
    }
};

template<typename S>
struct StreamWriter< ::Test::CTwoMembers, S>
{
    static void write(S* ostr, const ::Test::CTwoMembers& v)
    {
        ostr->write(v.e1);
        ostr->write(v.e2);
    }
};

template<typename S>
struct StreamReader< ::Test::CTwoMembers, S>
{
    static void read(S* istr, ::Test::CTwoMembers& v)
    {
        istr->read(v.e1);
        istr->read(v.e2);
    }
};

template<>
struct StreamableTraits< ::Test::EOneMember>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::EOneMember, S>
{
    static void write(S* ostr, const ::Test::EOneMember& v)
    {
        ostr->write(v.e);
    }
};

template<typename S>
struct StreamReader< ::Test::EOneMember, S>
{
    static void read(S* istr, ::Test::EOneMember& v)
    {
        istr->read(v.e);
    }
};

template<>
struct StreamableTraits< ::Test::ETwoMembers>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::ETwoMembers, S>
{
    static void write(S* ostr, const ::Test::ETwoMembers& v)
    {
        ostr->write(v.e1);
        ostr->write(v.e2);
    }
};

template<typename S>
struct StreamReader< ::Test::ETwoMembers, S>
{
    static void read(S* istr, ::Test::ETwoMembers& v)
    {
        istr->read(v.e1);
        istr->read(v.e2);
    }
};

template<>
struct StreamableTraits< ::Test::SOneMember>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Test::SOneMember, S>
{
    static void write(S* ostr, const ::Test::SOneMember& v)
    {
        ostr->write(v.e);
    }
};

template<typename S>
struct StreamReader< ::Test::SOneMember, S>
{
    static void read(S* istr, ::Test::SOneMember& v)
    {
        istr->read(v.e);
    }
};

template<>
struct StreamableTraits< ::Test::STwoMembers>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Test::STwoMembers, S>
{
    static void write(S* ostr, const ::Test::STwoMembers& v)
    {
        ostr->write(v.e1);
        ostr->write(v.e2);
    }
};

template<typename S>
struct StreamReader< ::Test::STwoMembers, S>
{
    static void read(S* istr, ::Test::STwoMembers& v)
    {
        istr->read(v.e1);
        istr->read(v.e2);
    }
};

}
/// \endcond

namespace Test
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::AbstractBase::begin_op.
 * Create a wrapper instance by calling ::Test::newCallback_AbstractBase_op.
 */
template<class T>
class CallbackNC_AbstractBase_op : public Callback_AbstractBase_op_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_AbstractBase_op(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::AbstractBase::begin_op.
 */
template<class T> Callback_AbstractBase_opPtr
newCallback_AbstractBase_op(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AbstractBase_op<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::AbstractBase::begin_op.
 */
template<class T> Callback_AbstractBase_opPtr
newCallback_AbstractBase_op(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AbstractBase_op<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::AbstractBase::begin_op.
 */
template<class T> Callback_AbstractBase_opPtr
newCallback_AbstractBase_op(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AbstractBase_op<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::AbstractBase::begin_op.
 */
template<class T> Callback_AbstractBase_opPtr
newCallback_AbstractBase_op(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_AbstractBase_op<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::AbstractBase::begin_op.
 * Create a wrapper instance by calling ::Test::newCallback_AbstractBase_op.
 */
template<class T, typename CT>
class Callback_AbstractBase_op : public Callback_AbstractBase_op_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_AbstractBase_op(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::AbstractBase::begin_op.
 */
template<class T, typename CT> Callback_AbstractBase_opPtr
newCallback_AbstractBase_op(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AbstractBase_op<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::AbstractBase::begin_op.
 */
template<class T, typename CT> Callback_AbstractBase_opPtr
newCallback_AbstractBase_op(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AbstractBase_op<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::AbstractBase::begin_op.
 */
template<class T, typename CT> Callback_AbstractBase_opPtr
newCallback_AbstractBase_op(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AbstractBase_op<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::AbstractBase::begin_op.
 */
template<class T, typename CT> Callback_AbstractBase_opPtr
newCallback_AbstractBase_op(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_AbstractBase_op<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::I::begin_doI.
 * Create a wrapper instance by calling ::Test::newCallback_I_doI.
 */
template<class T>
class CallbackNC_I_doI : public Callback_I_doI_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_I_doI(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::I::begin_doI.
 */
template<class T> Callback_I_doIPtr
newCallback_I_doI(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_I_doI<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::I::begin_doI.
 */
template<class T> Callback_I_doIPtr
newCallback_I_doI(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_I_doI<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::I::begin_doI.
 */
template<class T> Callback_I_doIPtr
newCallback_I_doI(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_I_doI<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::I::begin_doI.
 */
template<class T> Callback_I_doIPtr
newCallback_I_doI(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_I_doI<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::I::begin_doI.
 * Create a wrapper instance by calling ::Test::newCallback_I_doI.
 */
template<class T, typename CT>
class Callback_I_doI : public Callback_I_doI_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_I_doI(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::I::begin_doI.
 */
template<class T, typename CT> Callback_I_doIPtr
newCallback_I_doI(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_I_doI<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::I::begin_doI.
 */
template<class T, typename CT> Callback_I_doIPtr
newCallback_I_doI(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_I_doI<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::I::begin_doI.
 */
template<class T, typename CT> Callback_I_doIPtr
newCallback_I_doI(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_I_doI<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::I::begin_doI.
 */
template<class T, typename CT> Callback_I_doIPtr
newCallback_I_doI(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_I_doI<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::J::begin_doJ.
 * Create a wrapper instance by calling ::Test::newCallback_J_doJ.
 */
template<class T>
class CallbackNC_J_doJ : public Callback_J_doJ_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_J_doJ(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::J::begin_doJ.
 */
template<class T> Callback_J_doJPtr
newCallback_J_doJ(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_J_doJ<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::J::begin_doJ.
 */
template<class T> Callback_J_doJPtr
newCallback_J_doJ(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_J_doJ<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::J::begin_doJ.
 */
template<class T> Callback_J_doJPtr
newCallback_J_doJ(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_J_doJ<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::J::begin_doJ.
 */
template<class T> Callback_J_doJPtr
newCallback_J_doJ(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_J_doJ<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::J::begin_doJ.
 * Create a wrapper instance by calling ::Test::newCallback_J_doJ.
 */
template<class T, typename CT>
class Callback_J_doJ : public Callback_J_doJ_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_J_doJ(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::J::begin_doJ.
 */
template<class T, typename CT> Callback_J_doJPtr
newCallback_J_doJ(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_J_doJ<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::J::begin_doJ.
 */
template<class T, typename CT> Callback_J_doJPtr
newCallback_J_doJ(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_J_doJ<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::J::begin_doJ.
 */
template<class T, typename CT> Callback_J_doJPtr
newCallback_J_doJ(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_J_doJ<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::J::begin_doJ.
 */
template<class T, typename CT> Callback_J_doJPtr
newCallback_J_doJ(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_J_doJ<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::H::begin_doH.
 * Create a wrapper instance by calling ::Test::newCallback_H_doH.
 */
template<class T>
class CallbackNC_H_doH : public Callback_H_doH_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_H_doH(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::H::begin_doH.
 */
template<class T> Callback_H_doHPtr
newCallback_H_doH(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_H_doH<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::H::begin_doH.
 */
template<class T> Callback_H_doHPtr
newCallback_H_doH(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_H_doH<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::H::begin_doH.
 */
template<class T> Callback_H_doHPtr
newCallback_H_doH(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_H_doH<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::H::begin_doH.
 */
template<class T> Callback_H_doHPtr
newCallback_H_doH(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_H_doH<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::H::begin_doH.
 * Create a wrapper instance by calling ::Test::newCallback_H_doH.
 */
template<class T, typename CT>
class Callback_H_doH : public Callback_H_doH_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_H_doH(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::H::begin_doH.
 */
template<class T, typename CT> Callback_H_doHPtr
newCallback_H_doH(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_H_doH<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::H::begin_doH.
 */
template<class T, typename CT> Callback_H_doHPtr
newCallback_H_doH(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_H_doH<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::H::begin_doH.
 */
template<class T, typename CT> Callback_H_doHPtr
newCallback_H_doH(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_H_doH<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::H::begin_doH.
 */
template<class T, typename CT> Callback_H_doHPtr
newCallback_H_doH(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_H_doH<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::H::begin_doH2.
 * Create a wrapper instance by calling ::Test::newCallback_H_doH2.
 */
template<class T>
class CallbackNC_H_doH2 : public Callback_H_doH2_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_H_doH2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::H::begin_doH2.
 */
template<class T> Callback_H_doH2Ptr
newCallback_H_doH2(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_H_doH2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::H::begin_doH2.
 */
template<class T> Callback_H_doH2Ptr
newCallback_H_doH2(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_H_doH2<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::H::begin_doH2.
 */
template<class T> Callback_H_doH2Ptr
newCallback_H_doH2(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_H_doH2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::H::begin_doH2.
 */
template<class T> Callback_H_doH2Ptr
newCallback_H_doH2(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_H_doH2<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::H::begin_doH2.
 * Create a wrapper instance by calling ::Test::newCallback_H_doH2.
 */
template<class T, typename CT>
class Callback_H_doH2 : public Callback_H_doH2_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_H_doH2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::H::begin_doH2.
 */
template<class T, typename CT> Callback_H_doH2Ptr
newCallback_H_doH2(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_H_doH2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::H::begin_doH2.
 */
template<class T, typename CT> Callback_H_doH2Ptr
newCallback_H_doH2(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_H_doH2<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::H::begin_doH2.
 */
template<class T, typename CT> Callback_H_doH2Ptr
newCallback_H_doH2(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_H_doH2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::H::begin_doH2.
 */
template<class T, typename CT> Callback_H_doH2Ptr
newCallback_H_doH2(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_H_doH2<T, CT>(instance, 0, excb, sentcb);
}

namespace Inner
{

namespace Sub
{

}

}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_shutdown.
 */
template<class T>
class CallbackNC_Initial_shutdown : public Callback_Initial_shutdown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Initial_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_shutdown.
 */
template<class T> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_shutdown.
 */
template<class T> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_shutdown.
 */
template<class T> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_shutdown.
 */
template<class T> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_shutdown.
 */
template<class T, typename CT>
class Callback_Initial_shutdown : public Callback_Initial_shutdown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Initial_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_shutdown.
 */
template<class T, typename CT> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_shutdown.
 */
template<class T, typename CT> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_shutdown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_shutdown.
 */
template<class T, typename CT> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_shutdown.
 */
template<class T, typename CT> Callback_Initial_shutdownPtr
newCallback_Initial_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_shutdown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_getB1.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getB1.
 */
template<class T>
class CallbackNC_Initial_getB1 : public Callback_Initial_getB1_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BPtr&);

    CallbackNC_Initial_getB1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        BPtr ret;
        try
        {
            ret = proxy->end_getB1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getB1.
 */
template<class T> Callback_Initial_getB1Ptr
newCallback_Initial_getB1(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getB1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getB1.
 */
template<class T> Callback_Initial_getB1Ptr
newCallback_Initial_getB1(T* instance, void (T::*cb)(const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getB1<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_getB1.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getB1.
 */
template<class T, typename CT>
class Callback_Initial_getB1 : public Callback_Initial_getB1_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BPtr&, const CT&);

    Callback_Initial_getB1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        BPtr ret;
        try
        {
            ret = proxy->end_getB1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getB1.
 */
template<class T, typename CT> Callback_Initial_getB1Ptr
newCallback_Initial_getB1(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getB1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getB1.
 */
template<class T, typename CT> Callback_Initial_getB1Ptr
newCallback_Initial_getB1(T* instance, void (T::*cb)(const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getB1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_getB2.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getB2.
 */
template<class T>
class CallbackNC_Initial_getB2 : public Callback_Initial_getB2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BPtr&);

    CallbackNC_Initial_getB2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        BPtr ret;
        try
        {
            ret = proxy->end_getB2(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getB2.
 */
template<class T> Callback_Initial_getB2Ptr
newCallback_Initial_getB2(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getB2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getB2.
 */
template<class T> Callback_Initial_getB2Ptr
newCallback_Initial_getB2(T* instance, void (T::*cb)(const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getB2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_getB2.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getB2.
 */
template<class T, typename CT>
class Callback_Initial_getB2 : public Callback_Initial_getB2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BPtr&, const CT&);

    Callback_Initial_getB2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        BPtr ret;
        try
        {
            ret = proxy->end_getB2(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getB2.
 */
template<class T, typename CT> Callback_Initial_getB2Ptr
newCallback_Initial_getB2(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getB2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getB2.
 */
template<class T, typename CT> Callback_Initial_getB2Ptr
newCallback_Initial_getB2(T* instance, void (T::*cb)(const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getB2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_getC.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getC.
 */
template<class T>
class CallbackNC_Initial_getC : public Callback_Initial_getC_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const CPtr&);

    CallbackNC_Initial_getC(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        CPtr ret;
        try
        {
            ret = proxy->end_getC(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getC.
 */
template<class T> Callback_Initial_getCPtr
newCallback_Initial_getC(const IceUtil::Handle<T>& instance, void (T::*cb)(const CPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getC<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getC.
 */
template<class T> Callback_Initial_getCPtr
newCallback_Initial_getC(T* instance, void (T::*cb)(const CPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getC<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_getC.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getC.
 */
template<class T, typename CT>
class Callback_Initial_getC : public Callback_Initial_getC_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CPtr&, const CT&);

    Callback_Initial_getC(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        CPtr ret;
        try
        {
            ret = proxy->end_getC(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getC.
 */
template<class T, typename CT> Callback_Initial_getCPtr
newCallback_Initial_getC(const IceUtil::Handle<T>& instance, void (T::*cb)(const CPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getC<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getC.
 */
template<class T, typename CT> Callback_Initial_getCPtr
newCallback_Initial_getC(T* instance, void (T::*cb)(const CPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getC<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_getD.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getD.
 */
template<class T>
class CallbackNC_Initial_getD : public Callback_Initial_getD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const DPtr&);

    CallbackNC_Initial_getD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        DPtr ret;
        try
        {
            ret = proxy->end_getD(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getD.
 */
template<class T> Callback_Initial_getDPtr
newCallback_Initial_getD(const IceUtil::Handle<T>& instance, void (T::*cb)(const DPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getD<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getD.
 */
template<class T> Callback_Initial_getDPtr
newCallback_Initial_getD(T* instance, void (T::*cb)(const DPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getD<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_getD.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getD.
 */
template<class T, typename CT>
class Callback_Initial_getD : public Callback_Initial_getD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const DPtr&, const CT&);

    Callback_Initial_getD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        DPtr ret;
        try
        {
            ret = proxy->end_getD(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getD.
 */
template<class T, typename CT> Callback_Initial_getDPtr
newCallback_Initial_getD(const IceUtil::Handle<T>& instance, void (T::*cb)(const DPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getD.
 */
template<class T, typename CT> Callback_Initial_getDPtr
newCallback_Initial_getD(T* instance, void (T::*cb)(const DPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_getE.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getE.
 */
template<class T>
class CallbackNC_Initial_getE : public Callback_Initial_getE_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const EPtr&);

    CallbackNC_Initial_getE(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        EPtr ret;
        try
        {
            ret = proxy->end_getE(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getE.
 */
template<class T> Callback_Initial_getEPtr
newCallback_Initial_getE(const IceUtil::Handle<T>& instance, void (T::*cb)(const EPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getE<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getE.
 */
template<class T> Callback_Initial_getEPtr
newCallback_Initial_getE(T* instance, void (T::*cb)(const EPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getE<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_getE.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getE.
 */
template<class T, typename CT>
class Callback_Initial_getE : public Callback_Initial_getE_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const EPtr&, const CT&);

    Callback_Initial_getE(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        EPtr ret;
        try
        {
            ret = proxy->end_getE(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getE.
 */
template<class T, typename CT> Callback_Initial_getEPtr
newCallback_Initial_getE(const IceUtil::Handle<T>& instance, void (T::*cb)(const EPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getE<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getE.
 */
template<class T, typename CT> Callback_Initial_getEPtr
newCallback_Initial_getE(T* instance, void (T::*cb)(const EPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getE<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_getF.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getF.
 */
template<class T>
class CallbackNC_Initial_getF : public Callback_Initial_getF_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const FPtr&);

    CallbackNC_Initial_getF(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        FPtr ret;
        try
        {
            ret = proxy->end_getF(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getF.
 */
template<class T> Callback_Initial_getFPtr
newCallback_Initial_getF(const IceUtil::Handle<T>& instance, void (T::*cb)(const FPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getF<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getF.
 */
template<class T> Callback_Initial_getFPtr
newCallback_Initial_getF(T* instance, void (T::*cb)(const FPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getF<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_getF.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getF.
 */
template<class T, typename CT>
class Callback_Initial_getF : public Callback_Initial_getF_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const FPtr&, const CT&);

    Callback_Initial_getF(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        FPtr ret;
        try
        {
            ret = proxy->end_getF(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getF.
 */
template<class T, typename CT> Callback_Initial_getFPtr
newCallback_Initial_getF(const IceUtil::Handle<T>& instance, void (T::*cb)(const FPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getF<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getF.
 */
template<class T, typename CT> Callback_Initial_getFPtr
newCallback_Initial_getF(T* instance, void (T::*cb)(const FPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getF<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_setRecursive.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_setRecursive.
 */
template<class T>
class CallbackNC_Initial_setRecursive : public Callback_Initial_setRecursive_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Initial_setRecursive(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setRecursive.
 */
template<class T> Callback_Initial_setRecursivePtr
newCallback_Initial_setRecursive(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_setRecursive<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setRecursive.
 */
template<class T> Callback_Initial_setRecursivePtr
newCallback_Initial_setRecursive(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_setRecursive<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setRecursive.
 */
template<class T> Callback_Initial_setRecursivePtr
newCallback_Initial_setRecursive(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_setRecursive<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setRecursive.
 */
template<class T> Callback_Initial_setRecursivePtr
newCallback_Initial_setRecursive(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_setRecursive<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_setRecursive.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_setRecursive.
 */
template<class T, typename CT>
class Callback_Initial_setRecursive : public Callback_Initial_setRecursive_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Initial_setRecursive(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setRecursive.
 */
template<class T, typename CT> Callback_Initial_setRecursivePtr
newCallback_Initial_setRecursive(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_setRecursive<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setRecursive.
 */
template<class T, typename CT> Callback_Initial_setRecursivePtr
newCallback_Initial_setRecursive(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_setRecursive<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setRecursive.
 */
template<class T, typename CT> Callback_Initial_setRecursivePtr
newCallback_Initial_setRecursive(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_setRecursive<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setRecursive.
 */
template<class T, typename CT> Callback_Initial_setRecursivePtr
newCallback_Initial_setRecursive(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_setRecursive<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_supportsClassGraphDepthMax.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_supportsClassGraphDepthMax.
 */
template<class T>
class CallbackNC_Initial_supportsClassGraphDepthMax : public Callback_Initial_supportsClassGraphDepthMax_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Initial_supportsClassGraphDepthMax(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_supportsClassGraphDepthMax(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_supportsClassGraphDepthMax.
 */
template<class T> Callback_Initial_supportsClassGraphDepthMaxPtr
newCallback_Initial_supportsClassGraphDepthMax(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_supportsClassGraphDepthMax<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_supportsClassGraphDepthMax.
 */
template<class T> Callback_Initial_supportsClassGraphDepthMaxPtr
newCallback_Initial_supportsClassGraphDepthMax(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_supportsClassGraphDepthMax<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_supportsClassGraphDepthMax.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_supportsClassGraphDepthMax.
 */
template<class T, typename CT>
class Callback_Initial_supportsClassGraphDepthMax : public Callback_Initial_supportsClassGraphDepthMax_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Initial_supportsClassGraphDepthMax(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_supportsClassGraphDepthMax(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_supportsClassGraphDepthMax.
 */
template<class T, typename CT> Callback_Initial_supportsClassGraphDepthMaxPtr
newCallback_Initial_supportsClassGraphDepthMax(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_supportsClassGraphDepthMax<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_supportsClassGraphDepthMax.
 */
template<class T, typename CT> Callback_Initial_supportsClassGraphDepthMaxPtr
newCallback_Initial_supportsClassGraphDepthMax(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_supportsClassGraphDepthMax<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_setCycle.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_setCycle.
 */
template<class T>
class CallbackNC_Initial_setCycle : public Callback_Initial_setCycle_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Initial_setCycle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setCycle.
 */
template<class T> Callback_Initial_setCyclePtr
newCallback_Initial_setCycle(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_setCycle<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setCycle.
 */
template<class T> Callback_Initial_setCyclePtr
newCallback_Initial_setCycle(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_setCycle<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setCycle.
 */
template<class T> Callback_Initial_setCyclePtr
newCallback_Initial_setCycle(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_setCycle<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setCycle.
 */
template<class T> Callback_Initial_setCyclePtr
newCallback_Initial_setCycle(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_setCycle<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_setCycle.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_setCycle.
 */
template<class T, typename CT>
class Callback_Initial_setCycle : public Callback_Initial_setCycle_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Initial_setCycle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setCycle.
 */
template<class T, typename CT> Callback_Initial_setCyclePtr
newCallback_Initial_setCycle(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_setCycle<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setCycle.
 */
template<class T, typename CT> Callback_Initial_setCyclePtr
newCallback_Initial_setCycle(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_setCycle<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setCycle.
 */
template<class T, typename CT> Callback_Initial_setCyclePtr
newCallback_Initial_setCycle(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_setCycle<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setCycle.
 */
template<class T, typename CT> Callback_Initial_setCyclePtr
newCallback_Initial_setCycle(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_setCycle<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_acceptsClassCycles.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_acceptsClassCycles.
 */
template<class T>
class CallbackNC_Initial_acceptsClassCycles : public Callback_Initial_acceptsClassCycles_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Initial_acceptsClassCycles(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_acceptsClassCycles(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_acceptsClassCycles.
 */
template<class T> Callback_Initial_acceptsClassCyclesPtr
newCallback_Initial_acceptsClassCycles(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_acceptsClassCycles<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_acceptsClassCycles.
 */
template<class T> Callback_Initial_acceptsClassCyclesPtr
newCallback_Initial_acceptsClassCycles(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_acceptsClassCycles<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_acceptsClassCycles.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_acceptsClassCycles.
 */
template<class T, typename CT>
class Callback_Initial_acceptsClassCycles : public Callback_Initial_acceptsClassCycles_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Initial_acceptsClassCycles(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_acceptsClassCycles(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_acceptsClassCycles.
 */
template<class T, typename CT> Callback_Initial_acceptsClassCyclesPtr
newCallback_Initial_acceptsClassCycles(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_acceptsClassCycles<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_acceptsClassCycles.
 */
template<class T, typename CT> Callback_Initial_acceptsClassCyclesPtr
newCallback_Initial_acceptsClassCycles(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_acceptsClassCycles<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_getMB.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getMB.
 */
template<class T>
class CallbackNC_Initial_getMB : public Callback_Initial_getMB_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BPtr&);

    CallbackNC_Initial_getMB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        BPtr ret;
        try
        {
            ret = proxy->end_getMB(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getMB.
 */
template<class T> Callback_Initial_getMBPtr
newCallback_Initial_getMB(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getMB<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getMB.
 */
template<class T> Callback_Initial_getMBPtr
newCallback_Initial_getMB(T* instance, void (T::*cb)(const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getMB<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_getMB.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getMB.
 */
template<class T, typename CT>
class Callback_Initial_getMB : public Callback_Initial_getMB_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BPtr&, const CT&);

    Callback_Initial_getMB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        BPtr ret;
        try
        {
            ret = proxy->end_getMB(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getMB.
 */
template<class T, typename CT> Callback_Initial_getMBPtr
newCallback_Initial_getMB(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getMB<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getMB.
 */
template<class T, typename CT> Callback_Initial_getMBPtr
newCallback_Initial_getMB(T* instance, void (T::*cb)(const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getMB<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_getAMDMB.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getAMDMB.
 */
template<class T>
class CallbackNC_Initial_getAMDMB : public Callback_Initial_getAMDMB_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BPtr&);

    CallbackNC_Initial_getAMDMB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        BPtr ret;
        try
        {
            ret = proxy->end_getAMDMB(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getAMDMB.
 */
template<class T> Callback_Initial_getAMDMBPtr
newCallback_Initial_getAMDMB(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getAMDMB<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getAMDMB.
 */
template<class T> Callback_Initial_getAMDMBPtr
newCallback_Initial_getAMDMB(T* instance, void (T::*cb)(const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getAMDMB<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_getAMDMB.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getAMDMB.
 */
template<class T, typename CT>
class Callback_Initial_getAMDMB : public Callback_Initial_getAMDMB_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BPtr&, const CT&);

    Callback_Initial_getAMDMB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        BPtr ret;
        try
        {
            ret = proxy->end_getAMDMB(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getAMDMB.
 */
template<class T, typename CT> Callback_Initial_getAMDMBPtr
newCallback_Initial_getAMDMB(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getAMDMB<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getAMDMB.
 */
template<class T, typename CT> Callback_Initial_getAMDMBPtr
newCallback_Initial_getAMDMB(T* instance, void (T::*cb)(const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getAMDMB<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_getAll.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getAll.
 */
template<class T>
class CallbackNC_Initial_getAll : public Callback_Initial_getAll_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BPtr&, const BPtr&, const CPtr&, const DPtr&);

    CallbackNC_Initial_getAll(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        BPtr iceP_b1;
        BPtr iceP_b2;
        CPtr iceP_theC;
        DPtr iceP_theD;
        try
        {
            proxy->end_getAll(iceP_b1, iceP_b2, iceP_theC, iceP_theD, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_b1, iceP_b2, iceP_theC, iceP_theD);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getAll.
 */
template<class T> Callback_Initial_getAllPtr
newCallback_Initial_getAll(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&, const BPtr&, const CPtr&, const DPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getAll<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getAll.
 */
template<class T> Callback_Initial_getAllPtr
newCallback_Initial_getAll(T* instance, void (T::*cb)(const BPtr&, const BPtr&, const CPtr&, const DPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getAll<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_getAll.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getAll.
 */
template<class T, typename CT>
class Callback_Initial_getAll : public Callback_Initial_getAll_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BPtr&, const BPtr&, const CPtr&, const DPtr&, const CT&);

    Callback_Initial_getAll(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        BPtr iceP_b1;
        BPtr iceP_b2;
        CPtr iceP_theC;
        DPtr iceP_theD;
        try
        {
            proxy->end_getAll(iceP_b1, iceP_b2, iceP_theC, iceP_theD, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_b1, iceP_b2, iceP_theC, iceP_theD, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getAll.
 */
template<class T, typename CT> Callback_Initial_getAllPtr
newCallback_Initial_getAll(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&, const BPtr&, const CPtr&, const DPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getAll<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getAll.
 */
template<class T, typename CT> Callback_Initial_getAllPtr
newCallback_Initial_getAll(T* instance, void (T::*cb)(const BPtr&, const BPtr&, const CPtr&, const DPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getAll<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_getH.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getH.
 */
template<class T>
class CallbackNC_Initial_getH : public Callback_Initial_getH_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IPtr&);

    CallbackNC_Initial_getH(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IPtr ret;
        try
        {
            ret = proxy->end_getH(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getH.
 */
template<class T> Callback_Initial_getHPtr
newCallback_Initial_getH(const IceUtil::Handle<T>& instance, void (T::*cb)(const IPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getH<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getH.
 */
template<class T> Callback_Initial_getHPtr
newCallback_Initial_getH(T* instance, void (T::*cb)(const IPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getH<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_getH.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getH.
 */
template<class T, typename CT>
class Callback_Initial_getH : public Callback_Initial_getH_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IPtr&, const CT&);

    Callback_Initial_getH(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IPtr ret;
        try
        {
            ret = proxy->end_getH(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getH.
 */
template<class T, typename CT> Callback_Initial_getHPtr
newCallback_Initial_getH(const IceUtil::Handle<T>& instance, void (T::*cb)(const IPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getH<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getH.
 */
template<class T, typename CT> Callback_Initial_getHPtr
newCallback_Initial_getH(T* instance, void (T::*cb)(const IPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getH<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_getI.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getI.
 */
template<class T>
class CallbackNC_Initial_getI : public Callback_Initial_getI_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IPtr&);

    CallbackNC_Initial_getI(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IPtr ret;
        try
        {
            ret = proxy->end_getI(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getI.
 */
template<class T> Callback_Initial_getIPtr
newCallback_Initial_getI(const IceUtil::Handle<T>& instance, void (T::*cb)(const IPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getI<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getI.
 */
template<class T> Callback_Initial_getIPtr
newCallback_Initial_getI(T* instance, void (T::*cb)(const IPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getI<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_getI.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getI.
 */
template<class T, typename CT>
class Callback_Initial_getI : public Callback_Initial_getI_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IPtr&, const CT&);

    Callback_Initial_getI(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IPtr ret;
        try
        {
            ret = proxy->end_getI(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getI.
 */
template<class T, typename CT> Callback_Initial_getIPtr
newCallback_Initial_getI(const IceUtil::Handle<T>& instance, void (T::*cb)(const IPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getI<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getI.
 */
template<class T, typename CT> Callback_Initial_getIPtr
newCallback_Initial_getI(T* instance, void (T::*cb)(const IPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getI<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_getJ.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getJ.
 */
template<class T>
class CallbackNC_Initial_getJ : public Callback_Initial_getJ_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IPtr&);

    CallbackNC_Initial_getJ(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IPtr ret;
        try
        {
            ret = proxy->end_getJ(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getJ.
 */
template<class T> Callback_Initial_getJPtr
newCallback_Initial_getJ(const IceUtil::Handle<T>& instance, void (T::*cb)(const IPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getJ<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getJ.
 */
template<class T> Callback_Initial_getJPtr
newCallback_Initial_getJ(T* instance, void (T::*cb)(const IPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getJ<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_getJ.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getJ.
 */
template<class T, typename CT>
class Callback_Initial_getJ : public Callback_Initial_getJ_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IPtr&, const CT&);

    Callback_Initial_getJ(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        IPtr ret;
        try
        {
            ret = proxy->end_getJ(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getJ.
 */
template<class T, typename CT> Callback_Initial_getJPtr
newCallback_Initial_getJ(const IceUtil::Handle<T>& instance, void (T::*cb)(const IPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getJ<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getJ.
 */
template<class T, typename CT> Callback_Initial_getJPtr
newCallback_Initial_getJ(T* instance, void (T::*cb)(const IPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getJ<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_getK.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getK.
 */
template<class T>
class CallbackNC_Initial_getK : public Callback_Initial_getK_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const KPtr&);

    CallbackNC_Initial_getK(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        KPtr ret;
        try
        {
            ret = proxy->end_getK(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getK.
 */
template<class T> Callback_Initial_getKPtr
newCallback_Initial_getK(const IceUtil::Handle<T>& instance, void (T::*cb)(const KPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getK<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getK.
 */
template<class T> Callback_Initial_getKPtr
newCallback_Initial_getK(T* instance, void (T::*cb)(const KPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getK<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_getK.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getK.
 */
template<class T, typename CT>
class Callback_Initial_getK : public Callback_Initial_getK_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const KPtr&, const CT&);

    Callback_Initial_getK(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        KPtr ret;
        try
        {
            ret = proxy->end_getK(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getK.
 */
template<class T, typename CT> Callback_Initial_getKPtr
newCallback_Initial_getK(const IceUtil::Handle<T>& instance, void (T::*cb)(const KPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getK<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getK.
 */
template<class T, typename CT> Callback_Initial_getKPtr
newCallback_Initial_getK(T* instance, void (T::*cb)(const KPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getK<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opValue.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opValue.
 */
template<class T>
class CallbackNC_Initial_opValue : public Callback_Initial_opValue_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Ice::ValuePtr&, const ::Ice::ValuePtr&);

    CallbackNC_Initial_opValue(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        ::Ice::ValuePtr iceP_v2;
        ::Ice::ValuePtr ret;
        try
        {
            ret = proxy->end_opValue(iceP_v2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_v2);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opValue.
 */
template<class T> Callback_Initial_opValuePtr
newCallback_Initial_opValue(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ValuePtr&, const ::Ice::ValuePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opValue<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opValue.
 */
template<class T> Callback_Initial_opValuePtr
newCallback_Initial_opValue(T* instance, void (T::*cb)(const ::Ice::ValuePtr&, const ::Ice::ValuePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opValue<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opValue.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opValue.
 */
template<class T, typename CT>
class Callback_Initial_opValue : public Callback_Initial_opValue_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Ice::ValuePtr&, const ::Ice::ValuePtr&, const CT&);

    Callback_Initial_opValue(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        ::Ice::ValuePtr iceP_v2;
        ::Ice::ValuePtr ret;
        try
        {
            ret = proxy->end_opValue(iceP_v2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_v2, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opValue.
 */
template<class T, typename CT> Callback_Initial_opValuePtr
newCallback_Initial_opValue(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ValuePtr&, const ::Ice::ValuePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opValue<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opValue.
 */
template<class T, typename CT> Callback_Initial_opValuePtr
newCallback_Initial_opValue(T* instance, void (T::*cb)(const ::Ice::ValuePtr&, const ::Ice::ValuePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opValue<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opValueSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opValueSeq.
 */
template<class T>
class CallbackNC_Initial_opValueSeq : public Callback_Initial_opValueSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ValueSeq&, const ValueSeq&);

    CallbackNC_Initial_opValueSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        ValueSeq iceP_v2;
        ValueSeq ret;
        try
        {
            ret = proxy->end_opValueSeq(iceP_v2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_v2);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opValueSeq.
 */
template<class T> Callback_Initial_opValueSeqPtr
newCallback_Initial_opValueSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ValueSeq&, const ValueSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opValueSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opValueSeq.
 */
template<class T> Callback_Initial_opValueSeqPtr
newCallback_Initial_opValueSeq(T* instance, void (T::*cb)(const ValueSeq&, const ValueSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opValueSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opValueSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opValueSeq.
 */
template<class T, typename CT>
class Callback_Initial_opValueSeq : public Callback_Initial_opValueSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ValueSeq&, const ValueSeq&, const CT&);

    Callback_Initial_opValueSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        ValueSeq iceP_v2;
        ValueSeq ret;
        try
        {
            ret = proxy->end_opValueSeq(iceP_v2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_v2, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opValueSeq.
 */
template<class T, typename CT> Callback_Initial_opValueSeqPtr
newCallback_Initial_opValueSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ValueSeq&, const ValueSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opValueSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opValueSeq.
 */
template<class T, typename CT> Callback_Initial_opValueSeqPtr
newCallback_Initial_opValueSeq(T* instance, void (T::*cb)(const ValueSeq&, const ValueSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opValueSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opValueMap.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opValueMap.
 */
template<class T>
class CallbackNC_Initial_opValueMap : public Callback_Initial_opValueMap_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ValueMap&, const ValueMap&);

    CallbackNC_Initial_opValueMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        ValueMap iceP_v2;
        ValueMap ret;
        try
        {
            ret = proxy->end_opValueMap(iceP_v2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_v2);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opValueMap.
 */
template<class T> Callback_Initial_opValueMapPtr
newCallback_Initial_opValueMap(const IceUtil::Handle<T>& instance, void (T::*cb)(const ValueMap&, const ValueMap&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opValueMap<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opValueMap.
 */
template<class T> Callback_Initial_opValueMapPtr
newCallback_Initial_opValueMap(T* instance, void (T::*cb)(const ValueMap&, const ValueMap&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opValueMap<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opValueMap.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opValueMap.
 */
template<class T, typename CT>
class Callback_Initial_opValueMap : public Callback_Initial_opValueMap_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ValueMap&, const ValueMap&, const CT&);

    Callback_Initial_opValueMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        ValueMap iceP_v2;
        ValueMap ret;
        try
        {
            ret = proxy->end_opValueMap(iceP_v2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_v2, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opValueMap.
 */
template<class T, typename CT> Callback_Initial_opValueMapPtr
newCallback_Initial_opValueMap(const IceUtil::Handle<T>& instance, void (T::*cb)(const ValueMap&, const ValueMap&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opValueMap<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opValueMap.
 */
template<class T, typename CT> Callback_Initial_opValueMapPtr
newCallback_Initial_opValueMap(T* instance, void (T::*cb)(const ValueMap&, const ValueMap&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opValueMap<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_getD1.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getD1.
 */
template<class T>
class CallbackNC_Initial_getD1 : public Callback_Initial_getD1_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const D1Ptr&);

    CallbackNC_Initial_getD1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        D1Ptr ret;
        try
        {
            ret = proxy->end_getD1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getD1.
 */
template<class T> Callback_Initial_getD1Ptr
newCallback_Initial_getD1(const IceUtil::Handle<T>& instance, void (T::*cb)(const D1Ptr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getD1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getD1.
 */
template<class T> Callback_Initial_getD1Ptr
newCallback_Initial_getD1(T* instance, void (T::*cb)(const D1Ptr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getD1<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_getD1.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getD1.
 */
template<class T, typename CT>
class Callback_Initial_getD1 : public Callback_Initial_getD1_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const D1Ptr&, const CT&);

    Callback_Initial_getD1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        D1Ptr ret;
        try
        {
            ret = proxy->end_getD1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getD1.
 */
template<class T, typename CT> Callback_Initial_getD1Ptr
newCallback_Initial_getD1(const IceUtil::Handle<T>& instance, void (T::*cb)(const D1Ptr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getD1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getD1.
 */
template<class T, typename CT> Callback_Initial_getD1Ptr
newCallback_Initial_getD1(T* instance, void (T::*cb)(const D1Ptr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getD1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_throwEDerived.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_throwEDerived.
 */
template<class T>
class CallbackNC_Initial_throwEDerived : public Callback_Initial_throwEDerived_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Initial_throwEDerived(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwEDerived(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_throwEDerived.
 */
template<class T> Callback_Initial_throwEDerivedPtr
newCallback_Initial_throwEDerived(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_throwEDerived<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_throwEDerived.
 */
template<class T> Callback_Initial_throwEDerivedPtr
newCallback_Initial_throwEDerived(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_throwEDerived<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_throwEDerived.
 */
template<class T> Callback_Initial_throwEDerivedPtr
newCallback_Initial_throwEDerived(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_throwEDerived<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_throwEDerived.
 */
template<class T> Callback_Initial_throwEDerivedPtr
newCallback_Initial_throwEDerived(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_throwEDerived<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_throwEDerived.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_throwEDerived.
 */
template<class T, typename CT>
class Callback_Initial_throwEDerived : public Callback_Initial_throwEDerived_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Initial_throwEDerived(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwEDerived(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_throwEDerived.
 */
template<class T, typename CT> Callback_Initial_throwEDerivedPtr
newCallback_Initial_throwEDerived(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_throwEDerived<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_throwEDerived.
 */
template<class T, typename CT> Callback_Initial_throwEDerivedPtr
newCallback_Initial_throwEDerived(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_throwEDerived<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_throwEDerived.
 */
template<class T, typename CT> Callback_Initial_throwEDerivedPtr
newCallback_Initial_throwEDerived(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_throwEDerived<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_throwEDerived.
 */
template<class T, typename CT> Callback_Initial_throwEDerivedPtr
newCallback_Initial_throwEDerived(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_throwEDerived<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_setG.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_setG.
 */
template<class T>
class CallbackNC_Initial_setG : public Callback_Initial_setG_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Initial_setG(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setG.
 */
template<class T> Callback_Initial_setGPtr
newCallback_Initial_setG(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_setG<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setG.
 */
template<class T> Callback_Initial_setGPtr
newCallback_Initial_setG(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_setG<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setG.
 */
template<class T> Callback_Initial_setGPtr
newCallback_Initial_setG(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_setG<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setG.
 */
template<class T> Callback_Initial_setGPtr
newCallback_Initial_setG(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_setG<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_setG.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_setG.
 */
template<class T, typename CT>
class Callback_Initial_setG : public Callback_Initial_setG_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Initial_setG(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setG.
 */
template<class T, typename CT> Callback_Initial_setGPtr
newCallback_Initial_setG(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_setG<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setG.
 */
template<class T, typename CT> Callback_Initial_setGPtr
newCallback_Initial_setG(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_setG<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setG.
 */
template<class T, typename CT> Callback_Initial_setGPtr
newCallback_Initial_setG(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_setG<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setG.
 */
template<class T, typename CT> Callback_Initial_setGPtr
newCallback_Initial_setG(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_setG<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_setI.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_setI.
 */
template<class T>
class CallbackNC_Initial_setI : public Callback_Initial_setI_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Initial_setI(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setI.
 */
template<class T> Callback_Initial_setIPtr
newCallback_Initial_setI(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_setI<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setI.
 */
template<class T> Callback_Initial_setIPtr
newCallback_Initial_setI(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_setI<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setI.
 */
template<class T> Callback_Initial_setIPtr
newCallback_Initial_setI(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_setI<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setI.
 */
template<class T> Callback_Initial_setIPtr
newCallback_Initial_setI(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_setI<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_setI.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_setI.
 */
template<class T, typename CT>
class Callback_Initial_setI : public Callback_Initial_setI_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Initial_setI(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setI.
 */
template<class T, typename CT> Callback_Initial_setIPtr
newCallback_Initial_setI(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_setI<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setI.
 */
template<class T, typename CT> Callback_Initial_setIPtr
newCallback_Initial_setI(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_setI<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setI.
 */
template<class T, typename CT> Callback_Initial_setIPtr
newCallback_Initial_setI(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_setI<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_setI.
 */
template<class T, typename CT> Callback_Initial_setIPtr
newCallback_Initial_setI(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_setI<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opBaseSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opBaseSeq.
 */
template<class T>
class CallbackNC_Initial_opBaseSeq : public Callback_Initial_opBaseSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BaseSeq&, const BaseSeq&);

    CallbackNC_Initial_opBaseSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        BaseSeq iceP_outSeq;
        BaseSeq ret;
        try
        {
            ret = proxy->end_opBaseSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opBaseSeq.
 */
template<class T> Callback_Initial_opBaseSeqPtr
newCallback_Initial_opBaseSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const BaseSeq&, const BaseSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opBaseSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opBaseSeq.
 */
template<class T> Callback_Initial_opBaseSeqPtr
newCallback_Initial_opBaseSeq(T* instance, void (T::*cb)(const BaseSeq&, const BaseSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opBaseSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opBaseSeq.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opBaseSeq.
 */
template<class T, typename CT>
class Callback_Initial_opBaseSeq : public Callback_Initial_opBaseSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BaseSeq&, const BaseSeq&, const CT&);

    Callback_Initial_opBaseSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        BaseSeq iceP_outSeq;
        BaseSeq ret;
        try
        {
            ret = proxy->end_opBaseSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opBaseSeq.
 */
template<class T, typename CT> Callback_Initial_opBaseSeqPtr
newCallback_Initial_opBaseSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const BaseSeq&, const BaseSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opBaseSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opBaseSeq.
 */
template<class T, typename CT> Callback_Initial_opBaseSeqPtr
newCallback_Initial_opBaseSeq(T* instance, void (T::*cb)(const BaseSeq&, const BaseSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opBaseSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_getCompact.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getCompact.
 */
template<class T>
class CallbackNC_Initial_getCompact : public Callback_Initial_getCompact_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const CompactPtr&);

    CallbackNC_Initial_getCompact(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        CompactPtr ret;
        try
        {
            ret = proxy->end_getCompact(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getCompact.
 */
template<class T> Callback_Initial_getCompactPtr
newCallback_Initial_getCompact(const IceUtil::Handle<T>& instance, void (T::*cb)(const CompactPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getCompact<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getCompact.
 */
template<class T> Callback_Initial_getCompactPtr
newCallback_Initial_getCompact(T* instance, void (T::*cb)(const CompactPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getCompact<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_getCompact.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getCompact.
 */
template<class T, typename CT>
class Callback_Initial_getCompact : public Callback_Initial_getCompact_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CompactPtr&, const CT&);

    Callback_Initial_getCompact(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        CompactPtr ret;
        try
        {
            ret = proxy->end_getCompact(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getCompact.
 */
template<class T, typename CT> Callback_Initial_getCompactPtr
newCallback_Initial_getCompact(const IceUtil::Handle<T>& instance, void (T::*cb)(const CompactPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getCompact<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getCompact.
 */
template<class T, typename CT> Callback_Initial_getCompactPtr
newCallback_Initial_getCompact(T* instance, void (T::*cb)(const CompactPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getCompact<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_getInnerA.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getInnerA.
 */
template<class T>
class CallbackNC_Initial_getInnerA : public Callback_Initial_getInnerA_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::Inner::APtr&);

    CallbackNC_Initial_getInnerA(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        ::Test::Inner::APtr ret;
        try
        {
            ret = proxy->end_getInnerA(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getInnerA.
 */
template<class T> Callback_Initial_getInnerAPtr
newCallback_Initial_getInnerA(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::Inner::APtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getInnerA<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getInnerA.
 */
template<class T> Callback_Initial_getInnerAPtr
newCallback_Initial_getInnerA(T* instance, void (T::*cb)(const ::Test::Inner::APtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getInnerA<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_getInnerA.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getInnerA.
 */
template<class T, typename CT>
class Callback_Initial_getInnerA : public Callback_Initial_getInnerA_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::Inner::APtr&, const CT&);

    Callback_Initial_getInnerA(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        ::Test::Inner::APtr ret;
        try
        {
            ret = proxy->end_getInnerA(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getInnerA.
 */
template<class T, typename CT> Callback_Initial_getInnerAPtr
newCallback_Initial_getInnerA(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::Inner::APtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getInnerA<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getInnerA.
 */
template<class T, typename CT> Callback_Initial_getInnerAPtr
newCallback_Initial_getInnerA(T* instance, void (T::*cb)(const ::Test::Inner::APtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getInnerA<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_getInnerSubA.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getInnerSubA.
 */
template<class T>
class CallbackNC_Initial_getInnerSubA : public Callback_Initial_getInnerSubA_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::Inner::Sub::APtr&);

    CallbackNC_Initial_getInnerSubA(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        ::Test::Inner::Sub::APtr ret;
        try
        {
            ret = proxy->end_getInnerSubA(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getInnerSubA.
 */
template<class T> Callback_Initial_getInnerSubAPtr
newCallback_Initial_getInnerSubA(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::Inner::Sub::APtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getInnerSubA<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getInnerSubA.
 */
template<class T> Callback_Initial_getInnerSubAPtr
newCallback_Initial_getInnerSubA(T* instance, void (T::*cb)(const ::Test::Inner::Sub::APtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_getInnerSubA<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_getInnerSubA.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_getInnerSubA.
 */
template<class T, typename CT>
class Callback_Initial_getInnerSubA : public Callback_Initial_getInnerSubA_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::Inner::Sub::APtr&, const CT&);

    Callback_Initial_getInnerSubA(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        ::Test::Inner::Sub::APtr ret;
        try
        {
            ret = proxy->end_getInnerSubA(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getInnerSubA.
 */
template<class T, typename CT> Callback_Initial_getInnerSubAPtr
newCallback_Initial_getInnerSubA(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::Inner::Sub::APtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getInnerSubA<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_getInnerSubA.
 */
template<class T, typename CT> Callback_Initial_getInnerSubAPtr
newCallback_Initial_getInnerSubA(T* instance, void (T::*cb)(const ::Test::Inner::Sub::APtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_getInnerSubA<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_throwInnerEx.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_throwInnerEx.
 */
template<class T>
class CallbackNC_Initial_throwInnerEx : public Callback_Initial_throwInnerEx_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Initial_throwInnerEx(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwInnerEx(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_throwInnerEx.
 */
template<class T> Callback_Initial_throwInnerExPtr
newCallback_Initial_throwInnerEx(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_throwInnerEx<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_throwInnerEx.
 */
template<class T> Callback_Initial_throwInnerExPtr
newCallback_Initial_throwInnerEx(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_throwInnerEx<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_throwInnerEx.
 */
template<class T> Callback_Initial_throwInnerExPtr
newCallback_Initial_throwInnerEx(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_throwInnerEx<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_throwInnerEx.
 */
template<class T> Callback_Initial_throwInnerExPtr
newCallback_Initial_throwInnerEx(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_throwInnerEx<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_throwInnerEx.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_throwInnerEx.
 */
template<class T, typename CT>
class Callback_Initial_throwInnerEx : public Callback_Initial_throwInnerEx_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Initial_throwInnerEx(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwInnerEx(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_throwInnerEx.
 */
template<class T, typename CT> Callback_Initial_throwInnerExPtr
newCallback_Initial_throwInnerEx(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_throwInnerEx<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_throwInnerEx.
 */
template<class T, typename CT> Callback_Initial_throwInnerExPtr
newCallback_Initial_throwInnerEx(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_throwInnerEx<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_throwInnerEx.
 */
template<class T, typename CT> Callback_Initial_throwInnerExPtr
newCallback_Initial_throwInnerEx(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_throwInnerEx<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_throwInnerEx.
 */
template<class T, typename CT> Callback_Initial_throwInnerExPtr
newCallback_Initial_throwInnerEx(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_throwInnerEx<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_throwInnerSubEx.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_throwInnerSubEx.
 */
template<class T>
class CallbackNC_Initial_throwInnerSubEx : public Callback_Initial_throwInnerSubEx_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Initial_throwInnerSubEx(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwInnerSubEx(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_throwInnerSubEx.
 */
template<class T> Callback_Initial_throwInnerSubExPtr
newCallback_Initial_throwInnerSubEx(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_throwInnerSubEx<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_throwInnerSubEx.
 */
template<class T> Callback_Initial_throwInnerSubExPtr
newCallback_Initial_throwInnerSubEx(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_throwInnerSubEx<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_throwInnerSubEx.
 */
template<class T> Callback_Initial_throwInnerSubExPtr
newCallback_Initial_throwInnerSubEx(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_throwInnerSubEx<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_throwInnerSubEx.
 */
template<class T> Callback_Initial_throwInnerSubExPtr
newCallback_Initial_throwInnerSubEx(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_throwInnerSubEx<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_throwInnerSubEx.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_throwInnerSubEx.
 */
template<class T, typename CT>
class Callback_Initial_throwInnerSubEx : public Callback_Initial_throwInnerSubEx_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Initial_throwInnerSubEx(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwInnerSubEx(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_throwInnerSubEx.
 */
template<class T, typename CT> Callback_Initial_throwInnerSubExPtr
newCallback_Initial_throwInnerSubEx(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_throwInnerSubEx<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_throwInnerSubEx.
 */
template<class T, typename CT> Callback_Initial_throwInnerSubExPtr
newCallback_Initial_throwInnerSubEx(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_throwInnerSubEx<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_throwInnerSubEx.
 */
template<class T, typename CT> Callback_Initial_throwInnerSubExPtr
newCallback_Initial_throwInnerSubEx(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_throwInnerSubEx<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_throwInnerSubEx.
 */
template<class T, typename CT> Callback_Initial_throwInnerSubExPtr
newCallback_Initial_throwInnerSubEx(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_throwInnerSubEx<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opM.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opM.
 */
template<class T>
class CallbackNC_Initial_opM : public Callback_Initial_opM_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const MPtr&, const MPtr&);

    CallbackNC_Initial_opM(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        MPtr iceP_v2;
        MPtr ret;
        try
        {
            ret = proxy->end_opM(iceP_v2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_v2);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opM.
 */
template<class T> Callback_Initial_opMPtr
newCallback_Initial_opM(const IceUtil::Handle<T>& instance, void (T::*cb)(const MPtr&, const MPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opM<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opM.
 */
template<class T> Callback_Initial_opMPtr
newCallback_Initial_opM(T* instance, void (T::*cb)(const MPtr&, const MPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opM<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opM.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opM.
 */
template<class T, typename CT>
class Callback_Initial_opM : public Callback_Initial_opM_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const MPtr&, const MPtr&, const CT&);

    Callback_Initial_opM(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        MPtr iceP_v2;
        MPtr ret;
        try
        {
            ret = proxy->end_opM(iceP_v2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_v2, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opM.
 */
template<class T, typename CT> Callback_Initial_opMPtr
newCallback_Initial_opM(const IceUtil::Handle<T>& instance, void (T::*cb)(const MPtr&, const MPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opM<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opM.
 */
template<class T, typename CT> Callback_Initial_opMPtr
newCallback_Initial_opM(T* instance, void (T::*cb)(const MPtr&, const MPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opM<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opF1.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opF1.
 */
template<class T>
class CallbackNC_Initial_opF1 : public Callback_Initial_opF1_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const F1Ptr&, const F1Ptr&);

    CallbackNC_Initial_opF1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        F1Ptr iceP_f12;
        F1Ptr ret;
        try
        {
            ret = proxy->end_opF1(iceP_f12, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_f12);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opF1.
 */
template<class T> Callback_Initial_opF1Ptr
newCallback_Initial_opF1(const IceUtil::Handle<T>& instance, void (T::*cb)(const F1Ptr&, const F1Ptr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opF1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opF1.
 */
template<class T> Callback_Initial_opF1Ptr
newCallback_Initial_opF1(T* instance, void (T::*cb)(const F1Ptr&, const F1Ptr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opF1<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opF1.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opF1.
 */
template<class T, typename CT>
class Callback_Initial_opF1 : public Callback_Initial_opF1_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const F1Ptr&, const F1Ptr&, const CT&);

    Callback_Initial_opF1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        F1Ptr iceP_f12;
        F1Ptr ret;
        try
        {
            ret = proxy->end_opF1(iceP_f12, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_f12, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opF1.
 */
template<class T, typename CT> Callback_Initial_opF1Ptr
newCallback_Initial_opF1(const IceUtil::Handle<T>& instance, void (T::*cb)(const F1Ptr&, const F1Ptr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opF1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opF1.
 */
template<class T, typename CT> Callback_Initial_opF1Ptr
newCallback_Initial_opF1(T* instance, void (T::*cb)(const F1Ptr&, const F1Ptr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opF1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opF2.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opF2.
 */
template<class T>
class CallbackNC_Initial_opF2 : public Callback_Initial_opF2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const F2Prx&, const F2Prx&);

    CallbackNC_Initial_opF2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        F2Prx iceP_f22;
        F2Prx ret;
        try
        {
            ret = proxy->end_opF2(iceP_f22, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_f22);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opF2.
 */
template<class T> Callback_Initial_opF2Ptr
newCallback_Initial_opF2(const IceUtil::Handle<T>& instance, void (T::*cb)(const F2Prx&, const F2Prx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opF2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opF2.
 */
template<class T> Callback_Initial_opF2Ptr
newCallback_Initial_opF2(T* instance, void (T::*cb)(const F2Prx&, const F2Prx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opF2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opF2.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opF2.
 */
template<class T, typename CT>
class Callback_Initial_opF2 : public Callback_Initial_opF2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const F2Prx&, const F2Prx&, const CT&);

    Callback_Initial_opF2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        F2Prx iceP_f22;
        F2Prx ret;
        try
        {
            ret = proxy->end_opF2(iceP_f22, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_f22, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opF2.
 */
template<class T, typename CT> Callback_Initial_opF2Ptr
newCallback_Initial_opF2(const IceUtil::Handle<T>& instance, void (T::*cb)(const F2Prx&, const F2Prx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opF2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opF2.
 */
template<class T, typename CT> Callback_Initial_opF2Ptr
newCallback_Initial_opF2(T* instance, void (T::*cb)(const F2Prx&, const F2Prx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opF2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opF3.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opF3.
 */
template<class T>
class CallbackNC_Initial_opF3 : public Callback_Initial_opF3_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const F3Ptr&, const F3Ptr&);

    CallbackNC_Initial_opF3(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        F3Ptr iceP_f32;
        F3Ptr ret;
        try
        {
            ret = proxy->end_opF3(iceP_f32, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_f32);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opF3.
 */
template<class T> Callback_Initial_opF3Ptr
newCallback_Initial_opF3(const IceUtil::Handle<T>& instance, void (T::*cb)(const F3Ptr&, const F3Ptr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opF3<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opF3.
 */
template<class T> Callback_Initial_opF3Ptr
newCallback_Initial_opF3(T* instance, void (T::*cb)(const F3Ptr&, const F3Ptr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opF3<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opF3.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opF3.
 */
template<class T, typename CT>
class Callback_Initial_opF3 : public Callback_Initial_opF3_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const F3Ptr&, const F3Ptr&, const CT&);

    Callback_Initial_opF3(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        F3Ptr iceP_f32;
        F3Ptr ret;
        try
        {
            ret = proxy->end_opF3(iceP_f32, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_f32, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opF3.
 */
template<class T, typename CT> Callback_Initial_opF3Ptr
newCallback_Initial_opF3(const IceUtil::Handle<T>& instance, void (T::*cb)(const F3Ptr&, const F3Ptr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opF3<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opF3.
 */
template<class T, typename CT> Callback_Initial_opF3Ptr
newCallback_Initial_opF3(T* instance, void (T::*cb)(const F3Ptr&, const F3Ptr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opF3<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_hasF3.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_hasF3.
 */
template<class T>
class CallbackNC_Initial_hasF3 : public Callback_Initial_hasF3_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Initial_hasF3(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_hasF3(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_hasF3.
 */
template<class T> Callback_Initial_hasF3Ptr
newCallback_Initial_hasF3(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_hasF3<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_hasF3.
 */
template<class T> Callback_Initial_hasF3Ptr
newCallback_Initial_hasF3(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_hasF3<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_hasF3.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_hasF3.
 */
template<class T, typename CT>
class Callback_Initial_hasF3 : public Callback_Initial_hasF3_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Initial_hasF3(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_hasF3(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_hasF3.
 */
template<class T, typename CT> Callback_Initial_hasF3Ptr
newCallback_Initial_hasF3(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_hasF3<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_hasF3.
 */
template<class T, typename CT> Callback_Initial_hasF3Ptr
newCallback_Initial_hasF3(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_hasF3<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Initial::begin_opN.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opN.
 */
template<class T>
class CallbackNC_Initial_opN : public Callback_Initial_opN_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const NPtr&);

    CallbackNC_Initial_opN(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        NPtr ret;
        try
        {
            ret = proxy->end_opN(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opN.
 */
template<class T> Callback_Initial_opNPtr
newCallback_Initial_opN(const IceUtil::Handle<T>& instance, void (T::*cb)(const NPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opN<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opN.
 */
template<class T> Callback_Initial_opNPtr
newCallback_Initial_opN(T* instance, void (T::*cb)(const NPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Initial_opN<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Initial::begin_opN.
 * Create a wrapper instance by calling ::Test::newCallback_Initial_opN.
 */
template<class T, typename CT>
class Callback_Initial_opN : public Callback_Initial_opN_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const NPtr&, const CT&);

    Callback_Initial_opN(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InitialPrx proxy = InitialPrx::uncheckedCast(result->getProxy());
        NPtr ret;
        try
        {
            ret = proxy->end_opN(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opN.
 */
template<class T, typename CT> Callback_Initial_opNPtr
newCallback_Initial_opN(const IceUtil::Handle<T>& instance, void (T::*cb)(const NPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opN<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Initial::begin_opN.
 */
template<class T, typename CT> Callback_Initial_opNPtr
newCallback_Initial_opN(T* instance, void (T::*cb)(const NPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Initial_opN<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::UnexpectedObjectExceptionTest::begin_op.
 * Create a wrapper instance by calling ::Test::newCallback_UnexpectedObjectExceptionTest_op.
 */
template<class T>
class CallbackNC_UnexpectedObjectExceptionTest_op : public Callback_UnexpectedObjectExceptionTest_op_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const EmptyPtr&);

    CallbackNC_UnexpectedObjectExceptionTest_op(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        UnexpectedObjectExceptionTestPrx proxy = UnexpectedObjectExceptionTestPrx::uncheckedCast(result->getProxy());
        EmptyPtr ret;
        try
        {
            ret = proxy->end_op(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::UnexpectedObjectExceptionTest::begin_op.
 */
template<class T> Callback_UnexpectedObjectExceptionTest_opPtr
newCallback_UnexpectedObjectExceptionTest_op(const IceUtil::Handle<T>& instance, void (T::*cb)(const EmptyPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_UnexpectedObjectExceptionTest_op<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::UnexpectedObjectExceptionTest::begin_op.
 */
template<class T> Callback_UnexpectedObjectExceptionTest_opPtr
newCallback_UnexpectedObjectExceptionTest_op(T* instance, void (T::*cb)(const EmptyPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_UnexpectedObjectExceptionTest_op<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::UnexpectedObjectExceptionTest::begin_op.
 * Create a wrapper instance by calling ::Test::newCallback_UnexpectedObjectExceptionTest_op.
 */
template<class T, typename CT>
class Callback_UnexpectedObjectExceptionTest_op : public Callback_UnexpectedObjectExceptionTest_op_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const EmptyPtr&, const CT&);

    Callback_UnexpectedObjectExceptionTest_op(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        UnexpectedObjectExceptionTestPrx proxy = UnexpectedObjectExceptionTestPrx::uncheckedCast(result->getProxy());
        EmptyPtr ret;
        try
        {
            ret = proxy->end_op(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::UnexpectedObjectExceptionTest::begin_op.
 */
template<class T, typename CT> Callback_UnexpectedObjectExceptionTest_opPtr
newCallback_UnexpectedObjectExceptionTest_op(const IceUtil::Handle<T>& instance, void (T::*cb)(const EmptyPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_UnexpectedObjectExceptionTest_op<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::UnexpectedObjectExceptionTest::begin_op.
 */
template<class T, typename CT> Callback_UnexpectedObjectExceptionTest_opPtr
newCallback_UnexpectedObjectExceptionTest_op(T* instance, void (T::*cb)(const EmptyPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_UnexpectedObjectExceptionTest_op<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Echo::begin_setConnection.
 * Create a wrapper instance by calling ::Test::newCallback_Echo_setConnection.
 */
template<class T>
class CallbackNC_Echo_setConnection : public Callback_Echo_setConnection_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Echo_setConnection(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Echo::begin_setConnection.
 */
template<class T> Callback_Echo_setConnectionPtr
newCallback_Echo_setConnection(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Echo_setConnection<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Echo::begin_setConnection.
 */
template<class T> Callback_Echo_setConnectionPtr
newCallback_Echo_setConnection(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Echo_setConnection<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Echo::begin_setConnection.
 */
template<class T> Callback_Echo_setConnectionPtr
newCallback_Echo_setConnection(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Echo_setConnection<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Echo::begin_setConnection.
 */
template<class T> Callback_Echo_setConnectionPtr
newCallback_Echo_setConnection(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Echo_setConnection<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Echo::begin_setConnection.
 * Create a wrapper instance by calling ::Test::newCallback_Echo_setConnection.
 */
template<class T, typename CT>
class Callback_Echo_setConnection : public Callback_Echo_setConnection_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Echo_setConnection(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Echo::begin_setConnection.
 */
template<class T, typename CT> Callback_Echo_setConnectionPtr
newCallback_Echo_setConnection(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Echo_setConnection<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Echo::begin_setConnection.
 */
template<class T, typename CT> Callback_Echo_setConnectionPtr
newCallback_Echo_setConnection(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Echo_setConnection<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Echo::begin_setConnection.
 */
template<class T, typename CT> Callback_Echo_setConnectionPtr
newCallback_Echo_setConnection(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Echo_setConnection<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Echo::begin_setConnection.
 */
template<class T, typename CT> Callback_Echo_setConnectionPtr
newCallback_Echo_setConnection(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Echo_setConnection<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Echo::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_Echo_shutdown.
 */
template<class T>
class CallbackNC_Echo_shutdown : public Callback_Echo_shutdown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Echo_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Echo::begin_shutdown.
 */
template<class T> Callback_Echo_shutdownPtr
newCallback_Echo_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Echo_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Echo::begin_shutdown.
 */
template<class T> Callback_Echo_shutdownPtr
newCallback_Echo_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Echo_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Echo::begin_shutdown.
 */
template<class T> Callback_Echo_shutdownPtr
newCallback_Echo_shutdown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Echo_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Echo::begin_shutdown.
 */
template<class T> Callback_Echo_shutdownPtr
newCallback_Echo_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Echo_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Echo::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_Echo_shutdown.
 */
template<class T, typename CT>
class Callback_Echo_shutdown : public Callback_Echo_shutdown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Echo_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Echo::begin_shutdown.
 */
template<class T, typename CT> Callback_Echo_shutdownPtr
newCallback_Echo_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Echo_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Echo::begin_shutdown.
 */
template<class T, typename CT> Callback_Echo_shutdownPtr
newCallback_Echo_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Echo_shutdown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Echo::begin_shutdown.
 */
template<class T, typename CT> Callback_Echo_shutdownPtr
newCallback_Echo_shutdown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Echo_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Echo::begin_shutdown.
 */
template<class T, typename CT> Callback_Echo_shutdownPtr
newCallback_Echo_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Echo_shutdown<T, CT>(instance, 0, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
