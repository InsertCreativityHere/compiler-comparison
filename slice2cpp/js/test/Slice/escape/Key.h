// Copyright (c) ZeroC, Inc.
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file 'Key.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>

// clang-format off

#ifndef Key_h_
#define Key_h_

#include <Ice/PushDisableWarnings.h>
#include <Ice/Ice.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace await
{
    enum class var : std::uint8_t
    {
        base
    };

    std::ostream& operator<<(std::ostream&, var);

    struct break;

    class casePrx;

    class typeofPrx;

    class delete;
    using deletePtr = std::shared_ptr<delete>;

    class explicitPrx;

    using while = std::map<std::string, break>;

    class package;
    using packagePtr = std::shared_ptr<package>;

    class optionalParamsPrx;

    class implicitPrx;

    constexpr std::int32_t protected = 0;

    constexpr std::int32_t public = 0;

    namespace System
    {

        class TestPrx;
    }
}

namespace System
{

    class TestPrx;
}

namespace await
{
    class casePrx : public Ice::Proxy<casePrx, Ice::ObjectPrx>
    {
    public:

        void catch(std::int32_t checked, std::int32_t& continue, const Ice::Context& context = Ice::noExplicitContext) const;

        [[nodiscard]] std::future<std::int32_t> catchAsync(std::int32_t checked, const Ice::Context& context = Ice::noExplicitContext) const;

        std::function<void()> // NOLINT(modernize-use-nodiscard)
        catchAsync(std::int32_t checked, std::function<void(std::int32_t)> response, std::function<void(std::exception_ptr)> ex = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// \cond INTERNAL
        void _iceI_catch(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::int32_t>>&, std::int32_t, const Ice::Context&) const;
        /// \endcond

        /// Obtains the Slice type ID of this interface.
        /// @return The fully-scoped type ID.
        static const char* ice_staticId() noexcept;

        casePrx(const casePrx& other) noexcept : Ice::ObjectPrx(other) {} // NOLINT(modernize-use-equals-default)

        casePrx(casePrx&& other) noexcept : Ice::ObjectPrx(std::move(other)) {} // NOLINT(modernize-use-equals-default)

        casePrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx(communicator, proxyString) {} // NOLINT(modernize-use-equals-default)

        ~casePrx() override;

        casePrx& operator=(const casePrx& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(rhs);
            }
            return *this;
        }

        casePrx& operator=(casePrx&& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(std::move(rhs));
            }
            return *this;
        }

        /// \cond INTERNAL
        static casePrx _fromReference(IceInternal::ReferencePtr ref) { return casePrx(std::move(ref)); }

    protected:
        casePrx() = default;

        explicit casePrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx(std::move(ref))
        {
        }
        /// \endcond
    };

    class typeofPrx : public Ice::Proxy<typeofPrx, Ice::ObjectPrx>
    {
    public:

        void default(const Ice::Context& context = Ice::noExplicitContext) const;

        [[nodiscard]] std::future<void> defaultAsync(const Ice::Context& context = Ice::noExplicitContext) const;

        std::function<void()> // NOLINT(modernize-use-nodiscard)
        defaultAsync(std::function<void()> response, std::function<void(std::exception_ptr)> ex = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// \cond INTERNAL
        void _iceI_default(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const Ice::Context&) const;
        /// \endcond

        /// Obtains the Slice type ID of this interface.
        /// @return The fully-scoped type ID.
        static const char* ice_staticId() noexcept;

        typeofPrx(const typeofPrx& other) noexcept : Ice::ObjectPrx(other) {} // NOLINT(modernize-use-equals-default)

        typeofPrx(typeofPrx&& other) noexcept : Ice::ObjectPrx(std::move(other)) {} // NOLINT(modernize-use-equals-default)

        typeofPrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx(communicator, proxyString) {} // NOLINT(modernize-use-equals-default)

        ~typeofPrx() override;

        typeofPrx& operator=(const typeofPrx& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(rhs);
            }
            return *this;
        }

        typeofPrx& operator=(typeofPrx&& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(std::move(rhs));
            }
            return *this;
        }

        /// \cond INTERNAL
        static typeofPrx _fromReference(IceInternal::ReferencePtr ref) { return typeofPrx(std::move(ref)); }

    protected:
        typeofPrx() = default;

        explicit typeofPrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx(std::move(ref))
        {
        }
        /// \endcond
    };

    class explicitPrx : public Ice::Proxy<explicitPrx, typeofPrx, casePrx>
    {
    public:

        /// Obtains the Slice type ID of this interface.
        /// @return The fully-scoped type ID.
        static const char* ice_staticId() noexcept;

#if defined(__GNUC__)
#   pragma GCC diagnostic push
#   pragma GCC diagnostic ignored "-Wextra" // initialize all virtual bases in correct order
#endif

        explicitPrx(const explicitPrx& other) noexcept : Ice::ObjectPrx(other) {} // NOLINT(modernize-use-equals-default)

        explicitPrx(explicitPrx&& other) noexcept : Ice::ObjectPrx(std::move(other)) {} // NOLINT(modernize-use-equals-default)

        explicitPrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx(communicator, proxyString) {} // NOLINT(modernize-use-equals-default)

        ~explicitPrx() override;

        explicitPrx& operator=(const explicitPrx& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(rhs);
            }
            return *this;
        }

        explicitPrx& operator=(explicitPrx&& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(std::move(rhs));
            }
            return *this;
        }

        /// \cond INTERNAL
        static explicitPrx _fromReference(IceInternal::ReferencePtr ref) { return explicitPrx(std::move(ref)); }

    protected:
        explicitPrx() = default;

        explicit explicitPrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx(std::move(ref))
        {
        }
        /// \endcond

#if defined(__GNUC__)
#   pragma GCC diagnostic pop
#endif
    };

    class optionalParamsPrx : public Ice::Proxy<optionalParamsPrx, Ice::ObjectPrx>
    {
    public:

        std::optional<break> for(std::optional<var> goto, const std::optional<explicitPrx>& if, const std::optional<while>& internal, std::optional<std::string_view> namespace, const std::optional<explicitPrx>& null, const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

        [[nodiscard]] std::future<std::optional<break>> forAsync(std::optional<var> goto, const std::optional<explicitPrx>& if, const std::optional<while>& internal, std::optional<std::string_view> namespace, const std::optional<explicitPrx>& null, const Ice::Context& context = Ice::noExplicitContext) const;

        std::function<void()> // NOLINT(modernize-use-nodiscard)
        forAsync(std::optional<var> goto, const std::optional<explicitPrx>& if, const std::optional<while>& internal, std::optional<std::string_view> namespace, const std::optional<explicitPrx>& null, std::function<void(std::optional<::await::break>)> response, std::function<void(std::exception_ptr)> ex = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// \cond INTERNAL
        void _iceI_for(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::optional<break>>>&, std::optional<var>, const std::optional<explicitPrx>&, const std::optional<while>&, std::optional<std::string_view>, const std::optional<explicitPrx>&, const Ice::Context&) const;
        /// \endcond

        std::optional<break> continue(std::optional<var> goto, const std::optional<explicitPrx>& if, const std::optional<while>& internal, std::optional<std::string_view> namespace, const std::optional<explicitPrx>& null, const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

        [[nodiscard]] std::future<std::optional<break>> continueAsync(std::optional<var> goto, const std::optional<explicitPrx>& if, const std::optional<while>& internal, std::optional<std::string_view> namespace, const std::optional<explicitPrx>& null, const Ice::Context& context = Ice::noExplicitContext) const;

        std::function<void()> // NOLINT(modernize-use-nodiscard)
        continueAsync(std::optional<var> goto, const std::optional<explicitPrx>& if, const std::optional<while>& internal, std::optional<std::string_view> namespace, const std::optional<explicitPrx>& null, std::function<void(std::optional<::await::break>)> response, std::function<void(std::exception_ptr)> ex = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// \cond INTERNAL
        void _iceI_continue(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::optional<break>>>&, std::optional<var>, const std::optional<explicitPrx>&, const std::optional<while>&, std::optional<std::string_view>, const std::optional<explicitPrx>&, const Ice::Context&) const;
        /// \endcond

        std::optional<break> in(std::optional<var>& goto, std::optional<explicitPrx>& if, std::optional<while>& internal, std::optional<std::string>& namespace, std::optional<explicitPrx>& null, const Ice::Context& context = Ice::noExplicitContext) const;

        [[nodiscard]] std::future<std::tuple<std::optional<break>, std::optional<var>, std::optional<explicitPrx>, std::optional<while>, std::optional<std::string>, std::optional<explicitPrx>>> inAsync(const Ice::Context& context = Ice::noExplicitContext) const;

        std::function<void()> // NOLINT(modernize-use-nodiscard)
        inAsync(std::function<void(std::optional<::await::break>, std::optional<::await::var>, std::optional<::await::explicitPrx>, std::optional<::await::while>, std::optional<std::string>, std::optional<::await::explicitPrx>)> response, std::function<void(std::exception_ptr)> ex = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// \cond INTERNAL
        void _iceI_in(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<std::optional<break>, std::optional<var>, std::optional<explicitPrx>, std::optional<while>, std::optional<std::string>, std::optional<explicitPrx>>>>&, const Ice::Context&) const;
        /// \endcond

        std::optional<break> foreach(std::optional<var>& goto, std::optional<explicitPrx>& if, std::optional<while>& internal, std::optional<std::string>& namespace, std::optional<explicitPrx>& null, const Ice::Context& context = Ice::noExplicitContext) const;

        [[nodiscard]] std::future<std::tuple<std::optional<break>, std::optional<var>, std::optional<explicitPrx>, std::optional<while>, std::optional<std::string>, std::optional<explicitPrx>>> foreachAsync(const Ice::Context& context = Ice::noExplicitContext) const;

        std::function<void()> // NOLINT(modernize-use-nodiscard)
        foreachAsync(std::function<void(std::optional<::await::break>, std::optional<::await::var>, std::optional<::await::explicitPrx>, std::optional<::await::while>, std::optional<std::string>, std::optional<::await::explicitPrx>)> response, std::function<void(std::exception_ptr)> ex = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// \cond INTERNAL
        void _iceI_foreach(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<std::optional<break>, std::optional<var>, std::optional<explicitPrx>, std::optional<while>, std::optional<std::string>, std::optional<explicitPrx>>>>&, const Ice::Context&) const;
        /// \endcond

        /// Obtains the Slice type ID of this interface.
        /// @return The fully-scoped type ID.
        static const char* ice_staticId() noexcept;

        optionalParamsPrx(const optionalParamsPrx& other) noexcept : Ice::ObjectPrx(other) {} // NOLINT(modernize-use-equals-default)

        optionalParamsPrx(optionalParamsPrx&& other) noexcept : Ice::ObjectPrx(std::move(other)) {} // NOLINT(modernize-use-equals-default)

        optionalParamsPrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx(communicator, proxyString) {} // NOLINT(modernize-use-equals-default)

        ~optionalParamsPrx() override;

        optionalParamsPrx& operator=(const optionalParamsPrx& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(rhs);
            }
            return *this;
        }

        optionalParamsPrx& operator=(optionalParamsPrx&& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(std::move(rhs));
            }
            return *this;
        }

        /// \cond INTERNAL
        static optionalParamsPrx _fromReference(IceInternal::ReferencePtr ref) { return optionalParamsPrx(std::move(ref)); }

    protected:
        optionalParamsPrx() = default;

        explicit optionalParamsPrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx(std::move(ref))
        {
        }
        /// \endcond
    };

    class implicitPrx : public Ice::Proxy<implicitPrx, Ice::ObjectPrx>
    {
    public:

        var in(const break& internal, const deletePtr& is, const std::optional<explicitPrx>& lock, const std::optional<casePrx>& namespace, const std::optional<typeofPrx>& new, const deletePtr& null, const std::optional<explicitPrx>& operator, std::int32_t override, std::int32_t params, std::int32_t private, const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

        [[nodiscard]] std::future<var> inAsync(const break& internal, const deletePtr& is, const std::optional<explicitPrx>& lock, const std::optional<casePrx>& namespace, const std::optional<typeofPrx>& new, const deletePtr& null, const std::optional<explicitPrx>& operator, std::int32_t override, std::int32_t params, std::int32_t private, const Ice::Context& context = Ice::noExplicitContext) const;

        std::function<void()> // NOLINT(modernize-use-nodiscard)
        inAsync(const break& internal, const deletePtr& is, const std::optional<explicitPrx>& lock, const std::optional<casePrx>& namespace, const std::optional<typeofPrx>& new, const deletePtr& null, const std::optional<explicitPrx>& operator, std::int32_t override, std::int32_t params, std::int32_t private, std::function<void(::await::var)> response, std::function<void(std::exception_ptr)> ex = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// \cond INTERNAL
        void _iceI_in(const std::shared_ptr<IceInternal::OutgoingAsyncT<var>>&, const break&, const deletePtr&, const std::optional<explicitPrx>&, const std::optional<casePrx>&, const std::optional<typeofPrx>&, const deletePtr&, const std::optional<explicitPrx>&, std::int32_t, std::int32_t, std::int32_t, const Ice::Context&) const;
        /// \endcond

        /// Obtains the Slice type ID of this interface.
        /// @return The fully-scoped type ID.
        static const char* ice_staticId() noexcept;

        implicitPrx(const implicitPrx& other) noexcept : Ice::ObjectPrx(other) {} // NOLINT(modernize-use-equals-default)

        implicitPrx(implicitPrx&& other) noexcept : Ice::ObjectPrx(std::move(other)) {} // NOLINT(modernize-use-equals-default)

        implicitPrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx(communicator, proxyString) {} // NOLINT(modernize-use-equals-default)

        ~implicitPrx() override;

        implicitPrx& operator=(const implicitPrx& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(rhs);
            }
            return *this;
        }

        implicitPrx& operator=(implicitPrx&& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(std::move(rhs));
            }
            return *this;
        }

        /// \cond INTERNAL
        static implicitPrx _fromReference(IceInternal::ReferencePtr ref) { return implicitPrx(std::move(ref)); }

    protected:
        implicitPrx() = default;

        explicit implicitPrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx(std::move(ref))
        {
        }
        /// \endcond
    };

    namespace System
    {

        class TestPrx : public Ice::Proxy<TestPrx, Ice::ObjectPrx>
        {
        public:

            void op(const Ice::Context& context = Ice::noExplicitContext) const;

            [[nodiscard]] std::future<void> opAsync(const Ice::Context& context = Ice::noExplicitContext) const;

            std::function<void()> // NOLINT(modernize-use-nodiscard)
            opAsync(std::function<void()> response, std::function<void(std::exception_ptr)> ex = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

            /// \cond INTERNAL
            void _iceI_op(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const Ice::Context&) const;
            /// \endcond

            /// Obtains the Slice type ID of this interface.
            /// @return The fully-scoped type ID.
            static const char* ice_staticId() noexcept;

            TestPrx(const TestPrx& other) noexcept : Ice::ObjectPrx(other) {} // NOLINT(modernize-use-equals-default)

            TestPrx(TestPrx&& other) noexcept : Ice::ObjectPrx(std::move(other)) {} // NOLINT(modernize-use-equals-default)

            TestPrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx(communicator, proxyString) {} // NOLINT(modernize-use-equals-default)

            ~TestPrx() override;

            TestPrx& operator=(const TestPrx& rhs) noexcept
            {
                if (this != &rhs)
                {
                    Ice::ObjectPrx::operator=(rhs);
                }
                return *this;
            }

            TestPrx& operator=(TestPrx&& rhs) noexcept
            {
                if (this != &rhs)
                {
                    Ice::ObjectPrx::operator=(std::move(rhs));
                }
                return *this;
            }

            /// \cond INTERNAL
            static TestPrx _fromReference(IceInternal::ReferencePtr ref) { return TestPrx(std::move(ref)); }

        protected:
            TestPrx() = default;

            explicit TestPrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx(std::move(ref))
            {
            }
            /// \endcond
        };
    }
}

namespace System
{

    class TestPrx : public Ice::Proxy<TestPrx, Ice::ObjectPrx>
    {
    public:

        void op(const Ice::Context& context = Ice::noExplicitContext) const;

        [[nodiscard]] std::future<void> opAsync(const Ice::Context& context = Ice::noExplicitContext) const;

        std::function<void()> // NOLINT(modernize-use-nodiscard)
        opAsync(std::function<void()> response, std::function<void(std::exception_ptr)> ex = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// \cond INTERNAL
        void _iceI_op(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const Ice::Context&) const;
        /// \endcond

        /// Obtains the Slice type ID of this interface.
        /// @return The fully-scoped type ID.
        static const char* ice_staticId() noexcept;

        TestPrx(const TestPrx& other) noexcept : Ice::ObjectPrx(other) {} // NOLINT(modernize-use-equals-default)

        TestPrx(TestPrx&& other) noexcept : Ice::ObjectPrx(std::move(other)) {} // NOLINT(modernize-use-equals-default)

        TestPrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx(communicator, proxyString) {} // NOLINT(modernize-use-equals-default)

        ~TestPrx() override;

        TestPrx& operator=(const TestPrx& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(rhs);
            }
            return *this;
        }

        TestPrx& operator=(TestPrx&& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(std::move(rhs));
            }
            return *this;
        }

        /// \cond INTERNAL
        static TestPrx _fromReference(IceInternal::ReferencePtr ref) { return TestPrx(std::move(ref)); }

    protected:
        TestPrx() = default;

        explicit TestPrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx(std::move(ref))
        {
        }
        /// \endcond
    };
}

namespace await
{
    struct break
    {
        std::int32_t while;
        std::string clone;
        std::string equals;
        std::string hashCode;
        std::string constructor;

        /// Obtains a tuple containing all of the struct's data members.
        /// @return The data members in a tuple.
        [[nodiscard]] std::tuple<const std::int32_t&, const std::string&, const std::string&, const std::string&, const std::string&> ice_tuple() const
        {
            return std::tie(while, clone, equals, hashCode, constructor);
        }

        /// Outputs the name and value of each field of this instance to the stream.
        /// @param os The output stream.
        void ice_printFields(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream&, const break&);

    class delete : public Ice::Value
    {
    public:
        /// Default constructor.
        delete() noexcept = default;

        /// One-shot constructor to initialize all data members.
        delete(std::int32_t if, std::optional<::await::casePrx> else, std::int32_t export, std::string clone, std::string equals, std::string hashCode, std::string constructor) noexcept :
            if(if),
            else(std::move(else)),
            export(export),
            clone(std::move(clone)),
            equals(std::move(equals)),
            hashCode(std::move(hashCode)),
            constructor(std::move(constructor))
        {
        }

        /// Obtains the Slice type ID of this value.
        /// @return The fully-scoped type ID.
        static const char* ice_staticId() noexcept;

        [[nodiscard]] const char* ice_id() const noexcept override;

        /// Obtains a tuple containing all of the value's data members.
        /// @return The data members in a tuple.
        [[nodiscard]] std::tuple<const std::int32_t&, const std::optional<::await::casePrx>&, const std::int32_t&, const std::string&, const std::string&, const std::string&, const std::string&> ice_tuple() const
        {
            return std::tie(if, else, export, clone, equals, hashCode, constructor);
        }

        /// Creates a shallow polymorphic copy of this instance.
        /// @return The cloned value.
        [[nodiscard]] deletePtr ice_clone() const { return std::static_pointer_cast<delete>(_iceCloneImpl()); }

        std::int32_t if;
        std::optional<::await::casePrx> else;
        std::int32_t export;
        std::string clone;
        std::string equals;
        std::string hashCode;
        std::string constructor;

        void ice_printFields(std::ostream& os) const override;
        delete(const delete&) = default;

        [[nodiscard]] Ice::ValuePtr _iceCloneImpl() const override;

        void _iceWriteImpl(Ice::OutputStream*) const override;

        void _iceReadImpl(Ice::InputStream*) override;
    };

    class package : public Ice::Value
    {
    public:
        /// Default constructor.
        package() noexcept = default;

        /// One-shot constructor to initialize all data members.
        package(std::optional<::await::break> for, std::optional<::await::var> goto, std::optional<::await::explicitPrx> if, std::optional<::await::while> internal, std::optional<std::string> debugger, std::optional<::await::explicitPrx> null) noexcept :
            for(std::move(for)),
            goto(goto),
            if(std::move(if)),
            internal(std::move(internal)),
            debugger(std::move(debugger)),
            null(std::move(null))
        {
        }

        /// Obtains the Slice type ID of this value.
        /// @return The fully-scoped type ID.
        static const char* ice_staticId() noexcept;

        [[nodiscard]] const char* ice_id() const noexcept override;

        /// Obtains a tuple containing all of the value's data members.
        /// @return The data members in a tuple.
        [[nodiscard]] std::tuple<const std::optional<::await::break>&, const std::optional<::await::var>&, const std::optional<::await::explicitPrx>&, const std::optional<::await::while>&, const std::optional<std::string>&, const std::optional<::await::explicitPrx>&> ice_tuple() const
        {
            return std::tie(for, goto, if, internal, debugger, null);
        }

        /// Creates a shallow polymorphic copy of this instance.
        /// @return The cloned value.
        [[nodiscard]] packagePtr ice_clone() const { return std::static_pointer_cast<package>(_iceCloneImpl()); }

        std::optional<::await::break> for;
        std::optional<::await::var> goto;
        std::optional<::await::explicitPrx> if;
        std::optional<::await::while> internal;
        std::optional<std::string> debugger;
        std::optional<::await::explicitPrx> null;

        void ice_printFields(std::ostream& os) const override;
        package(const package&) = default;

        [[nodiscard]] Ice::ValuePtr _iceCloneImpl() const override;

        void _iceWriteImpl(Ice::OutputStream*) const override;

        void _iceReadImpl(Ice::InputStream*) override;
    };

    class fixed : public Ice::UserException
    {
    public:
        /// Default constructor.
        fixed() noexcept = default;

        /// One-shot constructor to initialize all data members.
        fixed(std::int32_t for) noexcept :
            for(for)
        {
        }

        /// Copy constructor.
        fixed(const fixed&) noexcept = default;

        /// Obtains a tuple containing all of the exception's data members.
        /// @return The data members in a tuple.
        [[nodiscard]] std::tuple<const std::int32_t&> ice_tuple() const
        {
            return std::tie(for);
        }


        void ice_printFields(std::ostream& os) const override;
        /// Obtains the Slice type ID of this exception.
        /// @return The fully-scoped type ID.
        static const char* ice_staticId() noexcept;

        [[nodiscard]] const char* ice_id() const noexcept override;

        void ice_throw() const override;

        std::int32_t for;

    protected:
        void _writeImpl(Ice::OutputStream*) const override;

        void _readImpl(Ice::InputStream*) override;
    };

    class foreach : public fixed
    {
    public:
        /// Default constructor.
        foreach() noexcept = default;

        /// One-shot constructor to initialize all data members.
        foreach(std::int32_t for, std::int32_t goto, std::int32_t if) noexcept :
            fixed(for),
            goto(goto),
            if(if)
        {
        }

        /// Copy constructor.
        foreach(const foreach&) noexcept = default;

        /// Obtains a tuple containing all of the exception's data members.
        /// @return The data members in a tuple.
        [[nodiscard]] std::tuple<const std::int32_t&, const std::int32_t&, const std::int32_t&> ice_tuple() const
        {
            return std::tie(for, goto, if);
        }


        void ice_printFields(std::ostream& os) const override;
        /// Obtains the Slice type ID of this exception.
        /// @return The fully-scoped type ID.
        static const char* ice_staticId() noexcept;

        [[nodiscard]] const char* ice_id() const noexcept override;

        void ice_throw() const override;

        std::int32_t goto;
        std::int32_t if;

    protected:
        void _writeImpl(Ice::OutputStream*) const override;

        void _readImpl(Ice::InputStream*) override;
    };

    class BaseMethods : public Ice::UserException
    {
    public:
        /// Default constructor.
        BaseMethods() noexcept = default;

        /// One-shot constructor to initialize all data members.
        BaseMethods(std::int32_t Data, std::int32_t HelpLink, std::int32_t InnerException, std::int32_t Message, std::int32_t Source, std::int32_t StackTrace, std::int32_t TargetSite, std::int32_t HResult, std::int32_t Equals, std::int32_t GetBaseException, std::int32_t GetHashCode, std::int32_t GetObjectData, std::int32_t GetType, std::int32_t ReferenceEquals, std::int32_t ToString) noexcept :
            Data(Data),
            HelpLink(HelpLink),
            InnerException(InnerException),
            Message(Message),
            Source(Source),
            StackTrace(StackTrace),
            TargetSite(TargetSite),
            HResult(HResult),
            Equals(Equals),
            GetBaseException(GetBaseException),
            GetHashCode(GetHashCode),
            GetObjectData(GetObjectData),
            GetType(GetType),
            ReferenceEquals(ReferenceEquals),
            ToString(ToString)
        {
        }

        /// Copy constructor.
        BaseMethods(const BaseMethods&) noexcept = default;

        /// Obtains a tuple containing all of the exception's data members.
        /// @return The data members in a tuple.
        [[nodiscard]] std::tuple<const std::int32_t&, const std::int32_t&, const std::int32_t&, const std::int32_t&, const std::int32_t&, const std::int32_t&, const std::int32_t&, const std::int32_t&, const std::int32_t&, const std::int32_t&, const std::int32_t&, const std::int32_t&, const std::int32_t&, const std::int32_t&, const std::int32_t&> ice_tuple() const
        {
            return std::tie(Data, HelpLink, InnerException, Message, Source, StackTrace, TargetSite, HResult, Equals, GetBaseException, GetHashCode, GetObjectData, GetType, ReferenceEquals, ToString);
        }


        void ice_printFields(std::ostream& os) const override;
        /// Obtains the Slice type ID of this exception.
        /// @return The fully-scoped type ID.
        static const char* ice_staticId() noexcept;

        [[nodiscard]] const char* ice_id() const noexcept override;

        void ice_throw() const override;

        std::int32_t Data;
        std::int32_t HelpLink;
        std::int32_t InnerException;
        std::int32_t Message;
        std::int32_t Source;
        std::int32_t StackTrace;
        std::int32_t TargetSite;
        std::int32_t HResult;
        std::int32_t Equals;
        std::int32_t GetBaseException;
        std::int32_t GetHashCode;
        std::int32_t GetObjectData;
        std::int32_t GetType;
        std::int32_t ReferenceEquals;
        std::int32_t ToString;

    protected:
        void _writeImpl(Ice::OutputStream*) const override;

        void _readImpl(Ice::InputStream*) override;
    };

    using Ice::Tuple::operator<;
    using Ice::Tuple::operator<=;
    using Ice::Tuple::operator>;
    using Ice::Tuple::operator>=;
    using Ice::Tuple::operator==;
    using Ice::Tuple::operator!=;
}

namespace await
{
    class case : public virtual Ice::Object
    {
    public:
        using ProxyType = casePrx;

        /// Obtains a list of the Slice type IDs representing the interfaces supported by this object.
        /// @param current The Current object for the invocation.
        /// @return A list of fully-scoped type IDs.
        [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

        /// Obtains a Slice type ID representing the most-derived interface supported by this object.
        /// @param current The Current object for the invocation.
        /// @return A fully-scoped type ID.
        [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

        /// Obtains the Slice type ID corresponding to this interface.
        /// @return A fully-scoped type ID.
        static const char* ice_staticId() noexcept;

        virtual void catchAsync(std::int32_t checked, std::function<void(std::int32_t continue)> response, std::function<void(std::exception_ptr)> exception, const Ice::Current& current) = 0;

        /// \cond INTERNAL
        void _iceD_catch(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
        /// \endcond

        void dispatch(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>) override;
    };

    using casePtr = std::shared_ptr<case>;

    class typeof : public virtual Ice::Object
    {
    public:
        using ProxyType = typeofPrx;

        /// Obtains a list of the Slice type IDs representing the interfaces supported by this object.
        /// @param current The Current object for the invocation.
        /// @return A list of fully-scoped type IDs.
        [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

        /// Obtains a Slice type ID representing the most-derived interface supported by this object.
        /// @param current The Current object for the invocation.
        /// @return A fully-scoped type ID.
        [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

        /// Obtains the Slice type ID corresponding to this interface.
        /// @return A fully-scoped type ID.
        static const char* ice_staticId() noexcept;

        virtual void default(const Ice::Current& current) = 0;

        /// \cond INTERNAL
        void _iceD_default(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
        /// \endcond

        void dispatch(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>) override;
    };

    using typeofPtr = std::shared_ptr<typeof>;

    class explicit : public virtual typeof,
                     public virtual case
    {
    public:
        using ProxyType = explicitPrx;

        /// Obtains a list of the Slice type IDs representing the interfaces supported by this object.
        /// @param current The Current object for the invocation.
        /// @return A list of fully-scoped type IDs.
        [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

        /// Obtains a Slice type ID representing the most-derived interface supported by this object.
        /// @param current The Current object for the invocation.
        /// @return A fully-scoped type ID.
        [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

        /// Obtains the Slice type ID corresponding to this interface.
        /// @return A fully-scoped type ID.
        static const char* ice_staticId() noexcept;

        void dispatch(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>) override;
    };

    using explicitPtr = std::shared_ptr<explicit>;

    class optionalParams : public virtual Ice::Object
    {
    public:
        using ProxyType = optionalParamsPrx;

        /// Obtains a list of the Slice type IDs representing the interfaces supported by this object.
        /// @param current The Current object for the invocation.
        /// @return A list of fully-scoped type IDs.
        [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

        /// Obtains a Slice type ID representing the most-derived interface supported by this object.
        /// @param current The Current object for the invocation.
        /// @return A fully-scoped type ID.
        [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

        /// Obtains the Slice type ID corresponding to this interface.
        /// @return A fully-scoped type ID.
        static const char* ice_staticId() noexcept;

        virtual std::optional<break> for(std::optional<var> goto, std::optional<explicitPrx> if, std::optional<while> internal, std::optional<std::string> namespace, std::optional<explicitPrx> null, const Ice::Current& current) = 0;

        /// \cond INTERNAL
        void _iceD_for(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
        /// \endcond

        virtual void continueAsync(std::optional<var> goto, std::optional<explicitPrx> if, std::optional<while> internal, std::optional<std::string> namespace, std::optional<explicitPrx> null, std::function<void(const std::optional<break>& returnValue)> response, std::function<void(std::exception_ptr)> exception, const Ice::Current& current) = 0;

        /// \cond INTERNAL
        void _iceD_continue(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
        /// \endcond

        virtual std::optional<break> in(std::optional<var>& goto, std::optional<explicitPrx>& if, std::optional<while>& internal, std::optional<std::string>& namespace, std::optional<explicitPrx>& null, const Ice::Current& current) = 0;

        /// \cond INTERNAL
        void _iceD_in(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
        /// \endcond

        virtual void foreachAsync(std::function<void(const std::optional<break>& returnValue, std::optional<var> goto, const std::optional<explicitPrx>& if, const std::optional<while>& internal, std::optional<std::string_view> namespace, const std::optional<explicitPrx>& null)> response, std::function<void(std::exception_ptr)> exception, const Ice::Current& current) = 0;

        /// \cond INTERNAL
        void _iceD_foreach(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
        /// \endcond

        void dispatch(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>) override;
    };

    using optionalParamsPtr = std::shared_ptr<optionalParams>;

    class implicit : public virtual Ice::Object
    {
    public:
        using ProxyType = implicitPrx;

        /// Obtains a list of the Slice type IDs representing the interfaces supported by this object.
        /// @param current The Current object for the invocation.
        /// @return A list of fully-scoped type IDs.
        [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

        /// Obtains a Slice type ID representing the most-derived interface supported by this object.
        /// @param current The Current object for the invocation.
        /// @return A fully-scoped type ID.
        [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

        /// Obtains the Slice type ID corresponding to this interface.
        /// @return A fully-scoped type ID.
        static const char* ice_staticId() noexcept;

        virtual var in(break internal, deletePtr is, std::optional<explicitPrx> lock, std::optional<casePrx> namespace, std::optional<typeofPrx> new, deletePtr null, std::optional<explicitPrx> operator, std::int32_t override, std::int32_t params, std::int32_t private, const Ice::Current& current) = 0;

        /// \cond INTERNAL
        void _iceD_in(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
        /// \endcond

        void dispatch(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>) override;
    };

    using implicitPtr = std::shared_ptr<implicit>;

    namespace System
    {

        class Test : public virtual Ice::Object
        {
        public:
            using ProxyType = TestPrx;

            /// Obtains a list of the Slice type IDs representing the interfaces supported by this object.
            /// @param current The Current object for the invocation.
            /// @return A list of fully-scoped type IDs.
            [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

            /// Obtains a Slice type ID representing the most-derived interface supported by this object.
            /// @param current The Current object for the invocation.
            /// @return A fully-scoped type ID.
            [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

            /// Obtains the Slice type ID corresponding to this interface.
            /// @return A fully-scoped type ID.
            static const char* ice_staticId() noexcept;

            virtual void op(const Ice::Current& current) = 0;

            /// \cond INTERNAL
            void _iceD_op(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
            /// \endcond

            void dispatch(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>) override;
        };

        using TestPtr = std::shared_ptr<Test>;
    }
}

namespace System
{

    class Test : public virtual Ice::Object
    {
    public:
        using ProxyType = TestPrx;

        /// Obtains a list of the Slice type IDs representing the interfaces supported by this object.
        /// @param current The Current object for the invocation.
        /// @return A list of fully-scoped type IDs.
        [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

        /// Obtains a Slice type ID representing the most-derived interface supported by this object.
        /// @param current The Current object for the invocation.
        /// @return A fully-scoped type ID.
        [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

        /// Obtains the Slice type ID corresponding to this interface.
        /// @return A fully-scoped type ID.
        static const char* ice_staticId() noexcept;

        virtual void op(const Ice::Current& current) = 0;

        /// \cond INTERNAL
        void _iceD_op(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
        /// \endcond

        void dispatch(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>) override;
    };

    using TestPtr = std::shared_ptr<Test>;
}

/// \cond STREAM
namespace Ice
{
    template<>
    struct StreamableTraits< ::await::var>
    {
        static const StreamHelperCategory helper = StreamHelperCategoryEnum;
        static const int minValue = 0;
        static const int maxValue = 0;
        static const int minWireSize = 1;
        static const bool fixedLength = false;
    };

    template<>
    struct StreamableTraits<::await::break>
    {
        static const StreamHelperCategory helper = StreamHelperCategoryStruct;
        static const int minWireSize = 8;
        static const bool fixedLength = false;
    };
    
    template<>
    struct StreamReader<::await::break>
    {
        static void read(InputStream* istr, ::await::break& v)
        {
            istr->readAll(v.while, v.clone, v.equals, v.hashCode, v.constructor);
        }
    };
}
/// \endcond

#include <Ice/PopDisableWarnings.h>
#endif
