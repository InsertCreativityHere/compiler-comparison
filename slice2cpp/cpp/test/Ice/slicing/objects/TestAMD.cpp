// Copyright (c) ZeroC, Inc.
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file 'TestAMD.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>

#define ICE_BUILDING_GENERATED_CODE
#include "TestAMD.h"
#include <Ice/AsyncResponseHandler.h>
#include <Ice/FactoryTable.h>
#include <Ice/OutgoingAsync.h>
#include <algorithm>
#include <array>

#if defined(_MSC_VER)
#   pragma warning(disable : 4458) // declaration of ... hides class member
#   pragma warning(disable : 4996) // ... was declared deprecated
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#   pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#   pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace
{
    const IceInternal::FactoryTableInit iceC_factoryTableInit;
    const IceInternal::DefaultValueFactoryInit<::Test::SBase> iceC_Test_SBase_init("::Test::SBase");
    const IceInternal::DefaultValueFactoryInit<::Test::SBSKnownDerived> iceC_Test_SBSKnownDerived_init("::Test::SBSKnownDerived");
    const IceInternal::DefaultValueFactoryInit<::Test::B> iceC_Test_B_init("::Test::B");
    const IceInternal::DefaultValueFactoryInit<::Test::D1> iceC_Test_D1_init("::Test::D1");
    const IceInternal::DefaultValueFactoryInit<::Test::SS1> iceC_Test_SS1_init("::Test::SS1");
    const IceInternal::DefaultValueFactoryInit<::Test::SS2> iceC_Test_SS2_init("::Test::SS2");
    const IceInternal::DefaultUserExceptionFactoryInit<::Test::BaseException> iceC_Test_BaseException_init("::Test::BaseException");
    const IceInternal::DefaultUserExceptionFactoryInit<::Test::DerivedException> iceC_Test_DerivedException_init("::Test::DerivedException");
    const IceInternal::DefaultValueFactoryInit<::Test::PBase> iceC_Test_PBase_init("::Test::PBase");
    const IceInternal::DefaultValueFactoryInit<::Test::Preserved> iceC_Test_Preserved_init("::Test::Preserved");
    const IceInternal::DefaultValueFactoryInit<::Test::PDerived> iceC_Test_PDerived_init("::Test::PDerived");
    const IceInternal::DefaultValueFactoryInit<::Test::PNode> iceC_Test_PNode_init("::Test::PNode");
    const IceInternal::DefaultValueFactoryInit<::Test::Hidden> iceC_Test_Hidden_init("::Test::Hidden");
    const IceInternal::DefaultValueFactoryInit<::Test::Forward> iceC_Test_Forward_init("::Test::Forward");
}

Ice::ValuePtr
Test::TestIntfPrx::SBaseAsObject(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<Ice::ValuePtr>(true, this, &TestIntfPrx::_iceI_SBaseAsObject, context).get();
}

std::future<Ice::ValuePtr>
Test::TestIntfPrx::SBaseAsObjectAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<Ice::ValuePtr>(false, this, &TestIntfPrx::_iceI_SBaseAsObject, context);
}

std::function<void()>
Test::TestIntfPrx::SBaseAsObjectAsync(std::function<void(Ice::ValuePtr)> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<Ice::ValuePtr>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_SBaseAsObject, context);
}

void
Test::TestIntfPrx::_iceI_SBaseAsObject(const std::shared_ptr<IceInternal::OutgoingAsyncT<Ice::ValuePtr>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "SBaseAsObject";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            Ice::ValuePtr ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

::Test::SBasePtr
Test::TestIntfPrx::SBaseAsSBase(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<SBasePtr>(true, this, &TestIntfPrx::_iceI_SBaseAsSBase, context).get();
}

std::future<::Test::SBasePtr>
Test::TestIntfPrx::SBaseAsSBaseAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<SBasePtr>(false, this, &TestIntfPrx::_iceI_SBaseAsSBase, context);
}

std::function<void()>
Test::TestIntfPrx::SBaseAsSBaseAsync(std::function<void(::Test::SBasePtr)> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<SBasePtr>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_SBaseAsSBase, context);
}

void
Test::TestIntfPrx::_iceI_SBaseAsSBase(const std::shared_ptr<IceInternal::OutgoingAsyncT<SBasePtr>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "SBaseAsSBase";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            SBasePtr ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

::Test::SBasePtr
Test::TestIntfPrx::SBSKnownDerivedAsSBase(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<SBasePtr>(true, this, &TestIntfPrx::_iceI_SBSKnownDerivedAsSBase, context).get();
}

std::future<::Test::SBasePtr>
Test::TestIntfPrx::SBSKnownDerivedAsSBaseAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<SBasePtr>(false, this, &TestIntfPrx::_iceI_SBSKnownDerivedAsSBase, context);
}

std::function<void()>
Test::TestIntfPrx::SBSKnownDerivedAsSBaseAsync(std::function<void(::Test::SBasePtr)> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<SBasePtr>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_SBSKnownDerivedAsSBase, context);
}

void
Test::TestIntfPrx::_iceI_SBSKnownDerivedAsSBase(const std::shared_ptr<IceInternal::OutgoingAsyncT<SBasePtr>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "SBSKnownDerivedAsSBase";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            SBasePtr ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

::Test::SBSKnownDerivedPtr
Test::TestIntfPrx::SBSKnownDerivedAsSBSKnownDerived(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<SBSKnownDerivedPtr>(true, this, &TestIntfPrx::_iceI_SBSKnownDerivedAsSBSKnownDerived, context).get();
}

std::future<::Test::SBSKnownDerivedPtr>
Test::TestIntfPrx::SBSKnownDerivedAsSBSKnownDerivedAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<SBSKnownDerivedPtr>(false, this, &TestIntfPrx::_iceI_SBSKnownDerivedAsSBSKnownDerived, context);
}

std::function<void()>
Test::TestIntfPrx::SBSKnownDerivedAsSBSKnownDerivedAsync(std::function<void(::Test::SBSKnownDerivedPtr)> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<SBSKnownDerivedPtr>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_SBSKnownDerivedAsSBSKnownDerived, context);
}

void
Test::TestIntfPrx::_iceI_SBSKnownDerivedAsSBSKnownDerived(const std::shared_ptr<IceInternal::OutgoingAsyncT<SBSKnownDerivedPtr>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "SBSKnownDerivedAsSBSKnownDerived";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            SBSKnownDerivedPtr ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

::Test::SBasePtr
Test::TestIntfPrx::SBSUnknownDerivedAsSBase(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<SBasePtr>(true, this, &TestIntfPrx::_iceI_SBSUnknownDerivedAsSBase, context).get();
}

std::future<::Test::SBasePtr>
Test::TestIntfPrx::SBSUnknownDerivedAsSBaseAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<SBasePtr>(false, this, &TestIntfPrx::_iceI_SBSUnknownDerivedAsSBase, context);
}

std::function<void()>
Test::TestIntfPrx::SBSUnknownDerivedAsSBaseAsync(std::function<void(::Test::SBasePtr)> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<SBasePtr>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_SBSUnknownDerivedAsSBase, context);
}

void
Test::TestIntfPrx::_iceI_SBSUnknownDerivedAsSBase(const std::shared_ptr<IceInternal::OutgoingAsyncT<SBasePtr>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "SBSUnknownDerivedAsSBase";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            SBasePtr ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

::Test::SBasePtr
Test::TestIntfPrx::SBSUnknownDerivedAsSBaseCompact(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<SBasePtr>(true, this, &TestIntfPrx::_iceI_SBSUnknownDerivedAsSBaseCompact, context).get();
}

std::future<::Test::SBasePtr>
Test::TestIntfPrx::SBSUnknownDerivedAsSBaseCompactAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<SBasePtr>(false, this, &TestIntfPrx::_iceI_SBSUnknownDerivedAsSBaseCompact, context);
}

std::function<void()>
Test::TestIntfPrx::SBSUnknownDerivedAsSBaseCompactAsync(std::function<void(::Test::SBasePtr)> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<SBasePtr>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_SBSUnknownDerivedAsSBaseCompact, context);
}

void
Test::TestIntfPrx::_iceI_SBSUnknownDerivedAsSBaseCompact(const std::shared_ptr<IceInternal::OutgoingAsyncT<SBasePtr>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "SBSUnknownDerivedAsSBaseCompact";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::CompactFormat, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            SBasePtr ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

Ice::ValuePtr
Test::TestIntfPrx::SUnknownAsObject(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<Ice::ValuePtr>(true, this, &TestIntfPrx::_iceI_SUnknownAsObject, context).get();
}

std::future<Ice::ValuePtr>
Test::TestIntfPrx::SUnknownAsObjectAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<Ice::ValuePtr>(false, this, &TestIntfPrx::_iceI_SUnknownAsObject, context);
}

std::function<void()>
Test::TestIntfPrx::SUnknownAsObjectAsync(std::function<void(Ice::ValuePtr)> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<Ice::ValuePtr>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_SUnknownAsObject, context);
}

void
Test::TestIntfPrx::_iceI_SUnknownAsObject(const std::shared_ptr<IceInternal::OutgoingAsyncT<Ice::ValuePtr>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "SUnknownAsObject";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            Ice::ValuePtr ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

void
Test::TestIntfPrx::checkSUnknown(const Ice::ValuePtr& iceP_o, const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_checkSUnknown, iceP_o, context).get();
}

std::future<void>
Test::TestIntfPrx::checkSUnknownAsync(const Ice::ValuePtr& iceP_o, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &TestIntfPrx::_iceI_checkSUnknown, iceP_o, context);
}

std::function<void()>
Test::TestIntfPrx::checkSUnknownAsync(const Ice::ValuePtr& iceP_o, std::function<void()> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_checkSUnknown, iceP_o, context);
}

void
Test::TestIntfPrx::_iceI_checkSUnknown(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, const Ice::ValuePtr& iceP_o, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "checkSUnknown";

    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_o);
            ostr->writePendingValues();
        },
        nullptr);
}

::Test::BPtr
Test::TestIntfPrx::oneElementCycle(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<BPtr>(true, this, &TestIntfPrx::_iceI_oneElementCycle, context).get();
}

std::future<::Test::BPtr>
Test::TestIntfPrx::oneElementCycleAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<BPtr>(false, this, &TestIntfPrx::_iceI_oneElementCycle, context);
}

std::function<void()>
Test::TestIntfPrx::oneElementCycleAsync(std::function<void(::Test::BPtr)> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<BPtr>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_oneElementCycle, context);
}

void
Test::TestIntfPrx::_iceI_oneElementCycle(const std::shared_ptr<IceInternal::OutgoingAsyncT<BPtr>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "oneElementCycle";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            BPtr ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

::Test::BPtr
Test::TestIntfPrx::twoElementCycle(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<BPtr>(true, this, &TestIntfPrx::_iceI_twoElementCycle, context).get();
}

std::future<::Test::BPtr>
Test::TestIntfPrx::twoElementCycleAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<BPtr>(false, this, &TestIntfPrx::_iceI_twoElementCycle, context);
}

std::function<void()>
Test::TestIntfPrx::twoElementCycleAsync(std::function<void(::Test::BPtr)> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<BPtr>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_twoElementCycle, context);
}

void
Test::TestIntfPrx::_iceI_twoElementCycle(const std::shared_ptr<IceInternal::OutgoingAsyncT<BPtr>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "twoElementCycle";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            BPtr ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

::Test::BPtr
Test::TestIntfPrx::D1AsB(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<BPtr>(true, this, &TestIntfPrx::_iceI_D1AsB, context).get();
}

std::future<::Test::BPtr>
Test::TestIntfPrx::D1AsBAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<BPtr>(false, this, &TestIntfPrx::_iceI_D1AsB, context);
}

std::function<void()>
Test::TestIntfPrx::D1AsBAsync(std::function<void(::Test::BPtr)> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<BPtr>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_D1AsB, context);
}

void
Test::TestIntfPrx::_iceI_D1AsB(const std::shared_ptr<IceInternal::OutgoingAsyncT<BPtr>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "D1AsB";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            BPtr ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

::Test::D1Ptr
Test::TestIntfPrx::D1AsD1(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<D1Ptr>(true, this, &TestIntfPrx::_iceI_D1AsD1, context).get();
}

std::future<::Test::D1Ptr>
Test::TestIntfPrx::D1AsD1Async(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<D1Ptr>(false, this, &TestIntfPrx::_iceI_D1AsD1, context);
}

std::function<void()>
Test::TestIntfPrx::D1AsD1Async(std::function<void(::Test::D1Ptr)> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<D1Ptr>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_D1AsD1, context);
}

void
Test::TestIntfPrx::_iceI_D1AsD1(const std::shared_ptr<IceInternal::OutgoingAsyncT<D1Ptr>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "D1AsD1";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            D1Ptr ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

::Test::BPtr
Test::TestIntfPrx::D2AsB(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<BPtr>(true, this, &TestIntfPrx::_iceI_D2AsB, context).get();
}

std::future<::Test::BPtr>
Test::TestIntfPrx::D2AsBAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<BPtr>(false, this, &TestIntfPrx::_iceI_D2AsB, context);
}

std::function<void()>
Test::TestIntfPrx::D2AsBAsync(std::function<void(::Test::BPtr)> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<BPtr>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_D2AsB, context);
}

void
Test::TestIntfPrx::_iceI_D2AsB(const std::shared_ptr<IceInternal::OutgoingAsyncT<BPtr>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "D2AsB";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            BPtr ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

void
Test::TestIntfPrx::paramTest1(BPtr& iceP_p1, BPtr& iceP_p2, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<BPtr, BPtr>>(true, this, &TestIntfPrx::_iceI_paramTest1, context).get();
    iceP_p1 = std::move(std::get<0>(result));
    iceP_p2 = std::move(std::get<1>(result));
}

std::future<std::tuple<::Test::BPtr, ::Test::BPtr>>
Test::TestIntfPrx::paramTest1Async(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<BPtr, BPtr>>(false, this, &TestIntfPrx::_iceI_paramTest1, context);
}

std::function<void()>
Test::TestIntfPrx::paramTest1Async(std::function<void(::Test::BPtr, ::Test::BPtr)> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<BPtr, BPtr>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<BPtr, BPtr>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_paramTest1, context);
}

void
Test::TestIntfPrx::_iceI_paramTest1(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<BPtr, BPtr>>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "paramTest1";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<BPtr, BPtr> v;
            istr->readAll(std::get<0>(v), std::get<1>(v));
            istr->readPendingValues();
            return v;
        });
}

void
Test::TestIntfPrx::paramTest2(BPtr& iceP_p2, BPtr& iceP_p1, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<BPtr, BPtr>>(true, this, &TestIntfPrx::_iceI_paramTest2, context).get();
    iceP_p2 = std::move(std::get<0>(result));
    iceP_p1 = std::move(std::get<1>(result));
}

std::future<std::tuple<::Test::BPtr, ::Test::BPtr>>
Test::TestIntfPrx::paramTest2Async(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<BPtr, BPtr>>(false, this, &TestIntfPrx::_iceI_paramTest2, context);
}

std::function<void()>
Test::TestIntfPrx::paramTest2Async(std::function<void(::Test::BPtr, ::Test::BPtr)> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<BPtr, BPtr>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<BPtr, BPtr>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_paramTest2, context);
}

void
Test::TestIntfPrx::_iceI_paramTest2(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<BPtr, BPtr>>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "paramTest2";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<BPtr, BPtr> v;
            istr->readAll(std::get<0>(v), std::get<1>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::BPtr
Test::TestIntfPrx::paramTest3(BPtr& iceP_p1, BPtr& iceP_p2, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<BPtr, BPtr, BPtr>>(true, this, &TestIntfPrx::_iceI_paramTest3, context).get();
    iceP_p1 = std::move(std::get<1>(result));
    iceP_p2 = std::move(std::get<2>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::BPtr, ::Test::BPtr, ::Test::BPtr>>
Test::TestIntfPrx::paramTest3Async(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<BPtr, BPtr, BPtr>>(false, this, &TestIntfPrx::_iceI_paramTest3, context);
}

std::function<void()>
Test::TestIntfPrx::paramTest3Async(std::function<void(::Test::BPtr, ::Test::BPtr, ::Test::BPtr)> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<BPtr, BPtr, BPtr>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<BPtr, BPtr, BPtr>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_paramTest3, context);
}

void
Test::TestIntfPrx::_iceI_paramTest3(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<BPtr, BPtr, BPtr>>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "paramTest3";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<BPtr, BPtr, BPtr> v;
            istr->readAll(std::get<1>(v), std::get<2>(v), std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::BPtr
Test::TestIntfPrx::paramTest4(BPtr& iceP_p, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<BPtr, BPtr>>(true, this, &TestIntfPrx::_iceI_paramTest4, context).get();
    iceP_p = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::BPtr, ::Test::BPtr>>
Test::TestIntfPrx::paramTest4Async(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<BPtr, BPtr>>(false, this, &TestIntfPrx::_iceI_paramTest4, context);
}

std::function<void()>
Test::TestIntfPrx::paramTest4Async(std::function<void(::Test::BPtr, ::Test::BPtr)> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<BPtr, BPtr>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<BPtr, BPtr>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_paramTest4, context);
}

void
Test::TestIntfPrx::_iceI_paramTest4(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<BPtr, BPtr>>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "paramTest4";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<BPtr, BPtr> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::BPtr
Test::TestIntfPrx::returnTest1(BPtr& iceP_p1, BPtr& iceP_p2, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<BPtr, BPtr, BPtr>>(true, this, &TestIntfPrx::_iceI_returnTest1, context).get();
    iceP_p1 = std::move(std::get<1>(result));
    iceP_p2 = std::move(std::get<2>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::BPtr, ::Test::BPtr, ::Test::BPtr>>
Test::TestIntfPrx::returnTest1Async(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<BPtr, BPtr, BPtr>>(false, this, &TestIntfPrx::_iceI_returnTest1, context);
}

std::function<void()>
Test::TestIntfPrx::returnTest1Async(std::function<void(::Test::BPtr, ::Test::BPtr, ::Test::BPtr)> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<BPtr, BPtr, BPtr>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<BPtr, BPtr, BPtr>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_returnTest1, context);
}

void
Test::TestIntfPrx::_iceI_returnTest1(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<BPtr, BPtr, BPtr>>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "returnTest1";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<BPtr, BPtr, BPtr> v;
            istr->readAll(std::get<1>(v), std::get<2>(v), std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::BPtr
Test::TestIntfPrx::returnTest2(BPtr& iceP_p2, BPtr& iceP_p1, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<BPtr, BPtr, BPtr>>(true, this, &TestIntfPrx::_iceI_returnTest2, context).get();
    iceP_p2 = std::move(std::get<1>(result));
    iceP_p1 = std::move(std::get<2>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::BPtr, ::Test::BPtr, ::Test::BPtr>>
Test::TestIntfPrx::returnTest2Async(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<BPtr, BPtr, BPtr>>(false, this, &TestIntfPrx::_iceI_returnTest2, context);
}

std::function<void()>
Test::TestIntfPrx::returnTest2Async(std::function<void(::Test::BPtr, ::Test::BPtr, ::Test::BPtr)> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<BPtr, BPtr, BPtr>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<BPtr, BPtr, BPtr>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_returnTest2, context);
}

void
Test::TestIntfPrx::_iceI_returnTest2(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<BPtr, BPtr, BPtr>>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "returnTest2";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<BPtr, BPtr, BPtr> v;
            istr->readAll(std::get<1>(v), std::get<2>(v), std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::BPtr
Test::TestIntfPrx::returnTest3(const BPtr& iceP_p1, const BPtr& iceP_p2, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<BPtr>(true, this, &TestIntfPrx::_iceI_returnTest3, iceP_p1, iceP_p2, context).get();
}

std::future<::Test::BPtr>
Test::TestIntfPrx::returnTest3Async(const BPtr& iceP_p1, const BPtr& iceP_p2, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<BPtr>(false, this, &TestIntfPrx::_iceI_returnTest3, iceP_p1, iceP_p2, context);
}

std::function<void()>
Test::TestIntfPrx::returnTest3Async(const BPtr& iceP_p1, const BPtr& iceP_p2, std::function<void(::Test::BPtr)> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<BPtr>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_returnTest3, iceP_p1, iceP_p2, context);
}

void
Test::TestIntfPrx::_iceI_returnTest3(const std::shared_ptr<IceInternal::OutgoingAsyncT<BPtr>>& outAsync, const BPtr& iceP_p1, const BPtr& iceP_p2, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "returnTest3";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
            ostr->writePendingValues();
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            BPtr ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

::Test::SS3
Test::TestIntfPrx::sequenceTest(const SS1Ptr& iceP_p1, const SS2Ptr& iceP_p2, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<SS3>(true, this, &TestIntfPrx::_iceI_sequenceTest, iceP_p1, iceP_p2, context).get();
}

std::future<::Test::SS3>
Test::TestIntfPrx::sequenceTestAsync(const SS1Ptr& iceP_p1, const SS2Ptr& iceP_p2, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<SS3>(false, this, &TestIntfPrx::_iceI_sequenceTest, iceP_p1, iceP_p2, context);
}

std::function<void()>
Test::TestIntfPrx::sequenceTestAsync(const SS1Ptr& iceP_p1, const SS2Ptr& iceP_p2, std::function<void(::Test::SS3)> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<SS3>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_sequenceTest, iceP_p1, iceP_p2, context);
}

void
Test::TestIntfPrx::_iceI_sequenceTest(const std::shared_ptr<IceInternal::OutgoingAsyncT<SS3>>& outAsync, const SS1Ptr& iceP_p1, const SS2Ptr& iceP_p2, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "sequenceTest";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
            ostr->writePendingValues();
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            SS3 ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

::Test::BDict
Test::TestIntfPrx::dictionaryTest(const BDict& iceP_bin, BDict& iceP_bout, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<BDict, BDict>>(true, this, &TestIntfPrx::_iceI_dictionaryTest, iceP_bin, context).get();
    iceP_bout = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::BDict, ::Test::BDict>>
Test::TestIntfPrx::dictionaryTestAsync(const BDict& iceP_bin, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<BDict, BDict>>(false, this, &TestIntfPrx::_iceI_dictionaryTest, iceP_bin, context);
}

std::function<void()>
Test::TestIntfPrx::dictionaryTestAsync(const BDict& iceP_bin, std::function<void(::Test::BDict, ::Test::BDict)> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<BDict, BDict>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<BDict, BDict>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_dictionaryTest, iceP_bin, context);
}

void
Test::TestIntfPrx::_iceI_dictionaryTest(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<BDict, BDict>>>& outAsync, const BDict& iceP_bin, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "dictionaryTest";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_bin);
            ostr->writePendingValues();
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<BDict, BDict> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::PBasePtr
Test::TestIntfPrx::exchangePBase(const PBasePtr& iceP_pb, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<PBasePtr>(true, this, &TestIntfPrx::_iceI_exchangePBase, iceP_pb, context).get();
}

std::future<::Test::PBasePtr>
Test::TestIntfPrx::exchangePBaseAsync(const PBasePtr& iceP_pb, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<PBasePtr>(false, this, &TestIntfPrx::_iceI_exchangePBase, iceP_pb, context);
}

std::function<void()>
Test::TestIntfPrx::exchangePBaseAsync(const PBasePtr& iceP_pb, std::function<void(::Test::PBasePtr)> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<PBasePtr>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_exchangePBase, iceP_pb, context);
}

void
Test::TestIntfPrx::_iceI_exchangePBase(const std::shared_ptr<IceInternal::OutgoingAsyncT<PBasePtr>>& outAsync, const PBasePtr& iceP_pb, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "exchangePBase";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_pb);
            ostr->writePendingValues();
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            PBasePtr ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

::Test::PreservedPtr
Test::TestIntfPrx::PBSUnknownAsPreserved(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<PreservedPtr>(true, this, &TestIntfPrx::_iceI_PBSUnknownAsPreserved, context).get();
}

std::future<::Test::PreservedPtr>
Test::TestIntfPrx::PBSUnknownAsPreservedAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<PreservedPtr>(false, this, &TestIntfPrx::_iceI_PBSUnknownAsPreserved, context);
}

std::function<void()>
Test::TestIntfPrx::PBSUnknownAsPreservedAsync(std::function<void(::Test::PreservedPtr)> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<PreservedPtr>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_PBSUnknownAsPreserved, context);
}

void
Test::TestIntfPrx::_iceI_PBSUnknownAsPreserved(const std::shared_ptr<IceInternal::OutgoingAsyncT<PreservedPtr>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "PBSUnknownAsPreserved";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            PreservedPtr ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

void
Test::TestIntfPrx::checkPBSUnknown(const PreservedPtr& iceP_p, const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_checkPBSUnknown, iceP_p, context).get();
}

std::future<void>
Test::TestIntfPrx::checkPBSUnknownAsync(const PreservedPtr& iceP_p, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &TestIntfPrx::_iceI_checkPBSUnknown, iceP_p, context);
}

std::function<void()>
Test::TestIntfPrx::checkPBSUnknownAsync(const PreservedPtr& iceP_p, std::function<void()> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_checkPBSUnknown, iceP_p, context);
}

void
Test::TestIntfPrx::_iceI_checkPBSUnknown(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, const PreservedPtr& iceP_p, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "checkPBSUnknown";

    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p);
            ostr->writePendingValues();
        },
        nullptr);
}

::Test::PreservedPtr
Test::TestIntfPrx::PBSUnknownAsPreservedWithGraph(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<PreservedPtr>(true, this, &TestIntfPrx::_iceI_PBSUnknownAsPreservedWithGraph, context).get();
}

std::future<::Test::PreservedPtr>
Test::TestIntfPrx::PBSUnknownAsPreservedWithGraphAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<PreservedPtr>(false, this, &TestIntfPrx::_iceI_PBSUnknownAsPreservedWithGraph, context);
}

std::function<void()>
Test::TestIntfPrx::PBSUnknownAsPreservedWithGraphAsync(std::function<void(::Test::PreservedPtr)> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<PreservedPtr>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_PBSUnknownAsPreservedWithGraph, context);
}

void
Test::TestIntfPrx::_iceI_PBSUnknownAsPreservedWithGraph(const std::shared_ptr<IceInternal::OutgoingAsyncT<PreservedPtr>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "PBSUnknownAsPreservedWithGraph";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            PreservedPtr ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

void
Test::TestIntfPrx::checkPBSUnknownWithGraph(const PreservedPtr& iceP_p, const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_checkPBSUnknownWithGraph, iceP_p, context).get();
}

std::future<void>
Test::TestIntfPrx::checkPBSUnknownWithGraphAsync(const PreservedPtr& iceP_p, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &TestIntfPrx::_iceI_checkPBSUnknownWithGraph, iceP_p, context);
}

std::function<void()>
Test::TestIntfPrx::checkPBSUnknownWithGraphAsync(const PreservedPtr& iceP_p, std::function<void()> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_checkPBSUnknownWithGraph, iceP_p, context);
}

void
Test::TestIntfPrx::_iceI_checkPBSUnknownWithGraph(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, const PreservedPtr& iceP_p, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "checkPBSUnknownWithGraph";

    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p);
            ostr->writePendingValues();
        },
        nullptr);
}

::Test::PreservedPtr
Test::TestIntfPrx::PBSUnknown2AsPreservedWithGraph(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<PreservedPtr>(true, this, &TestIntfPrx::_iceI_PBSUnknown2AsPreservedWithGraph, context).get();
}

std::future<::Test::PreservedPtr>
Test::TestIntfPrx::PBSUnknown2AsPreservedWithGraphAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<PreservedPtr>(false, this, &TestIntfPrx::_iceI_PBSUnknown2AsPreservedWithGraph, context);
}

std::function<void()>
Test::TestIntfPrx::PBSUnknown2AsPreservedWithGraphAsync(std::function<void(::Test::PreservedPtr)> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<PreservedPtr>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_PBSUnknown2AsPreservedWithGraph, context);
}

void
Test::TestIntfPrx::_iceI_PBSUnknown2AsPreservedWithGraph(const std::shared_ptr<IceInternal::OutgoingAsyncT<PreservedPtr>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "PBSUnknown2AsPreservedWithGraph";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            PreservedPtr ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

void
Test::TestIntfPrx::checkPBSUnknown2WithGraph(const PreservedPtr& iceP_p, const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_checkPBSUnknown2WithGraph, iceP_p, context).get();
}

std::future<void>
Test::TestIntfPrx::checkPBSUnknown2WithGraphAsync(const PreservedPtr& iceP_p, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &TestIntfPrx::_iceI_checkPBSUnknown2WithGraph, iceP_p, context);
}

std::function<void()>
Test::TestIntfPrx::checkPBSUnknown2WithGraphAsync(const PreservedPtr& iceP_p, std::function<void()> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_checkPBSUnknown2WithGraph, iceP_p, context);
}

void
Test::TestIntfPrx::_iceI_checkPBSUnknown2WithGraph(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, const PreservedPtr& iceP_p, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "checkPBSUnknown2WithGraph";

    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p);
            ostr->writePendingValues();
        },
        nullptr);
}

::Test::PNodePtr
Test::TestIntfPrx::exchangePNode(const PNodePtr& iceP_pn, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<PNodePtr>(true, this, &TestIntfPrx::_iceI_exchangePNode, iceP_pn, context).get();
}

std::future<::Test::PNodePtr>
Test::TestIntfPrx::exchangePNodeAsync(const PNodePtr& iceP_pn, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<PNodePtr>(false, this, &TestIntfPrx::_iceI_exchangePNode, iceP_pn, context);
}

std::function<void()>
Test::TestIntfPrx::exchangePNodeAsync(const PNodePtr& iceP_pn, std::function<void(::Test::PNodePtr)> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<PNodePtr>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_exchangePNode, iceP_pn, context);
}

void
Test::TestIntfPrx::_iceI_exchangePNode(const std::shared_ptr<IceInternal::OutgoingAsyncT<PNodePtr>>& outAsync, const PNodePtr& iceP_pn, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "exchangePNode";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_pn);
            ostr->writePendingValues();
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            PNodePtr ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

void
Test::TestIntfPrx::throwBaseAsBase(const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_throwBaseAsBase, context).get();
}

std::future<void>
Test::TestIntfPrx::throwBaseAsBaseAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &TestIntfPrx::_iceI_throwBaseAsBase, context);
}

std::function<void()>
Test::TestIntfPrx::throwBaseAsBaseAsync(std::function<void()> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_throwBaseAsBase, context);
}

void
Test::TestIntfPrx::_iceI_throwBaseAsBase(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "throwBaseAsBase";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch (const BaseException&)
            {
                throw;
            }
            catch (const Ice::UserException&)
            {
            }
        });
}

void
Test::TestIntfPrx::throwDerivedAsBase(const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_throwDerivedAsBase, context).get();
}

std::future<void>
Test::TestIntfPrx::throwDerivedAsBaseAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &TestIntfPrx::_iceI_throwDerivedAsBase, context);
}

std::function<void()>
Test::TestIntfPrx::throwDerivedAsBaseAsync(std::function<void()> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_throwDerivedAsBase, context);
}

void
Test::TestIntfPrx::_iceI_throwDerivedAsBase(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "throwDerivedAsBase";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch (const BaseException&)
            {
                throw;
            }
            catch (const Ice::UserException&)
            {
            }
        });
}

void
Test::TestIntfPrx::throwDerivedAsDerived(const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_throwDerivedAsDerived, context).get();
}

std::future<void>
Test::TestIntfPrx::throwDerivedAsDerivedAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &TestIntfPrx::_iceI_throwDerivedAsDerived, context);
}

std::function<void()>
Test::TestIntfPrx::throwDerivedAsDerivedAsync(std::function<void()> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_throwDerivedAsDerived, context);
}

void
Test::TestIntfPrx::_iceI_throwDerivedAsDerived(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "throwDerivedAsDerived";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch (const DerivedException&)
            {
                throw;
            }
            catch (const Ice::UserException&)
            {
            }
        });
}

void
Test::TestIntfPrx::throwUnknownDerivedAsBase(const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_throwUnknownDerivedAsBase, context).get();
}

std::future<void>
Test::TestIntfPrx::throwUnknownDerivedAsBaseAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &TestIntfPrx::_iceI_throwUnknownDerivedAsBase, context);
}

std::function<void()>
Test::TestIntfPrx::throwUnknownDerivedAsBaseAsync(std::function<void()> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_throwUnknownDerivedAsBase, context);
}

void
Test::TestIntfPrx::_iceI_throwUnknownDerivedAsBase(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "throwUnknownDerivedAsBase";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch (const BaseException&)
            {
                throw;
            }
            catch (const Ice::UserException&)
            {
            }
        });
}

void
Test::TestIntfPrx::useForward(ForwardPtr& iceP_f, const Ice::Context& context) const
{
    iceP_f = IceInternal::makePromiseOutgoing<ForwardPtr>(true, this, &TestIntfPrx::_iceI_useForward, context).get();
}

std::future<::Test::ForwardPtr>
Test::TestIntfPrx::useForwardAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<ForwardPtr>(false, this, &TestIntfPrx::_iceI_useForward, context);
}

std::function<void()>
Test::TestIntfPrx::useForwardAsync(std::function<void(::Test::ForwardPtr)> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<ForwardPtr>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_useForward, context);
}

void
Test::TestIntfPrx::_iceI_useForward(const std::shared_ptr<IceInternal::OutgoingAsyncT<ForwardPtr>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "useForward";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](Ice::InputStream* istr)
        {
            ForwardPtr iceP_f;
            istr->readAll(iceP_f);
            istr->readPendingValues();
            return iceP_f;
        });
}

void
Test::TestIntfPrx::shutdown(const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_shutdown, context).get();
}

std::future<void>
Test::TestIntfPrx::shutdownAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &TestIntfPrx::_iceI_shutdown, context);
}

std::function<void()>
Test::TestIntfPrx::shutdownAsync(std::function<void()> response, std::function<void(std::exception_ptr)> ex, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_shutdown, context);
}

void
Test::TestIntfPrx::_iceI_shutdown(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "shutdown";

    outAsync->invoke(operationName, Ice::OperationMode::Normal, Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr);
}

Test::TestIntfPrx::~TestIntfPrx() = default;

const char*
Test::TestIntfPrx::ice_staticId() noexcept
{
    return "::Test::TestIntf";
}

const char*
Test::SBase::ice_staticId() noexcept
{
    return "::Test::SBase";
}

const char*
Test::SBase::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::SBase::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "sb = ", this->sb);
}

Ice::ValuePtr
Test::SBase::_iceCloneImpl() const
{
    return CloneEnabler<SBase>::clone(*this);
}

void
Test::SBase::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll(this->sb);
    ostr->endSlice();
}

void
Test::SBase::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->sb);
    istr->endSlice();
}

const char*
Test::SBSKnownDerived::ice_staticId() noexcept
{
    return "::Test::SBSKnownDerived";
}

const char*
Test::SBSKnownDerived::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::SBSKnownDerived::ice_printFields(std::ostream& os) const
{
    SBase::ice_printFields(os);
    Ice::print(os << ", sbskd = ", this->sbskd);
}

Ice::ValuePtr
Test::SBSKnownDerived::_iceCloneImpl() const
{
    return CloneEnabler<SBSKnownDerived>::clone(*this);
}

void
Test::SBSKnownDerived::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, false);
    ostr->writeAll(this->sbskd);
    ostr->endSlice();
    SBase::_iceWriteImpl(ostr);
}

void
Test::SBSKnownDerived::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->sbskd);
    istr->endSlice();
    SBase::_iceReadImpl(istr);
}

const char*
Test::B::ice_staticId() noexcept
{
    return "::Test::B";
}

const char*
Test::B::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::B::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "sb = ", this->sb);
    Ice::print(os << ", pb = ", this->pb);
}

Ice::ValuePtr
Test::B::_iceCloneImpl() const
{
    return CloneEnabler<B>::clone(*this);
}

void
Test::B::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll(this->sb, this->pb);
    ostr->endSlice();
}

void
Test::B::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->sb, this->pb);
    istr->endSlice();
}

const char*
Test::D1::ice_staticId() noexcept
{
    return "::Test::D1";
}

const char*
Test::D1::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::D1::ice_printFields(std::ostream& os) const
{
    B::ice_printFields(os);
    Ice::print(os << ", sd1 = ", this->sd1);
    Ice::print(os << ", pd1 = ", this->pd1);
}

Ice::ValuePtr
Test::D1::_iceCloneImpl() const
{
    return CloneEnabler<D1>::clone(*this);
}

void
Test::D1::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, false);
    ostr->writeAll(this->sd1, this->pd1);
    ostr->endSlice();
    B::_iceWriteImpl(ostr);
}

void
Test::D1::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->sd1, this->pd1);
    istr->endSlice();
    B::_iceReadImpl(istr);
}

const char*
Test::SS1::ice_staticId() noexcept
{
    return "::Test::SS1";
}

const char*
Test::SS1::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::SS1::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "s = ", this->s);
}

Ice::ValuePtr
Test::SS1::_iceCloneImpl() const
{
    return CloneEnabler<SS1>::clone(*this);
}

void
Test::SS1::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll(this->s);
    ostr->endSlice();
}

void
Test::SS1::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->s);
    istr->endSlice();
}

const char*
Test::SS2::ice_staticId() noexcept
{
    return "::Test::SS2";
}

const char*
Test::SS2::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::SS2::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "s = ", this->s);
}

Ice::ValuePtr
Test::SS2::_iceCloneImpl() const
{
    return CloneEnabler<SS2>::clone(*this);
}

void
Test::SS2::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll(this->s);
    ostr->endSlice();
}

void
Test::SS2::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->s);
    istr->endSlice();
}

void
Test::SS3::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "c1 = ", this->c1);
    Ice::print(os << ", c2 = ", this->c2);
}

std::ostream&
Test::operator<<(std::ostream& os, const ::Test::SS3& value)
{
    os << "Test::SS3{";
    value.ice_printFields(os);
    os << '}';
    return os;
}

void
Test::BaseException::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "sbe = ", this->sbe);
    Ice::print(os << ", pb = ", this->pb);
}

const char*
Test::BaseException::ice_staticId() noexcept
{
    return "::Test::BaseException";
}

const char*
Test::BaseException::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::BaseException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
bool
Test::BaseException::_usesClasses() const
{
    return true;
}
/// \endcond

void
Test::BaseException::_writeImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll(this->sbe, this->pb);
    ostr->endSlice();
}

void
Test::BaseException::_readImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->sbe, this->pb);
    istr->endSlice();
}

void
Test::DerivedException::ice_printFields(std::ostream& os) const
{
    BaseException::ice_printFields(os);
    Ice::print(os << ", sde = ", this->sde);
    Ice::print(os << ", pd1 = ", this->pd1);
}

const char*
Test::DerivedException::ice_staticId() noexcept
{
    return "::Test::DerivedException";
}

const char*
Test::DerivedException::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::DerivedException::ice_throw() const
{
    throw *this;
}

void
Test::DerivedException::_writeImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, false);
    ostr->writeAll(this->sde, this->pd1);
    ostr->endSlice();
    BaseException::_writeImpl(ostr);
}

void
Test::DerivedException::_readImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->sde, this->pd1);
    istr->endSlice();
    BaseException::_readImpl(istr);
}

const char*
Test::PBase::ice_staticId() noexcept
{
    return "::Test::PBase";
}

const char*
Test::PBase::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::PBase::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "pi = ", this->pi);
}

Ice::ValuePtr
Test::PBase::_iceCloneImpl() const
{
    return CloneEnabler<PBase>::clone(*this);
}

void
Test::PBase::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll(this->pi);
    ostr->endSlice();
}

void
Test::PBase::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->pi);
    istr->endSlice();
}

const char*
Test::Preserved::ice_staticId() noexcept
{
    return "::Test::Preserved";
}

const char*
Test::Preserved::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::Preserved::ice_printFields(std::ostream& os) const
{
    PBase::ice_printFields(os);
    Ice::print(os << ", ps = ", this->ps);
}

Ice::ValuePtr
Test::Preserved::_iceCloneImpl() const
{
    return CloneEnabler<Preserved>::clone(*this);
}

void
Test::Preserved::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, false);
    ostr->writeAll(this->ps);
    ostr->endSlice();
    PBase::_iceWriteImpl(ostr);
}

void
Test::Preserved::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->ps);
    istr->endSlice();
    PBase::_iceReadImpl(istr);
}

const char*
Test::PDerived::ice_staticId() noexcept
{
    return "::Test::PDerived";
}

const char*
Test::PDerived::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::PDerived::ice_printFields(std::ostream& os) const
{
    Preserved::ice_printFields(os);
    Ice::print(os << ", pb = ", this->pb);
}

Ice::ValuePtr
Test::PDerived::_iceCloneImpl() const
{
    return CloneEnabler<PDerived>::clone(*this);
}

void
Test::PDerived::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, false);
    ostr->writeAll(this->pb);
    ostr->endSlice();
    Preserved::_iceWriteImpl(ostr);
}

void
Test::PDerived::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->pb);
    istr->endSlice();
    Preserved::_iceReadImpl(istr);
}

const char*
Test::PNode::ice_staticId() noexcept
{
    return "::Test::PNode";
}

const char*
Test::PNode::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::PNode::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "next = ", this->next);
}

Ice::ValuePtr
Test::PNode::_iceCloneImpl() const
{
    return CloneEnabler<PNode>::clone(*this);
}

void
Test::PNode::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll(this->next);
    ostr->endSlice();
}

void
Test::PNode::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->next);
    istr->endSlice();
}

const char*
Test::Hidden::ice_staticId() noexcept
{
    return "::Test::Hidden";
}

const char*
Test::Hidden::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::Hidden::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "f = ", this->f);
}

Ice::ValuePtr
Test::Hidden::_iceCloneImpl() const
{
    return CloneEnabler<Hidden>::clone(*this);
}

void
Test::Hidden::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll(this->f);
    ostr->endSlice();
}

void
Test::Hidden::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->f);
    istr->endSlice();
}

const char*
Test::Forward::ice_staticId() noexcept
{
    return "::Test::Forward";
}

const char*
Test::Forward::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::Forward::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "h = ", this->h);
}

Ice::ValuePtr
Test::Forward::_iceCloneImpl() const
{
    return CloneEnabler<Forward>::clone(*this);
}

void
Test::Forward::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll(this->h);
    ostr->endSlice();
}

void
Test::Forward::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->h);
    istr->endSlice();
}

std::vector<std::string>
Test::TestIntf::ice_ids(const Ice::Current&) const
{
    static const std::vector<std::string> allTypeIds = {"::Ice::Object", "::Test::TestIntf"};
    return allTypeIds;
}

std::string
Test::TestIntf::ice_id(const Ice::Current&) const
{
    return std::string{ice_staticId()};
}

const char*
Test::TestIntf::ice_staticId() noexcept
{
    return "::Test::TestIntf";
}

/// \cond INTERNAL
void
Test::TestIntf::_iceD_SBaseAsObject(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const Ice::ValuePtr& ret)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(ret);
                ostr->writePendingValues();
            },
            Ice::FormatType::SlicedFormat);
    };
    try
    {
        this->SBaseAsObjectAsync(std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_SBaseAsSBase(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const SBasePtr& ret)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(ret);
                ostr->writePendingValues();
            },
            Ice::FormatType::SlicedFormat);
    };
    try
    {
        this->SBaseAsSBaseAsync(std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_SBSKnownDerivedAsSBase(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const SBasePtr& ret)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(ret);
                ostr->writePendingValues();
            },
            Ice::FormatType::SlicedFormat);
    };
    try
    {
        this->SBSKnownDerivedAsSBaseAsync(std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_SBSKnownDerivedAsSBSKnownDerived(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const SBSKnownDerivedPtr& ret)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(ret);
                ostr->writePendingValues();
            },
            Ice::FormatType::SlicedFormat);
    };
    try
    {
        this->SBSKnownDerivedAsSBSKnownDerivedAsync(std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_SBSUnknownDerivedAsSBase(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const SBasePtr& ret)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(ret);
                ostr->writePendingValues();
            },
            Ice::FormatType::SlicedFormat);
    };
    try
    {
        this->SBSUnknownDerivedAsSBaseAsync(std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_SBSUnknownDerivedAsSBaseCompact(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const SBasePtr& ret)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(ret);
                ostr->writePendingValues();
            },
            Ice::FormatType::CompactFormat);
    };
    try
    {
        this->SBSUnknownDerivedAsSBaseCompactAsync(std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_SUnknownAsObject(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const Ice::ValuePtr& ret)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(ret);
                ostr->writePendingValues();
            },
            Ice::FormatType::SlicedFormat);
    };
    try
    {
        this->SUnknownAsObjectAsync(std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_checkSUnknown(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    Ice::ValuePtr iceP_o;
    istr->readAll(iceP_o);
    istr->readPendingValues();
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    try
    {
        this->checkSUnknownAsync(std::move(iceP_o), [responseHandler] { responseHandler->sendEmptyResponse(); }, [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_oneElementCycle(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const BPtr& ret)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(ret);
                ostr->writePendingValues();
            },
            Ice::FormatType::SlicedFormat);
    };
    try
    {
        this->oneElementCycleAsync(std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_twoElementCycle(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const BPtr& ret)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(ret);
                ostr->writePendingValues();
            },
            Ice::FormatType::SlicedFormat);
    };
    try
    {
        this->twoElementCycleAsync(std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_D1AsB(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const BPtr& ret)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(ret);
                ostr->writePendingValues();
            },
            Ice::FormatType::SlicedFormat);
    };
    try
    {
        this->D1AsBAsync(std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_D1AsD1(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const D1Ptr& ret)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(ret);
                ostr->writePendingValues();
            },
            Ice::FormatType::SlicedFormat);
    };
    try
    {
        this->D1AsD1Async(std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_D2AsB(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const BPtr& ret)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(ret);
                ostr->writePendingValues();
            },
            Ice::FormatType::SlicedFormat);
    };
    try
    {
        this->D2AsBAsync(std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_paramTest1(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const BPtr& iceP_p1, const BPtr& iceP_p2)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_p1, iceP_p2);
                ostr->writePendingValues();
            },
            Ice::FormatType::SlicedFormat);
    };
    try
    {
        this->paramTest1Async(std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_paramTest2(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const BPtr& iceP_p2, const BPtr& iceP_p1)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_p2, iceP_p1);
                ostr->writePendingValues();
            },
            Ice::FormatType::SlicedFormat);
    };
    try
    {
        this->paramTest2Async(std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_paramTest3(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const BPtr& ret, const BPtr& iceP_p1, const BPtr& iceP_p2)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_p1, iceP_p2, ret);
                ostr->writePendingValues();
            },
            Ice::FormatType::SlicedFormat);
    };
    try
    {
        this->paramTest3Async(std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_paramTest4(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const BPtr& ret, const BPtr& iceP_p)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_p, ret);
                ostr->writePendingValues();
            },
            Ice::FormatType::SlicedFormat);
    };
    try
    {
        this->paramTest4Async(std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_returnTest1(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const BPtr& ret, const BPtr& iceP_p1, const BPtr& iceP_p2)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_p1, iceP_p2, ret);
                ostr->writePendingValues();
            },
            Ice::FormatType::SlicedFormat);
    };
    try
    {
        this->returnTest1Async(std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_returnTest2(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const BPtr& ret, const BPtr& iceP_p2, const BPtr& iceP_p1)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_p2, iceP_p1, ret);
                ostr->writePendingValues();
            },
            Ice::FormatType::SlicedFormat);
    };
    try
    {
        this->returnTest2Async(std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_returnTest3(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    BPtr iceP_p1;
    BPtr iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    istr->readPendingValues();
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const BPtr& ret)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(ret);
                ostr->writePendingValues();
            },
            Ice::FormatType::SlicedFormat);
    };
    try
    {
        this->returnTest3Async(std::move(iceP_p1), std::move(iceP_p2), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_sequenceTest(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    SS1Ptr iceP_p1;
    SS2Ptr iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    istr->readPendingValues();
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const SS3& ret)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(ret);
                ostr->writePendingValues();
            },
            Ice::FormatType::SlicedFormat);
    };
    try
    {
        this->sequenceTestAsync(std::move(iceP_p1), std::move(iceP_p2), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_dictionaryTest(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    BDict iceP_bin;
    istr->readAll(iceP_bin);
    istr->readPendingValues();
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const BDict& ret, const BDict& iceP_bout)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_bout, ret);
                ostr->writePendingValues();
            },
            Ice::FormatType::SlicedFormat);
    };
    try
    {
        this->dictionaryTestAsync(std::move(iceP_bin), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_exchangePBase(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    PBasePtr iceP_pb;
    istr->readAll(iceP_pb);
    istr->readPendingValues();
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const PBasePtr& ret)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(ret);
                ostr->writePendingValues();
            },
            Ice::FormatType::SlicedFormat);
    };
    try
    {
        this->exchangePBaseAsync(std::move(iceP_pb), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_PBSUnknownAsPreserved(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const PreservedPtr& ret)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(ret);
                ostr->writePendingValues();
            },
            Ice::FormatType::SlicedFormat);
    };
    try
    {
        this->PBSUnknownAsPreservedAsync(std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_checkPBSUnknown(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    PreservedPtr iceP_p;
    istr->readAll(iceP_p);
    istr->readPendingValues();
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    try
    {
        this->checkPBSUnknownAsync(std::move(iceP_p), [responseHandler] { responseHandler->sendEmptyResponse(); }, [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_PBSUnknownAsPreservedWithGraph(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const PreservedPtr& ret)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(ret);
                ostr->writePendingValues();
            },
            Ice::FormatType::SlicedFormat);
    };
    try
    {
        this->PBSUnknownAsPreservedWithGraphAsync(std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_checkPBSUnknownWithGraph(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    PreservedPtr iceP_p;
    istr->readAll(iceP_p);
    istr->readPendingValues();
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    try
    {
        this->checkPBSUnknownWithGraphAsync(std::move(iceP_p), [responseHandler] { responseHandler->sendEmptyResponse(); }, [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_PBSUnknown2AsPreservedWithGraph(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const PreservedPtr& ret)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(ret);
                ostr->writePendingValues();
            },
            Ice::FormatType::SlicedFormat);
    };
    try
    {
        this->PBSUnknown2AsPreservedWithGraphAsync(std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_checkPBSUnknown2WithGraph(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    PreservedPtr iceP_p;
    istr->readAll(iceP_p);
    istr->readPendingValues();
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    try
    {
        this->checkPBSUnknown2WithGraphAsync(std::move(iceP_p), [responseHandler] { responseHandler->sendEmptyResponse(); }, [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_exchangePNode(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    PNodePtr iceP_pn;
    istr->readAll(iceP_pn);
    istr->readPendingValues();
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const PNodePtr& ret)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(ret);
                ostr->writePendingValues();
            },
            Ice::FormatType::SlicedFormat);
    };
    try
    {
        this->exchangePNodeAsync(std::move(iceP_pn), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_throwBaseAsBase(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    try
    {
        this->throwBaseAsBaseAsync([responseHandler] { responseHandler->sendEmptyResponse(); }, [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_throwDerivedAsBase(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    try
    {
        this->throwDerivedAsBaseAsync([responseHandler] { responseHandler->sendEmptyResponse(); }, [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_throwDerivedAsDerived(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    try
    {
        this->throwDerivedAsDerivedAsync([responseHandler] { responseHandler->sendEmptyResponse(); }, [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_throwUnknownDerivedAsBase(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    try
    {
        this->throwUnknownDerivedAsBaseAsync([responseHandler] { responseHandler->sendEmptyResponse(); }, [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_useForward(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const ForwardPtr& iceP_f)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_f);
                ostr->writePendingValues();
            },
            Ice::FormatType::SlicedFormat);
    };
    try
    {
        this->useForwardAsync(std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_shutdown(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    try
    {
        this->shutdownAsync([responseHandler] { responseHandler->sendEmptyResponse(); }, [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::dispatch(Ice::IncomingRequest& request, std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    static constexpr std::array<std::string_view, 40> allOperations{"D1AsB", "D1AsD1", "D2AsB", "PBSUnknown2AsPreservedWithGraph", "PBSUnknownAsPreserved", "PBSUnknownAsPreservedWithGraph", "SBSKnownDerivedAsSBSKnownDerived", "SBSKnownDerivedAsSBase", "SBSUnknownDerivedAsSBase", "SBSUnknownDerivedAsSBaseCompact", "SBaseAsObject", "SBaseAsSBase", "SUnknownAsObject", "checkPBSUnknown", "checkPBSUnknown2WithGraph", "checkPBSUnknownWithGraph", "checkSUnknown", "dictionaryTest", "exchangePBase", "exchangePNode", "ice_id", "ice_ids", "ice_isA", "ice_ping", "oneElementCycle", "paramTest1", "paramTest2", "paramTest3", "paramTest4", "returnTest1", "returnTest2", "returnTest3", "sequenceTest", "shutdown", "throwBaseAsBase", "throwDerivedAsBase", "throwDerivedAsDerived", "throwUnknownDerivedAsBase", "twoElementCycle", "useForward"};

    const Ice::Current& current = request.current();
    auto r = std::equal_range(allOperations.begin(), allOperations.end(), current.operation);
    if (r.first == r.second)
    {
        sendResponse(Ice::makeOutgoingResponse(std::make_exception_ptr(Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        return;
    }

    switch (r.first - allOperations.begin())
    {
        case 0:
        {
            _iceD_D1AsB(request, std::move(sendResponse));
            break;
        }
        case 1:
        {
            _iceD_D1AsD1(request, std::move(sendResponse));
            break;
        }
        case 2:
        {
            _iceD_D2AsB(request, std::move(sendResponse));
            break;
        }
        case 3:
        {
            _iceD_PBSUnknown2AsPreservedWithGraph(request, std::move(sendResponse));
            break;
        }
        case 4:
        {
            _iceD_PBSUnknownAsPreserved(request, std::move(sendResponse));
            break;
        }
        case 5:
        {
            _iceD_PBSUnknownAsPreservedWithGraph(request, std::move(sendResponse));
            break;
        }
        case 6:
        {
            _iceD_SBSKnownDerivedAsSBSKnownDerived(request, std::move(sendResponse));
            break;
        }
        case 7:
        {
            _iceD_SBSKnownDerivedAsSBase(request, std::move(sendResponse));
            break;
        }
        case 8:
        {
            _iceD_SBSUnknownDerivedAsSBase(request, std::move(sendResponse));
            break;
        }
        case 9:
        {
            _iceD_SBSUnknownDerivedAsSBaseCompact(request, std::move(sendResponse));
            break;
        }
        case 10:
        {
            _iceD_SBaseAsObject(request, std::move(sendResponse));
            break;
        }
        case 11:
        {
            _iceD_SBaseAsSBase(request, std::move(sendResponse));
            break;
        }
        case 12:
        {
            _iceD_SUnknownAsObject(request, std::move(sendResponse));
            break;
        }
        case 13:
        {
            _iceD_checkPBSUnknown(request, std::move(sendResponse));
            break;
        }
        case 14:
        {
            _iceD_checkPBSUnknown2WithGraph(request, std::move(sendResponse));
            break;
        }
        case 15:
        {
            _iceD_checkPBSUnknownWithGraph(request, std::move(sendResponse));
            break;
        }
        case 16:
        {
            _iceD_checkSUnknown(request, std::move(sendResponse));
            break;
        }
        case 17:
        {
            _iceD_dictionaryTest(request, std::move(sendResponse));
            break;
        }
        case 18:
        {
            _iceD_exchangePBase(request, std::move(sendResponse));
            break;
        }
        case 19:
        {
            _iceD_exchangePNode(request, std::move(sendResponse));
            break;
        }
        case 20:
        {
            _iceD_ice_id(request, std::move(sendResponse));
            break;
        }
        case 21:
        {
            _iceD_ice_ids(request, std::move(sendResponse));
            break;
        }
        case 22:
        {
            _iceD_ice_isA(request, std::move(sendResponse));
            break;
        }
        case 23:
        {
            _iceD_ice_ping(request, std::move(sendResponse));
            break;
        }
        case 24:
        {
            _iceD_oneElementCycle(request, std::move(sendResponse));
            break;
        }
        case 25:
        {
            _iceD_paramTest1(request, std::move(sendResponse));
            break;
        }
        case 26:
        {
            _iceD_paramTest2(request, std::move(sendResponse));
            break;
        }
        case 27:
        {
            _iceD_paramTest3(request, std::move(sendResponse));
            break;
        }
        case 28:
        {
            _iceD_paramTest4(request, std::move(sendResponse));
            break;
        }
        case 29:
        {
            _iceD_returnTest1(request, std::move(sendResponse));
            break;
        }
        case 30:
        {
            _iceD_returnTest2(request, std::move(sendResponse));
            break;
        }
        case 31:
        {
            _iceD_returnTest3(request, std::move(sendResponse));
            break;
        }
        case 32:
        {
            _iceD_sequenceTest(request, std::move(sendResponse));
            break;
        }
        case 33:
        {
            _iceD_shutdown(request, std::move(sendResponse));
            break;
        }
        case 34:
        {
            _iceD_throwBaseAsBase(request, std::move(sendResponse));
            break;
        }
        case 35:
        {
            _iceD_throwDerivedAsBase(request, std::move(sendResponse));
            break;
        }
        case 36:
        {
            _iceD_throwDerivedAsDerived(request, std::move(sendResponse));
            break;
        }
        case 37:
        {
            _iceD_throwUnknownDerivedAsBase(request, std::move(sendResponse));
            break;
        }
        case 38:
        {
            _iceD_twoElementCycle(request, std::move(sendResponse));
            break;
        }
        case 39:
        {
            _iceD_useForward(request, std::move(sendResponse));
            break;
        }
        default:
        {
            assert(false);
            sendResponse(Ice::makeOutgoingResponse(std::make_exception_ptr(Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        }
    }
}
/// \endcond
