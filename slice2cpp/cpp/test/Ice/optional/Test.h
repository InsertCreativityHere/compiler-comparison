//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Test_h__
#define __Test_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <IceUtil/UndefSysMacros.h>
#include <list>
#include <CustomMap.h>
#include <StringView.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace Test
{

class OneOptional;
class MyInterface;
class MyInterfacePrx;
class MultiOptional;
class A;
class B;
class C;
class WD;
class OptionalWithCustom;
class E;
class F;
class G1;
class G2;
class G;
class Recursive;
class Initial;
class InitialPrx;

}

namespace Test
{

enum class MyEnum : unsigned char
{
    MyEnumMember
};

struct SmallStruct
{
    ::Ice::Byte m;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Ice::Byte&> ice_tuple() const
    {
        return std::tie(m);
    }
};

struct FixedStruct
{
    int m;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(m);
    }
};

struct VarStruct
{
    ::std::string m;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(m);
    }
};

struct ClassVarStruct
{
    int a;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(a);
    }
};

using ByteSeq = ::std::vector<::Ice::Byte>;

using BoolSeq = ::std::vector<bool>;

using ShortSeq = ::std::vector<short>;

using IntSeq = ::std::vector<int>;

using LongSeq = ::std::vector<long long int>;

using FloatSeq = ::std::vector<float>;

using DoubleSeq = ::std::vector<double>;

using StringSeq = ::std::vector<::std::string>;

using MyEnumSeq = ::std::vector<MyEnum>;

using SmallStructSeq = ::std::vector<SmallStruct>;

using SmallStructList = std::list< ::Test::SmallStruct>;

using FixedStructSeq = ::std::vector<FixedStruct>;

using FixedStructList = std::list< ::Test::FixedStruct>;

using VarStructSeq = ::std::vector<VarStruct>;

using OneOptionalSeq = ::std::vector<::std::shared_ptr<OneOptional>>;

using MyInterfacePrxSeq = ::std::vector<::std::shared_ptr<MyInterfacePrx>>;

using Serializable = ::std::vector<::Ice::Byte>;

using IntIntDict = ::std::map<int, int>;

using StringIntDict = ::std::map<::std::string, int>;

using IntEnumDict = ::std::map<int, MyEnum>;

using IntFixedStructDict = ::std::map<int, FixedStruct>;

using IntVarStructDict = ::std::map<int, VarStruct>;

using IntOneOptionalDict = ::std::map<int, ::std::shared_ptr<OneOptional>>;

using IntMyInterfacePrxDict = ::std::map<int, ::std::shared_ptr<MyInterfacePrx>>;

using IntStringDict = Test::CustomMap<Ice::Int, std::string>;

class OptionalException : public ::Ice::UserExceptionHelper<OptionalException, ::Ice::UserException>
{
public:

    virtual ~OptionalException();

    OptionalException(const OptionalException&) = default;

    OptionalException() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    OptionalException(bool req, const std::optional<int>& a, const std::optional<::std::string>& b, const std::optional<::std::shared_ptr<OneOptional>>& o) :
        req(req),
        a(a),
        b(b),
        o(o)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const bool&, const std::optional<int>&, const std::optional<::std::string>&, const std::optional<::std::shared_ptr<::Test::OneOptional>>&> ice_tuple() const
    {
        return std::tie(req, a, b, o);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    bool req = false;
    std::optional<int> a = 5;
    std::optional<::std::string> b;
    std::optional<::std::shared_ptr<::Test::OneOptional>> o;
};

/// \cond INTERNAL
static OptionalException _iceS_OptionalException_init;
/// \endcond

class DerivedException : public ::Ice::UserExceptionHelper<DerivedException, OptionalException>
{
public:

    virtual ~DerivedException();

    DerivedException(const DerivedException&) = default;

    DerivedException() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    DerivedException(bool req, const std::optional<int>& a, const std::optional<::std::string>& b, const std::optional<::std::shared_ptr<OneOptional>>& o, const ::std::string& d1, const std::optional<::std::string>& ss, const std::optional<::std::shared_ptr<OneOptional>>& o2, const ::std::string& d2) :
        ::Ice::UserExceptionHelper<DerivedException, OptionalException>(req, a, b, o),
        d1(d1),
        ss(ss),
        o2(o2),
        d2(d2)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const bool&, const std::optional<int>&, const std::optional<::std::string>&, const std::optional<::std::shared_ptr<::Test::OneOptional>>&, const ::std::string&, const std::optional<::std::string>&, const std::optional<::std::shared_ptr<::Test::OneOptional>>&, const ::std::string&> ice_tuple() const
    {
        return std::tie(req, a, b, o, d1, ss, o2, d2);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string d1;
    std::optional<::std::string> ss{"test"};
    std::optional<::std::shared_ptr<::Test::OneOptional>> o2;
    ::std::string d2;
};

class RequiredException : public ::Ice::UserExceptionHelper<RequiredException, OptionalException>
{
public:

    virtual ~RequiredException();

    RequiredException(const RequiredException&) = default;

    RequiredException() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    RequiredException(bool req, const std::optional<int>& a, const std::optional<::std::string>& b, const std::optional<::std::shared_ptr<OneOptional>>& o, const ::std::string& ss, const ::std::shared_ptr<OneOptional>& o2) :
        ::Ice::UserExceptionHelper<RequiredException, OptionalException>(req, a, b, o),
        ss(ss),
        o2(o2)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const bool&, const std::optional<int>&, const std::optional<::std::string>&, const std::optional<::std::shared_ptr<::Test::OneOptional>>&, const ::std::string&, const ::std::shared_ptr<::Test::OneOptional>&> ice_tuple() const
    {
        return std::tie(req, a, b, o, ss, o2);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /// \cond STREAM
    virtual bool _usesClasses() const override;
    /// \endcond

    ::std::string ss = "test";
    ::std::shared_ptr<::Test::OneOptional> o2;
};

using RecursiveSeq = ::std::vector<::std::shared_ptr<Recursive>>;

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace Test
{

class MyInterface : public virtual ::Ice::Object
{
public:

    using ProxyType = MyInterfacePrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void op(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_op(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class Initial : public virtual ::Ice::Object
{
public:

    using ProxyType = InitialPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void shutdown(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Marshaled result structure for operation pingPong.
     */
    class PingPongMarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        PingPongMarshaledResult(const ::std::shared_ptr<::Ice::Value>& returnValue, const ::Ice::Current& current);
    };

    virtual PingPongMarshaledResult pingPong(::std::shared_ptr<::Ice::Value> o, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_pingPong(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opOptionalException(std::optional<int> a, std::optional<::std::string> b, std::optional<::std::shared_ptr<OneOptional>> o, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptionalException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opDerivedException(std::optional<int> a, std::optional<::std::string> b, std::optional<::std::shared_ptr<OneOptional>> o, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDerivedException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opRequiredException(std::optional<int> a, std::optional<::std::string> b, std::optional<::std::shared_ptr<OneOptional>> o, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opRequiredException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByte.
     */
    struct OpByteResult
    {
        std::optional<::Ice::Byte> returnValue;
        std::optional<::Ice::Byte> p3;
    };

    virtual std::optional<::Ice::Byte> opByte(std::optional<::Ice::Byte> p1, std::optional<::Ice::Byte>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByte(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBool.
     */
    struct OpBoolResult
    {
        std::optional<bool> returnValue;
        std::optional<bool> p3;
    };

    virtual std::optional<bool> opBool(std::optional<bool> p1, std::optional<bool>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBool(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opShort.
     */
    struct OpShortResult
    {
        std::optional<short> returnValue;
        std::optional<short> p3;
    };

    virtual std::optional<short> opShort(std::optional<short> p1, std::optional<short>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShort(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opInt.
     */
    struct OpIntResult
    {
        std::optional<int> returnValue;
        std::optional<int> p3;
    };

    virtual std::optional<int> opInt(std::optional<int> p1, std::optional<int>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opInt(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLong.
     */
    struct OpLongResult
    {
        std::optional<long long int> returnValue;
        std::optional<long long int> p3;
    };

    virtual std::optional<long long int> opLong(std::optional<long long int> p1, std::optional<long long int>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLong(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFloat.
     */
    struct OpFloatResult
    {
        std::optional<float> returnValue;
        std::optional<float> p3;
    };

    virtual std::optional<float> opFloat(std::optional<float> p1, std::optional<float>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloat(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opDouble.
     */
    struct OpDoubleResult
    {
        std::optional<double> returnValue;
        std::optional<double> p3;
    };

    virtual std::optional<double> opDouble(std::optional<double> p1, std::optional<double>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDouble(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opString.
     */
    struct OpStringResult
    {
        std::optional<::std::string> returnValue;
        std::optional<::std::string> p3;
    };

    virtual std::optional<::std::string> opString(std::optional<::std::string> p1, std::optional<::std::string>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opString(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opCustomString.
     */
    struct OpCustomStringResult
    {
        std::optional<::std::string> returnValue;
        std::optional<::std::string> p3;
    };

    virtual std::optional<::std::string> opCustomString(std::optional<Util::string_view> p1, std::optional<::std::string>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opCustomString(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMyEnum.
     */
    struct OpMyEnumResult
    {
        std::optional<MyEnum> returnValue;
        std::optional<MyEnum> p3;
    };

    virtual std::optional<MyEnum> opMyEnum(std::optional<MyEnum> p1, std::optional<MyEnum>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyEnum(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSmallStruct.
     */
    struct OpSmallStructResult
    {
        std::optional<SmallStruct> returnValue;
        std::optional<SmallStruct> p3;
    };

    virtual std::optional<SmallStruct> opSmallStruct(std::optional<SmallStruct> p1, std::optional<SmallStruct>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSmallStruct(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFixedStruct.
     */
    struct OpFixedStructResult
    {
        std::optional<FixedStruct> returnValue;
        std::optional<FixedStruct> p3;
    };

    virtual std::optional<FixedStruct> opFixedStruct(std::optional<FixedStruct> p1, std::optional<FixedStruct>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFixedStruct(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opVarStruct.
     */
    struct OpVarStructResult
    {
        std::optional<VarStruct> returnValue;
        std::optional<VarStruct> p3;
    };

    virtual std::optional<VarStruct> opVarStruct(std::optional<VarStruct> p1, std::optional<VarStruct>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVarStruct(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOneOptional.
     */
    struct OpOneOptionalResult
    {
        std::optional<::std::shared_ptr<OneOptional>> returnValue;
        std::optional<::std::shared_ptr<OneOptional>> p3;
    };

    virtual std::optional<::std::shared_ptr<OneOptional>> opOneOptional(std::optional<::std::shared_ptr<OneOptional>> p1, std::optional<::std::shared_ptr<OneOptional>>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOneOptional(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMyInterfaceProxy.
     */
    struct OpMyInterfaceProxyResult
    {
        std::optional<::std::shared_ptr<MyInterfacePrx>> returnValue;
        std::optional<::std::shared_ptr<MyInterfacePrx>> p3;
    };

    virtual std::optional<::std::shared_ptr<MyInterfacePrx>> opMyInterfaceProxy(std::optional<::std::shared_ptr<MyInterfacePrx>> p1, std::optional<::std::shared_ptr<MyInterfacePrx>>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyInterfaceProxy(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteSeq.
     */
    struct OpByteSeqResult
    {
        std::optional<ByteSeq> returnValue;
        std::optional<ByteSeq> p3;
    };

    virtual std::optional<ByteSeq> opByteSeq(std::optional<::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>> p1, std::optional<ByteSeq>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolSeq.
     */
    struct OpBoolSeqResult
    {
        std::optional<BoolSeq> returnValue;
        std::optional<BoolSeq> p3;
    };

    virtual std::optional<BoolSeq> opBoolSeq(std::optional<::std::pair<const bool*, const bool*>> p1, std::optional<BoolSeq>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opShortSeq.
     */
    struct OpShortSeqResult
    {
        std::optional<ShortSeq> returnValue;
        std::optional<ShortSeq> p3;
    };

    virtual std::optional<ShortSeq> opShortSeq(std::optional<::std::pair<const short*, const short*>> p1, std::optional<ShortSeq>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opIntSeq.
     */
    struct OpIntSeqResult
    {
        std::optional<IntSeq> returnValue;
        std::optional<IntSeq> p3;
    };

    virtual std::optional<IntSeq> opIntSeq(std::optional<::std::pair<const int*, const int*>> p1, std::optional<IntSeq>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLongSeq.
     */
    struct OpLongSeqResult
    {
        std::optional<LongSeq> returnValue;
        std::optional<LongSeq> p3;
    };

    virtual std::optional<LongSeq> opLongSeq(std::optional<::std::pair<const long long int*, const long long int*>> p1, std::optional<LongSeq>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLongSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFloatSeq.
     */
    struct OpFloatSeqResult
    {
        std::optional<FloatSeq> returnValue;
        std::optional<FloatSeq> p3;
    };

    virtual std::optional<FloatSeq> opFloatSeq(std::optional<::std::pair<const float*, const float*>> p1, std::optional<FloatSeq>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloatSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opDoubleSeq.
     */
    struct OpDoubleSeqResult
    {
        std::optional<DoubleSeq> returnValue;
        std::optional<DoubleSeq> p3;
    };

    virtual std::optional<DoubleSeq> opDoubleSeq(std::optional<::std::pair<const double*, const double*>> p1, std::optional<DoubleSeq>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDoubleSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringSeq.
     */
    struct OpStringSeqResult
    {
        std::optional<StringSeq> returnValue;
        std::optional<StringSeq> p3;
    };

    virtual std::optional<StringSeq> opStringSeq(std::optional<StringSeq> p1, std::optional<StringSeq>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSmallStructSeq.
     */
    struct OpSmallStructSeqResult
    {
        std::optional<SmallStructSeq> returnValue;
        std::optional<SmallStructSeq> p3;
    };

    virtual std::optional<SmallStructSeq> opSmallStructSeq(std::optional<::std::pair<const SmallStruct*, const SmallStruct*>> p1, std::optional<SmallStructSeq>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSmallStructSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSmallStructList.
     */
    struct OpSmallStructListResult
    {
        std::optional<SmallStructList> returnValue;
        std::optional<SmallStructList> p3;
    };

    virtual std::optional<SmallStructList> opSmallStructList(std::optional<::std::pair<const SmallStruct*, const SmallStruct*>> p1, std::optional<SmallStructList>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSmallStructList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFixedStructSeq.
     */
    struct OpFixedStructSeqResult
    {
        std::optional<FixedStructSeq> returnValue;
        std::optional<FixedStructSeq> p3;
    };

    virtual std::optional<FixedStructSeq> opFixedStructSeq(std::optional<::std::pair<const FixedStruct*, const FixedStruct*>> p1, std::optional<FixedStructSeq>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFixedStructSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFixedStructList.
     */
    struct OpFixedStructListResult
    {
        std::optional<FixedStructList> returnValue;
        std::optional<FixedStructList> p3;
    };

    virtual std::optional<FixedStructList> opFixedStructList(std::optional<::std::pair<const FixedStruct*, const FixedStruct*>> p1, std::optional<FixedStructList>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFixedStructList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opVarStructSeq.
     */
    struct OpVarStructSeqResult
    {
        std::optional<VarStructSeq> returnValue;
        std::optional<VarStructSeq> p3;
    };

    virtual std::optional<VarStructSeq> opVarStructSeq(std::optional<VarStructSeq> p1, std::optional<VarStructSeq>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVarStructSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSerializable.
     */
    struct OpSerializableResult
    {
        std::optional<Serializable> returnValue;
        std::optional<Serializable> p3;
    };

    virtual std::optional<Serializable> opSerializable(std::optional<Serializable> p1, std::optional<Serializable>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSerializable(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opIntIntDict.
     */
    struct OpIntIntDictResult
    {
        std::optional<IntIntDict> returnValue;
        std::optional<IntIntDict> p3;
    };

    virtual std::optional<IntIntDict> opIntIntDict(std::optional<IntIntDict> p1, std::optional<IntIntDict>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntIntDict(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringIntDict.
     */
    struct OpStringIntDictResult
    {
        std::optional<StringIntDict> returnValue;
        std::optional<StringIntDict> p3;
    };

    virtual std::optional<StringIntDict> opStringIntDict(std::optional<StringIntDict> p1, std::optional<StringIntDict>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringIntDict(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opCustomIntStringDict.
     */
    struct OpCustomIntStringDictResult
    {
        std::optional<::Test::CustomMap< ::Ice::Int, std::string>> returnValue;
        std::optional<::Test::CustomMap< ::Ice::Int, std::string>> p3;
    };

    virtual std::optional<::Test::CustomMap< ::Ice::Int, std::string>> opCustomIntStringDict(std::optional<::std::map< ::Ice::Int, ::Util::string_view>> p1, std::optional<::Test::CustomMap< ::Ice::Int, std::string>>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opCustomIntStringDict(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opIntOneOptionalDict.
     */
    struct OpIntOneOptionalDictResult
    {
        std::optional<IntOneOptionalDict> returnValue;
        std::optional<IntOneOptionalDict> p3;
    };

    virtual std::optional<IntOneOptionalDict> opIntOneOptionalDict(std::optional<IntOneOptionalDict> p1, std::optional<IntOneOptionalDict>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntOneOptionalDict(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opClassAndUnknownOptional(::std::shared_ptr<A> p, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opClassAndUnknownOptional(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void sendOptionalClass(bool req, std::optional<::std::shared_ptr<OneOptional>> o, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_sendOptionalClass(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void returnOptionalClass(bool req, std::optional<::std::shared_ptr<OneOptional>>& o, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_returnOptionalClass(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<G> opG(::std::shared_ptr<G> g, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opG(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opVoid(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVoid(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Marshaled result structure for operation opMStruct1.
     */
    class OpMStruct1MarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        OpMStruct1MarshaledResult(const std::optional<SmallStruct>& returnValue, const ::Ice::Current& current);
    };

    virtual OpMStruct1MarshaledResult opMStruct1(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMStruct1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMStruct2.
     */
    struct OpMStruct2Result
    {
        std::optional<SmallStruct> returnValue;
        std::optional<SmallStruct> p2;
    };

    /**
     * Marshaled result structure for operation opMStruct2.
     */
    class OpMStruct2MarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        OpMStruct2MarshaledResult(const std::optional<SmallStruct>& returnValue, const std::optional<SmallStruct>& p2, const ::Ice::Current& current);
    };

    virtual OpMStruct2MarshaledResult opMStruct2(std::optional<SmallStruct> p1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMStruct2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Marshaled result structure for operation opMSeq1.
     */
    class OpMSeq1MarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        OpMSeq1MarshaledResult(const std::optional<StringSeq>& returnValue, const ::Ice::Current& current);
    };

    virtual OpMSeq1MarshaledResult opMSeq1(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMSeq1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMSeq2.
     */
    struct OpMSeq2Result
    {
        std::optional<StringSeq> returnValue;
        std::optional<StringSeq> p2;
    };

    /**
     * Marshaled result structure for operation opMSeq2.
     */
    class OpMSeq2MarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        OpMSeq2MarshaledResult(const std::optional<StringSeq>& returnValue, const std::optional<StringSeq>& p2, const ::Ice::Current& current);
    };

    virtual OpMSeq2MarshaledResult opMSeq2(std::optional<StringSeq> p1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMSeq2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Marshaled result structure for operation opMDict1.
     */
    class OpMDict1MarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        OpMDict1MarshaledResult(const std::optional<StringIntDict>& returnValue, const ::Ice::Current& current);
    };

    virtual OpMDict1MarshaledResult opMDict1(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMDict1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMDict2.
     */
    struct OpMDict2Result
    {
        std::optional<StringIntDict> returnValue;
        std::optional<StringIntDict> p2;
    };

    /**
     * Marshaled result structure for operation opMDict2.
     */
    class OpMDict2MarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        OpMDict2MarshaledResult(const std::optional<StringIntDict>& returnValue, const std::optional<StringIntDict>& p2, const ::Ice::Current& current);
    };

    virtual OpMDict2MarshaledResult opMDict2(std::optional<StringIntDict> p1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMDict2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Marshaled result structure for operation opMG1.
     */
    class OpMG1MarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        OpMG1MarshaledResult(const std::optional<::std::shared_ptr<G>>& returnValue, const ::Ice::Current& current);
    };

    virtual OpMG1MarshaledResult opMG1(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMG1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMG2.
     */
    struct OpMG2Result
    {
        std::optional<::std::shared_ptr<G>> returnValue;
        std::optional<::std::shared_ptr<G>> p2;
    };

    /**
     * Marshaled result structure for operation opMG2.
     */
    class OpMG2MarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        OpMG2MarshaledResult(const std::optional<::std::shared_ptr<G>>& returnValue, const std::optional<::std::shared_ptr<G>>& p2, const ::Ice::Current& current);
    };

    virtual OpMG2MarshaledResult opMG2(std::optional<::std::shared_ptr<G>> p1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMG2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool supportsRequiredParams(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_supportsRequiredParams(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool supportsJavaSerializable(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_supportsJavaSerializable(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool supportsCsharpSerializable(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_supportsCsharpSerializable(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool supportsCppStringView(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_supportsCppStringView(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool supportsNullOptional(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_supportsNullOptional(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace Test
{

class OneOptional : public ::Ice::ValueHelper<OneOptional, ::Ice::Value>
{
public:

    virtual ~OneOptional();

    OneOptional() = default;

    OneOptional(const OneOptional&) = default;
    OneOptional(OneOptional&&) = default;
    OneOptional& operator=(const OneOptional&) = default;
    OneOptional& operator=(OneOptional&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit OneOptional(const std::optional<int>& a) :
        a(a)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const std::optional<int>&> ice_tuple() const
    {
        return std::tie(a);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    std::optional<int> a;
};

/// \cond INTERNAL
static OneOptional _iceS_OneOptional_init;
/// \endcond

class MultiOptional : public ::Ice::ValueHelper<MultiOptional, ::Ice::Value>
{
public:

    virtual ~MultiOptional();

    MultiOptional() = default;

    MultiOptional(const MultiOptional&) = default;
    MultiOptional(MultiOptional&&) = default;
    MultiOptional& operator=(const MultiOptional&) = default;
    MultiOptional& operator=(MultiOptional&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    MultiOptional(const std::optional<::Ice::Byte>& a, const std::optional<bool>& b, const std::optional<short>& c, const std::optional<int>& d, const std::optional<long long int>& e, const std::optional<float>& f, const std::optional<double>& g, const std::optional<::std::string>& h, const std::optional<::Test::MyEnum>& i, const std::optional<::std::shared_ptr<::Test::MyInterfacePrx>>& j, const std::optional<::std::shared_ptr<::Test::MultiOptional>>& k, const std::optional<::Test::ByteSeq>& bs, const std::optional<::Test::StringSeq>& ss, const std::optional<::Test::IntIntDict>& iid, const std::optional<::Test::StringIntDict>& sid, const std::optional<::Test::FixedStruct>& fs, const std::optional<::Test::VarStruct>& vs, const std::optional<::Test::ShortSeq>& shs, const std::optional<::Test::MyEnumSeq>& es, const std::optional<::Test::FixedStructSeq>& fss, const std::optional<::Test::VarStructSeq>& vss, const std::optional<::Test::OneOptionalSeq>& oos, const std::optional<::Test::MyInterfacePrxSeq>& mips, const std::optional<::Test::IntEnumDict>& ied, const std::optional<::Test::IntFixedStructDict>& ifsd, const std::optional<::Test::IntVarStructDict>& ivsd, const std::optional<::Test::IntOneOptionalDict>& iood, const std::optional<::Test::IntMyInterfacePrxDict>& imipd, const std::optional<::Test::BoolSeq>& bos, const std::optional<::Test::Serializable>& ser) :
        a(a),
        b(b),
        c(c),
        d(d),
        e(e),
        f(f),
        g(g),
        h(h),
        i(i),
        j(j),
        k(k),
        bs(bs),
        ss(ss),
        iid(iid),
        sid(sid),
        fs(fs),
        vs(vs),
        shs(shs),
        es(es),
        fss(fss),
        vss(vss),
        oos(oos),
        mips(mips),
        ied(ied),
        ifsd(ifsd),
        ivsd(ivsd),
        iood(iood),
        imipd(imipd),
        bos(bos),
        ser(ser)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const std::optional<::Ice::Byte>&, const std::optional<bool>&, const std::optional<short>&, const std::optional<int>&, const std::optional<long long int>&, const std::optional<float>&, const std::optional<double>&, const std::optional<::std::string>&, const std::optional<::Test::MyEnum>&, const std::optional<::std::shared_ptr<::Test::MyInterfacePrx>>&, const std::optional<::std::shared_ptr<::Test::MultiOptional>>&, const std::optional<::Test::ByteSeq>&, const std::optional<::Test::StringSeq>&, const std::optional<::Test::IntIntDict>&, const std::optional<::Test::StringIntDict>&, const std::optional<::Test::FixedStruct>&, const std::optional<::Test::VarStruct>&, const std::optional<::Test::ShortSeq>&, const std::optional<::Test::MyEnumSeq>&, const std::optional<::Test::FixedStructSeq>&, const std::optional<::Test::VarStructSeq>&, const std::optional<::Test::OneOptionalSeq>&, const std::optional<::Test::MyInterfacePrxSeq>&, const std::optional<::Test::IntEnumDict>&, const std::optional<::Test::IntFixedStructDict>&, const std::optional<::Test::IntVarStructDict>&, const std::optional<::Test::IntOneOptionalDict>&, const std::optional<::Test::IntMyInterfacePrxDict>&, const std::optional<::Test::BoolSeq>&, const std::optional<::Test::Serializable>&> ice_tuple() const
    {
        return std::tie(a, b, c, d, e, f, g, h, i, j, k, bs, ss, iid, sid, fs, vs, shs, es, fss, vss, oos, mips, ied, ifsd, ivsd, iood, imipd, bos, ser);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    std::optional<::Ice::Byte> a;
    std::optional<bool> b;
    std::optional<short> c;
    std::optional<int> d;
    std::optional<long long int> e;
    std::optional<float> f;
    std::optional<double> g;
    std::optional<::std::string> h;
    std::optional<::Test::MyEnum> i;
    std::optional<::std::shared_ptr<::Test::MyInterfacePrx>> j;
    std::optional<::std::shared_ptr<::Test::MultiOptional>> k;
    std::optional<::Test::ByteSeq> bs;
    std::optional<::Test::StringSeq> ss;
    std::optional<::Test::IntIntDict> iid;
    std::optional<::Test::StringIntDict> sid;
    std::optional<::Test::FixedStruct> fs;
    std::optional<::Test::VarStruct> vs;
    std::optional<::Test::ShortSeq> shs;
    std::optional<::Test::MyEnumSeq> es;
    std::optional<::Test::FixedStructSeq> fss;
    std::optional<::Test::VarStructSeq> vss;
    std::optional<::Test::OneOptionalSeq> oos;
    std::optional<::Test::MyInterfacePrxSeq> mips;
    std::optional<::Test::IntEnumDict> ied;
    std::optional<::Test::IntFixedStructDict> ifsd;
    std::optional<::Test::IntVarStructDict> ivsd;
    std::optional<::Test::IntOneOptionalDict> iood;
    std::optional<::Test::IntMyInterfacePrxDict> imipd;
    std::optional<::Test::BoolSeq> bos;
    std::optional<::Test::Serializable> ser;
};

class A : public ::Ice::ValueHelper<A, ::Ice::Value>
{
public:

    virtual ~A();

    A() = default;

    A(const A&) = default;
    A(A&&) = default;
    A& operator=(const A&) = default;
    A& operator=(A&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    A(int requiredA, const std::optional<int>& ma, const std::optional<int>& mb, const std::optional<int>& mc) :
        requiredA(requiredA),
        ma(ma),
        mb(mb),
        mc(mc)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const std::optional<int>&, const std::optional<int>&, const std::optional<int>&> ice_tuple() const
    {
        return std::tie(requiredA, ma, mb, mc);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int requiredA = 0;
    std::optional<int> ma;
    std::optional<int> mb;
    std::optional<int> mc;
};

class B : public ::Ice::ValueHelper<B, A>
{
public:

    virtual ~B();

    B() = default;

    B(const B&) = default;
    B(B&&) = default;
    B& operator=(const B&) = default;
    B& operator=(B&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    B(int requiredA, const std::optional<int>& ma, const std::optional<int>& mb, const std::optional<int>& mc, int requiredB, const std::optional<int>& md) :
        Ice::ValueHelper<B, A>(requiredA, ma, mb, mc),
        requiredB(requiredB),
        md(md)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const std::optional<int>&, const std::optional<int>&, const std::optional<int>&, const int&, const std::optional<int>&> ice_tuple() const
    {
        return std::tie(requiredA, ma, mb, mc, requiredB, md);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains the SlicedData object created when an unknown value type was marshaled
     * in the sliced format and the Ice run time sliced it to a known type.
     * @return The SlicedData object, or nil if the value was not sliced or was not
     * marshaled in the sliced format.
     */
    virtual ::std::shared_ptr<::Ice::SlicedData> ice_getSlicedData() const override;

    /// \cond STREAM
    virtual void _iceWrite(::Ice::OutputStream*) const override;
    virtual void _iceRead(::Ice::InputStream*) override;
    /// \endcond

    int requiredB = 0;
    std::optional<int> md;

protected:

    /// \cond STREAM
    ::std::shared_ptr<::Ice::SlicedData> _iceSlicedData;
    /// \endcond
};

class C : public ::Ice::ValueHelper<C, B>
{
public:

    virtual ~C();

    C() = default;

    C(const C&) = default;
    C(C&&) = default;
    C& operator=(const C&) = default;
    C& operator=(C&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    C(int requiredA, const std::optional<int>& ma, const std::optional<int>& mb, const std::optional<int>& mc, int requiredB, const std::optional<int>& md, const ::std::string& ss, const std::optional<::std::string>& ms) :
        Ice::ValueHelper<C, B>(requiredA, ma, mb, mc, requiredB, md),
        ss(ss),
        ms(ms)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const std::optional<int>&, const std::optional<int>&, const std::optional<int>&, const int&, const std::optional<int>&, const ::std::string&, const std::optional<::std::string>&> ice_tuple() const
    {
        return std::tie(requiredA, ma, mb, mc, requiredB, md, ss, ms);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string ss;
    std::optional<::std::string> ms;
};

class WD : public ::Ice::ValueHelper<WD, ::Ice::Value>
{
public:

    virtual ~WD();

    WD() = default;

    WD(const WD&) = default;
    WD(WD&&) = default;
    WD& operator=(const WD&) = default;
    WD& operator=(WD&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    WD(const std::optional<int>& a, const std::optional<::std::string>& s) :
        a(a),
        s(s)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const std::optional<int>&, const std::optional<::std::string>&> ice_tuple() const
    {
        return std::tie(a, s);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    std::optional<int> a = 5;
    std::optional<::std::string> s{"test"};
};

class OptionalWithCustom : public ::Ice::ValueHelper<OptionalWithCustom, ::Ice::Value>
{
public:

    virtual ~OptionalWithCustom();

    OptionalWithCustom() = default;

    OptionalWithCustom(const OptionalWithCustom&) = default;
    OptionalWithCustom(OptionalWithCustom&&) = default;
    OptionalWithCustom& operator=(const OptionalWithCustom&) = default;
    OptionalWithCustom& operator=(OptionalWithCustom&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    OptionalWithCustom(const std::optional<::Test::SmallStructList>& l, const std::optional<::Test::SmallStructList>& lp, const std::optional<::Test::ClassVarStruct>& s) :
        l(l),
        lp(lp),
        s(s)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const std::optional<::Test::SmallStructList>&, const std::optional<::Test::SmallStructList>&, const std::optional<::Test::ClassVarStruct>&> ice_tuple() const
    {
        return std::tie(l, lp, s);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    std::optional<::Test::SmallStructList> l;

protected:

    std::optional<::Test::SmallStructList> lp;

public:

    std::optional<::Test::ClassVarStruct> s;

protected:

    template<typename T, typename S>
    friend struct Ice::StreamWriter;
    template<typename T, typename S>
    friend struct Ice::StreamReader;
};

class E : public ::Ice::ValueHelper<E, ::Ice::Value>
{
public:

    virtual ~E();

    E() = default;

    E(const E&) = default;
    E(E&&) = default;
    E& operator=(const E&) = default;
    E& operator=(E&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit E(const ::std::shared_ptr<::Test::A>& ae) :
        ae(ae)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::A>&> ice_tuple() const
    {
        return std::tie(ae);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::A> ae;
};

class F : public ::Ice::ValueHelper<F, E>
{
public:

    virtual ~F();

    F() = default;

    F(const F&) = default;
    F(F&&) = default;
    F& operator=(const F&) = default;
    F& operator=(F&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    F(const ::std::shared_ptr<::Test::A>& ae, const std::optional<::std::shared_ptr<::Test::A>>& af) :
        Ice::ValueHelper<F, E>(ae),
        af(af)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::A>&, const std::optional<::std::shared_ptr<::Test::A>>&> ice_tuple() const
    {
        return std::tie(ae, af);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    std::optional<::std::shared_ptr<::Test::A>> af;
};

class G1 : public ::Ice::ValueHelper<G1, ::Ice::Value>
{
public:

    virtual ~G1();

    G1() = default;

    G1(const G1&) = default;
    G1(G1&&) = default;
    G1& operator=(const G1&) = default;
    G1& operator=(G1&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit G1(const ::std::string& a) :
        a(a)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(a);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string a;
};

class G2 : public ::Ice::ValueHelper<G2, ::Ice::Value>
{
public:

    virtual ~G2();

    G2() = default;

    G2(const G2&) = default;
    G2(G2&&) = default;
    G2& operator=(const G2&) = default;
    G2& operator=(G2&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit G2(long long int a) :
        a(a)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const long long int&> ice_tuple() const
    {
        return std::tie(a);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    long long int a;
};

class G : public ::Ice::ValueHelper<G, ::Ice::Value>
{
public:

    virtual ~G();

    G() = default;

    G(const G&) = default;
    G(G&&) = default;
    G& operator=(const G&) = default;
    G& operator=(G&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    G(const std::optional<::std::shared_ptr<::Test::G1>>& gg1Opt, const ::std::shared_ptr<::Test::G2>& gg2, const std::optional<::std::shared_ptr<::Test::G2>>& gg2Opt, const ::std::shared_ptr<::Test::G1>& gg1) :
        gg1Opt(gg1Opt),
        gg2(gg2),
        gg2Opt(gg2Opt),
        gg1(gg1)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const std::optional<::std::shared_ptr<::Test::G1>>&, const ::std::shared_ptr<::Test::G2>&, const std::optional<::std::shared_ptr<::Test::G2>>&, const ::std::shared_ptr<::Test::G1>&> ice_tuple() const
    {
        return std::tie(gg1Opt, gg2, gg2Opt, gg1);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    std::optional<::std::shared_ptr<::Test::G1>> gg1Opt;
    ::std::shared_ptr<::Test::G2> gg2;
    std::optional<::std::shared_ptr<::Test::G2>> gg2Opt;
    ::std::shared_ptr<::Test::G1> gg1;
};

class Recursive : public ::Ice::ValueHelper<Recursive, ::Ice::Value>
{
public:

    virtual ~Recursive();

    Recursive() = default;

    Recursive(const Recursive&) = default;
    Recursive(Recursive&&) = default;
    Recursive& operator=(const Recursive&) = default;
    Recursive& operator=(Recursive&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit Recursive(const std::optional<::Test::RecursiveSeq>& value) :
        value(value)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const std::optional<::Test::RecursiveSeq>&> ice_tuple() const
    {
        return std::tie(value);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    std::optional<::Test::RecursiveSeq> value;
};

}

namespace Test
{

class MyInterfacePrx : public virtual ::Ice::Proxy<MyInterfacePrx, ::Ice::ObjectPrx>
{
public:

    void op(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MyInterfacePrx::_iceI_op, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MyInterfacePrx::_iceI_op, context);
    }

    ::std::function<void()>
    opAsync(::std::function<void()> response,
            ::std::function<void(::std::exception_ptr)> ex = nullptr,
            ::std::function<void(bool)> sent = nullptr,
            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyInterfacePrx::_iceI_op, context);
    }

    /// \cond INTERNAL
    void _iceI_op(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    MyInterfacePrx() = default;
    friend ::std::shared_ptr<MyInterfacePrx> IceInternal::createProxy<MyInterfacePrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class InitialPrx : public virtual ::Ice::Proxy<InitialPrx, ::Ice::ObjectPrx>
{
public:

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &InitialPrx::_iceI_shutdown, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto shutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &InitialPrx::_iceI_shutdown, context);
    }

    ::std::function<void()>
    shutdownAsync(::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_shutdown, context);
    }

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<::Ice::Value> pingPong(const ::std::shared_ptr<::Ice::Value>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::Value>>(true, this, &InitialPrx::_iceI_pingPong, o, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto pingPongAsync(const ::std::shared_ptr<::Ice::Value>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Ice::Value>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::Value>, P>(false, this, &InitialPrx::_iceI_pingPong, o, context);
    }

    ::std::function<void()>
    pingPongAsync(const ::std::shared_ptr<::Ice::Value>& o,
                  ::std::function<void(::std::shared_ptr<::Ice::Value>)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Ice::Value>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_pingPong, o, context);
    }

    /// \cond INTERNAL
    void _iceI_pingPong(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Ice::Value>>>&, const ::std::shared_ptr<::Ice::Value>&, const ::Ice::Context&);
    /// \endcond

    void opOptionalException(const std::optional<int>& a, const std::optional<::std::string>& b, const std::optional<::std::shared_ptr<OneOptional>>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &InitialPrx::_iceI_opOptionalException, a, b, o, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opOptionalExceptionAsync(const std::optional<int>& a, const std::optional<::std::string>& b, const std::optional<::std::shared_ptr<OneOptional>>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &InitialPrx::_iceI_opOptionalException, a, b, o, context);
    }

    ::std::function<void()>
    opOptionalExceptionAsync(const std::optional<int>& a, const std::optional<::std::string>& b, const std::optional<::std::shared_ptr<OneOptional>>& o,
                             ::std::function<void()> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opOptionalException, a, b, o, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptionalException(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const std::optional<int>&, const std::optional<::std::string>&, const std::optional<::std::shared_ptr<OneOptional>>&, const ::Ice::Context&);
    /// \endcond

    void opDerivedException(const std::optional<int>& a, const std::optional<::std::string>& b, const std::optional<::std::shared_ptr<OneOptional>>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &InitialPrx::_iceI_opDerivedException, a, b, o, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opDerivedExceptionAsync(const std::optional<int>& a, const std::optional<::std::string>& b, const std::optional<::std::shared_ptr<OneOptional>>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &InitialPrx::_iceI_opDerivedException, a, b, o, context);
    }

    ::std::function<void()>
    opDerivedExceptionAsync(const std::optional<int>& a, const std::optional<::std::string>& b, const std::optional<::std::shared_ptr<OneOptional>>& o,
                            ::std::function<void()> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opDerivedException, a, b, o, context);
    }

    /// \cond INTERNAL
    void _iceI_opDerivedException(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const std::optional<int>&, const std::optional<::std::string>&, const std::optional<::std::shared_ptr<OneOptional>>&, const ::Ice::Context&);
    /// \endcond

    void opRequiredException(const std::optional<int>& a, const std::optional<::std::string>& b, const std::optional<::std::shared_ptr<OneOptional>>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &InitialPrx::_iceI_opRequiredException, a, b, o, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opRequiredExceptionAsync(const std::optional<int>& a, const std::optional<::std::string>& b, const std::optional<::std::shared_ptr<OneOptional>>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &InitialPrx::_iceI_opRequiredException, a, b, o, context);
    }

    ::std::function<void()>
    opRequiredExceptionAsync(const std::optional<int>& a, const std::optional<::std::string>& b, const std::optional<::std::shared_ptr<OneOptional>>& o,
                             ::std::function<void()> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opRequiredException, a, b, o, context);
    }

    /// \cond INTERNAL
    void _iceI_opRequiredException(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const std::optional<int>&, const std::optional<::std::string>&, const std::optional<::std::shared_ptr<OneOptional>>&, const ::Ice::Context&);
    /// \endcond

    std::optional<::Ice::Byte> opByte(const std::optional<::Ice::Byte>& p1, std::optional<::Ice::Byte>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpByteResult>(true, this, &InitialPrx::_iceI_opByte, p1, context).get();
        p3 = _result.p3;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto opByteAsync(const std::optional<::Ice::Byte>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpByteResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpByteResult, P>(false, this, &InitialPrx::_iceI_opByte, p1, context);
    }

    ::std::function<void()>
    opByteAsync(const std::optional<::Ice::Byte>& p1,
                ::std::function<void(std::optional<::Ice::Byte>, std::optional<::Ice::Byte>)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpByteResult&& _result)
        {
            response(_result.returnValue, _result.p3);
        };
        return _makeLambdaOutgoing<Initial::OpByteResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opByte, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opByte(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpByteResult>>&, const std::optional<::Ice::Byte>&, const ::Ice::Context&);
    /// \endcond

    std::optional<bool> opBool(const std::optional<bool>& p1, std::optional<bool>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpBoolResult>(true, this, &InitialPrx::_iceI_opBool, p1, context).get();
        p3 = _result.p3;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto opBoolAsync(const std::optional<bool>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpBoolResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpBoolResult, P>(false, this, &InitialPrx::_iceI_opBool, p1, context);
    }

    ::std::function<void()>
    opBoolAsync(const std::optional<bool>& p1,
                ::std::function<void(std::optional<bool>, std::optional<bool>)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpBoolResult&& _result)
        {
            response(_result.returnValue, _result.p3);
        };
        return _makeLambdaOutgoing<Initial::OpBoolResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opBool, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opBool(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpBoolResult>>&, const std::optional<bool>&, const ::Ice::Context&);
    /// \endcond

    std::optional<short> opShort(const std::optional<short>& p1, std::optional<short>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpShortResult>(true, this, &InitialPrx::_iceI_opShort, p1, context).get();
        p3 = _result.p3;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto opShortAsync(const std::optional<short>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpShortResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpShortResult, P>(false, this, &InitialPrx::_iceI_opShort, p1, context);
    }

    ::std::function<void()>
    opShortAsync(const std::optional<short>& p1,
                 ::std::function<void(std::optional<short>, std::optional<short>)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpShortResult&& _result)
        {
            response(_result.returnValue, _result.p3);
        };
        return _makeLambdaOutgoing<Initial::OpShortResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opShort, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opShort(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpShortResult>>&, const std::optional<short>&, const ::Ice::Context&);
    /// \endcond

    std::optional<int> opInt(const std::optional<int>& p1, std::optional<int>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpIntResult>(true, this, &InitialPrx::_iceI_opInt, p1, context).get();
        p3 = _result.p3;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto opIntAsync(const std::optional<int>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpIntResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpIntResult, P>(false, this, &InitialPrx::_iceI_opInt, p1, context);
    }

    ::std::function<void()>
    opIntAsync(const std::optional<int>& p1,
               ::std::function<void(std::optional<int>, std::optional<int>)> response,
               ::std::function<void(::std::exception_ptr)> ex = nullptr,
               ::std::function<void(bool)> sent = nullptr,
               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpIntResult&& _result)
        {
            response(_result.returnValue, _result.p3);
        };
        return _makeLambdaOutgoing<Initial::OpIntResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opInt, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opInt(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpIntResult>>&, const std::optional<int>&, const ::Ice::Context&);
    /// \endcond

    std::optional<long long int> opLong(const std::optional<long long int>& p1, std::optional<long long int>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpLongResult>(true, this, &InitialPrx::_iceI_opLong, p1, context).get();
        p3 = _result.p3;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto opLongAsync(const std::optional<long long int>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpLongResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpLongResult, P>(false, this, &InitialPrx::_iceI_opLong, p1, context);
    }

    ::std::function<void()>
    opLongAsync(const std::optional<long long int>& p1,
                ::std::function<void(std::optional<long long int>, std::optional<long long int>)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpLongResult&& _result)
        {
            response(_result.returnValue, _result.p3);
        };
        return _makeLambdaOutgoing<Initial::OpLongResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opLong, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opLong(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpLongResult>>&, const std::optional<long long int>&, const ::Ice::Context&);
    /// \endcond

    std::optional<float> opFloat(const std::optional<float>& p1, std::optional<float>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpFloatResult>(true, this, &InitialPrx::_iceI_opFloat, p1, context).get();
        p3 = _result.p3;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto opFloatAsync(const std::optional<float>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpFloatResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpFloatResult, P>(false, this, &InitialPrx::_iceI_opFloat, p1, context);
    }

    ::std::function<void()>
    opFloatAsync(const std::optional<float>& p1,
                 ::std::function<void(std::optional<float>, std::optional<float>)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpFloatResult&& _result)
        {
            response(_result.returnValue, _result.p3);
        };
        return _makeLambdaOutgoing<Initial::OpFloatResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opFloat, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opFloat(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpFloatResult>>&, const std::optional<float>&, const ::Ice::Context&);
    /// \endcond

    std::optional<double> opDouble(const std::optional<double>& p1, std::optional<double>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpDoubleResult>(true, this, &InitialPrx::_iceI_opDouble, p1, context).get();
        p3 = _result.p3;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto opDoubleAsync(const std::optional<double>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpDoubleResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpDoubleResult, P>(false, this, &InitialPrx::_iceI_opDouble, p1, context);
    }

    ::std::function<void()>
    opDoubleAsync(const std::optional<double>& p1,
                  ::std::function<void(std::optional<double>, std::optional<double>)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpDoubleResult&& _result)
        {
            response(_result.returnValue, _result.p3);
        };
        return _makeLambdaOutgoing<Initial::OpDoubleResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opDouble, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opDouble(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpDoubleResult>>&, const std::optional<double>&, const ::Ice::Context&);
    /// \endcond

    std::optional<::std::string> opString(const std::optional<::std::string>& p1, std::optional<::std::string>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpStringResult>(true, this, &InitialPrx::_iceI_opString, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringAsync(const std::optional<::std::string>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpStringResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpStringResult, P>(false, this, &InitialPrx::_iceI_opString, p1, context);
    }

    ::std::function<void()>
    opStringAsync(const std::optional<::std::string>& p1,
                  ::std::function<void(std::optional<::std::string>, std::optional<::std::string>)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpStringResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpStringResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opString, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opString(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpStringResult>>&, const std::optional<::std::string>&, const ::Ice::Context&);
    /// \endcond

    std::optional<::std::string> opCustomString(const std::optional<Util::string_view>& p1, std::optional<::std::string>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpCustomStringResult>(true, this, &InitialPrx::_iceI_opCustomString, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opCustomStringAsync(const std::optional<Util::string_view>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpCustomStringResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpCustomStringResult, P>(false, this, &InitialPrx::_iceI_opCustomString, p1, context);
    }

    ::std::function<void()>
    opCustomStringAsync(const std::optional<Util::string_view>& p1,
                        ::std::function<void(std::optional<Util::string_view>, std::optional<Util::string_view>)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opCustomString(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpCustomStringResult>>&, const std::optional<Util::string_view>&, const ::Ice::Context&);
    /// \endcond

    std::optional<MyEnum> opMyEnum(const std::optional<MyEnum>& p1, std::optional<MyEnum>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpMyEnumResult>(true, this, &InitialPrx::_iceI_opMyEnum, p1, context).get();
        p3 = _result.p3;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto opMyEnumAsync(const std::optional<MyEnum>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpMyEnumResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpMyEnumResult, P>(false, this, &InitialPrx::_iceI_opMyEnum, p1, context);
    }

    ::std::function<void()>
    opMyEnumAsync(const std::optional<MyEnum>& p1,
                  ::std::function<void(std::optional<::Test::MyEnum>, std::optional<::Test::MyEnum>)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpMyEnumResult&& _result)
        {
            response(_result.returnValue, _result.p3);
        };
        return _makeLambdaOutgoing<Initial::OpMyEnumResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opMyEnum, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMyEnum(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpMyEnumResult>>&, const std::optional<MyEnum>&, const ::Ice::Context&);
    /// \endcond

    std::optional<SmallStruct> opSmallStruct(const std::optional<SmallStruct>& p1, std::optional<SmallStruct>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpSmallStructResult>(true, this, &InitialPrx::_iceI_opSmallStruct, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSmallStructAsync(const std::optional<SmallStruct>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpSmallStructResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpSmallStructResult, P>(false, this, &InitialPrx::_iceI_opSmallStruct, p1, context);
    }

    ::std::function<void()>
    opSmallStructAsync(const std::optional<SmallStruct>& p1,
                       ::std::function<void(std::optional<::Test::SmallStruct>, std::optional<::Test::SmallStruct>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpSmallStructResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpSmallStructResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opSmallStruct, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opSmallStruct(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpSmallStructResult>>&, const std::optional<SmallStruct>&, const ::Ice::Context&);
    /// \endcond

    std::optional<FixedStruct> opFixedStruct(const std::optional<FixedStruct>& p1, std::optional<FixedStruct>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpFixedStructResult>(true, this, &InitialPrx::_iceI_opFixedStruct, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opFixedStructAsync(const std::optional<FixedStruct>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpFixedStructResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpFixedStructResult, P>(false, this, &InitialPrx::_iceI_opFixedStruct, p1, context);
    }

    ::std::function<void()>
    opFixedStructAsync(const std::optional<FixedStruct>& p1,
                       ::std::function<void(std::optional<::Test::FixedStruct>, std::optional<::Test::FixedStruct>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpFixedStructResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpFixedStructResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opFixedStruct, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opFixedStruct(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpFixedStructResult>>&, const std::optional<FixedStruct>&, const ::Ice::Context&);
    /// \endcond

    std::optional<VarStruct> opVarStruct(const std::optional<VarStruct>& p1, std::optional<VarStruct>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpVarStructResult>(true, this, &InitialPrx::_iceI_opVarStruct, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opVarStructAsync(const std::optional<VarStruct>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpVarStructResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpVarStructResult, P>(false, this, &InitialPrx::_iceI_opVarStruct, p1, context);
    }

    ::std::function<void()>
    opVarStructAsync(const std::optional<VarStruct>& p1,
                     ::std::function<void(std::optional<::Test::VarStruct>, std::optional<::Test::VarStruct>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpVarStructResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpVarStructResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opVarStruct, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opVarStruct(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpVarStructResult>>&, const std::optional<VarStruct>&, const ::Ice::Context&);
    /// \endcond

    std::optional<::std::shared_ptr<OneOptional>> opOneOptional(const std::optional<::std::shared_ptr<OneOptional>>& p1, std::optional<::std::shared_ptr<OneOptional>>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpOneOptionalResult>(true, this, &InitialPrx::_iceI_opOneOptional, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOneOptionalAsync(const std::optional<::std::shared_ptr<OneOptional>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpOneOptionalResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpOneOptionalResult, P>(false, this, &InitialPrx::_iceI_opOneOptional, p1, context);
    }

    ::std::function<void()>
    opOneOptionalAsync(const std::optional<::std::shared_ptr<OneOptional>>& p1,
                       ::std::function<void(std::optional<::std::shared_ptr<::Test::OneOptional>>, std::optional<::std::shared_ptr<::Test::OneOptional>>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpOneOptionalResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpOneOptionalResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opOneOptional, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opOneOptional(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpOneOptionalResult>>&, const std::optional<::std::shared_ptr<OneOptional>>&, const ::Ice::Context&);
    /// \endcond

    std::optional<::std::shared_ptr<MyInterfacePrx>> opMyInterfaceProxy(const std::optional<::std::shared_ptr<MyInterfacePrx>>& p1, std::optional<::std::shared_ptr<MyInterfacePrx>>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpMyInterfaceProxyResult>(true, this, &InitialPrx::_iceI_opMyInterfaceProxy, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opMyInterfaceProxyAsync(const std::optional<::std::shared_ptr<MyInterfacePrx>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpMyInterfaceProxyResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpMyInterfaceProxyResult, P>(false, this, &InitialPrx::_iceI_opMyInterfaceProxy, p1, context);
    }

    ::std::function<void()>
    opMyInterfaceProxyAsync(const std::optional<::std::shared_ptr<MyInterfacePrx>>& p1,
                            ::std::function<void(std::optional<::std::shared_ptr<::Test::MyInterfacePrx>>, std::optional<::std::shared_ptr<::Test::MyInterfacePrx>>)> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpMyInterfaceProxyResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpMyInterfaceProxyResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opMyInterfaceProxy, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMyInterfaceProxy(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpMyInterfaceProxyResult>>&, const std::optional<::std::shared_ptr<MyInterfacePrx>>&, const ::Ice::Context&);
    /// \endcond

    std::optional<ByteSeq> opByteSeq(const std::optional<::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>>& p1, std::optional<ByteSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpByteSeqResult>(true, this, &InitialPrx::_iceI_opByteSeq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opByteSeqAsync(const std::optional<::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpByteSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpByteSeqResult, P>(false, this, &InitialPrx::_iceI_opByteSeq, p1, context);
    }

    ::std::function<void()>
    opByteSeqAsync(const std::optional<::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>>& p1,
                   ::std::function<void(std::optional<::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>>, std::optional<::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpByteSeqResult>>&, const std::optional<::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>>&, const ::Ice::Context&);
    /// \endcond

    std::optional<BoolSeq> opBoolSeq(const std::optional<::std::pair<const bool*, const bool*>>& p1, std::optional<BoolSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpBoolSeqResult>(true, this, &InitialPrx::_iceI_opBoolSeq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opBoolSeqAsync(const std::optional<::std::pair<const bool*, const bool*>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpBoolSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpBoolSeqResult, P>(false, this, &InitialPrx::_iceI_opBoolSeq, p1, context);
    }

    ::std::function<void()>
    opBoolSeqAsync(const std::optional<::std::pair<const bool*, const bool*>>& p1,
                   ::std::function<void(std::optional<::std::pair<const bool*, const bool*>>, std::optional<::std::pair<const bool*, const bool*>>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opBoolSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpBoolSeqResult>>&, const std::optional<::std::pair<const bool*, const bool*>>&, const ::Ice::Context&);
    /// \endcond

    std::optional<ShortSeq> opShortSeq(const std::optional<::std::pair<const short*, const short*>>& p1, std::optional<ShortSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpShortSeqResult>(true, this, &InitialPrx::_iceI_opShortSeq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opShortSeqAsync(const std::optional<::std::pair<const short*, const short*>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpShortSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpShortSeqResult, P>(false, this, &InitialPrx::_iceI_opShortSeq, p1, context);
    }

    ::std::function<void()>
    opShortSeqAsync(const std::optional<::std::pair<const short*, const short*>>& p1,
                    ::std::function<void(std::optional<::std::pair<const short*, const short*>>, std::optional<::std::pair<const short*, const short*>>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opShortSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpShortSeqResult>>&, const std::optional<::std::pair<const short*, const short*>>&, const ::Ice::Context&);
    /// \endcond

    std::optional<IntSeq> opIntSeq(const std::optional<::std::pair<const int*, const int*>>& p1, std::optional<IntSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpIntSeqResult>(true, this, &InitialPrx::_iceI_opIntSeq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opIntSeqAsync(const std::optional<::std::pair<const int*, const int*>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpIntSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpIntSeqResult, P>(false, this, &InitialPrx::_iceI_opIntSeq, p1, context);
    }

    ::std::function<void()>
    opIntSeqAsync(const std::optional<::std::pair<const int*, const int*>>& p1,
                  ::std::function<void(std::optional<::std::pair<const int*, const int*>>, std::optional<::std::pair<const int*, const int*>>)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opIntSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpIntSeqResult>>&, const std::optional<::std::pair<const int*, const int*>>&, const ::Ice::Context&);
    /// \endcond

    std::optional<LongSeq> opLongSeq(const std::optional<::std::pair<const long long int*, const long long int*>>& p1, std::optional<LongSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpLongSeqResult>(true, this, &InitialPrx::_iceI_opLongSeq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opLongSeqAsync(const std::optional<::std::pair<const long long int*, const long long int*>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpLongSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpLongSeqResult, P>(false, this, &InitialPrx::_iceI_opLongSeq, p1, context);
    }

    ::std::function<void()>
    opLongSeqAsync(const std::optional<::std::pair<const long long int*, const long long int*>>& p1,
                   ::std::function<void(std::optional<::std::pair<const long long int*, const long long int*>>, std::optional<::std::pair<const long long int*, const long long int*>>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opLongSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpLongSeqResult>>&, const std::optional<::std::pair<const long long int*, const long long int*>>&, const ::Ice::Context&);
    /// \endcond

    std::optional<FloatSeq> opFloatSeq(const std::optional<::std::pair<const float*, const float*>>& p1, std::optional<FloatSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpFloatSeqResult>(true, this, &InitialPrx::_iceI_opFloatSeq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opFloatSeqAsync(const std::optional<::std::pair<const float*, const float*>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpFloatSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpFloatSeqResult, P>(false, this, &InitialPrx::_iceI_opFloatSeq, p1, context);
    }

    ::std::function<void()>
    opFloatSeqAsync(const std::optional<::std::pair<const float*, const float*>>& p1,
                    ::std::function<void(std::optional<::std::pair<const float*, const float*>>, std::optional<::std::pair<const float*, const float*>>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opFloatSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpFloatSeqResult>>&, const std::optional<::std::pair<const float*, const float*>>&, const ::Ice::Context&);
    /// \endcond

    std::optional<DoubleSeq> opDoubleSeq(const std::optional<::std::pair<const double*, const double*>>& p1, std::optional<DoubleSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpDoubleSeqResult>(true, this, &InitialPrx::_iceI_opDoubleSeq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opDoubleSeqAsync(const std::optional<::std::pair<const double*, const double*>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpDoubleSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpDoubleSeqResult, P>(false, this, &InitialPrx::_iceI_opDoubleSeq, p1, context);
    }

    ::std::function<void()>
    opDoubleSeqAsync(const std::optional<::std::pair<const double*, const double*>>& p1,
                     ::std::function<void(std::optional<::std::pair<const double*, const double*>>, std::optional<::std::pair<const double*, const double*>>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opDoubleSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpDoubleSeqResult>>&, const std::optional<::std::pair<const double*, const double*>>&, const ::Ice::Context&);
    /// \endcond

    std::optional<StringSeq> opStringSeq(const std::optional<StringSeq>& p1, std::optional<StringSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpStringSeqResult>(true, this, &InitialPrx::_iceI_opStringSeq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringSeqAsync(const std::optional<StringSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpStringSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpStringSeqResult, P>(false, this, &InitialPrx::_iceI_opStringSeq, p1, context);
    }

    ::std::function<void()>
    opStringSeqAsync(const std::optional<StringSeq>& p1,
                     ::std::function<void(std::optional<::Test::StringSeq>, std::optional<::Test::StringSeq>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpStringSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpStringSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opStringSeq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpStringSeqResult>>&, const std::optional<StringSeq>&, const ::Ice::Context&);
    /// \endcond

    std::optional<SmallStructSeq> opSmallStructSeq(const std::optional<::std::pair<const SmallStruct*, const SmallStruct*>>& p1, std::optional<SmallStructSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpSmallStructSeqResult>(true, this, &InitialPrx::_iceI_opSmallStructSeq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSmallStructSeqAsync(const std::optional<::std::pair<const SmallStruct*, const SmallStruct*>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpSmallStructSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpSmallStructSeqResult, P>(false, this, &InitialPrx::_iceI_opSmallStructSeq, p1, context);
    }

    ::std::function<void()>
    opSmallStructSeqAsync(const std::optional<::std::pair<const SmallStruct*, const SmallStruct*>>& p1,
                          ::std::function<void(std::optional<::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*>>, std::optional<::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*>>)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opSmallStructSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpSmallStructSeqResult>>&, const std::optional<::std::pair<const SmallStruct*, const SmallStruct*>>&, const ::Ice::Context&);
    /// \endcond

    std::optional<SmallStructList> opSmallStructList(const std::optional<::std::pair<const SmallStruct*, const SmallStruct*>>& p1, std::optional<SmallStructList>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpSmallStructListResult>(true, this, &InitialPrx::_iceI_opSmallStructList, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSmallStructListAsync(const std::optional<::std::pair<const SmallStruct*, const SmallStruct*>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpSmallStructListResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpSmallStructListResult, P>(false, this, &InitialPrx::_iceI_opSmallStructList, p1, context);
    }

    ::std::function<void()>
    opSmallStructListAsync(const std::optional<::std::pair<const SmallStruct*, const SmallStruct*>>& p1,
                           ::std::function<void(std::optional<::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*>>, std::optional<::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*>>)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opSmallStructList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpSmallStructListResult>>&, const std::optional<::std::pair<const SmallStruct*, const SmallStruct*>>&, const ::Ice::Context&);
    /// \endcond

    std::optional<FixedStructSeq> opFixedStructSeq(const std::optional<::std::pair<const FixedStruct*, const FixedStruct*>>& p1, std::optional<FixedStructSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpFixedStructSeqResult>(true, this, &InitialPrx::_iceI_opFixedStructSeq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opFixedStructSeqAsync(const std::optional<::std::pair<const FixedStruct*, const FixedStruct*>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpFixedStructSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpFixedStructSeqResult, P>(false, this, &InitialPrx::_iceI_opFixedStructSeq, p1, context);
    }

    ::std::function<void()>
    opFixedStructSeqAsync(const std::optional<::std::pair<const FixedStruct*, const FixedStruct*>>& p1,
                          ::std::function<void(std::optional<::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*>>, std::optional<::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*>>)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opFixedStructSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpFixedStructSeqResult>>&, const std::optional<::std::pair<const FixedStruct*, const FixedStruct*>>&, const ::Ice::Context&);
    /// \endcond

    std::optional<FixedStructList> opFixedStructList(const std::optional<::std::pair<const FixedStruct*, const FixedStruct*>>& p1, std::optional<FixedStructList>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpFixedStructListResult>(true, this, &InitialPrx::_iceI_opFixedStructList, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opFixedStructListAsync(const std::optional<::std::pair<const FixedStruct*, const FixedStruct*>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpFixedStructListResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpFixedStructListResult, P>(false, this, &InitialPrx::_iceI_opFixedStructList, p1, context);
    }

    ::std::function<void()>
    opFixedStructListAsync(const std::optional<::std::pair<const FixedStruct*, const FixedStruct*>>& p1,
                           ::std::function<void(std::optional<::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*>>, std::optional<::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*>>)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opFixedStructList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpFixedStructListResult>>&, const std::optional<::std::pair<const FixedStruct*, const FixedStruct*>>&, const ::Ice::Context&);
    /// \endcond

    std::optional<VarStructSeq> opVarStructSeq(const std::optional<VarStructSeq>& p1, std::optional<VarStructSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpVarStructSeqResult>(true, this, &InitialPrx::_iceI_opVarStructSeq, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opVarStructSeqAsync(const std::optional<VarStructSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpVarStructSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpVarStructSeqResult, P>(false, this, &InitialPrx::_iceI_opVarStructSeq, p1, context);
    }

    ::std::function<void()>
    opVarStructSeqAsync(const std::optional<VarStructSeq>& p1,
                        ::std::function<void(std::optional<::Test::VarStructSeq>, std::optional<::Test::VarStructSeq>)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpVarStructSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpVarStructSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opVarStructSeq, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opVarStructSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpVarStructSeqResult>>&, const std::optional<VarStructSeq>&, const ::Ice::Context&);
    /// \endcond

    std::optional<Serializable> opSerializable(const std::optional<Serializable>& p1, std::optional<Serializable>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpSerializableResult>(true, this, &InitialPrx::_iceI_opSerializable, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSerializableAsync(const std::optional<Serializable>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpSerializableResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpSerializableResult, P>(false, this, &InitialPrx::_iceI_opSerializable, p1, context);
    }

    ::std::function<void()>
    opSerializableAsync(const std::optional<Serializable>& p1,
                        ::std::function<void(std::optional<::Test::Serializable>, std::optional<::Test::Serializable>)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpSerializableResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpSerializableResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opSerializable, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opSerializable(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpSerializableResult>>&, const std::optional<Serializable>&, const ::Ice::Context&);
    /// \endcond

    std::optional<IntIntDict> opIntIntDict(const std::optional<IntIntDict>& p1, std::optional<IntIntDict>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpIntIntDictResult>(true, this, &InitialPrx::_iceI_opIntIntDict, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opIntIntDictAsync(const std::optional<IntIntDict>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpIntIntDictResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpIntIntDictResult, P>(false, this, &InitialPrx::_iceI_opIntIntDict, p1, context);
    }

    ::std::function<void()>
    opIntIntDictAsync(const std::optional<IntIntDict>& p1,
                      ::std::function<void(std::optional<::Test::IntIntDict>, std::optional<::Test::IntIntDict>)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpIntIntDictResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpIntIntDictResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opIntIntDict, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opIntIntDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpIntIntDictResult>>&, const std::optional<IntIntDict>&, const ::Ice::Context&);
    /// \endcond

    std::optional<StringIntDict> opStringIntDict(const std::optional<StringIntDict>& p1, std::optional<StringIntDict>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpStringIntDictResult>(true, this, &InitialPrx::_iceI_opStringIntDict, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringIntDictAsync(const std::optional<StringIntDict>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpStringIntDictResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpStringIntDictResult, P>(false, this, &InitialPrx::_iceI_opStringIntDict, p1, context);
    }

    ::std::function<void()>
    opStringIntDictAsync(const std::optional<StringIntDict>& p1,
                         ::std::function<void(std::optional<::Test::StringIntDict>, std::optional<::Test::StringIntDict>)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpStringIntDictResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpStringIntDictResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opStringIntDict, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringIntDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpStringIntDictResult>>&, const std::optional<StringIntDict>&, const ::Ice::Context&);
    /// \endcond

    std::optional<::Test::CustomMap< ::Ice::Int, std::string>> opCustomIntStringDict(const std::optional<::std::map< ::Ice::Int, ::Util::string_view>>& p1, std::optional<::Test::CustomMap< ::Ice::Int, std::string>>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpCustomIntStringDictResult>(true, this, &InitialPrx::_iceI_opCustomIntStringDict, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opCustomIntStringDictAsync(const std::optional<::std::map< ::Ice::Int, ::Util::string_view>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpCustomIntStringDictResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpCustomIntStringDictResult, P>(false, this, &InitialPrx::_iceI_opCustomIntStringDict, p1, context);
    }

    ::std::function<void()>
    opCustomIntStringDictAsync(const std::optional<::std::map< ::Ice::Int, ::Util::string_view>>& p1,
                               ::std::function<void(std::optional<::std::map< ::Ice::Int, ::Util::string_view>>, std::optional<::std::map< ::Ice::Int, ::Util::string_view>>)> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opCustomIntStringDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpCustomIntStringDictResult>>&, const std::optional<::std::map< ::Ice::Int, ::Util::string_view>>&, const ::Ice::Context&);
    /// \endcond

    std::optional<IntOneOptionalDict> opIntOneOptionalDict(const std::optional<IntOneOptionalDict>& p1, std::optional<IntOneOptionalDict>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpIntOneOptionalDictResult>(true, this, &InitialPrx::_iceI_opIntOneOptionalDict, p1, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opIntOneOptionalDictAsync(const std::optional<IntOneOptionalDict>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpIntOneOptionalDictResult>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpIntOneOptionalDictResult, P>(false, this, &InitialPrx::_iceI_opIntOneOptionalDict, p1, context);
    }

    ::std::function<void()>
    opIntOneOptionalDictAsync(const std::optional<IntOneOptionalDict>& p1,
                              ::std::function<void(std::optional<::Test::IntOneOptionalDict>, std::optional<::Test::IntOneOptionalDict>)> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpIntOneOptionalDictResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLambdaOutgoing<Initial::OpIntOneOptionalDictResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opIntOneOptionalDict, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opIntOneOptionalDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpIntOneOptionalDictResult>>&, const std::optional<IntOneOptionalDict>&, const ::Ice::Context&);
    /// \endcond

    void opClassAndUnknownOptional(const ::std::shared_ptr<A>& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &InitialPrx::_iceI_opClassAndUnknownOptional, p, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opClassAndUnknownOptionalAsync(const ::std::shared_ptr<A>& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &InitialPrx::_iceI_opClassAndUnknownOptional, p, context);
    }

    ::std::function<void()>
    opClassAndUnknownOptionalAsync(const ::std::shared_ptr<A>& p,
                                   ::std::function<void()> response,
                                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                   ::std::function<void(bool)> sent = nullptr,
                                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opClassAndUnknownOptional, p, context);
    }

    /// \cond INTERNAL
    void _iceI_opClassAndUnknownOptional(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<A>&, const ::Ice::Context&);
    /// \endcond

    void sendOptionalClass(bool req, const std::optional<::std::shared_ptr<OneOptional>>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &InitialPrx::_iceI_sendOptionalClass, req, o, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto sendOptionalClassAsync(bool req, const std::optional<::std::shared_ptr<OneOptional>>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &InitialPrx::_iceI_sendOptionalClass, req, o, context);
    }

    ::std::function<void()>
    sendOptionalClassAsync(bool req, const std::optional<::std::shared_ptr<OneOptional>>& o,
                           ::std::function<void()> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_sendOptionalClass, req, o, context);
    }

    /// \cond INTERNAL
    void _iceI_sendOptionalClass(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, bool, const std::optional<::std::shared_ptr<OneOptional>>&, const ::Ice::Context&);
    /// \endcond

    void returnOptionalClass(bool req, std::optional<::std::shared_ptr<OneOptional>>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        o = _makePromiseOutgoing<std::optional<::std::shared_ptr<::Test::OneOptional>>>(true, this, &InitialPrx::_iceI_returnOptionalClass, req, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto returnOptionalClassAsync(bool req, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<std::optional<::std::shared_ptr<::Test::OneOptional>>>>().get_future())
    {
        return _makePromiseOutgoing<std::optional<::std::shared_ptr<::Test::OneOptional>>, P>(false, this, &InitialPrx::_iceI_returnOptionalClass, req, context);
    }

    ::std::function<void()>
    returnOptionalClassAsync(bool req,
                             ::std::function<void(std::optional<::std::shared_ptr<::Test::OneOptional>>)> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<std::optional<::std::shared_ptr<::Test::OneOptional>>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_returnOptionalClass, req, context);
    }

    /// \cond INTERNAL
    void _iceI_returnOptionalClass(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<std::optional<::std::shared_ptr<::Test::OneOptional>>>>&, bool, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<G> opG(const ::std::shared_ptr<G>& g, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::G>>(true, this, &InitialPrx::_iceI_opG, g, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opGAsync(const ::std::shared_ptr<G>& g, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::G>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::G>, P>(false, this, &InitialPrx::_iceI_opG, g, context);
    }

    ::std::function<void()>
    opGAsync(const ::std::shared_ptr<G>& g,
             ::std::function<void(::std::shared_ptr<::Test::G>)> response,
             ::std::function<void(::std::exception_ptr)> ex = nullptr,
             ::std::function<void(bool)> sent = nullptr,
             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::G>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opG, g, context);
    }

    /// \cond INTERNAL
    void _iceI_opG(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::G>>>&, const ::std::shared_ptr<G>&, const ::Ice::Context&);
    /// \endcond

    void opVoid(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &InitialPrx::_iceI_opVoid, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opVoidAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &InitialPrx::_iceI_opVoid, context);
    }

    ::std::function<void()>
    opVoidAsync(::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opVoid, context);
    }

    /// \cond INTERNAL
    void _iceI_opVoid(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    std::optional<SmallStruct> opMStruct1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<std::optional<::Test::SmallStruct>>(true, this, &InitialPrx::_iceI_opMStruct1, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opMStruct1Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<std::optional<::Test::SmallStruct>>>().get_future())
    {
        return _makePromiseOutgoing<std::optional<::Test::SmallStruct>, P>(false, this, &InitialPrx::_iceI_opMStruct1, context);
    }

    ::std::function<void()>
    opMStruct1Async(::std::function<void(std::optional<::Test::SmallStruct>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<std::optional<::Test::SmallStruct>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opMStruct1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMStruct1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<std::optional<::Test::SmallStruct>>>&, const ::Ice::Context&);
    /// \endcond

    std::optional<SmallStruct> opMStruct2(const std::optional<SmallStruct>& p1, std::optional<SmallStruct>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpMStruct2Result>(true, this, &InitialPrx::_iceI_opMStruct2, p1, context).get();
        p2 = ::std::move(_result.p2);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opMStruct2Async(const std::optional<SmallStruct>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpMStruct2Result>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpMStruct2Result, P>(false, this, &InitialPrx::_iceI_opMStruct2, p1, context);
    }

    ::std::function<void()>
    opMStruct2Async(const std::optional<SmallStruct>& p1,
                    ::std::function<void(std::optional<::Test::SmallStruct>, std::optional<::Test::SmallStruct>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpMStruct2Result&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p2));
        };
        return _makeLambdaOutgoing<Initial::OpMStruct2Result>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opMStruct2, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMStruct2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpMStruct2Result>>&, const std::optional<SmallStruct>&, const ::Ice::Context&);
    /// \endcond

    std::optional<StringSeq> opMSeq1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<std::optional<::Test::StringSeq>>(true, this, &InitialPrx::_iceI_opMSeq1, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opMSeq1Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<std::optional<::Test::StringSeq>>>().get_future())
    {
        return _makePromiseOutgoing<std::optional<::Test::StringSeq>, P>(false, this, &InitialPrx::_iceI_opMSeq1, context);
    }

    ::std::function<void()>
    opMSeq1Async(::std::function<void(std::optional<::Test::StringSeq>)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<std::optional<::Test::StringSeq>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opMSeq1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMSeq1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<std::optional<::Test::StringSeq>>>&, const ::Ice::Context&);
    /// \endcond

    std::optional<StringSeq> opMSeq2(const std::optional<StringSeq>& p1, std::optional<StringSeq>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpMSeq2Result>(true, this, &InitialPrx::_iceI_opMSeq2, p1, context).get();
        p2 = ::std::move(_result.p2);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opMSeq2Async(const std::optional<StringSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpMSeq2Result>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpMSeq2Result, P>(false, this, &InitialPrx::_iceI_opMSeq2, p1, context);
    }

    ::std::function<void()>
    opMSeq2Async(const std::optional<StringSeq>& p1,
                 ::std::function<void(std::optional<::Test::StringSeq>, std::optional<::Test::StringSeq>)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpMSeq2Result&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p2));
        };
        return _makeLambdaOutgoing<Initial::OpMSeq2Result>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opMSeq2, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMSeq2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpMSeq2Result>>&, const std::optional<StringSeq>&, const ::Ice::Context&);
    /// \endcond

    std::optional<StringIntDict> opMDict1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<std::optional<::Test::StringIntDict>>(true, this, &InitialPrx::_iceI_opMDict1, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opMDict1Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<std::optional<::Test::StringIntDict>>>().get_future())
    {
        return _makePromiseOutgoing<std::optional<::Test::StringIntDict>, P>(false, this, &InitialPrx::_iceI_opMDict1, context);
    }

    ::std::function<void()>
    opMDict1Async(::std::function<void(std::optional<::Test::StringIntDict>)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<std::optional<::Test::StringIntDict>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opMDict1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMDict1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<std::optional<::Test::StringIntDict>>>&, const ::Ice::Context&);
    /// \endcond

    std::optional<StringIntDict> opMDict2(const std::optional<StringIntDict>& p1, std::optional<StringIntDict>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpMDict2Result>(true, this, &InitialPrx::_iceI_opMDict2, p1, context).get();
        p2 = ::std::move(_result.p2);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opMDict2Async(const std::optional<StringIntDict>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpMDict2Result>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpMDict2Result, P>(false, this, &InitialPrx::_iceI_opMDict2, p1, context);
    }

    ::std::function<void()>
    opMDict2Async(const std::optional<StringIntDict>& p1,
                  ::std::function<void(std::optional<::Test::StringIntDict>, std::optional<::Test::StringIntDict>)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpMDict2Result&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p2));
        };
        return _makeLambdaOutgoing<Initial::OpMDict2Result>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opMDict2, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMDict2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpMDict2Result>>&, const std::optional<StringIntDict>&, const ::Ice::Context&);
    /// \endcond

    std::optional<::std::shared_ptr<G>> opMG1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<std::optional<::std::shared_ptr<::Test::G>>>(true, this, &InitialPrx::_iceI_opMG1, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opMG1Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<std::optional<::std::shared_ptr<::Test::G>>>>().get_future())
    {
        return _makePromiseOutgoing<std::optional<::std::shared_ptr<::Test::G>>, P>(false, this, &InitialPrx::_iceI_opMG1, context);
    }

    ::std::function<void()>
    opMG1Async(::std::function<void(std::optional<::std::shared_ptr<::Test::G>>)> response,
               ::std::function<void(::std::exception_ptr)> ex = nullptr,
               ::std::function<void(bool)> sent = nullptr,
               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<std::optional<::std::shared_ptr<::Test::G>>>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opMG1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMG1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<std::optional<::std::shared_ptr<::Test::G>>>>&, const ::Ice::Context&);
    /// \endcond

    std::optional<::std::shared_ptr<G>> opMG2(const std::optional<::std::shared_ptr<G>>& p1, std::optional<::std::shared_ptr<G>>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Initial::OpMG2Result>(true, this, &InitialPrx::_iceI_opMG2, p1, context).get();
        p2 = ::std::move(_result.p2);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opMG2Async(const std::optional<::std::shared_ptr<G>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Initial::OpMG2Result>>().get_future())
    {
        return _makePromiseOutgoing<Initial::OpMG2Result, P>(false, this, &InitialPrx::_iceI_opMG2, p1, context);
    }

    ::std::function<void()>
    opMG2Async(const std::optional<::std::shared_ptr<G>>& p1,
               ::std::function<void(std::optional<::std::shared_ptr<::Test::G>>, std::optional<::std::shared_ptr<::Test::G>>)> response,
               ::std::function<void(::std::exception_ptr)> ex = nullptr,
               ::std::function<void(bool)> sent = nullptr,
               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Initial::OpMG2Result&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p2));
        };
        return _makeLambdaOutgoing<Initial::OpMG2Result>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_opMG2, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMG2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Initial::OpMG2Result>>&, const std::optional<::std::shared_ptr<G>>&, const ::Ice::Context&);
    /// \endcond

    bool supportsRequiredParams(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &InitialPrx::_iceI_supportsRequiredParams, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto supportsRequiredParamsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &InitialPrx::_iceI_supportsRequiredParams, context);
    }

    ::std::function<void()>
    supportsRequiredParamsAsync(::std::function<void(bool)> response,
                                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                ::std::function<void(bool)> sent = nullptr,
                                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_supportsRequiredParams, context);
    }

    /// \cond INTERNAL
    void _iceI_supportsRequiredParams(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    bool supportsJavaSerializable(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &InitialPrx::_iceI_supportsJavaSerializable, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto supportsJavaSerializableAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &InitialPrx::_iceI_supportsJavaSerializable, context);
    }

    ::std::function<void()>
    supportsJavaSerializableAsync(::std::function<void(bool)> response,
                                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                  ::std::function<void(bool)> sent = nullptr,
                                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_supportsJavaSerializable, context);
    }

    /// \cond INTERNAL
    void _iceI_supportsJavaSerializable(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    bool supportsCsharpSerializable(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &InitialPrx::_iceI_supportsCsharpSerializable, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto supportsCsharpSerializableAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &InitialPrx::_iceI_supportsCsharpSerializable, context);
    }

    ::std::function<void()>
    supportsCsharpSerializableAsync(::std::function<void(bool)> response,
                                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                    ::std::function<void(bool)> sent = nullptr,
                                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_supportsCsharpSerializable, context);
    }

    /// \cond INTERNAL
    void _iceI_supportsCsharpSerializable(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    bool supportsCppStringView(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &InitialPrx::_iceI_supportsCppStringView, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto supportsCppStringViewAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &InitialPrx::_iceI_supportsCppStringView, context);
    }

    ::std::function<void()>
    supportsCppStringViewAsync(::std::function<void(bool)> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_supportsCppStringView, context);
    }

    /// \cond INTERNAL
    void _iceI_supportsCppStringView(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    bool supportsNullOptional(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &InitialPrx::_iceI_supportsNullOptional, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto supportsNullOptionalAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &InitialPrx::_iceI_supportsNullOptional, context);
    }

    ::std::function<void()>
    supportsNullOptionalAsync(::std::function<void(bool)> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &Test::InitialPrx::_iceI_supportsNullOptional, context);
    }

    /// \cond INTERNAL
    void _iceI_supportsNullOptional(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    InitialPrx() = default;
    friend ::std::shared_ptr<InitialPrx> IceInternal::createProxy<InitialPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamWriter<::Test::OneOptional, S>
{
    static void write(S* ostr, const ::Test::OneOptional& v)
    {
        ostr->writeAll({1}, v.a);
    }
};

template<typename S>
struct StreamReader<::Test::OneOptional, S>
{
    static void read(S* istr, ::Test::OneOptional& v)
    {
        istr->readAll({1}, v.a);
    }
};

template<>
struct StreamableTraits< ::Test::MyEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 0;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::Test::SmallStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::Test::SmallStruct, S>
{
    static void read(S* istr, ::Test::SmallStruct& v)
    {
        istr->readAll(v.m);
    }
};

template<>
struct StreamableTraits<::Test::FixedStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::Test::FixedStruct, S>
{
    static void read(S* istr, ::Test::FixedStruct& v)
    {
        istr->readAll(v.m);
    }
};

template<>
struct StreamableTraits<::Test::VarStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::VarStruct, S>
{
    static void read(S* istr, ::Test::VarStruct& v)
    {
        istr->readAll(v.m);
    }
};

template<>
struct StreamableTraits<::Test::ClassVarStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::Test::ClassVarStruct, S>
{
    static void read(S* istr, ::Test::ClassVarStruct& v)
    {
        istr->readAll(v.a);
    }
};

template<typename S>
struct StreamWriter<::Test::MultiOptional, S>
{
    static void write(S* ostr, const ::Test::MultiOptional& v)
    {
        ostr->writeAll({1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30}, v.a, v.b, v.c, v.d, v.e, v.f, v.g, v.h, v.i, v.j, v.k, v.bs, v.ss, v.iid, v.sid, v.fs, v.vs, v.shs, v.es, v.fss, v.vss, v.oos, v.mips, v.ied, v.ifsd, v.ivsd, v.iood, v.imipd, v.bos, v.ser);
    }
};

template<typename S>
struct StreamReader<::Test::MultiOptional, S>
{
    static void read(S* istr, ::Test::MultiOptional& v)
    {
        istr->readAll({1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30}, v.a, v.b, v.c, v.d, v.e, v.f, v.g, v.h, v.i, v.j, v.k, v.bs, v.ss, v.iid, v.sid, v.fs, v.vs, v.shs, v.es, v.fss, v.vss, v.oos, v.mips, v.ied, v.ifsd, v.ivsd, v.iood, v.imipd, v.bos, v.ser);
    }
};

template<typename S>
struct StreamWriter<::Test::A, S>
{
    static void write(S* ostr, const ::Test::A& v)
    {
        ostr->writeAll(v.requiredA);
        ostr->writeAll({1, 50, 500}, v.ma, v.mb, v.mc);
    }
};

template<typename S>
struct StreamReader<::Test::A, S>
{
    static void read(S* istr, ::Test::A& v)
    {
        istr->readAll(v.requiredA);
        istr->readAll({1, 50, 500}, v.ma, v.mb, v.mc);
    }
};

template<typename S>
struct StreamWriter<::Test::B, S>
{
    static void write(S* ostr, const ::Test::B& v)
    {
        ostr->writeAll(v.requiredB);
        ostr->writeAll({10}, v.md);
    }
};

template<typename S>
struct StreamReader<::Test::B, S>
{
    static void read(S* istr, ::Test::B& v)
    {
        istr->readAll(v.requiredB);
        istr->readAll({10}, v.md);
    }
};

template<typename S>
struct StreamWriter<::Test::C, S>
{
    static void write(S* ostr, const ::Test::C& v)
    {
        ostr->writeAll(v.ss);
        ostr->writeAll({890}, v.ms);
    }
};

template<typename S>
struct StreamReader<::Test::C, S>
{
    static void read(S* istr, ::Test::C& v)
    {
        istr->readAll(v.ss);
        istr->readAll({890}, v.ms);
    }
};

template<typename S>
struct StreamWriter<::Test::WD, S>
{
    static void write(S* ostr, const ::Test::WD& v)
    {
        ostr->writeAll({1, 2}, v.a, v.s);
    }
};

template<typename S>
struct StreamReader<::Test::WD, S>
{
    static void read(S* istr, ::Test::WD& v)
    {
        istr->readAll({1, 2}, v.a, v.s);
    }
};

template<typename S>
struct StreamWriter<::Test::OptionalException, S>
{
    static void write(S* ostr, const ::Test::OptionalException& v)
    {
        ostr->writeAll(v.req);
        ostr->writeAll({1, 2, 50}, v.a, v.b, v.o);
    }
};

template<typename S>
struct StreamReader<::Test::OptionalException, S>
{
    static void read(S* istr, ::Test::OptionalException& v)
    {
        istr->readAll(v.req);
        istr->readAll({1, 2, 50}, v.a, v.b, v.o);
    }
};

template<typename S>
struct StreamWriter<::Test::DerivedException, S>
{
    static void write(S* ostr, const ::Test::DerivedException& v)
    {
        ostr->writeAll(v.d1, v.d2);
        ostr->writeAll({600, 601}, v.ss, v.o2);
    }
};

template<typename S>
struct StreamReader<::Test::DerivedException, S>
{
    static void read(S* istr, ::Test::DerivedException& v)
    {
        istr->readAll(v.d1, v.d2);
        istr->readAll({600, 601}, v.ss, v.o2);
    }
};

template<typename S>
struct StreamWriter<::Test::RequiredException, S>
{
    static void write(S* ostr, const ::Test::RequiredException& v)
    {
        ostr->writeAll(v.ss, v.o2);
    }
};

template<typename S>
struct StreamReader<::Test::RequiredException, S>
{
    static void read(S* istr, ::Test::RequiredException& v)
    {
        istr->readAll(v.ss, v.o2);
    }
};

template<typename S>
struct StreamWriter<::Test::OptionalWithCustom, S>
{
    static void write(S* ostr, const ::Test::OptionalWithCustom& v)
    {
        ostr->writeAll({1, 2, 3}, v.l, v.lp, v.s);
    }
};

template<typename S>
struct StreamReader<::Test::OptionalWithCustom, S>
{
    static void read(S* istr, ::Test::OptionalWithCustom& v)
    {
        istr->readAll({1, 2, 3}, v.l, v.lp, v.s);
    }
};

template<typename S>
struct StreamReader<::Test::E, S>
{
    static void read(S* istr, ::Test::E& v)
    {
        istr->readAll(v.ae);
    }
};

template<typename S>
struct StreamWriter<::Test::F, S>
{
    static void write(S* ostr, const ::Test::F& v)
    {
        ostr->writeAll({1}, v.af);
    }
};

template<typename S>
struct StreamReader<::Test::F, S>
{
    static void read(S* istr, ::Test::F& v)
    {
        istr->readAll({1}, v.af);
    }
};

template<typename S>
struct StreamReader<::Test::G1, S>
{
    static void read(S* istr, ::Test::G1& v)
    {
        istr->readAll(v.a);
    }
};

template<typename S>
struct StreamReader<::Test::G2, S>
{
    static void read(S* istr, ::Test::G2& v)
    {
        istr->readAll(v.a);
    }
};

template<typename S>
struct StreamWriter<::Test::G, S>
{
    static void write(S* ostr, const ::Test::G& v)
    {
        ostr->writeAll(v.gg2, v.gg1);
        ostr->writeAll({0, 1}, v.gg2Opt, v.gg1Opt);
    }
};

template<typename S>
struct StreamReader<::Test::G, S>
{
    static void read(S* istr, ::Test::G& v)
    {
        istr->readAll(v.gg2, v.gg1);
        istr->readAll({0, 1}, v.gg2Opt, v.gg1Opt);
    }
};

template<typename S>
struct StreamWriter<::Test::Recursive, S>
{
    static void write(S* ostr, const ::Test::Recursive& v)
    {
        ostr->writeAll({0}, v.value);
    }
};

template<typename S>
struct StreamReader<::Test::Recursive, S>
{
    static void read(S* istr, ::Test::Recursive& v)
    {
        istr->readAll({0}, v.value);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace Test
{

using OneOptionalPtr = ::std::shared_ptr<OneOptional>;

using MyInterfacePtr = ::std::shared_ptr<MyInterface>;
using MyInterfacePrxPtr = ::std::shared_ptr<MyInterfacePrx>;

using MultiOptionalPtr = ::std::shared_ptr<MultiOptional>;

using APtr = ::std::shared_ptr<A>;

using BPtr = ::std::shared_ptr<B>;

using CPtr = ::std::shared_ptr<C>;

using WDPtr = ::std::shared_ptr<WD>;

using OptionalWithCustomPtr = ::std::shared_ptr<OptionalWithCustom>;

using EPtr = ::std::shared_ptr<E>;

using FPtr = ::std::shared_ptr<F>;

using G1Ptr = ::std::shared_ptr<G1>;

using G2Ptr = ::std::shared_ptr<G2>;

using GPtr = ::std::shared_ptr<G>;

using RecursivePtr = ::std::shared_ptr<Recursive>;

using InitialPtr = ::std::shared_ptr<Initial>;
using InitialPrxPtr = ::std::shared_ptr<InitialPrx>;

}
/// \endcond

#include <IceUtil/PopDisableWarnings.h>
#endif
