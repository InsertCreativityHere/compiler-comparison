//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Test_h__
#define __Test_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <IceUtil/UndefSysMacros.h>
#include <list>
#include <CustomMap.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace Test
{

class OneOptional;

using OneOptionalPtr = ::std::shared_ptr<OneOptional>;
class MyInterfacePrx;

enum class MyEnum : unsigned char
{
    MyEnumMember
};
struct SmallStruct;
struct FixedStruct;
struct VarStruct;

using ByteSeq = ::std::vector<std::byte>;

using BoolSeq = ::std::vector<bool>;

using ShortSeq = ::std::vector<::std::int16_t>;

using IntSeq = ::std::vector<::std::int32_t>;

using LongSeq = ::std::vector<::std::int64_t>;

using FloatSeq = ::std::vector<float>;

using DoubleSeq = ::std::vector<double>;

using StringSeq = ::std::vector<::std::string>;

using MyEnumSeq = ::std::vector<MyEnum>;

using SmallStructSeq = ::std::vector<SmallStruct>;

using SmallStructList = std::list< ::Test::SmallStruct>;

using FixedStructSeq = ::std::vector<FixedStruct>;

using FixedStructList = std::list< ::Test::FixedStruct>;

using VarStructSeq = ::std::vector<VarStruct>;

using OneOptionalSeq = ::std::vector<::std::shared_ptr<OneOptional>>;

using MyInterfacePrxSeq = ::std::vector<::std::optional<MyInterfacePrx>>;

using Serializable = ::std::vector<std::byte>;

using IntIntDict = ::std::map<::std::int32_t, ::std::int32_t>;

using StringIntDict = ::std::map<::std::string, ::std::int32_t>;

using IntEnumDict = ::std::map<::std::int32_t, MyEnum>;

using IntFixedStructDict = ::std::map<::std::int32_t, FixedStruct>;

using IntVarStructDict = ::std::map<::std::int32_t, VarStruct>;

using IntOneOptionalDict = ::std::map<::std::int32_t, ::std::shared_ptr<OneOptional>>;

using IntMyInterfacePrxDict = ::std::map<::std::int32_t, ::std::optional<MyInterfacePrx>>;

using IntStringDict = Test::CustomMap<std::int32_t, std::string>;
class MultiOptional;

using MultiOptionalPtr = ::std::shared_ptr<MultiOptional>;
class A;

using APtr = ::std::shared_ptr<A>;
class B;

using BPtr = ::std::shared_ptr<B>;
class C;

using CPtr = ::std::shared_ptr<C>;
class WD;

using WDPtr = ::std::shared_ptr<WD>;
class OptionalWithCustom;

using OptionalWithCustomPtr = ::std::shared_ptr<OptionalWithCustom>;
class E;

using EPtr = ::std::shared_ptr<E>;
class F;

using FPtr = ::std::shared_ptr<F>;
class G1;

using G1Ptr = ::std::shared_ptr<G1>;
class G2;

using G2Ptr = ::std::shared_ptr<G2>;
class G;

using GPtr = ::std::shared_ptr<G>;
class Recursive;

using RecursivePtr = ::std::shared_ptr<Recursive>;

using RecursiveSeq = ::std::vector<::std::shared_ptr<Recursive>>;
class InitialPrx;

}

namespace Test
{

class MyInterfacePrx : public ::Ice::Proxy<MyInterfacePrx, ::Ice::ObjectPrx>
{
public:

    void op(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> opAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_op(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    explicit MyInterfacePrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    MyInterfacePrx(const MyInterfacePrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    MyInterfacePrx(MyInterfacePrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    MyInterfacePrx(const ::std::shared_ptr<::Ice::Communicator>& communicator, std::string_view proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    MyInterfacePrx& operator=(const MyInterfacePrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    MyInterfacePrx& operator=(MyInterfacePrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static MyInterfacePrx _fromReference(::IceInternal::ReferencePtr ref) { return MyInterfacePrx(::std::move(ref)); }

protected:

    MyInterfacePrx() = default;

    explicit MyInterfacePrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond
};

class InitialPrx : public ::Ice::Proxy<InitialPrx, ::Ice::ObjectPrx>
{
public:

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> shutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    shutdownAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<::Ice::Value> pingPong(const ::std::shared_ptr<::Ice::Value>& o, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<::Ice::Value>> pingPongAsync(const ::std::shared_ptr<::Ice::Value>& o, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    pingPongAsync(const ::std::shared_ptr<::Ice::Value>& o, ::std::function<void(::std::shared_ptr<::Ice::Value>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_pingPong(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Ice::Value>>>&, const ::std::shared_ptr<::Ice::Value>&, const ::Ice::Context&) const;
    /// \endcond

    void opOptionalException(::std::optional<::std::int32_t> a, ::std::optional<::std::string_view> b, const ::std::optional<::std::shared_ptr<OneOptional>>& o, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> opOptionalExceptionAsync(::std::optional<::std::int32_t> a, ::std::optional<::std::string_view> b, const ::std::optional<::std::shared_ptr<OneOptional>>& o, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opOptionalExceptionAsync(::std::optional<::std::int32_t> a, ::std::optional<::std::string_view> b, const ::std::optional<::std::shared_ptr<OneOptional>>& o, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opOptionalException(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, ::std::optional<::std::int32_t>, ::std::optional<::std::string_view>, const ::std::optional<::std::shared_ptr<OneOptional>>&, const ::Ice::Context&) const;
    /// \endcond

    void opDerivedException(::std::optional<::std::int32_t> a, ::std::optional<::std::string_view> b, const ::std::optional<::std::shared_ptr<OneOptional>>& o, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> opDerivedExceptionAsync(::std::optional<::std::int32_t> a, ::std::optional<::std::string_view> b, const ::std::optional<::std::shared_ptr<OneOptional>>& o, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opDerivedExceptionAsync(::std::optional<::std::int32_t> a, ::std::optional<::std::string_view> b, const ::std::optional<::std::shared_ptr<OneOptional>>& o, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opDerivedException(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, ::std::optional<::std::int32_t>, ::std::optional<::std::string_view>, const ::std::optional<::std::shared_ptr<OneOptional>>&, const ::Ice::Context&) const;
    /// \endcond

    void opRequiredException(::std::optional<::std::int32_t> a, ::std::optional<::std::string_view> b, const ::std::optional<::std::shared_ptr<OneOptional>>& o, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> opRequiredExceptionAsync(::std::optional<::std::int32_t> a, ::std::optional<::std::string_view> b, const ::std::optional<::std::shared_ptr<OneOptional>>& o, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opRequiredExceptionAsync(::std::optional<::std::int32_t> a, ::std::optional<::std::string_view> b, const ::std::optional<::std::shared_ptr<OneOptional>>& o, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opRequiredException(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, ::std::optional<::std::int32_t>, ::std::optional<::std::string_view>, const ::std::optional<::std::shared_ptr<OneOptional>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<::std::uint8_t> opByte(::std::optional<::std::uint8_t> p1, ::std::optional<::std::uint8_t>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<::std::uint8_t>, ::std::optional<::std::uint8_t>>> opByteAsync(::std::optional<::std::uint8_t> p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opByteAsync(::std::optional<::std::uint8_t> p1, ::std::function<void(::std::optional<::std::uint8_t>, ::std::optional<::std::uint8_t>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opByte(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<::std::uint8_t>, ::std::optional<::std::uint8_t>>>>&, ::std::optional<::std::uint8_t>, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<bool> opBool(::std::optional<bool> p1, ::std::optional<bool>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<bool>, ::std::optional<bool>>> opBoolAsync(::std::optional<bool> p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opBoolAsync(::std::optional<bool> p1, ::std::function<void(::std::optional<bool>, ::std::optional<bool>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opBool(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<bool>, ::std::optional<bool>>>>&, ::std::optional<bool>, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<::std::int16_t> opShort(::std::optional<::std::int16_t> p1, ::std::optional<::std::int16_t>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<::std::int16_t>, ::std::optional<::std::int16_t>>> opShortAsync(::std::optional<::std::int16_t> p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opShortAsync(::std::optional<::std::int16_t> p1, ::std::function<void(::std::optional<::std::int16_t>, ::std::optional<::std::int16_t>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opShort(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<::std::int16_t>, ::std::optional<::std::int16_t>>>>&, ::std::optional<::std::int16_t>, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<::std::int32_t> opInt(::std::optional<::std::int32_t> p1, ::std::optional<::std::int32_t>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<::std::int32_t>, ::std::optional<::std::int32_t>>> opIntAsync(::std::optional<::std::int32_t> p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opIntAsync(::std::optional<::std::int32_t> p1, ::std::function<void(::std::optional<::std::int32_t>, ::std::optional<::std::int32_t>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opInt(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<::std::int32_t>, ::std::optional<::std::int32_t>>>>&, ::std::optional<::std::int32_t>, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<::std::int64_t> opLong(::std::optional<::std::int64_t> p1, ::std::optional<::std::int64_t>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<::std::int64_t>, ::std::optional<::std::int64_t>>> opLongAsync(::std::optional<::std::int64_t> p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opLongAsync(::std::optional<::std::int64_t> p1, ::std::function<void(::std::optional<::std::int64_t>, ::std::optional<::std::int64_t>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opLong(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<::std::int64_t>, ::std::optional<::std::int64_t>>>>&, ::std::optional<::std::int64_t>, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<float> opFloat(::std::optional<float> p1, ::std::optional<float>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<float>, ::std::optional<float>>> opFloatAsync(::std::optional<float> p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opFloatAsync(::std::optional<float> p1, ::std::function<void(::std::optional<float>, ::std::optional<float>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opFloat(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<float>, ::std::optional<float>>>>&, ::std::optional<float>, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<double> opDouble(::std::optional<double> p1, ::std::optional<double>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<double>, ::std::optional<double>>> opDoubleAsync(::std::optional<double> p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opDoubleAsync(::std::optional<double> p1, ::std::function<void(::std::optional<double>, ::std::optional<double>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opDouble(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<double>, ::std::optional<double>>>>&, ::std::optional<double>, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<::std::string> opString(::std::optional<::std::string_view> p1, ::std::optional<::std::string>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<::std::string>, ::std::optional<::std::string>>> opStringAsync(::std::optional<::std::string_view> p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opStringAsync(::std::optional<::std::string_view> p1, ::std::function<void(::std::optional<::std::string>, ::std::optional<::std::string>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opString(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<::std::string>, ::std::optional<::std::string>>>>&, ::std::optional<::std::string_view>, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<MyEnum> opMyEnum(::std::optional<MyEnum> p1, ::std::optional<MyEnum>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<MyEnum>, ::std::optional<MyEnum>>> opMyEnumAsync(::std::optional<MyEnum> p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opMyEnumAsync(::std::optional<MyEnum> p1, ::std::function<void(::std::optional<::Test::MyEnum>, ::std::optional<::Test::MyEnum>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opMyEnum(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<MyEnum>, ::std::optional<MyEnum>>>>&, ::std::optional<MyEnum>, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<SmallStruct> opSmallStruct(const ::std::optional<SmallStruct>& p1, ::std::optional<SmallStruct>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<SmallStruct>, ::std::optional<SmallStruct>>> opSmallStructAsync(const ::std::optional<SmallStruct>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opSmallStructAsync(const ::std::optional<SmallStruct>& p1, ::std::function<void(::std::optional<::Test::SmallStruct>, ::std::optional<::Test::SmallStruct>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opSmallStruct(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<SmallStruct>, ::std::optional<SmallStruct>>>>&, const ::std::optional<SmallStruct>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<FixedStruct> opFixedStruct(const ::std::optional<FixedStruct>& p1, ::std::optional<FixedStruct>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<FixedStruct>, ::std::optional<FixedStruct>>> opFixedStructAsync(const ::std::optional<FixedStruct>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opFixedStructAsync(const ::std::optional<FixedStruct>& p1, ::std::function<void(::std::optional<::Test::FixedStruct>, ::std::optional<::Test::FixedStruct>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opFixedStruct(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<FixedStruct>, ::std::optional<FixedStruct>>>>&, const ::std::optional<FixedStruct>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<VarStruct> opVarStruct(const ::std::optional<VarStruct>& p1, ::std::optional<VarStruct>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<VarStruct>, ::std::optional<VarStruct>>> opVarStructAsync(const ::std::optional<VarStruct>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opVarStructAsync(const ::std::optional<VarStruct>& p1, ::std::function<void(::std::optional<::Test::VarStruct>, ::std::optional<::Test::VarStruct>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opVarStruct(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<VarStruct>, ::std::optional<VarStruct>>>>&, const ::std::optional<VarStruct>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<::std::shared_ptr<OneOptional>> opOneOptional(const ::std::optional<::std::shared_ptr<OneOptional>>& p1, ::std::optional<::std::shared_ptr<OneOptional>>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<::std::shared_ptr<OneOptional>>, ::std::optional<::std::shared_ptr<OneOptional>>>> opOneOptionalAsync(const ::std::optional<::std::shared_ptr<OneOptional>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opOneOptionalAsync(const ::std::optional<::std::shared_ptr<OneOptional>>& p1, ::std::function<void(::std::optional<::std::shared_ptr<::Test::OneOptional>>, ::std::optional<::std::shared_ptr<::Test::OneOptional>>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opOneOptional(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<::std::shared_ptr<OneOptional>>, ::std::optional<::std::shared_ptr<OneOptional>>>>>&, const ::std::optional<::std::shared_ptr<OneOptional>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<MyInterfacePrx> opMyInterfaceProxy(const ::std::optional<MyInterfacePrx>& p1, ::std::optional<MyInterfacePrx>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<MyInterfacePrx>, ::std::optional<MyInterfacePrx>>> opMyInterfaceProxyAsync(const ::std::optional<MyInterfacePrx>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opMyInterfaceProxyAsync(const ::std::optional<MyInterfacePrx>& p1, ::std::function<void(::std::optional<::Test::MyInterfacePrx>, ::std::optional<::Test::MyInterfacePrx>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opMyInterfaceProxy(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<MyInterfacePrx>, ::std::optional<MyInterfacePrx>>>>&, const ::std::optional<MyInterfacePrx>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<ByteSeq> opByteSeq(const ::std::optional<::std::pair<const std::byte*, const std::byte*>>& p1, ::std::optional<ByteSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<ByteSeq>, ::std::optional<ByteSeq>>> opByteSeqAsync(const ::std::optional<::std::pair<const std::byte*, const std::byte*>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opByteSeqAsync(const ::std::optional<::std::pair<const std::byte*, const std::byte*>>& p1, ::std::function<void(::std::optional<::std::pair<const std::byte*, const std::byte*>>, ::std::optional<::std::pair<const std::byte*, const std::byte*>>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<ByteSeq>, ::std::optional<ByteSeq>>>>&, const ::std::optional<::std::pair<const std::byte*, const std::byte*>>&, const ::Ice::Context&) const;
    /// \endcond

    /// \cond INTERNAL
    void _iceIL_opByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<::std::pair<const std::byte*, const std::byte*>>, ::std::optional<::std::pair<const std::byte*, const std::byte*>>>>>&, const ::std::optional<::std::pair<const std::byte*, const std::byte*>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<BoolSeq> opBoolSeq(const ::std::optional<::std::pair<const bool*, const bool*>>& p1, ::std::optional<BoolSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<BoolSeq>, ::std::optional<BoolSeq>>> opBoolSeqAsync(const ::std::optional<::std::pair<const bool*, const bool*>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opBoolSeqAsync(const ::std::optional<::std::pair<const bool*, const bool*>>& p1, ::std::function<void(::std::optional<::std::pair<const bool*, const bool*>>, ::std::optional<::std::pair<const bool*, const bool*>>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opBoolSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<BoolSeq>, ::std::optional<BoolSeq>>>>&, const ::std::optional<::std::pair<const bool*, const bool*>>&, const ::Ice::Context&) const;
    /// \endcond

    /// \cond INTERNAL
    void _iceIL_opBoolSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<::std::pair<const bool*, const bool*>>, ::std::optional<::std::pair<const bool*, const bool*>>>>>&, const ::std::optional<::std::pair<const bool*, const bool*>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<ShortSeq> opShortSeq(const ::std::optional<::std::pair<const ::std::int16_t*, const ::std::int16_t*>>& p1, ::std::optional<ShortSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<ShortSeq>, ::std::optional<ShortSeq>>> opShortSeqAsync(const ::std::optional<::std::pair<const ::std::int16_t*, const ::std::int16_t*>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opShortSeqAsync(const ::std::optional<::std::pair<const ::std::int16_t*, const ::std::int16_t*>>& p1, ::std::function<void(::std::optional<::std::pair<const ::std::int16_t*, const ::std::int16_t*>>, ::std::optional<::std::pair<const ::std::int16_t*, const ::std::int16_t*>>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opShortSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<ShortSeq>, ::std::optional<ShortSeq>>>>&, const ::std::optional<::std::pair<const ::std::int16_t*, const ::std::int16_t*>>&, const ::Ice::Context&) const;
    /// \endcond

    /// \cond INTERNAL
    void _iceIL_opShortSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<::std::pair<const ::std::int16_t*, const ::std::int16_t*>>, ::std::optional<::std::pair<const ::std::int16_t*, const ::std::int16_t*>>>>>&, const ::std::optional<::std::pair<const ::std::int16_t*, const ::std::int16_t*>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<IntSeq> opIntSeq(const ::std::optional<::std::pair<const ::std::int32_t*, const ::std::int32_t*>>& p1, ::std::optional<IntSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<IntSeq>, ::std::optional<IntSeq>>> opIntSeqAsync(const ::std::optional<::std::pair<const ::std::int32_t*, const ::std::int32_t*>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opIntSeqAsync(const ::std::optional<::std::pair<const ::std::int32_t*, const ::std::int32_t*>>& p1, ::std::function<void(::std::optional<::std::pair<const ::std::int32_t*, const ::std::int32_t*>>, ::std::optional<::std::pair<const ::std::int32_t*, const ::std::int32_t*>>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opIntSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<IntSeq>, ::std::optional<IntSeq>>>>&, const ::std::optional<::std::pair<const ::std::int32_t*, const ::std::int32_t*>>&, const ::Ice::Context&) const;
    /// \endcond

    /// \cond INTERNAL
    void _iceIL_opIntSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<::std::pair<const ::std::int32_t*, const ::std::int32_t*>>, ::std::optional<::std::pair<const ::std::int32_t*, const ::std::int32_t*>>>>>&, const ::std::optional<::std::pair<const ::std::int32_t*, const ::std::int32_t*>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<LongSeq> opLongSeq(const ::std::optional<::std::pair<const ::std::int64_t*, const ::std::int64_t*>>& p1, ::std::optional<LongSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<LongSeq>, ::std::optional<LongSeq>>> opLongSeqAsync(const ::std::optional<::std::pair<const ::std::int64_t*, const ::std::int64_t*>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opLongSeqAsync(const ::std::optional<::std::pair<const ::std::int64_t*, const ::std::int64_t*>>& p1, ::std::function<void(::std::optional<::std::pair<const ::std::int64_t*, const ::std::int64_t*>>, ::std::optional<::std::pair<const ::std::int64_t*, const ::std::int64_t*>>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opLongSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<LongSeq>, ::std::optional<LongSeq>>>>&, const ::std::optional<::std::pair<const ::std::int64_t*, const ::std::int64_t*>>&, const ::Ice::Context&) const;
    /// \endcond

    /// \cond INTERNAL
    void _iceIL_opLongSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<::std::pair<const ::std::int64_t*, const ::std::int64_t*>>, ::std::optional<::std::pair<const ::std::int64_t*, const ::std::int64_t*>>>>>&, const ::std::optional<::std::pair<const ::std::int64_t*, const ::std::int64_t*>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<FloatSeq> opFloatSeq(const ::std::optional<::std::pair<const float*, const float*>>& p1, ::std::optional<FloatSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<FloatSeq>, ::std::optional<FloatSeq>>> opFloatSeqAsync(const ::std::optional<::std::pair<const float*, const float*>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opFloatSeqAsync(const ::std::optional<::std::pair<const float*, const float*>>& p1, ::std::function<void(::std::optional<::std::pair<const float*, const float*>>, ::std::optional<::std::pair<const float*, const float*>>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opFloatSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<FloatSeq>, ::std::optional<FloatSeq>>>>&, const ::std::optional<::std::pair<const float*, const float*>>&, const ::Ice::Context&) const;
    /// \endcond

    /// \cond INTERNAL
    void _iceIL_opFloatSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<::std::pair<const float*, const float*>>, ::std::optional<::std::pair<const float*, const float*>>>>>&, const ::std::optional<::std::pair<const float*, const float*>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<DoubleSeq> opDoubleSeq(const ::std::optional<::std::pair<const double*, const double*>>& p1, ::std::optional<DoubleSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<DoubleSeq>, ::std::optional<DoubleSeq>>> opDoubleSeqAsync(const ::std::optional<::std::pair<const double*, const double*>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opDoubleSeqAsync(const ::std::optional<::std::pair<const double*, const double*>>& p1, ::std::function<void(::std::optional<::std::pair<const double*, const double*>>, ::std::optional<::std::pair<const double*, const double*>>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opDoubleSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<DoubleSeq>, ::std::optional<DoubleSeq>>>>&, const ::std::optional<::std::pair<const double*, const double*>>&, const ::Ice::Context&) const;
    /// \endcond

    /// \cond INTERNAL
    void _iceIL_opDoubleSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<::std::pair<const double*, const double*>>, ::std::optional<::std::pair<const double*, const double*>>>>>&, const ::std::optional<::std::pair<const double*, const double*>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<StringSeq> opStringSeq(const ::std::optional<StringSeq>& p1, ::std::optional<StringSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<StringSeq>, ::std::optional<StringSeq>>> opStringSeqAsync(const ::std::optional<StringSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opStringSeqAsync(const ::std::optional<StringSeq>& p1, ::std::function<void(::std::optional<::Test::StringSeq>, ::std::optional<::Test::StringSeq>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opStringSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<StringSeq>, ::std::optional<StringSeq>>>>&, const ::std::optional<StringSeq>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<SmallStructSeq> opSmallStructSeq(const ::std::optional<::std::pair<const SmallStruct*, const SmallStruct*>>& p1, ::std::optional<SmallStructSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<SmallStructSeq>, ::std::optional<SmallStructSeq>>> opSmallStructSeqAsync(const ::std::optional<::std::pair<const SmallStruct*, const SmallStruct*>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opSmallStructSeqAsync(const ::std::optional<::std::pair<const SmallStruct*, const SmallStruct*>>& p1, ::std::function<void(::std::optional<::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*>>, ::std::optional<::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*>>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opSmallStructSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<SmallStructSeq>, ::std::optional<SmallStructSeq>>>>&, const ::std::optional<::std::pair<const SmallStruct*, const SmallStruct*>>&, const ::Ice::Context&) const;
    /// \endcond

    /// \cond INTERNAL
    void _iceIL_opSmallStructSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<::std::pair<const SmallStruct*, const SmallStruct*>>, ::std::optional<::std::pair<const SmallStruct*, const SmallStruct*>>>>>&, const ::std::optional<::std::pair<const SmallStruct*, const SmallStruct*>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<SmallStructList> opSmallStructList(const ::std::optional<::std::pair<const SmallStruct*, const SmallStruct*>>& p1, ::std::optional<SmallStructList>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<SmallStructList>, ::std::optional<SmallStructList>>> opSmallStructListAsync(const ::std::optional<::std::pair<const SmallStruct*, const SmallStruct*>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opSmallStructListAsync(const ::std::optional<::std::pair<const SmallStruct*, const SmallStruct*>>& p1, ::std::function<void(::std::optional<::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*>>, ::std::optional<::std::pair<const ::Test::SmallStruct*, const ::Test::SmallStruct*>>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opSmallStructList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<SmallStructList>, ::std::optional<SmallStructList>>>>&, const ::std::optional<::std::pair<const SmallStruct*, const SmallStruct*>>&, const ::Ice::Context&) const;
    /// \endcond

    /// \cond INTERNAL
    void _iceIL_opSmallStructList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<::std::pair<const SmallStruct*, const SmallStruct*>>, ::std::optional<::std::pair<const SmallStruct*, const SmallStruct*>>>>>&, const ::std::optional<::std::pair<const SmallStruct*, const SmallStruct*>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<FixedStructSeq> opFixedStructSeq(const ::std::optional<::std::pair<const FixedStruct*, const FixedStruct*>>& p1, ::std::optional<FixedStructSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<FixedStructSeq>, ::std::optional<FixedStructSeq>>> opFixedStructSeqAsync(const ::std::optional<::std::pair<const FixedStruct*, const FixedStruct*>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opFixedStructSeqAsync(const ::std::optional<::std::pair<const FixedStruct*, const FixedStruct*>>& p1, ::std::function<void(::std::optional<::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*>>, ::std::optional<::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*>>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opFixedStructSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<FixedStructSeq>, ::std::optional<FixedStructSeq>>>>&, const ::std::optional<::std::pair<const FixedStruct*, const FixedStruct*>>&, const ::Ice::Context&) const;
    /// \endcond

    /// \cond INTERNAL
    void _iceIL_opFixedStructSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<::std::pair<const FixedStruct*, const FixedStruct*>>, ::std::optional<::std::pair<const FixedStruct*, const FixedStruct*>>>>>&, const ::std::optional<::std::pair<const FixedStruct*, const FixedStruct*>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<FixedStructList> opFixedStructList(const ::std::optional<::std::pair<const FixedStruct*, const FixedStruct*>>& p1, ::std::optional<FixedStructList>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<FixedStructList>, ::std::optional<FixedStructList>>> opFixedStructListAsync(const ::std::optional<::std::pair<const FixedStruct*, const FixedStruct*>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opFixedStructListAsync(const ::std::optional<::std::pair<const FixedStruct*, const FixedStruct*>>& p1, ::std::function<void(::std::optional<::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*>>, ::std::optional<::std::pair<const ::Test::FixedStruct*, const ::Test::FixedStruct*>>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opFixedStructList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<FixedStructList>, ::std::optional<FixedStructList>>>>&, const ::std::optional<::std::pair<const FixedStruct*, const FixedStruct*>>&, const ::Ice::Context&) const;
    /// \endcond

    /// \cond INTERNAL
    void _iceIL_opFixedStructList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<::std::pair<const FixedStruct*, const FixedStruct*>>, ::std::optional<::std::pair<const FixedStruct*, const FixedStruct*>>>>>&, const ::std::optional<::std::pair<const FixedStruct*, const FixedStruct*>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<VarStructSeq> opVarStructSeq(const ::std::optional<VarStructSeq>& p1, ::std::optional<VarStructSeq>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<VarStructSeq>, ::std::optional<VarStructSeq>>> opVarStructSeqAsync(const ::std::optional<VarStructSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opVarStructSeqAsync(const ::std::optional<VarStructSeq>& p1, ::std::function<void(::std::optional<::Test::VarStructSeq>, ::std::optional<::Test::VarStructSeq>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opVarStructSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<VarStructSeq>, ::std::optional<VarStructSeq>>>>&, const ::std::optional<VarStructSeq>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<Serializable> opSerializable(const ::std::optional<Serializable>& p1, ::std::optional<Serializable>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<Serializable>, ::std::optional<Serializable>>> opSerializableAsync(const ::std::optional<Serializable>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opSerializableAsync(const ::std::optional<Serializable>& p1, ::std::function<void(::std::optional<::Test::Serializable>, ::std::optional<::Test::Serializable>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opSerializable(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<Serializable>, ::std::optional<Serializable>>>>&, const ::std::optional<Serializable>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<IntIntDict> opIntIntDict(const ::std::optional<IntIntDict>& p1, ::std::optional<IntIntDict>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<IntIntDict>, ::std::optional<IntIntDict>>> opIntIntDictAsync(const ::std::optional<IntIntDict>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opIntIntDictAsync(const ::std::optional<IntIntDict>& p1, ::std::function<void(::std::optional<::Test::IntIntDict>, ::std::optional<::Test::IntIntDict>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opIntIntDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<IntIntDict>, ::std::optional<IntIntDict>>>>&, const ::std::optional<IntIntDict>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<StringIntDict> opStringIntDict(const ::std::optional<StringIntDict>& p1, ::std::optional<StringIntDict>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<StringIntDict>, ::std::optional<StringIntDict>>> opStringIntDictAsync(const ::std::optional<StringIntDict>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opStringIntDictAsync(const ::std::optional<StringIntDict>& p1, ::std::function<void(::std::optional<::Test::StringIntDict>, ::std::optional<::Test::StringIntDict>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opStringIntDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<StringIntDict>, ::std::optional<StringIntDict>>>>&, const ::std::optional<StringIntDict>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<IntOneOptionalDict> opIntOneOptionalDict(const ::std::optional<IntOneOptionalDict>& p1, ::std::optional<IntOneOptionalDict>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<IntOneOptionalDict>, ::std::optional<IntOneOptionalDict>>> opIntOneOptionalDictAsync(const ::std::optional<IntOneOptionalDict>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opIntOneOptionalDictAsync(const ::std::optional<IntOneOptionalDict>& p1, ::std::function<void(::std::optional<::Test::IntOneOptionalDict>, ::std::optional<::Test::IntOneOptionalDict>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opIntOneOptionalDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<IntOneOptionalDict>, ::std::optional<IntOneOptionalDict>>>>&, const ::std::optional<IntOneOptionalDict>&, const ::Ice::Context&) const;
    /// \endcond

    void opClassAndUnknownOptional(const ::std::shared_ptr<A>& p, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> opClassAndUnknownOptionalAsync(const ::std::shared_ptr<A>& p, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opClassAndUnknownOptionalAsync(const ::std::shared_ptr<A>& p, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opClassAndUnknownOptional(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<A>&, const ::Ice::Context&) const;
    /// \endcond

    void sendOptionalClass(bool req, const ::std::optional<::std::shared_ptr<OneOptional>>& o, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> sendOptionalClassAsync(bool req, const ::std::optional<::std::shared_ptr<OneOptional>>& o, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    sendOptionalClassAsync(bool req, const ::std::optional<::std::shared_ptr<OneOptional>>& o, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_sendOptionalClass(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, bool, const ::std::optional<::std::shared_ptr<OneOptional>>&, const ::Ice::Context&) const;
    /// \endcond

    void returnOptionalClass(bool req, ::std::optional<::std::shared_ptr<OneOptional>>& o, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::optional<::std::shared_ptr<OneOptional>>> returnOptionalClassAsync(bool req, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    returnOptionalClassAsync(bool req, ::std::function<void(::std::optional<::std::shared_ptr<::Test::OneOptional>>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_returnOptionalClass(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<::std::shared_ptr<OneOptional>>>>&, bool, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<G> opG(const ::std::shared_ptr<G>& g, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<G>> opGAsync(const ::std::shared_ptr<G>& g, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opGAsync(const ::std::shared_ptr<G>& g, ::std::function<void(::std::shared_ptr<::Test::G>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opG(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<G>>>&, const ::std::shared_ptr<G>&, const ::Ice::Context&) const;
    /// \endcond

    void opVoid(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> opVoidAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opVoidAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opVoid(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<SmallStruct> opMStruct1(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::optional<SmallStruct>> opMStruct1Async(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opMStruct1Async(::std::function<void(::std::optional<::Test::SmallStruct>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opMStruct1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<SmallStruct>>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<SmallStruct> opMStruct2(const ::std::optional<SmallStruct>& p1, ::std::optional<SmallStruct>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<SmallStruct>, ::std::optional<SmallStruct>>> opMStruct2Async(const ::std::optional<SmallStruct>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opMStruct2Async(const ::std::optional<SmallStruct>& p1, ::std::function<void(::std::optional<::Test::SmallStruct>, ::std::optional<::Test::SmallStruct>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opMStruct2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<SmallStruct>, ::std::optional<SmallStruct>>>>&, const ::std::optional<SmallStruct>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<StringSeq> opMSeq1(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::optional<StringSeq>> opMSeq1Async(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opMSeq1Async(::std::function<void(::std::optional<::Test::StringSeq>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opMSeq1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<StringSeq>>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<StringSeq> opMSeq2(const ::std::optional<StringSeq>& p1, ::std::optional<StringSeq>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<StringSeq>, ::std::optional<StringSeq>>> opMSeq2Async(const ::std::optional<StringSeq>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opMSeq2Async(const ::std::optional<StringSeq>& p1, ::std::function<void(::std::optional<::Test::StringSeq>, ::std::optional<::Test::StringSeq>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opMSeq2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<StringSeq>, ::std::optional<StringSeq>>>>&, const ::std::optional<StringSeq>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<StringIntDict> opMDict1(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::optional<StringIntDict>> opMDict1Async(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opMDict1Async(::std::function<void(::std::optional<::Test::StringIntDict>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opMDict1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<StringIntDict>>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<StringIntDict> opMDict2(const ::std::optional<StringIntDict>& p1, ::std::optional<StringIntDict>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<StringIntDict>, ::std::optional<StringIntDict>>> opMDict2Async(const ::std::optional<StringIntDict>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opMDict2Async(const ::std::optional<StringIntDict>& p1, ::std::function<void(::std::optional<::Test::StringIntDict>, ::std::optional<::Test::StringIntDict>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opMDict2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<StringIntDict>, ::std::optional<StringIntDict>>>>&, const ::std::optional<StringIntDict>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<::std::shared_ptr<G>> opMG1(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::optional<::std::shared_ptr<G>>> opMG1Async(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opMG1Async(::std::function<void(::std::optional<::std::shared_ptr<::Test::G>>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opMG1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<::std::shared_ptr<G>>>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::optional<::std::shared_ptr<G>> opMG2(const ::std::optional<::std::shared_ptr<G>>& p1, ::std::optional<::std::shared_ptr<G>>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::optional<::std::shared_ptr<G>>, ::std::optional<::std::shared_ptr<G>>>> opMG2Async(const ::std::optional<::std::shared_ptr<G>>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opMG2Async(const ::std::optional<::std::shared_ptr<G>>& p1, ::std::function<void(::std::optional<::std::shared_ptr<::Test::G>>, ::std::optional<::std::shared_ptr<::Test::G>>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opMG2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<::std::shared_ptr<G>>, ::std::optional<::std::shared_ptr<G>>>>>&, const ::std::optional<::std::shared_ptr<G>>&, const ::Ice::Context&) const;
    /// \endcond

    bool supportsRequiredParams(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<bool> supportsRequiredParamsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    supportsRequiredParamsAsync(::std::function<void(bool)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_supportsRequiredParams(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&) const;
    /// \endcond

    bool supportsJavaSerializable(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<bool> supportsJavaSerializableAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    supportsJavaSerializableAsync(::std::function<void(bool)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_supportsJavaSerializable(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&) const;
    /// \endcond

    bool supportsCsharpSerializable(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<bool> supportsCsharpSerializableAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    supportsCsharpSerializableAsync(::std::function<void(bool)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_supportsCsharpSerializable(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&) const;
    /// \endcond

    bool supportsNullOptional(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<bool> supportsNullOptionalAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    supportsNullOptionalAsync(::std::function<void(bool)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_supportsNullOptional(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    explicit InitialPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    InitialPrx(const InitialPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    InitialPrx(InitialPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    InitialPrx(const ::std::shared_ptr<::Ice::Communicator>& communicator, std::string_view proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    InitialPrx& operator=(const InitialPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    InitialPrx& operator=(InitialPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static InitialPrx _fromReference(::IceInternal::ReferencePtr ref) { return InitialPrx(::std::move(ref)); }

protected:

    InitialPrx() = default;

    explicit InitialPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond
};

}

namespace Test
{

class OneOptional : public ::Ice::ValueHelper<OneOptional, ::Ice::Value>
{
public:

    OneOptional() = default;
    OneOptional(const OneOptional&) = default;
    OneOptional(OneOptional&&) = default;
    OneOptional& operator=(const OneOptional&) = default;
    OneOptional& operator=(OneOptional&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit OneOptional(::std::optional<::std::int32_t> a) :
        a(a)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::optional<::std::int32_t>&> ice_tuple() const
    {
        return std::tie(a);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::optional<::std::int32_t> a;
};

/// \cond INTERNAL
static OneOptional _iceS_OneOptional_init;
/// \endcond

struct SmallStruct
{
    ::std::uint8_t m;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::uint8_t&> ice_tuple() const
    {
        return std::tie(m);
    }
};

struct FixedStruct
{
    ::std::int32_t m;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&> ice_tuple() const
    {
        return std::tie(m);
    }
};

struct VarStruct
{
    ::std::string m;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(m);
    }
};

class MultiOptional : public ::Ice::ValueHelper<MultiOptional, ::Ice::Value>
{
public:

    MultiOptional() = default;
    MultiOptional(const MultiOptional&) = default;
    MultiOptional(MultiOptional&&) = default;
    MultiOptional& operator=(const MultiOptional&) = default;
    MultiOptional& operator=(MultiOptional&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    MultiOptional(::std::optional<::std::uint8_t> a, ::std::optional<bool> b, ::std::optional<::std::int16_t> c, ::std::optional<::std::int32_t> d, ::std::optional<::std::int64_t> e, ::std::optional<float> f, ::std::optional<double> g, ::std::optional<::std::string> h, ::std::optional<::Test::MyEnum> i, ::std::optional<::Test::MyInterfacePrx> j, ::std::optional<::std::shared_ptr<::Test::MultiOptional>> k, ::std::optional<::Test::ByteSeq> bs, ::std::optional<::Test::StringSeq> ss, ::std::optional<::Test::IntIntDict> iid, ::std::optional<::Test::StringIntDict> sid, ::std::optional<::Test::FixedStruct> fs, ::std::optional<::Test::VarStruct> vs, ::std::optional<::Test::ShortSeq> shs, ::std::optional<::Test::MyEnumSeq> es, ::std::optional<::Test::FixedStructSeq> fss, ::std::optional<::Test::VarStructSeq> vss, ::std::optional<::Test::OneOptionalSeq> oos, ::std::optional<::Test::MyInterfacePrxSeq> mips, ::std::optional<::Test::IntEnumDict> ied, ::std::optional<::Test::IntFixedStructDict> ifsd, ::std::optional<::Test::IntVarStructDict> ivsd, ::std::optional<::Test::IntOneOptionalDict> iood, ::std::optional<::Test::IntMyInterfacePrxDict> imipd, ::std::optional<::Test::BoolSeq> bos, ::std::optional<::Test::Serializable> ser) :
        a(a),
        b(b),
        c(c),
        d(d),
        e(e),
        f(f),
        g(g),
        h(::std::move(h)),
        i(i),
        j(::std::move(j)),
        k(::std::move(k)),
        bs(::std::move(bs)),
        ss(::std::move(ss)),
        iid(::std::move(iid)),
        sid(::std::move(sid)),
        fs(::std::move(fs)),
        vs(::std::move(vs)),
        shs(::std::move(shs)),
        es(::std::move(es)),
        fss(::std::move(fss)),
        vss(::std::move(vss)),
        oos(::std::move(oos)),
        mips(::std::move(mips)),
        ied(::std::move(ied)),
        ifsd(::std::move(ifsd)),
        ivsd(::std::move(ivsd)),
        iood(::std::move(iood)),
        imipd(::std::move(imipd)),
        bos(::std::move(bos)),
        ser(::std::move(ser))
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::optional<::std::uint8_t>&, const ::std::optional<bool>&, const ::std::optional<::std::int16_t>&, const ::std::optional<::std::int32_t>&, const ::std::optional<::std::int64_t>&, const ::std::optional<float>&, const ::std::optional<double>&, const ::std::optional<::std::string>&, const ::std::optional<::Test::MyEnum>&, const ::std::optional<::Test::MyInterfacePrx>&, const ::std::optional<::std::shared_ptr<::Test::MultiOptional>>&, const ::std::optional<::Test::ByteSeq>&, const ::std::optional<::Test::StringSeq>&, const ::std::optional<::Test::IntIntDict>&, const ::std::optional<::Test::StringIntDict>&, const ::std::optional<::Test::FixedStruct>&, const ::std::optional<::Test::VarStruct>&, const ::std::optional<::Test::ShortSeq>&, const ::std::optional<::Test::MyEnumSeq>&, const ::std::optional<::Test::FixedStructSeq>&, const ::std::optional<::Test::VarStructSeq>&, const ::std::optional<::Test::OneOptionalSeq>&, const ::std::optional<::Test::MyInterfacePrxSeq>&, const ::std::optional<::Test::IntEnumDict>&, const ::std::optional<::Test::IntFixedStructDict>&, const ::std::optional<::Test::IntVarStructDict>&, const ::std::optional<::Test::IntOneOptionalDict>&, const ::std::optional<::Test::IntMyInterfacePrxDict>&, const ::std::optional<::Test::BoolSeq>&, const ::std::optional<::Test::Serializable>&> ice_tuple() const
    {
        return std::tie(a, b, c, d, e, f, g, h, i, j, k, bs, ss, iid, sid, fs, vs, shs, es, fss, vss, oos, mips, ied, ifsd, ivsd, iood, imipd, bos, ser);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::optional<::std::uint8_t> a;
    ::std::optional<bool> b;
    ::std::optional<::std::int16_t> c;
    ::std::optional<::std::int32_t> d;
    ::std::optional<::std::int64_t> e;
    ::std::optional<float> f;
    ::std::optional<double> g;
    ::std::optional<::std::string> h;
    ::std::optional<::Test::MyEnum> i;
    ::std::optional<::Test::MyInterfacePrx> j;
    ::std::optional<::std::shared_ptr<::Test::MultiOptional>> k;
    ::std::optional<::Test::ByteSeq> bs;
    ::std::optional<::Test::StringSeq> ss;
    ::std::optional<::Test::IntIntDict> iid;
    ::std::optional<::Test::StringIntDict> sid;
    ::std::optional<::Test::FixedStruct> fs;
    ::std::optional<::Test::VarStruct> vs;
    ::std::optional<::Test::ShortSeq> shs;
    ::std::optional<::Test::MyEnumSeq> es;
    ::std::optional<::Test::FixedStructSeq> fss;
    ::std::optional<::Test::VarStructSeq> vss;
    ::std::optional<::Test::OneOptionalSeq> oos;
    ::std::optional<::Test::MyInterfacePrxSeq> mips;
    ::std::optional<::Test::IntEnumDict> ied;
    ::std::optional<::Test::IntFixedStructDict> ifsd;
    ::std::optional<::Test::IntVarStructDict> ivsd;
    ::std::optional<::Test::IntOneOptionalDict> iood;
    ::std::optional<::Test::IntMyInterfacePrxDict> imipd;
    ::std::optional<::Test::BoolSeq> bos;
    ::std::optional<::Test::Serializable> ser;
};

class A : public ::Ice::ValueHelper<A, ::Ice::Value>
{
public:

    A() = default;
    A(const A&) = default;
    A(A&&) = default;
    A& operator=(const A&) = default;
    A& operator=(A&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    A(::std::int32_t requiredA, ::std::optional<::std::int32_t> ma, ::std::optional<::std::int32_t> mb, ::std::optional<::std::int32_t> mc) :
        requiredA(requiredA),
        ma(ma),
        mb(mb),
        mc(mc)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::optional<::std::int32_t>&, const ::std::optional<::std::int32_t>&, const ::std::optional<::std::int32_t>&> ice_tuple() const
    {
        return std::tie(requiredA, ma, mb, mc);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::int32_t requiredA = 0;
    ::std::optional<::std::int32_t> ma;
    ::std::optional<::std::int32_t> mb;
    ::std::optional<::std::int32_t> mc;
};

class B : public ::Ice::ValueHelper<B, A>
{
public:

    B() = default;
    B(const B&) = default;
    B(B&&) = default;
    B& operator=(const B&) = default;
    B& operator=(B&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    B(::std::int32_t requiredA, ::std::optional<::std::int32_t> ma, ::std::optional<::std::int32_t> mb, ::std::optional<::std::int32_t> mc, ::std::int32_t requiredB, ::std::optional<::std::int32_t> md) :
        Ice::ValueHelper<B, A>(requiredA, ma, mb, mc),
        requiredB(requiredB),
        md(md)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::optional<::std::int32_t>&, const ::std::optional<::std::int32_t>&, const ::std::optional<::std::int32_t>&, const ::std::int32_t&, const ::std::optional<::std::int32_t>&> ice_tuple() const
    {
        return std::tie(requiredA, ma, mb, mc, requiredB, md);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::int32_t requiredB = 0;
    ::std::optional<::std::int32_t> md;
};

class C : public ::Ice::ValueHelper<C, B>
{
public:

    C() = default;
    C(const C&) = default;
    C(C&&) = default;
    C& operator=(const C&) = default;
    C& operator=(C&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    C(::std::int32_t requiredA, ::std::optional<::std::int32_t> ma, ::std::optional<::std::int32_t> mb, ::std::optional<::std::int32_t> mc, ::std::int32_t requiredB, ::std::optional<::std::int32_t> md, ::std::string ss, ::std::optional<::std::string> ms) :
        Ice::ValueHelper<C, B>(requiredA, ma, mb, mc, requiredB, md),
        ss(::std::move(ss)),
        ms(::std::move(ms))
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::optional<::std::int32_t>&, const ::std::optional<::std::int32_t>&, const ::std::optional<::std::int32_t>&, const ::std::int32_t&, const ::std::optional<::std::int32_t>&, const ::std::string&, const ::std::optional<::std::string>&> ice_tuple() const
    {
        return std::tie(requiredA, ma, mb, mc, requiredB, md, ss, ms);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string ss;
    ::std::optional<::std::string> ms;
};

class WD : public ::Ice::ValueHelper<WD, ::Ice::Value>
{
public:

    WD() = default;
    WD(const WD&) = default;
    WD(WD&&) = default;
    WD& operator=(const WD&) = default;
    WD& operator=(WD&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    WD(::std::optional<::std::int32_t> a, ::std::optional<::std::string> s) :
        a(a),
        s(::std::move(s))
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::optional<::std::int32_t>&, const ::std::optional<::std::string>&> ice_tuple() const
    {
        return std::tie(a, s);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::optional<::std::int32_t> a = 5;
    ::std::optional<::std::string> s{"test"};
};

class OptionalException : public ::Ice::UserException
{
public:
    using ::Ice::UserException::UserException;

    /**
     * One-shot constructor to initialize all data members.
     */
    OptionalException(bool req, ::std::optional<::std::int32_t> a, ::std::optional<::std::string> b, ::std::optional<::std::shared_ptr<OneOptional>> o) noexcept :
        req(req),
        a(a),
        b(::std::move(b)),
        o(::std::move(o))
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const bool&, const ::std::optional<::std::int32_t>&, const ::std::optional<::std::string>&, const ::std::optional<::std::shared_ptr<::Test::OneOptional>>&> ice_tuple() const
    {
        return std::tie(req, a, b, o);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string ice_id() const override;

    void ice_throw() const override;

    bool req = false;
    ::std::optional<::std::int32_t> a = 5;
    ::std::optional<::std::string> b;
    ::std::optional<::std::shared_ptr<::Test::OneOptional>> o;

protected:
    void _writeImpl(::Ice::OutputStream*) const override;

    void _readImpl(::Ice::InputStream*) override;
};

class DerivedException : public OptionalException
{
public:
    using OptionalException::OptionalException;

    /**
     * One-shot constructor to initialize all data members.
     */
    DerivedException(bool req, ::std::optional<::std::int32_t> a, ::std::optional<::std::string> b, ::std::optional<::std::shared_ptr<OneOptional>> o, ::std::string d1, ::std::optional<::std::string> ss, ::std::optional<::std::shared_ptr<OneOptional>> o2, ::std::string d2) noexcept :
        OptionalException(req, a, ::std::move(b), ::std::move(o)),
        d1(::std::move(d1)),
        ss(::std::move(ss)),
        o2(::std::move(o2)),
        d2(::std::move(d2))
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const bool&, const ::std::optional<::std::int32_t>&, const ::std::optional<::std::string>&, const ::std::optional<::std::shared_ptr<::Test::OneOptional>>&, const ::std::string&, const ::std::optional<::std::string>&, const ::std::optional<::std::shared_ptr<::Test::OneOptional>>&, const ::std::string&> ice_tuple() const
    {
        return std::tie(req, a, b, o, d1, ss, o2, d2);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string ice_id() const override;

    void ice_throw() const override;

    ::std::string d1;
    ::std::optional<::std::string> ss{"test"};
    ::std::optional<::std::shared_ptr<::Test::OneOptional>> o2;
    ::std::string d2;

protected:
    void _writeImpl(::Ice::OutputStream*) const override;

    void _readImpl(::Ice::InputStream*) override;
};

class RequiredException : public OptionalException
{
public:
    using OptionalException::OptionalException;

    /**
     * One-shot constructor to initialize all data members.
     */
    RequiredException(bool req, ::std::optional<::std::int32_t> a, ::std::optional<::std::string> b, ::std::optional<::std::shared_ptr<OneOptional>> o, ::std::string ss, ::std::shared_ptr<OneOptional> o2) noexcept :
        OptionalException(req, a, ::std::move(b), ::std::move(o)),
        ss(::std::move(ss)),
        o2(::std::move(o2))
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const bool&, const ::std::optional<::std::int32_t>&, const ::std::optional<::std::string>&, const ::std::optional<::std::shared_ptr<::Test::OneOptional>>&, const ::std::string&, const ::std::shared_ptr<::Test::OneOptional>&> ice_tuple() const
    {
        return std::tie(req, a, b, o, ss, o2);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string ice_id() const override;

    void ice_throw() const override;

    /// \cond STREAM
    bool _usesClasses() const override;
    /// \endcond

    ::std::string ss = "test";
    ::std::shared_ptr<::Test::OneOptional> o2;

protected:
    void _writeImpl(::Ice::OutputStream*) const override;

    void _readImpl(::Ice::InputStream*) override;
};

class OptionalWithCustom : public ::Ice::ValueHelper<OptionalWithCustom, ::Ice::Value>
{
public:

    OptionalWithCustom() = default;
    OptionalWithCustom(const OptionalWithCustom&) = default;
    OptionalWithCustom(OptionalWithCustom&&) = default;
    OptionalWithCustom& operator=(const OptionalWithCustom&) = default;
    OptionalWithCustom& operator=(OptionalWithCustom&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    OptionalWithCustom(::std::optional<::Test::SmallStructList> l, ::std::optional<::Test::SmallStructList> lp) :
        l(::std::move(l)),
        lp(::std::move(lp))
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::optional<::Test::SmallStructList>&, const ::std::optional<::Test::SmallStructList>&> ice_tuple() const
    {
        return std::tie(l, lp);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::optional<::Test::SmallStructList> l;

protected:

    ::std::optional<::Test::SmallStructList> lp;

    template<typename T, typename S>
    friend struct Ice::StreamWriter;
    template<typename T, typename S>
    friend struct Ice::StreamReader;
};

class E : public ::Ice::ValueHelper<E, ::Ice::Value>
{
public:

    E() = default;
    E(const E&) = default;
    E(E&&) = default;
    E& operator=(const E&) = default;
    E& operator=(E&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit E(::std::shared_ptr<::Test::A> ae) :
        ae(::std::move(ae))
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::A>&> ice_tuple() const
    {
        return std::tie(ae);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::shared_ptr<::Test::A> ae;
};

class F : public ::Ice::ValueHelper<F, E>
{
public:

    F() = default;
    F(const F&) = default;
    F(F&&) = default;
    F& operator=(const F&) = default;
    F& operator=(F&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    F(::std::shared_ptr<::Test::A> ae, ::std::optional<::std::shared_ptr<::Test::A>> af) :
        Ice::ValueHelper<F, E>(::std::move(ae)),
        af(::std::move(af))
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::A>&, const ::std::optional<::std::shared_ptr<::Test::A>>&> ice_tuple() const
    {
        return std::tie(ae, af);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::optional<::std::shared_ptr<::Test::A>> af;
};

class G1 : public ::Ice::ValueHelper<G1, ::Ice::Value>
{
public:

    G1() = default;
    G1(const G1&) = default;
    G1(G1&&) = default;
    G1& operator=(const G1&) = default;
    G1& operator=(G1&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit G1(::std::string a) :
        a(::std::move(a))
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(a);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string a;
};

class G2 : public ::Ice::ValueHelper<G2, ::Ice::Value>
{
public:

    G2() = default;
    G2(const G2&) = default;
    G2(G2&&) = default;
    G2& operator=(const G2&) = default;
    G2& operator=(G2&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit G2(::std::int64_t a) :
        a(a)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int64_t&> ice_tuple() const
    {
        return std::tie(a);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::int64_t a;
};

class G : public ::Ice::ValueHelper<G, ::Ice::Value>
{
public:

    G() = default;
    G(const G&) = default;
    G(G&&) = default;
    G& operator=(const G&) = default;
    G& operator=(G&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    G(::std::optional<::std::shared_ptr<::Test::G1>> gg1Opt, ::std::shared_ptr<::Test::G2> gg2, ::std::optional<::std::shared_ptr<::Test::G2>> gg2Opt, ::std::shared_ptr<::Test::G1> gg1) :
        gg1Opt(::std::move(gg1Opt)),
        gg2(::std::move(gg2)),
        gg2Opt(::std::move(gg2Opt)),
        gg1(::std::move(gg1))
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::optional<::std::shared_ptr<::Test::G1>>&, const ::std::shared_ptr<::Test::G2>&, const ::std::optional<::std::shared_ptr<::Test::G2>>&, const ::std::shared_ptr<::Test::G1>&> ice_tuple() const
    {
        return std::tie(gg1Opt, gg2, gg2Opt, gg1);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::optional<::std::shared_ptr<::Test::G1>> gg1Opt;
    ::std::shared_ptr<::Test::G2> gg2;
    ::std::optional<::std::shared_ptr<::Test::G2>> gg2Opt;
    ::std::shared_ptr<::Test::G1> gg1;
};

class Recursive : public ::Ice::ValueHelper<Recursive, ::Ice::Value>
{
public:

    Recursive() = default;
    Recursive(const Recursive&) = default;
    Recursive(Recursive&&) = default;
    Recursive& operator=(const Recursive&) = default;
    Recursive& operator=(Recursive&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit Recursive(::std::optional<::Test::RecursiveSeq> value) :
        value(::std::move(value))
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::optional<::Test::RecursiveSeq>&> ice_tuple() const
    {
        return std::tie(value);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::optional<::Test::RecursiveSeq> value;
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace Test
{

class MyInterface : public virtual ::Ice::Object
{
public:

    using ProxyType = MyInterfacePrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    virtual void op(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_op(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /// \cond INTERNAL
    void dispatch(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>) override;
    /// \endcond
};

using MyInterfacePtr = ::std::shared_ptr<MyInterface>;

class Initial : public virtual ::Ice::Object
{
public:

    using ProxyType = InitialPrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    virtual void shutdown(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_shutdown(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /**
     * Marshaled result structure for operation pingPong.
     */
    class PingPongMarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        PingPongMarshaledResult(const ::std::shared_ptr<::Ice::Value>& returnValue, const ::Ice::Current& current);
    };

    virtual PingPongMarshaledResult pingPong(::std::shared_ptr<::Ice::Value> o, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_pingPong(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void opOptionalException(::std::optional<::std::int32_t> a, ::std::optional<::std::string> b, ::std::optional<::std::shared_ptr<OneOptional>> o, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opOptionalException(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void opDerivedException(::std::optional<::std::int32_t> a, ::std::optional<::std::string> b, ::std::optional<::std::shared_ptr<OneOptional>> o, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opDerivedException(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void opRequiredException(::std::optional<::std::int32_t> a, ::std::optional<::std::string> b, ::std::optional<::std::shared_ptr<OneOptional>> o, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opRequiredException(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<::std::uint8_t> opByte(::std::optional<::std::uint8_t> p1, ::std::optional<::std::uint8_t>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opByte(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<bool> opBool(::std::optional<bool> p1, ::std::optional<bool>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opBool(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<::std::int16_t> opShort(::std::optional<::std::int16_t> p1, ::std::optional<::std::int16_t>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opShort(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<::std::int32_t> opInt(::std::optional<::std::int32_t> p1, ::std::optional<::std::int32_t>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opInt(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<::std::int64_t> opLong(::std::optional<::std::int64_t> p1, ::std::optional<::std::int64_t>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opLong(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<float> opFloat(::std::optional<float> p1, ::std::optional<float>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opFloat(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<double> opDouble(::std::optional<double> p1, ::std::optional<double>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opDouble(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<::std::string> opString(::std::optional<::std::string> p1, ::std::optional<::std::string>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opString(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<MyEnum> opMyEnum(::std::optional<MyEnum> p1, ::std::optional<MyEnum>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opMyEnum(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<SmallStruct> opSmallStruct(::std::optional<SmallStruct> p1, ::std::optional<SmallStruct>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opSmallStruct(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<FixedStruct> opFixedStruct(::std::optional<FixedStruct> p1, ::std::optional<FixedStruct>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opFixedStruct(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<VarStruct> opVarStruct(::std::optional<VarStruct> p1, ::std::optional<VarStruct>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opVarStruct(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<::std::shared_ptr<OneOptional>> opOneOptional(::std::optional<::std::shared_ptr<OneOptional>> p1, ::std::optional<::std::shared_ptr<OneOptional>>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opOneOptional(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<MyInterfacePrx> opMyInterfaceProxy(::std::optional<MyInterfacePrx> p1, ::std::optional<MyInterfacePrx>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opMyInterfaceProxy(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<ByteSeq> opByteSeq(::std::optional<::std::pair<const std::byte*, const std::byte*>> p1, ::std::optional<ByteSeq>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opByteSeq(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<BoolSeq> opBoolSeq(::std::optional<::std::pair<const bool*, const bool*>> p1, ::std::optional<BoolSeq>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opBoolSeq(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<ShortSeq> opShortSeq(::std::optional<::std::pair<const ::std::int16_t*, const ::std::int16_t*>> p1, ::std::optional<ShortSeq>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opShortSeq(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<IntSeq> opIntSeq(::std::optional<::std::pair<const ::std::int32_t*, const ::std::int32_t*>> p1, ::std::optional<IntSeq>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opIntSeq(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<LongSeq> opLongSeq(::std::optional<::std::pair<const ::std::int64_t*, const ::std::int64_t*>> p1, ::std::optional<LongSeq>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opLongSeq(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<FloatSeq> opFloatSeq(::std::optional<::std::pair<const float*, const float*>> p1, ::std::optional<FloatSeq>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opFloatSeq(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<DoubleSeq> opDoubleSeq(::std::optional<::std::pair<const double*, const double*>> p1, ::std::optional<DoubleSeq>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opDoubleSeq(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<StringSeq> opStringSeq(::std::optional<StringSeq> p1, ::std::optional<StringSeq>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opStringSeq(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<SmallStructSeq> opSmallStructSeq(::std::optional<::std::pair<const SmallStruct*, const SmallStruct*>> p1, ::std::optional<SmallStructSeq>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opSmallStructSeq(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<SmallStructList> opSmallStructList(::std::optional<::std::pair<const SmallStruct*, const SmallStruct*>> p1, ::std::optional<SmallStructList>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opSmallStructList(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<FixedStructSeq> opFixedStructSeq(::std::optional<::std::pair<const FixedStruct*, const FixedStruct*>> p1, ::std::optional<FixedStructSeq>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opFixedStructSeq(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<FixedStructList> opFixedStructList(::std::optional<::std::pair<const FixedStruct*, const FixedStruct*>> p1, ::std::optional<FixedStructList>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opFixedStructList(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<VarStructSeq> opVarStructSeq(::std::optional<VarStructSeq> p1, ::std::optional<VarStructSeq>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opVarStructSeq(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<Serializable> opSerializable(::std::optional<Serializable> p1, ::std::optional<Serializable>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opSerializable(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<IntIntDict> opIntIntDict(::std::optional<IntIntDict> p1, ::std::optional<IntIntDict>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opIntIntDict(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<StringIntDict> opStringIntDict(::std::optional<StringIntDict> p1, ::std::optional<StringIntDict>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opStringIntDict(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::optional<IntOneOptionalDict> opIntOneOptionalDict(::std::optional<IntOneOptionalDict> p1, ::std::optional<IntOneOptionalDict>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opIntOneOptionalDict(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void opClassAndUnknownOptional(::std::shared_ptr<A> p, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opClassAndUnknownOptional(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void sendOptionalClass(bool req, ::std::optional<::std::shared_ptr<OneOptional>> o, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_sendOptionalClass(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void returnOptionalClass(bool req, ::std::optional<::std::shared_ptr<OneOptional>>& o, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_returnOptionalClass(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual ::std::shared_ptr<G> opG(::std::shared_ptr<G> g, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opG(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void opVoid(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opVoid(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /**
     * Marshaled result structure for operation opMStruct1.
     */
    class OpMStruct1MarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        OpMStruct1MarshaledResult(const ::std::optional<SmallStruct>& returnValue, const ::Ice::Current& current);
    };

    virtual OpMStruct1MarshaledResult opMStruct1(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opMStruct1(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /**
     * Marshaled result structure for operation opMStruct2.
     */
    class OpMStruct2MarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        OpMStruct2MarshaledResult(const ::std::optional<SmallStruct>& returnValue, const ::std::optional<SmallStruct>& p2, const ::Ice::Current& current);
    };

    virtual OpMStruct2MarshaledResult opMStruct2(::std::optional<SmallStruct> p1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opMStruct2(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /**
     * Marshaled result structure for operation opMSeq1.
     */
    class OpMSeq1MarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        OpMSeq1MarshaledResult(const ::std::optional<StringSeq>& returnValue, const ::Ice::Current& current);
    };

    virtual OpMSeq1MarshaledResult opMSeq1(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opMSeq1(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /**
     * Marshaled result structure for operation opMSeq2.
     */
    class OpMSeq2MarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        OpMSeq2MarshaledResult(const ::std::optional<StringSeq>& returnValue, const ::std::optional<StringSeq>& p2, const ::Ice::Current& current);
    };

    virtual OpMSeq2MarshaledResult opMSeq2(::std::optional<StringSeq> p1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opMSeq2(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /**
     * Marshaled result structure for operation opMDict1.
     */
    class OpMDict1MarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        OpMDict1MarshaledResult(const ::std::optional<StringIntDict>& returnValue, const ::Ice::Current& current);
    };

    virtual OpMDict1MarshaledResult opMDict1(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opMDict1(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /**
     * Marshaled result structure for operation opMDict2.
     */
    class OpMDict2MarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        OpMDict2MarshaledResult(const ::std::optional<StringIntDict>& returnValue, const ::std::optional<StringIntDict>& p2, const ::Ice::Current& current);
    };

    virtual OpMDict2MarshaledResult opMDict2(::std::optional<StringIntDict> p1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opMDict2(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /**
     * Marshaled result structure for operation opMG1.
     */
    class OpMG1MarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        OpMG1MarshaledResult(const ::std::optional<::std::shared_ptr<G>>& returnValue, const ::Ice::Current& current);
    };

    virtual OpMG1MarshaledResult opMG1(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opMG1(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /**
     * Marshaled result structure for operation opMG2.
     */
    class OpMG2MarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        OpMG2MarshaledResult(const ::std::optional<::std::shared_ptr<G>>& returnValue, const ::std::optional<::std::shared_ptr<G>>& p2, const ::Ice::Current& current);
    };

    virtual OpMG2MarshaledResult opMG2(::std::optional<::std::shared_ptr<G>> p1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_opMG2(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual bool supportsRequiredParams(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_supportsRequiredParams(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual bool supportsJavaSerializable(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_supportsJavaSerializable(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual bool supportsCsharpSerializable(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_supportsCsharpSerializable(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual bool supportsNullOptional(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_supportsNullOptional(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /// \cond INTERNAL
    void dispatch(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>) override;
    /// \endcond
};

using InitialPtr = ::std::shared_ptr<Initial>;

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamWriter<::Test::OneOptional, S>
{
    static void write(S* ostr, const ::Test::OneOptional& v)
    {
        ostr->writeAll({1}, v.a);
    }
};

template<typename S>
struct StreamReader<::Test::OneOptional, S>
{
    static void read(S* istr, ::Test::OneOptional& v)
    {
        istr->readAll({1}, v.a);
    }
};

template<>
struct StreamableTraits< ::Test::MyEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 0;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::Test::SmallStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::Test::SmallStruct, S>
{
    static void read(S* istr, ::Test::SmallStruct& v)
    {
        istr->readAll(v.m);
    }
};

template<>
struct StreamableTraits<::Test::FixedStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::Test::FixedStruct, S>
{
    static void read(S* istr, ::Test::FixedStruct& v)
    {
        istr->readAll(v.m);
    }
};

template<>
struct StreamableTraits<::Test::VarStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::VarStruct, S>
{
    static void read(S* istr, ::Test::VarStruct& v)
    {
        istr->readAll(v.m);
    }
};

template<typename S>
struct StreamWriter<::Test::MultiOptional, S>
{
    static void write(S* ostr, const ::Test::MultiOptional& v)
    {
        ostr->writeAll({1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30}, v.a, v.b, v.c, v.d, v.e, v.f, v.g, v.h, v.i, v.j, v.k, v.bs, v.ss, v.iid, v.sid, v.fs, v.vs, v.shs, v.es, v.fss, v.vss, v.oos, v.mips, v.ied, v.ifsd, v.ivsd, v.iood, v.imipd, v.bos, v.ser);
    }
};

template<typename S>
struct StreamReader<::Test::MultiOptional, S>
{
    static void read(S* istr, ::Test::MultiOptional& v)
    {
        istr->readAll({1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30}, v.a, v.b, v.c, v.d, v.e, v.f, v.g, v.h, v.i, v.j, v.k, v.bs, v.ss, v.iid, v.sid, v.fs, v.vs, v.shs, v.es, v.fss, v.vss, v.oos, v.mips, v.ied, v.ifsd, v.ivsd, v.iood, v.imipd, v.bos, v.ser);
    }
};

template<typename S>
struct StreamWriter<::Test::A, S>
{
    static void write(S* ostr, const ::Test::A& v)
    {
        ostr->writeAll(v.requiredA);
        ostr->writeAll({1, 50, 500}, v.ma, v.mb, v.mc);
    }
};

template<typename S>
struct StreamReader<::Test::A, S>
{
    static void read(S* istr, ::Test::A& v)
    {
        istr->readAll(v.requiredA);
        istr->readAll({1, 50, 500}, v.ma, v.mb, v.mc);
    }
};

template<typename S>
struct StreamWriter<::Test::B, S>
{
    static void write(S* ostr, const ::Test::B& v)
    {
        ostr->writeAll(v.requiredB);
        ostr->writeAll({10}, v.md);
    }
};

template<typename S>
struct StreamReader<::Test::B, S>
{
    static void read(S* istr, ::Test::B& v)
    {
        istr->readAll(v.requiredB);
        istr->readAll({10}, v.md);
    }
};

template<typename S>
struct StreamWriter<::Test::C, S>
{
    static void write(S* ostr, const ::Test::C& v)
    {
        ostr->writeAll(v.ss);
        ostr->writeAll({890}, v.ms);
    }
};

template<typename S>
struct StreamReader<::Test::C, S>
{
    static void read(S* istr, ::Test::C& v)
    {
        istr->readAll(v.ss);
        istr->readAll({890}, v.ms);
    }
};

template<typename S>
struct StreamWriter<::Test::WD, S>
{
    static void write(S* ostr, const ::Test::WD& v)
    {
        ostr->writeAll({1, 2}, v.a, v.s);
    }
};

template<typename S>
struct StreamReader<::Test::WD, S>
{
    static void read(S* istr, ::Test::WD& v)
    {
        istr->readAll({1, 2}, v.a, v.s);
    }
};

template<typename S>
struct StreamWriter<::Test::OptionalException, S>
{
    static void write(S* ostr, const ::Test::OptionalException& v)
    {
        ostr->writeAll(v.req);
        ostr->writeAll({1, 2, 50}, v.a, v.b, v.o);
    }
};

template<typename S>
struct StreamReader<::Test::OptionalException, S>
{
    static void read(S* istr, ::Test::OptionalException& v)
    {
        istr->readAll(v.req);
        istr->readAll({1, 2, 50}, v.a, v.b, v.o);
    }
};

template<typename S>
struct StreamWriter<::Test::DerivedException, S>
{
    static void write(S* ostr, const ::Test::DerivedException& v)
    {
        ostr->writeAll(v.d1, v.d2);
        ostr->writeAll({600, 601}, v.ss, v.o2);
    }
};

template<typename S>
struct StreamReader<::Test::DerivedException, S>
{
    static void read(S* istr, ::Test::DerivedException& v)
    {
        istr->readAll(v.d1, v.d2);
        istr->readAll({600, 601}, v.ss, v.o2);
    }
};

template<typename S>
struct StreamWriter<::Test::RequiredException, S>
{
    static void write(S* ostr, const ::Test::RequiredException& v)
    {
        ostr->writeAll(v.ss, v.o2);
    }
};

template<typename S>
struct StreamReader<::Test::RequiredException, S>
{
    static void read(S* istr, ::Test::RequiredException& v)
    {
        istr->readAll(v.ss, v.o2);
    }
};

template<typename S>
struct StreamWriter<::Test::OptionalWithCustom, S>
{
    static void write(S* ostr, const ::Test::OptionalWithCustom& v)
    {
        ostr->writeAll({1, 2}, v.l, v.lp);
    }
};

template<typename S>
struct StreamReader<::Test::OptionalWithCustom, S>
{
    static void read(S* istr, ::Test::OptionalWithCustom& v)
    {
        istr->readAll({1, 2}, v.l, v.lp);
    }
};

template<typename S>
struct StreamReader<::Test::E, S>
{
    static void read(S* istr, ::Test::E& v)
    {
        istr->readAll(v.ae);
    }
};

template<typename S>
struct StreamWriter<::Test::F, S>
{
    static void write(S* ostr, const ::Test::F& v)
    {
        ostr->writeAll({1}, v.af);
    }
};

template<typename S>
struct StreamReader<::Test::F, S>
{
    static void read(S* istr, ::Test::F& v)
    {
        istr->readAll({1}, v.af);
    }
};

template<typename S>
struct StreamReader<::Test::G1, S>
{
    static void read(S* istr, ::Test::G1& v)
    {
        istr->readAll(v.a);
    }
};

template<typename S>
struct StreamReader<::Test::G2, S>
{
    static void read(S* istr, ::Test::G2& v)
    {
        istr->readAll(v.a);
    }
};

template<typename S>
struct StreamWriter<::Test::G, S>
{
    static void write(S* ostr, const ::Test::G& v)
    {
        ostr->writeAll(v.gg2, v.gg1);
        ostr->writeAll({0, 1}, v.gg2Opt, v.gg1Opt);
    }
};

template<typename S>
struct StreamReader<::Test::G, S>
{
    static void read(S* istr, ::Test::G& v)
    {
        istr->readAll(v.gg2, v.gg1);
        istr->readAll({0, 1}, v.gg2Opt, v.gg1Opt);
    }
};

template<typename S>
struct StreamWriter<::Test::Recursive, S>
{
    static void write(S* ostr, const ::Test::Recursive& v)
    {
        ostr->writeAll({0}, v.value);
    }
};

template<typename S>
struct StreamReader<::Test::Recursive, S>
{
    static void read(S* istr, ::Test::Recursive& v)
    {
        istr->readAll({0}, v.value);
    }
};

}
/// \endcond

#include <IceUtil/PopDisableWarnings.h>
#endif
