//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Test_h__
#define __Test_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <Ice/PropertyDict.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace Test
{

class RemoteCommunicator;
class RemoteCommunicatorPrx;
class RemoteCommunicatorFactory;
class RemoteCommunicatorFactoryPrx;
class TestFacet;
class TestFacetPrx;

}

namespace Test
{

class RemoteCommunicator : public virtual ::Ice::Object
{
public:

    using ProxyType = RemoteCommunicatorPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> getAdmin(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getAdmin(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::PropertyDict getChanges(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getChanges(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void addUpdateCallback(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_addUpdateCallback(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void removeUpdateCallback(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_removeUpdateCallback(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void print(::std::string message, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_print(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void trace(::std::string category, ::std::string message, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_trace(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void warning(::std::string message, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_warning(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void error(::std::string message, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_error(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void shutdown(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void waitForShutdown(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_waitForShutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void destroy(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_destroy(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class RemoteCommunicatorFactory : public virtual ::Ice::Object
{
public:

    using ProxyType = RemoteCommunicatorFactoryPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ::std::shared_ptr<RemoteCommunicatorPrx> createCommunicator(::Ice::PropertyDict props, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_createCommunicator(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void shutdown(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class TestFacet : public virtual ::Ice::Object
{
public:

    using ProxyType = TestFacetPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void op(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_op(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace Test
{

class RemoteCommunicatorPrx : public virtual ::Ice::Proxy<RemoteCommunicatorPrx, ::Ice::ObjectPrx>
{
public:

    ::std::shared_ptr<::Ice::ObjectPrx> getAdmin(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::ObjectPrx>>(true, this, &RemoteCommunicatorPrx::_iceI_getAdmin, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getAdminAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Ice::ObjectPrx>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::ObjectPrx>, P>(false, this, &RemoteCommunicatorPrx::_iceI_getAdmin, context);
    }

    ::std::function<void()>
    getAdminAsync(::std::function<void(::std::shared_ptr<::Ice::ObjectPrx>)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Ice::ObjectPrx>>(std::move(response), std::move(ex), std::move(sent), this, &Test::RemoteCommunicatorPrx::_iceI_getAdmin, context);
    }

    /// \cond INTERNAL
    void _iceI_getAdmin(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Ice::ObjectPrx>>>&, const ::Ice::Context&);
    /// \endcond

    ::Ice::PropertyDict getChanges(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Ice::PropertyDict>(true, this, &RemoteCommunicatorPrx::_iceI_getChanges, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getChangesAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Ice::PropertyDict>>().get_future())
    {
        return _makePromiseOutgoing<::Ice::PropertyDict, P>(false, this, &RemoteCommunicatorPrx::_iceI_getChanges, context);
    }

    ::std::function<void()>
    getChangesAsync(::std::function<void(::Ice::PropertyDict)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::Ice::PropertyDict>(std::move(response), std::move(ex), std::move(sent), this, &Test::RemoteCommunicatorPrx::_iceI_getChanges, context);
    }

    /// \cond INTERNAL
    void _iceI_getChanges(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Ice::PropertyDict>>&, const ::Ice::Context&);
    /// \endcond

    void addUpdateCallback(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &RemoteCommunicatorPrx::_iceI_addUpdateCallback, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto addUpdateCallbackAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &RemoteCommunicatorPrx::_iceI_addUpdateCallback, context);
    }

    ::std::function<void()>
    addUpdateCallbackAsync(::std::function<void()> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::RemoteCommunicatorPrx::_iceI_addUpdateCallback, context);
    }

    /// \cond INTERNAL
    void _iceI_addUpdateCallback(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void removeUpdateCallback(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &RemoteCommunicatorPrx::_iceI_removeUpdateCallback, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto removeUpdateCallbackAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &RemoteCommunicatorPrx::_iceI_removeUpdateCallback, context);
    }

    ::std::function<void()>
    removeUpdateCallbackAsync(::std::function<void()> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::RemoteCommunicatorPrx::_iceI_removeUpdateCallback, context);
    }

    /// \cond INTERNAL
    void _iceI_removeUpdateCallback(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void print(const ::std::string& message, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &RemoteCommunicatorPrx::_iceI_print, message, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto printAsync(const ::std::string& message, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &RemoteCommunicatorPrx::_iceI_print, message, context);
    }

    ::std::function<void()>
    printAsync(const ::std::string& message,
               ::std::function<void()> response,
               ::std::function<void(::std::exception_ptr)> ex = nullptr,
               ::std::function<void(bool)> sent = nullptr,
               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::RemoteCommunicatorPrx::_iceI_print, message, context);
    }

    /// \cond INTERNAL
    void _iceI_print(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void trace(const ::std::string& category, const ::std::string& message, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &RemoteCommunicatorPrx::_iceI_trace, category, message, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto traceAsync(const ::std::string& category, const ::std::string& message, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &RemoteCommunicatorPrx::_iceI_trace, category, message, context);
    }

    ::std::function<void()>
    traceAsync(const ::std::string& category, const ::std::string& message,
               ::std::function<void()> response,
               ::std::function<void(::std::exception_ptr)> ex = nullptr,
               ::std::function<void(bool)> sent = nullptr,
               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::RemoteCommunicatorPrx::_iceI_trace, category, message, context);
    }

    /// \cond INTERNAL
    void _iceI_trace(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void warning(const ::std::string& message, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &RemoteCommunicatorPrx::_iceI_warning, message, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto warningAsync(const ::std::string& message, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &RemoteCommunicatorPrx::_iceI_warning, message, context);
    }

    ::std::function<void()>
    warningAsync(const ::std::string& message,
                 ::std::function<void()> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::RemoteCommunicatorPrx::_iceI_warning, message, context);
    }

    /// \cond INTERNAL
    void _iceI_warning(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void error(const ::std::string& message, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &RemoteCommunicatorPrx::_iceI_error, message, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto errorAsync(const ::std::string& message, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &RemoteCommunicatorPrx::_iceI_error, message, context);
    }

    ::std::function<void()>
    errorAsync(const ::std::string& message,
               ::std::function<void()> response,
               ::std::function<void(::std::exception_ptr)> ex = nullptr,
               ::std::function<void(bool)> sent = nullptr,
               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::RemoteCommunicatorPrx::_iceI_error, message, context);
    }

    /// \cond INTERNAL
    void _iceI_error(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &RemoteCommunicatorPrx::_iceI_shutdown, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto shutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &RemoteCommunicatorPrx::_iceI_shutdown, context);
    }

    ::std::function<void()>
    shutdownAsync(::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::RemoteCommunicatorPrx::_iceI_shutdown, context);
    }

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void waitForShutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &RemoteCommunicatorPrx::_iceI_waitForShutdown, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto waitForShutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &RemoteCommunicatorPrx::_iceI_waitForShutdown, context);
    }

    ::std::function<void()>
    waitForShutdownAsync(::std::function<void()> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::RemoteCommunicatorPrx::_iceI_waitForShutdown, context);
    }

    /// \cond INTERNAL
    void _iceI_waitForShutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void destroy(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &RemoteCommunicatorPrx::_iceI_destroy, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto destroyAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &RemoteCommunicatorPrx::_iceI_destroy, context);
    }

    ::std::function<void()>
    destroyAsync(::std::function<void()> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::RemoteCommunicatorPrx::_iceI_destroy, context);
    }

    /// \cond INTERNAL
    void _iceI_destroy(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    RemoteCommunicatorPrx() = default;
    friend ::std::shared_ptr<RemoteCommunicatorPrx> IceInternal::createProxy<RemoteCommunicatorPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class RemoteCommunicatorFactoryPrx : public virtual ::Ice::Proxy<RemoteCommunicatorFactoryPrx, ::Ice::ObjectPrx>
{
public:

    ::std::shared_ptr<RemoteCommunicatorPrx> createCommunicator(const ::Ice::PropertyDict& props, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::RemoteCommunicatorPrx>>(true, this, &RemoteCommunicatorFactoryPrx::_iceI_createCommunicator, props, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto createCommunicatorAsync(const ::Ice::PropertyDict& props, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::RemoteCommunicatorPrx>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::RemoteCommunicatorPrx>, P>(false, this, &RemoteCommunicatorFactoryPrx::_iceI_createCommunicator, props, context);
    }

    ::std::function<void()>
    createCommunicatorAsync(const ::Ice::PropertyDict& props,
                            ::std::function<void(::std::shared_ptr<::Test::RemoteCommunicatorPrx>)> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::RemoteCommunicatorPrx>>(std::move(response), std::move(ex), std::move(sent), this, &Test::RemoteCommunicatorFactoryPrx::_iceI_createCommunicator, props, context);
    }

    /// \cond INTERNAL
    void _iceI_createCommunicator(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::RemoteCommunicatorPrx>>>&, const ::Ice::PropertyDict&, const ::Ice::Context&);
    /// \endcond

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &RemoteCommunicatorFactoryPrx::_iceI_shutdown, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto shutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &RemoteCommunicatorFactoryPrx::_iceI_shutdown, context);
    }

    ::std::function<void()>
    shutdownAsync(::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::RemoteCommunicatorFactoryPrx::_iceI_shutdown, context);
    }

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    RemoteCommunicatorFactoryPrx() = default;
    friend ::std::shared_ptr<RemoteCommunicatorFactoryPrx> IceInternal::createProxy<RemoteCommunicatorFactoryPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class TestFacetPrx : public virtual ::Ice::Proxy<TestFacetPrx, ::Ice::ObjectPrx>
{
public:

    void op(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestFacetPrx::_iceI_op, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestFacetPrx::_iceI_op, context);
    }

    ::std::function<void()>
    opAsync(::std::function<void()> response,
            ::std::function<void(::std::exception_ptr)> ex = nullptr,
            ::std::function<void(bool)> sent = nullptr,
            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestFacetPrx::_iceI_op, context);
    }

    /// \cond INTERNAL
    void _iceI_op(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    TestFacetPrx() = default;
    friend ::std::shared_ptr<TestFacetPrx> IceInternal::createProxy<TestFacetPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

}
/// \endcond

/// \cond INTERNAL
namespace Test
{

using RemoteCommunicatorPtr = ::std::shared_ptr<RemoteCommunicator>;
using RemoteCommunicatorPrxPtr = ::std::shared_ptr<RemoteCommunicatorPrx>;

using RemoteCommunicatorFactoryPtr = ::std::shared_ptr<RemoteCommunicatorFactory>;
using RemoteCommunicatorFactoryPrxPtr = ::std::shared_ptr<RemoteCommunicatorFactoryPrx>;

using TestFacetPtr = ::std::shared_ptr<TestFacet>;
using TestFacetPrxPtr = ::std::shared_ptr<TestFacetPrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace Test
{

class RemoteCommunicator;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< RemoteCommunicator>&);
::IceProxy::Ice::Object* upCast(RemoteCommunicator*);
/// \endcond

class RemoteCommunicatorFactory;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< RemoteCommunicatorFactory>&);
::IceProxy::Ice::Object* upCast(RemoteCommunicatorFactory*);
/// \endcond

class TestFacet;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< TestFacet>&);
::IceProxy::Ice::Object* upCast(TestFacet*);
/// \endcond

}

}

namespace Test
{

class RemoteCommunicator;
/// \cond INTERNAL
::Ice::Object* upCast(RemoteCommunicator*);
/// \endcond
typedef ::IceInternal::Handle< RemoteCommunicator> RemoteCommunicatorPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::RemoteCommunicator> RemoteCommunicatorPrx;
typedef RemoteCommunicatorPrx RemoteCommunicatorPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(RemoteCommunicatorPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class RemoteCommunicatorFactory;
/// \cond INTERNAL
::Ice::Object* upCast(RemoteCommunicatorFactory*);
/// \endcond
typedef ::IceInternal::Handle< RemoteCommunicatorFactory> RemoteCommunicatorFactoryPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::RemoteCommunicatorFactory> RemoteCommunicatorFactoryPrx;
typedef RemoteCommunicatorFactoryPrx RemoteCommunicatorFactoryPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(RemoteCommunicatorFactoryPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class TestFacet;
/// \cond INTERNAL
::Ice::Object* upCast(TestFacet*);
/// \endcond
typedef ::IceInternal::Handle< TestFacet> TestFacetPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::TestFacet> TestFacetPrx;
typedef TestFacetPrx TestFacetPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(TestFacetPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace Test
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_getAdmin.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_getAdmin.
 */
class Callback_RemoteCommunicator_getAdmin_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RemoteCommunicator_getAdmin_Base> Callback_RemoteCommunicator_getAdminPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_getChanges.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_getChanges.
 */
class Callback_RemoteCommunicator_getChanges_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RemoteCommunicator_getChanges_Base> Callback_RemoteCommunicator_getChangesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_addUpdateCallback.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_addUpdateCallback.
 */
class Callback_RemoteCommunicator_addUpdateCallback_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RemoteCommunicator_addUpdateCallback_Base> Callback_RemoteCommunicator_addUpdateCallbackPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_removeUpdateCallback.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_removeUpdateCallback.
 */
class Callback_RemoteCommunicator_removeUpdateCallback_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RemoteCommunicator_removeUpdateCallback_Base> Callback_RemoteCommunicator_removeUpdateCallbackPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_print.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_print.
 */
class Callback_RemoteCommunicator_print_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RemoteCommunicator_print_Base> Callback_RemoteCommunicator_printPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_trace.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_trace.
 */
class Callback_RemoteCommunicator_trace_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RemoteCommunicator_trace_Base> Callback_RemoteCommunicator_tracePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_warning.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_warning.
 */
class Callback_RemoteCommunicator_warning_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RemoteCommunicator_warning_Base> Callback_RemoteCommunicator_warningPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_error.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_error.
 */
class Callback_RemoteCommunicator_error_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RemoteCommunicator_error_Base> Callback_RemoteCommunicator_errorPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_shutdown.
 */
class Callback_RemoteCommunicator_shutdown_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RemoteCommunicator_shutdown_Base> Callback_RemoteCommunicator_shutdownPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_waitForShutdown.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_waitForShutdown.
 */
class Callback_RemoteCommunicator_waitForShutdown_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RemoteCommunicator_waitForShutdown_Base> Callback_RemoteCommunicator_waitForShutdownPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_destroy.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_destroy.
 */
class Callback_RemoteCommunicator_destroy_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RemoteCommunicator_destroy_Base> Callback_RemoteCommunicator_destroyPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::RemoteCommunicatorFactory::begin_createCommunicator.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicatorFactory_createCommunicator.
 */
class Callback_RemoteCommunicatorFactory_createCommunicator_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RemoteCommunicatorFactory_createCommunicator_Base> Callback_RemoteCommunicatorFactory_createCommunicatorPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::RemoteCommunicatorFactory::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicatorFactory_shutdown.
 */
class Callback_RemoteCommunicatorFactory_shutdown_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RemoteCommunicatorFactory_shutdown_Base> Callback_RemoteCommunicatorFactory_shutdownPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestFacet::begin_op.
 * Create a wrapper instance by calling ::Test::newCallback_TestFacet_op.
 */
class Callback_TestFacet_op_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestFacet_op_Base> Callback_TestFacet_opPtr;

}

namespace IceProxy
{

namespace Test
{

class RemoteCommunicator : public virtual ::Ice::Proxy<RemoteCommunicator, ::IceProxy::Ice::Object>
{
public:

    ::Ice::ObjectPrx getAdmin(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getAdmin(_iceI_begin_getAdmin(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getAdmin(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getAdmin(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAdmin(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAdmin(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAdmin(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAdmin(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAdmin(const ::Test::Callback_RemoteCommunicator_getAdminPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAdmin(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAdmin(const ::Ice::Context& context, const ::Test::Callback_RemoteCommunicator_getAdminPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAdmin(context, cb, cookie);
    }

    ::Ice::ObjectPrx end_getAdmin(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getAdmin(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::PropertyDict getChanges(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getChanges(_iceI_begin_getChanges(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getChanges(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getChanges(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getChanges(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getChanges(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getChanges(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getChanges(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getChanges(const ::Test::Callback_RemoteCommunicator_getChangesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getChanges(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getChanges(const ::Ice::Context& context, const ::Test::Callback_RemoteCommunicator_getChangesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getChanges(context, cb, cookie);
    }

    ::Ice::PropertyDict end_getChanges(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getChanges(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void addUpdateCallback(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_addUpdateCallback(_iceI_begin_addUpdateCallback(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_addUpdateCallback(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_addUpdateCallback(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addUpdateCallback(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addUpdateCallback(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addUpdateCallback(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addUpdateCallback(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addUpdateCallback(const ::Test::Callback_RemoteCommunicator_addUpdateCallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addUpdateCallback(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addUpdateCallback(const ::Ice::Context& context, const ::Test::Callback_RemoteCommunicator_addUpdateCallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addUpdateCallback(context, cb, cookie);
    }

    void end_addUpdateCallback(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_addUpdateCallback(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void removeUpdateCallback(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_removeUpdateCallback(_iceI_begin_removeUpdateCallback(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_removeUpdateCallback(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_removeUpdateCallback(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeUpdateCallback(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeUpdateCallback(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeUpdateCallback(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeUpdateCallback(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeUpdateCallback(const ::Test::Callback_RemoteCommunicator_removeUpdateCallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeUpdateCallback(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeUpdateCallback(const ::Ice::Context& context, const ::Test::Callback_RemoteCommunicator_removeUpdateCallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeUpdateCallback(context, cb, cookie);
    }

    void end_removeUpdateCallback(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_removeUpdateCallback(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void print(const ::std::string& message, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_print(_iceI_begin_print(message, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_print(const ::std::string& message, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_print(message, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_print(const ::std::string& message, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_print(message, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_print(const ::std::string& message, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_print(message, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_print(const ::std::string& message, const ::Test::Callback_RemoteCommunicator_printPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_print(message, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_print(const ::std::string& message, const ::Ice::Context& context, const ::Test::Callback_RemoteCommunicator_printPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_print(message, context, cb, cookie);
    }

    void end_print(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_print(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void trace(const ::std::string& category, const ::std::string& message, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_trace(_iceI_begin_trace(category, message, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_trace(const ::std::string& category, const ::std::string& message, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_trace(category, message, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_trace(const ::std::string& category, const ::std::string& message, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_trace(category, message, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_trace(const ::std::string& category, const ::std::string& message, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_trace(category, message, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_trace(const ::std::string& category, const ::std::string& message, const ::Test::Callback_RemoteCommunicator_tracePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_trace(category, message, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_trace(const ::std::string& category, const ::std::string& message, const ::Ice::Context& context, const ::Test::Callback_RemoteCommunicator_tracePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_trace(category, message, context, cb, cookie);
    }

    void end_trace(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_trace(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void warning(const ::std::string& message, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_warning(_iceI_begin_warning(message, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_warning(const ::std::string& message, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_warning(message, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_warning(const ::std::string& message, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_warning(message, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_warning(const ::std::string& message, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_warning(message, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_warning(const ::std::string& message, const ::Test::Callback_RemoteCommunicator_warningPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_warning(message, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_warning(const ::std::string& message, const ::Ice::Context& context, const ::Test::Callback_RemoteCommunicator_warningPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_warning(message, context, cb, cookie);
    }

    void end_warning(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_warning(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void error(const ::std::string& message, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_error(_iceI_begin_error(message, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_error(const ::std::string& message, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_error(message, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_error(const ::std::string& message, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_error(message, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_error(const ::std::string& message, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_error(message, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_error(const ::std::string& message, const ::Test::Callback_RemoteCommunicator_errorPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_error(message, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_error(const ::std::string& message, const ::Ice::Context& context, const ::Test::Callback_RemoteCommunicator_errorPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_error(message, context, cb, cookie);
    }

    void end_error(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_error(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_shutdown(_iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Test::Callback_RemoteCommunicator_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Test::Callback_RemoteCommunicator_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    void end_shutdown(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_shutdown(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void waitForShutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_waitForShutdown(_iceI_begin_waitForShutdown(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_waitForShutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_waitForShutdown(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_waitForShutdown(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_waitForShutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_waitForShutdown(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_waitForShutdown(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_waitForShutdown(const ::Test::Callback_RemoteCommunicator_waitForShutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_waitForShutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_waitForShutdown(const ::Ice::Context& context, const ::Test::Callback_RemoteCommunicator_waitForShutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_waitForShutdown(context, cb, cookie);
    }

    void end_waitForShutdown(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_waitForShutdown(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void destroy(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_destroy(_iceI_begin_destroy(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_destroy(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_destroy(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_destroy(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_destroy(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_destroy(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_destroy(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_destroy(const ::Test::Callback_RemoteCommunicator_destroyPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_destroy(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_destroy(const ::Ice::Context& context, const ::Test::Callback_RemoteCommunicator_destroyPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_destroy(context, cb, cookie);
    }

    void end_destroy(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_destroy(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class RemoteCommunicatorFactory : public virtual ::Ice::Proxy<RemoteCommunicatorFactory, ::IceProxy::Ice::Object>
{
public:

    ::Test::RemoteCommunicatorPrx createCommunicator(const ::Ice::PropertyDict& props, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_createCommunicator(_iceI_begin_createCommunicator(props, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_createCommunicator(const ::Ice::PropertyDict& props, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_createCommunicator(props, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createCommunicator(const ::Ice::PropertyDict& props, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_createCommunicator(props, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_createCommunicator(const ::Ice::PropertyDict& props, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_createCommunicator(props, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_createCommunicator(const ::Ice::PropertyDict& props, const ::Test::Callback_RemoteCommunicatorFactory_createCommunicatorPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_createCommunicator(props, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_createCommunicator(const ::Ice::PropertyDict& props, const ::Ice::Context& context, const ::Test::Callback_RemoteCommunicatorFactory_createCommunicatorPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_createCommunicator(props, context, cb, cookie);
    }

    ::Test::RemoteCommunicatorPrx end_createCommunicator(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_createCommunicator(const ::Ice::PropertyDict&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_shutdown(_iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Test::Callback_RemoteCommunicatorFactory_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Test::Callback_RemoteCommunicatorFactory_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    void end_shutdown(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_shutdown(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class TestFacet : public virtual ::Ice::Proxy<TestFacet, ::IceProxy::Ice::Object>
{
public:

    void op(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_op(_iceI_begin_op(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_op(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Test::Callback_TestFacet_opPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& context, const ::Test::Callback_TestFacet_opPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op(context, cb, cookie);
    }

    void end_op(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_op(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace Test
{

class RemoteCommunicator : public virtual ::Ice::Object
{
public:

    typedef RemoteCommunicatorPrx ProxyType;
    typedef RemoteCommunicatorPtr PointerType;

    virtual ~RemoteCommunicator();

#ifdef ICE_CPP11_COMPILER
    RemoteCommunicator() = default;
    RemoteCommunicator(const RemoteCommunicator&) = default;
    RemoteCommunicator& operator=(const RemoteCommunicator&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ::Ice::ObjectPrx getAdmin(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getAdmin(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::PropertyDict getChanges(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getChanges(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void addUpdateCallback(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_addUpdateCallback(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void removeUpdateCallback(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_removeUpdateCallback(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void print(const ::std::string& message, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_print(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void trace(const ::std::string& category, const ::std::string& message, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_trace(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void warning(const ::std::string& message, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_warning(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void error(const ::std::string& message, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_error(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void shutdown(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void waitForShutdown(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_waitForShutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void destroy(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_destroy(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const RemoteCommunicator& lhs, const RemoteCommunicator& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const RemoteCommunicator& lhs, const RemoteCommunicator& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class RemoteCommunicatorFactory : public virtual ::Ice::Object
{
public:

    typedef RemoteCommunicatorFactoryPrx ProxyType;
    typedef RemoteCommunicatorFactoryPtr PointerType;

    virtual ~RemoteCommunicatorFactory();

#ifdef ICE_CPP11_COMPILER
    RemoteCommunicatorFactory() = default;
    RemoteCommunicatorFactory(const RemoteCommunicatorFactory&) = default;
    RemoteCommunicatorFactory& operator=(const RemoteCommunicatorFactory&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual RemoteCommunicatorPrx createCommunicator(const ::Ice::PropertyDict& props, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_createCommunicator(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void shutdown(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const RemoteCommunicatorFactory& lhs, const RemoteCommunicatorFactory& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const RemoteCommunicatorFactory& lhs, const RemoteCommunicatorFactory& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class TestFacet : public virtual ::Ice::Object
{
public:

    typedef TestFacetPrx ProxyType;
    typedef TestFacetPtr PointerType;

    virtual ~TestFacet();

#ifdef ICE_CPP11_COMPILER
    TestFacet() = default;
    TestFacet(const TestFacet&) = default;
    TestFacet& operator=(const TestFacet&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void op(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_op(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const TestFacet& lhs, const TestFacet& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const TestFacet& lhs, const TestFacet& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

}
/// \endcond

namespace Test
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_getAdmin.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_getAdmin.
 */
template<class T>
class CallbackNC_RemoteCommunicator_getAdmin : public Callback_RemoteCommunicator_getAdmin_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Ice::ObjectPrx&);

    CallbackNC_RemoteCommunicator_getAdmin(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RemoteCommunicatorPrx proxy = RemoteCommunicatorPrx::uncheckedCast(result->getProxy());
        ::Ice::ObjectPrx ret;
        try
        {
            ret = proxy->end_getAdmin(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_getAdmin.
 */
template<class T> Callback_RemoteCommunicator_getAdminPtr
newCallback_RemoteCommunicator_getAdmin(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ObjectPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_getAdmin<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_getAdmin.
 */
template<class T> Callback_RemoteCommunicator_getAdminPtr
newCallback_RemoteCommunicator_getAdmin(T* instance, void (T::*cb)(const ::Ice::ObjectPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_getAdmin<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_getAdmin.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_getAdmin.
 */
template<class T, typename CT>
class Callback_RemoteCommunicator_getAdmin : public Callback_RemoteCommunicator_getAdmin_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Ice::ObjectPrx&, const CT&);

    Callback_RemoteCommunicator_getAdmin(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RemoteCommunicatorPrx proxy = RemoteCommunicatorPrx::uncheckedCast(result->getProxy());
        ::Ice::ObjectPrx ret;
        try
        {
            ret = proxy->end_getAdmin(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_getAdmin.
 */
template<class T, typename CT> Callback_RemoteCommunicator_getAdminPtr
newCallback_RemoteCommunicator_getAdmin(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ObjectPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_getAdmin<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_getAdmin.
 */
template<class T, typename CT> Callback_RemoteCommunicator_getAdminPtr
newCallback_RemoteCommunicator_getAdmin(T* instance, void (T::*cb)(const ::Ice::ObjectPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_getAdmin<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_getChanges.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_getChanges.
 */
template<class T>
class CallbackNC_RemoteCommunicator_getChanges : public Callback_RemoteCommunicator_getChanges_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Ice::PropertyDict&);

    CallbackNC_RemoteCommunicator_getChanges(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RemoteCommunicatorPrx proxy = RemoteCommunicatorPrx::uncheckedCast(result->getProxy());
        ::Ice::PropertyDict ret;
        try
        {
            ret = proxy->end_getChanges(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_getChanges.
 */
template<class T> Callback_RemoteCommunicator_getChangesPtr
newCallback_RemoteCommunicator_getChanges(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::PropertyDict&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_getChanges<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_getChanges.
 */
template<class T> Callback_RemoteCommunicator_getChangesPtr
newCallback_RemoteCommunicator_getChanges(T* instance, void (T::*cb)(const ::Ice::PropertyDict&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_getChanges<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_getChanges.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_getChanges.
 */
template<class T, typename CT>
class Callback_RemoteCommunicator_getChanges : public Callback_RemoteCommunicator_getChanges_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Ice::PropertyDict&, const CT&);

    Callback_RemoteCommunicator_getChanges(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RemoteCommunicatorPrx proxy = RemoteCommunicatorPrx::uncheckedCast(result->getProxy());
        ::Ice::PropertyDict ret;
        try
        {
            ret = proxy->end_getChanges(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_getChanges.
 */
template<class T, typename CT> Callback_RemoteCommunicator_getChangesPtr
newCallback_RemoteCommunicator_getChanges(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::PropertyDict&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_getChanges<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_getChanges.
 */
template<class T, typename CT> Callback_RemoteCommunicator_getChangesPtr
newCallback_RemoteCommunicator_getChanges(T* instance, void (T::*cb)(const ::Ice::PropertyDict&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_getChanges<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_addUpdateCallback.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_addUpdateCallback.
 */
template<class T>
class CallbackNC_RemoteCommunicator_addUpdateCallback : public Callback_RemoteCommunicator_addUpdateCallback_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RemoteCommunicator_addUpdateCallback(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_addUpdateCallback.
 */
template<class T> Callback_RemoteCommunicator_addUpdateCallbackPtr
newCallback_RemoteCommunicator_addUpdateCallback(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_addUpdateCallback<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_addUpdateCallback.
 */
template<class T> Callback_RemoteCommunicator_addUpdateCallbackPtr
newCallback_RemoteCommunicator_addUpdateCallback(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_addUpdateCallback<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_addUpdateCallback.
 */
template<class T> Callback_RemoteCommunicator_addUpdateCallbackPtr
newCallback_RemoteCommunicator_addUpdateCallback(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_addUpdateCallback<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_addUpdateCallback.
 */
template<class T> Callback_RemoteCommunicator_addUpdateCallbackPtr
newCallback_RemoteCommunicator_addUpdateCallback(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_addUpdateCallback<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_addUpdateCallback.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_addUpdateCallback.
 */
template<class T, typename CT>
class Callback_RemoteCommunicator_addUpdateCallback : public Callback_RemoteCommunicator_addUpdateCallback_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RemoteCommunicator_addUpdateCallback(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_addUpdateCallback.
 */
template<class T, typename CT> Callback_RemoteCommunicator_addUpdateCallbackPtr
newCallback_RemoteCommunicator_addUpdateCallback(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_addUpdateCallback<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_addUpdateCallback.
 */
template<class T, typename CT> Callback_RemoteCommunicator_addUpdateCallbackPtr
newCallback_RemoteCommunicator_addUpdateCallback(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_addUpdateCallback<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_addUpdateCallback.
 */
template<class T, typename CT> Callback_RemoteCommunicator_addUpdateCallbackPtr
newCallback_RemoteCommunicator_addUpdateCallback(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_addUpdateCallback<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_addUpdateCallback.
 */
template<class T, typename CT> Callback_RemoteCommunicator_addUpdateCallbackPtr
newCallback_RemoteCommunicator_addUpdateCallback(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_addUpdateCallback<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_removeUpdateCallback.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_removeUpdateCallback.
 */
template<class T>
class CallbackNC_RemoteCommunicator_removeUpdateCallback : public Callback_RemoteCommunicator_removeUpdateCallback_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RemoteCommunicator_removeUpdateCallback(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_removeUpdateCallback.
 */
template<class T> Callback_RemoteCommunicator_removeUpdateCallbackPtr
newCallback_RemoteCommunicator_removeUpdateCallback(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_removeUpdateCallback<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_removeUpdateCallback.
 */
template<class T> Callback_RemoteCommunicator_removeUpdateCallbackPtr
newCallback_RemoteCommunicator_removeUpdateCallback(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_removeUpdateCallback<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_removeUpdateCallback.
 */
template<class T> Callback_RemoteCommunicator_removeUpdateCallbackPtr
newCallback_RemoteCommunicator_removeUpdateCallback(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_removeUpdateCallback<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_removeUpdateCallback.
 */
template<class T> Callback_RemoteCommunicator_removeUpdateCallbackPtr
newCallback_RemoteCommunicator_removeUpdateCallback(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_removeUpdateCallback<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_removeUpdateCallback.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_removeUpdateCallback.
 */
template<class T, typename CT>
class Callback_RemoteCommunicator_removeUpdateCallback : public Callback_RemoteCommunicator_removeUpdateCallback_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RemoteCommunicator_removeUpdateCallback(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_removeUpdateCallback.
 */
template<class T, typename CT> Callback_RemoteCommunicator_removeUpdateCallbackPtr
newCallback_RemoteCommunicator_removeUpdateCallback(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_removeUpdateCallback<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_removeUpdateCallback.
 */
template<class T, typename CT> Callback_RemoteCommunicator_removeUpdateCallbackPtr
newCallback_RemoteCommunicator_removeUpdateCallback(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_removeUpdateCallback<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_removeUpdateCallback.
 */
template<class T, typename CT> Callback_RemoteCommunicator_removeUpdateCallbackPtr
newCallback_RemoteCommunicator_removeUpdateCallback(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_removeUpdateCallback<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_removeUpdateCallback.
 */
template<class T, typename CT> Callback_RemoteCommunicator_removeUpdateCallbackPtr
newCallback_RemoteCommunicator_removeUpdateCallback(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_removeUpdateCallback<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_print.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_print.
 */
template<class T>
class CallbackNC_RemoteCommunicator_print : public Callback_RemoteCommunicator_print_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RemoteCommunicator_print(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_print.
 */
template<class T> Callback_RemoteCommunicator_printPtr
newCallback_RemoteCommunicator_print(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_print<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_print.
 */
template<class T> Callback_RemoteCommunicator_printPtr
newCallback_RemoteCommunicator_print(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_print<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_print.
 */
template<class T> Callback_RemoteCommunicator_printPtr
newCallback_RemoteCommunicator_print(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_print<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_print.
 */
template<class T> Callback_RemoteCommunicator_printPtr
newCallback_RemoteCommunicator_print(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_print<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_print.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_print.
 */
template<class T, typename CT>
class Callback_RemoteCommunicator_print : public Callback_RemoteCommunicator_print_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RemoteCommunicator_print(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_print.
 */
template<class T, typename CT> Callback_RemoteCommunicator_printPtr
newCallback_RemoteCommunicator_print(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_print<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_print.
 */
template<class T, typename CT> Callback_RemoteCommunicator_printPtr
newCallback_RemoteCommunicator_print(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_print<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_print.
 */
template<class T, typename CT> Callback_RemoteCommunicator_printPtr
newCallback_RemoteCommunicator_print(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_print<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_print.
 */
template<class T, typename CT> Callback_RemoteCommunicator_printPtr
newCallback_RemoteCommunicator_print(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_print<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_trace.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_trace.
 */
template<class T>
class CallbackNC_RemoteCommunicator_trace : public Callback_RemoteCommunicator_trace_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RemoteCommunicator_trace(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_trace.
 */
template<class T> Callback_RemoteCommunicator_tracePtr
newCallback_RemoteCommunicator_trace(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_trace<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_trace.
 */
template<class T> Callback_RemoteCommunicator_tracePtr
newCallback_RemoteCommunicator_trace(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_trace<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_trace.
 */
template<class T> Callback_RemoteCommunicator_tracePtr
newCallback_RemoteCommunicator_trace(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_trace<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_trace.
 */
template<class T> Callback_RemoteCommunicator_tracePtr
newCallback_RemoteCommunicator_trace(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_trace<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_trace.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_trace.
 */
template<class T, typename CT>
class Callback_RemoteCommunicator_trace : public Callback_RemoteCommunicator_trace_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RemoteCommunicator_trace(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_trace.
 */
template<class T, typename CT> Callback_RemoteCommunicator_tracePtr
newCallback_RemoteCommunicator_trace(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_trace<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_trace.
 */
template<class T, typename CT> Callback_RemoteCommunicator_tracePtr
newCallback_RemoteCommunicator_trace(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_trace<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_trace.
 */
template<class T, typename CT> Callback_RemoteCommunicator_tracePtr
newCallback_RemoteCommunicator_trace(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_trace<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_trace.
 */
template<class T, typename CT> Callback_RemoteCommunicator_tracePtr
newCallback_RemoteCommunicator_trace(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_trace<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_warning.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_warning.
 */
template<class T>
class CallbackNC_RemoteCommunicator_warning : public Callback_RemoteCommunicator_warning_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RemoteCommunicator_warning(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_warning.
 */
template<class T> Callback_RemoteCommunicator_warningPtr
newCallback_RemoteCommunicator_warning(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_warning<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_warning.
 */
template<class T> Callback_RemoteCommunicator_warningPtr
newCallback_RemoteCommunicator_warning(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_warning<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_warning.
 */
template<class T> Callback_RemoteCommunicator_warningPtr
newCallback_RemoteCommunicator_warning(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_warning<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_warning.
 */
template<class T> Callback_RemoteCommunicator_warningPtr
newCallback_RemoteCommunicator_warning(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_warning<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_warning.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_warning.
 */
template<class T, typename CT>
class Callback_RemoteCommunicator_warning : public Callback_RemoteCommunicator_warning_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RemoteCommunicator_warning(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_warning.
 */
template<class T, typename CT> Callback_RemoteCommunicator_warningPtr
newCallback_RemoteCommunicator_warning(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_warning<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_warning.
 */
template<class T, typename CT> Callback_RemoteCommunicator_warningPtr
newCallback_RemoteCommunicator_warning(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_warning<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_warning.
 */
template<class T, typename CT> Callback_RemoteCommunicator_warningPtr
newCallback_RemoteCommunicator_warning(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_warning<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_warning.
 */
template<class T, typename CT> Callback_RemoteCommunicator_warningPtr
newCallback_RemoteCommunicator_warning(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_warning<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_error.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_error.
 */
template<class T>
class CallbackNC_RemoteCommunicator_error : public Callback_RemoteCommunicator_error_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RemoteCommunicator_error(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_error.
 */
template<class T> Callback_RemoteCommunicator_errorPtr
newCallback_RemoteCommunicator_error(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_error<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_error.
 */
template<class T> Callback_RemoteCommunicator_errorPtr
newCallback_RemoteCommunicator_error(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_error<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_error.
 */
template<class T> Callback_RemoteCommunicator_errorPtr
newCallback_RemoteCommunicator_error(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_error<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_error.
 */
template<class T> Callback_RemoteCommunicator_errorPtr
newCallback_RemoteCommunicator_error(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_error<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_error.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_error.
 */
template<class T, typename CT>
class Callback_RemoteCommunicator_error : public Callback_RemoteCommunicator_error_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RemoteCommunicator_error(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_error.
 */
template<class T, typename CT> Callback_RemoteCommunicator_errorPtr
newCallback_RemoteCommunicator_error(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_error<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_error.
 */
template<class T, typename CT> Callback_RemoteCommunicator_errorPtr
newCallback_RemoteCommunicator_error(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_error<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_error.
 */
template<class T, typename CT> Callback_RemoteCommunicator_errorPtr
newCallback_RemoteCommunicator_error(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_error<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_error.
 */
template<class T, typename CT> Callback_RemoteCommunicator_errorPtr
newCallback_RemoteCommunicator_error(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_error<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_shutdown.
 */
template<class T>
class CallbackNC_RemoteCommunicator_shutdown : public Callback_RemoteCommunicator_shutdown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RemoteCommunicator_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_shutdown.
 */
template<class T> Callback_RemoteCommunicator_shutdownPtr
newCallback_RemoteCommunicator_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_shutdown.
 */
template<class T> Callback_RemoteCommunicator_shutdownPtr
newCallback_RemoteCommunicator_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_shutdown.
 */
template<class T> Callback_RemoteCommunicator_shutdownPtr
newCallback_RemoteCommunicator_shutdown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_shutdown.
 */
template<class T> Callback_RemoteCommunicator_shutdownPtr
newCallback_RemoteCommunicator_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_shutdown.
 */
template<class T, typename CT>
class Callback_RemoteCommunicator_shutdown : public Callback_RemoteCommunicator_shutdown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RemoteCommunicator_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_shutdown.
 */
template<class T, typename CT> Callback_RemoteCommunicator_shutdownPtr
newCallback_RemoteCommunicator_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_shutdown.
 */
template<class T, typename CT> Callback_RemoteCommunicator_shutdownPtr
newCallback_RemoteCommunicator_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_shutdown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_shutdown.
 */
template<class T, typename CT> Callback_RemoteCommunicator_shutdownPtr
newCallback_RemoteCommunicator_shutdown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_shutdown.
 */
template<class T, typename CT> Callback_RemoteCommunicator_shutdownPtr
newCallback_RemoteCommunicator_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_shutdown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_waitForShutdown.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_waitForShutdown.
 */
template<class T>
class CallbackNC_RemoteCommunicator_waitForShutdown : public Callback_RemoteCommunicator_waitForShutdown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RemoteCommunicator_waitForShutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_waitForShutdown.
 */
template<class T> Callback_RemoteCommunicator_waitForShutdownPtr
newCallback_RemoteCommunicator_waitForShutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_waitForShutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_waitForShutdown.
 */
template<class T> Callback_RemoteCommunicator_waitForShutdownPtr
newCallback_RemoteCommunicator_waitForShutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_waitForShutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_waitForShutdown.
 */
template<class T> Callback_RemoteCommunicator_waitForShutdownPtr
newCallback_RemoteCommunicator_waitForShutdown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_waitForShutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_waitForShutdown.
 */
template<class T> Callback_RemoteCommunicator_waitForShutdownPtr
newCallback_RemoteCommunicator_waitForShutdown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_waitForShutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_waitForShutdown.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_waitForShutdown.
 */
template<class T, typename CT>
class Callback_RemoteCommunicator_waitForShutdown : public Callback_RemoteCommunicator_waitForShutdown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RemoteCommunicator_waitForShutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_waitForShutdown.
 */
template<class T, typename CT> Callback_RemoteCommunicator_waitForShutdownPtr
newCallback_RemoteCommunicator_waitForShutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_waitForShutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_waitForShutdown.
 */
template<class T, typename CT> Callback_RemoteCommunicator_waitForShutdownPtr
newCallback_RemoteCommunicator_waitForShutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_waitForShutdown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_waitForShutdown.
 */
template<class T, typename CT> Callback_RemoteCommunicator_waitForShutdownPtr
newCallback_RemoteCommunicator_waitForShutdown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_waitForShutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_waitForShutdown.
 */
template<class T, typename CT> Callback_RemoteCommunicator_waitForShutdownPtr
newCallback_RemoteCommunicator_waitForShutdown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_waitForShutdown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_destroy.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_destroy.
 */
template<class T>
class CallbackNC_RemoteCommunicator_destroy : public Callback_RemoteCommunicator_destroy_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RemoteCommunicator_destroy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_destroy.
 */
template<class T> Callback_RemoteCommunicator_destroyPtr
newCallback_RemoteCommunicator_destroy(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_destroy<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_destroy.
 */
template<class T> Callback_RemoteCommunicator_destroyPtr
newCallback_RemoteCommunicator_destroy(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_destroy<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_destroy.
 */
template<class T> Callback_RemoteCommunicator_destroyPtr
newCallback_RemoteCommunicator_destroy(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_destroy<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_destroy.
 */
template<class T> Callback_RemoteCommunicator_destroyPtr
newCallback_RemoteCommunicator_destroy(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicator_destroy<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::RemoteCommunicator::begin_destroy.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicator_destroy.
 */
template<class T, typename CT>
class Callback_RemoteCommunicator_destroy : public Callback_RemoteCommunicator_destroy_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RemoteCommunicator_destroy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_destroy.
 */
template<class T, typename CT> Callback_RemoteCommunicator_destroyPtr
newCallback_RemoteCommunicator_destroy(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_destroy<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_destroy.
 */
template<class T, typename CT> Callback_RemoteCommunicator_destroyPtr
newCallback_RemoteCommunicator_destroy(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_destroy<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_destroy.
 */
template<class T, typename CT> Callback_RemoteCommunicator_destroyPtr
newCallback_RemoteCommunicator_destroy(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_destroy<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicator::begin_destroy.
 */
template<class T, typename CT> Callback_RemoteCommunicator_destroyPtr
newCallback_RemoteCommunicator_destroy(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicator_destroy<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::RemoteCommunicatorFactory::begin_createCommunicator.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicatorFactory_createCommunicator.
 */
template<class T>
class CallbackNC_RemoteCommunicatorFactory_createCommunicator : public Callback_RemoteCommunicatorFactory_createCommunicator_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const RemoteCommunicatorPrx&);

    CallbackNC_RemoteCommunicatorFactory_createCommunicator(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RemoteCommunicatorFactoryPrx proxy = RemoteCommunicatorFactoryPrx::uncheckedCast(result->getProxy());
        RemoteCommunicatorPrx ret;
        try
        {
            ret = proxy->end_createCommunicator(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicatorFactory::begin_createCommunicator.
 */
template<class T> Callback_RemoteCommunicatorFactory_createCommunicatorPtr
newCallback_RemoteCommunicatorFactory_createCommunicator(const IceUtil::Handle<T>& instance, void (T::*cb)(const RemoteCommunicatorPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicatorFactory_createCommunicator<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicatorFactory::begin_createCommunicator.
 */
template<class T> Callback_RemoteCommunicatorFactory_createCommunicatorPtr
newCallback_RemoteCommunicatorFactory_createCommunicator(T* instance, void (T::*cb)(const RemoteCommunicatorPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicatorFactory_createCommunicator<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::RemoteCommunicatorFactory::begin_createCommunicator.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicatorFactory_createCommunicator.
 */
template<class T, typename CT>
class Callback_RemoteCommunicatorFactory_createCommunicator : public Callback_RemoteCommunicatorFactory_createCommunicator_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const RemoteCommunicatorPrx&, const CT&);

    Callback_RemoteCommunicatorFactory_createCommunicator(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RemoteCommunicatorFactoryPrx proxy = RemoteCommunicatorFactoryPrx::uncheckedCast(result->getProxy());
        RemoteCommunicatorPrx ret;
        try
        {
            ret = proxy->end_createCommunicator(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicatorFactory::begin_createCommunicator.
 */
template<class T, typename CT> Callback_RemoteCommunicatorFactory_createCommunicatorPtr
newCallback_RemoteCommunicatorFactory_createCommunicator(const IceUtil::Handle<T>& instance, void (T::*cb)(const RemoteCommunicatorPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicatorFactory_createCommunicator<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicatorFactory::begin_createCommunicator.
 */
template<class T, typename CT> Callback_RemoteCommunicatorFactory_createCommunicatorPtr
newCallback_RemoteCommunicatorFactory_createCommunicator(T* instance, void (T::*cb)(const RemoteCommunicatorPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicatorFactory_createCommunicator<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::RemoteCommunicatorFactory::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicatorFactory_shutdown.
 */
template<class T>
class CallbackNC_RemoteCommunicatorFactory_shutdown : public Callback_RemoteCommunicatorFactory_shutdown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RemoteCommunicatorFactory_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicatorFactory::begin_shutdown.
 */
template<class T> Callback_RemoteCommunicatorFactory_shutdownPtr
newCallback_RemoteCommunicatorFactory_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicatorFactory_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicatorFactory::begin_shutdown.
 */
template<class T> Callback_RemoteCommunicatorFactory_shutdownPtr
newCallback_RemoteCommunicatorFactory_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicatorFactory_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicatorFactory::begin_shutdown.
 */
template<class T> Callback_RemoteCommunicatorFactory_shutdownPtr
newCallback_RemoteCommunicatorFactory_shutdown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicatorFactory_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicatorFactory::begin_shutdown.
 */
template<class T> Callback_RemoteCommunicatorFactory_shutdownPtr
newCallback_RemoteCommunicatorFactory_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RemoteCommunicatorFactory_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::RemoteCommunicatorFactory::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_RemoteCommunicatorFactory_shutdown.
 */
template<class T, typename CT>
class Callback_RemoteCommunicatorFactory_shutdown : public Callback_RemoteCommunicatorFactory_shutdown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RemoteCommunicatorFactory_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicatorFactory::begin_shutdown.
 */
template<class T, typename CT> Callback_RemoteCommunicatorFactory_shutdownPtr
newCallback_RemoteCommunicatorFactory_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicatorFactory_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicatorFactory::begin_shutdown.
 */
template<class T, typename CT> Callback_RemoteCommunicatorFactory_shutdownPtr
newCallback_RemoteCommunicatorFactory_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicatorFactory_shutdown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicatorFactory::begin_shutdown.
 */
template<class T, typename CT> Callback_RemoteCommunicatorFactory_shutdownPtr
newCallback_RemoteCommunicatorFactory_shutdown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicatorFactory_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::RemoteCommunicatorFactory::begin_shutdown.
 */
template<class T, typename CT> Callback_RemoteCommunicatorFactory_shutdownPtr
newCallback_RemoteCommunicatorFactory_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RemoteCommunicatorFactory_shutdown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestFacet::begin_op.
 * Create a wrapper instance by calling ::Test::newCallback_TestFacet_op.
 */
template<class T>
class CallbackNC_TestFacet_op : public Callback_TestFacet_op_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestFacet_op(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestFacet::begin_op.
 */
template<class T> Callback_TestFacet_opPtr
newCallback_TestFacet_op(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestFacet_op<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestFacet::begin_op.
 */
template<class T> Callback_TestFacet_opPtr
newCallback_TestFacet_op(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestFacet_op<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestFacet::begin_op.
 */
template<class T> Callback_TestFacet_opPtr
newCallback_TestFacet_op(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestFacet_op<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestFacet::begin_op.
 */
template<class T> Callback_TestFacet_opPtr
newCallback_TestFacet_op(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestFacet_op<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestFacet::begin_op.
 * Create a wrapper instance by calling ::Test::newCallback_TestFacet_op.
 */
template<class T, typename CT>
class Callback_TestFacet_op : public Callback_TestFacet_op_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestFacet_op(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestFacet::begin_op.
 */
template<class T, typename CT> Callback_TestFacet_opPtr
newCallback_TestFacet_op(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestFacet_op<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestFacet::begin_op.
 */
template<class T, typename CT> Callback_TestFacet_opPtr
newCallback_TestFacet_op(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestFacet_op<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestFacet::begin_op.
 */
template<class T, typename CT> Callback_TestFacet_opPtr
newCallback_TestFacet_op(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestFacet_op<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestFacet::begin_op.
 */
template<class T, typename CT> Callback_TestFacet_opPtr
newCallback_TestFacet_op(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestFacet_op<T, CT>(instance, 0, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
