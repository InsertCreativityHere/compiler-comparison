//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `TestAMD.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#define ICE_BUILDING_GENERATED_CODE
#include <TestAMD.h>
#include <IceUtil/PushDisableWarnings.h>
#include <IceUtil/PopDisableWarnings.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace
{

const ::IceInternal::DefaultValueFactoryInit<::Test::C> iceC_Test_C_init("::Test::C");

const ::std::string iceC_Test_D_ids[2] =
{
    "::Ice::Object",
    "::Test::D"
};
const ::std::string iceC_Test_D_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

const ::IceInternal::DefaultValueFactoryInit<::Test::DictClass> iceC_Test_DictClass_init("::Test::DictClass");

const ::std::string iceC_Test_TestIntf_ids[2] =
{
    "::Ice::Object",
    "::Test::TestIntf"
};
const ::std::string iceC_Test_TestIntf_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "opBoolArray",
    "opBoolBuffer",
    "opBoolList",
    "opBoolRange",
    "opBoolSeq",
    "opBufferStruct",
    "opByteArray",
    "opByteList",
    "opByteRange",
    "opByteRangeType",
    "opByteSeq",
    "opCList",
    "opCSeq",
    "opClassStruct",
    "opCustomIntStringDict",
    "opDPrxList",
    "opDPrxSeq",
    "opDoubleArray",
    "opEList",
    "opESeq",
    "opFixedList",
    "opFixedSeq",
    "opIntStringDict",
    "opMyByteSeq",
    "opOutArrayByteSeq",
    "opOutRangeByteSeq",
    "opShortBuffer",
    "opString",
    "opStringList",
    "opStringSeq",
    "opStringStringDictList",
    "opStringStringDictSeq",
    "opVarDict",
    "opVariableArray",
    "opVariableList",
    "opVariableRange",
    "opVariableRangeType",
    "opVariableSeq",
    "shutdown"
};
const ::std::string iceC_Test_TestIntf_opDoubleArray_name = "opDoubleArray";
const ::std::string iceC_Test_TestIntf_opBoolArray_name = "opBoolArray";
const ::std::string iceC_Test_TestIntf_opByteArray_name = "opByteArray";
const ::std::string iceC_Test_TestIntf_opVariableArray_name = "opVariableArray";
const ::std::string iceC_Test_TestIntf_opBoolRange_name = "opBoolRange";
const ::std::string iceC_Test_TestIntf_opByteRange_name = "opByteRange";
const ::std::string iceC_Test_TestIntf_opVariableRange_name = "opVariableRange";
const ::std::string iceC_Test_TestIntf_opByteRangeType_name = "opByteRangeType";
const ::std::string iceC_Test_TestIntf_opVariableRangeType_name = "opVariableRangeType";
const ::std::string iceC_Test_TestIntf_opBoolSeq_name = "opBoolSeq";
const ::std::string iceC_Test_TestIntf_opBoolList_name = "opBoolList";
const ::std::string iceC_Test_TestIntf_opByteSeq_name = "opByteSeq";
const ::std::string iceC_Test_TestIntf_opByteList_name = "opByteList";
const ::std::string iceC_Test_TestIntf_opMyByteSeq_name = "opMyByteSeq";
const ::std::string iceC_Test_TestIntf_opString_name = "opString";
const ::std::string iceC_Test_TestIntf_opStringSeq_name = "opStringSeq";
const ::std::string iceC_Test_TestIntf_opStringList_name = "opStringList";
const ::std::string iceC_Test_TestIntf_opFixedSeq_name = "opFixedSeq";
const ::std::string iceC_Test_TestIntf_opFixedList_name = "opFixedList";
const ::std::string iceC_Test_TestIntf_opVariableSeq_name = "opVariableSeq";
const ::std::string iceC_Test_TestIntf_opVariableList_name = "opVariableList";
const ::std::string iceC_Test_TestIntf_opStringStringDictSeq_name = "opStringStringDictSeq";
const ::std::string iceC_Test_TestIntf_opStringStringDictList_name = "opStringStringDictList";
const ::std::string iceC_Test_TestIntf_opESeq_name = "opESeq";
const ::std::string iceC_Test_TestIntf_opEList_name = "opEList";
const ::std::string iceC_Test_TestIntf_opDPrxSeq_name = "opDPrxSeq";
const ::std::string iceC_Test_TestIntf_opDPrxList_name = "opDPrxList";
const ::std::string iceC_Test_TestIntf_opCSeq_name = "opCSeq";
const ::std::string iceC_Test_TestIntf_opCList_name = "opCList";
const ::std::string iceC_Test_TestIntf_opClassStruct_name = "opClassStruct";
const ::std::string iceC_Test_TestIntf_opOutArrayByteSeq_name = "opOutArrayByteSeq";
const ::std::string iceC_Test_TestIntf_opOutRangeByteSeq_name = "opOutRangeByteSeq";
const ::std::string iceC_Test_TestIntf_opIntStringDict_name = "opIntStringDict";
const ::std::string iceC_Test_TestIntf_opVarDict_name = "opVarDict";
const ::std::string iceC_Test_TestIntf_opCustomIntStringDict_name = "opCustomIntStringDict";
const ::std::string iceC_Test_TestIntf_opShortBuffer_name = "opShortBuffer";
const ::std::string iceC_Test_TestIntf_opBoolBuffer_name = "opBoolBuffer";
const ::std::string iceC_Test_TestIntf_opBufferStruct_name = "opBufferStruct";
const ::std::string iceC_Test_TestIntf_shutdown_name = "shutdown";

}

bool
Test::D::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_D_ids, iceC_Test_D_ids + 2, s);
}

::std::vector<::std::string>
Test::D::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_D_ids[0], &iceC_Test_D_ids[2]);
}

::std::string
Test::D::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::D::ice_staticId()
{
    static const ::std::string typeId = "::Test::D";
    return typeId;
}

bool
Test::TestIntf::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_TestIntf_ids, iceC_Test_TestIntf_ids + 2, s);
}

::std::vector<::std::string>
Test::TestIntf::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_TestIntf_ids[0], &iceC_Test_TestIntf_ids[2]);
}

::std::string
Test::TestIntf::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::TestIntf::ice_staticId()
{
    static const ::std::string typeId = "::Test::TestIntf";
    return typeId;
}

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDoubleArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::pair<const double*, const double*> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const DoubleSeq& ret, const DoubleSeq& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opDoubleArrayAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::pair<const bool*, const bool*> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const BoolSeq& ret, const BoolSeq& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opBoolArrayAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& ret, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opByteArrayAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVariableArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::pair<const Variable*, const Variable*> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const VariableList& ret, const VariableList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opVariableArrayAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    BoolSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const BoolSeq& ret, const BoolSeq& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opBoolRangeAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ByteList& ret, const ByteList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opByteRangeAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVariableRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    VariableList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const VariableList& ret, const VariableList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opVariableRangeAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteRangeType(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ByteList& ret, const ByteList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opByteRangeTypeAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVariableRangeType(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    VariableList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const VariableList& ret, const VariableList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opVariableRangeTypeAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque<bool> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const std::deque<bool>& ret, const std::deque<bool>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opBoolSeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    BoolList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const BoolList& ret, const BoolList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opBoolListAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque< ::Ice::Byte> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const std::deque< ::Ice::Byte>& ret, const std::deque< ::Ice::Byte>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opByteSeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ByteList& ret, const ByteList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opByteListAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opMyByteSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    MyByteSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const MyByteSeq& ret, const MyByteSeq& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opMyByteSeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opString(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    Util::string_view iceP_inString;
    istr->readAll(iceP_inString);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const Util::string_view& ret, const Util::string_view& iceP_outString)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outString, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opStringAsync(::std::move(iceP_inString), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque<std::string> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const std::deque<std::string>& ret, const std::deque<std::string>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opStringSeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const StringList& ret, const StringList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opStringListAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opFixedSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque< ::Test::Fixed> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const std::deque< ::Test::Fixed>& ret, const std::deque< ::Test::Fixed>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opFixedSeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opFixedList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    FixedList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const FixedList& ret, const FixedList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opFixedListAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVariableSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque< ::Test::Variable> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const std::deque< ::Test::Variable>& ret, const std::deque< ::Test::Variable>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opVariableSeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVariableList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    VariableList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const VariableList& ret, const VariableList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opVariableListAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringStringDictSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque< ::Test::StringStringDict> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const std::deque< ::Test::StringStringDict>& ret, const std::deque< ::Test::StringStringDict>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opStringStringDictSeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringStringDictList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringStringDictList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const StringStringDictList& ret, const StringStringDictList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opStringStringDictListAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opESeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque< ::Test::E> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const std::deque< ::Test::E>& ret, const std::deque< ::Test::E>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opESeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opEList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    EList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const EList& ret, const EList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opEListAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDPrxSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque<std::shared_ptr<::Test::DPrx>> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const std::deque<std::shared_ptr<::Test::DPrx>>& ret, const std::deque<std::shared_ptr<::Test::DPrx>>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opDPrxSeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDPrxList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    DPrxList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const DPrxList& ret, const DPrxList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opDPrxListAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opCSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque<std::shared_ptr<Test::C>> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->readPendingValues();
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const std::deque<std::shared_ptr<Test::C>>& ret, const std::deque<std::shared_ptr<Test::C>>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->opCSeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opCList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    CList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->readPendingValues();
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const CList& ret, const CList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->opCListAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opClassStruct(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ClassStruct iceP_inS;
    ClassStructSeq iceP_inSeq;
    istr->readAll(iceP_inS, iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ClassStruct& ret, const ClassStruct& iceP_outS, const ClassStructSeq& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outS, iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opClassStructAsync(::std::move(iceP_inS), ::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOutArrayByteSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteSeq iceP_org;
    istr->readAll(iceP_org);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& iceP_copy)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_copy);
        inA->endWriteParams();
        inA->completed();
    };
    this->opOutArrayByteSeqAsync(::std::move(iceP_org), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOutRangeByteSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteSeq iceP_org;
    istr->readAll(iceP_org);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ByteSeq& iceP_copy)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_copy);
        inA->endWriteParams();
        inA->completed();
    };
    this->opOutRangeByteSeqAsync(::std::move(iceP_org), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opIntStringDict(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    IntStringDict iceP_idict;
    istr->readAll(iceP_idict);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const IntStringDict& ret, const IntStringDict& iceP_odict)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_odict, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opIntStringDictAsync(::std::move(iceP_idict), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVarDict(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::Test::CustomMap<std::string, ::Ice::Int> iceP_idict;
    istr->readAll(iceP_idict);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>& ret, const ::Test::CustomMap<std::string, ::Ice::Int>& iceP_odict)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_odict, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opVarDictAsync(::std::move(iceP_idict), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opCustomIntStringDict(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::map< ::Ice::Int, ::Util::string_view> iceP_idict;
    istr->readAll(iceP_idict);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::map< ::Ice::Int, ::Util::string_view>& ret, const ::std::map< ::Ice::Int, ::Util::string_view>& iceP_odict)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_odict, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opCustomIntStringDictAsync(::std::move(iceP_idict), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opShortBuffer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ShortBuffer iceP_inS;
    istr->readAll(iceP_inS);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ShortBuffer& ret, const ShortBuffer& iceP_outS)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outS, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opShortBufferAsync(::std::move(iceP_inS), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolBuffer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::Test::CustomBuffer<bool> iceP_inS;
    istr->readAll(iceP_inS);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::Test::CustomBuffer<bool>& ret, const ::Test::CustomBuffer<bool>& iceP_outS)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outS, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opBoolBufferAsync(::std::move(iceP_inS), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBufferStruct(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    BufferStruct iceP_s;
    istr->readAll(iceP_s);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const BufferStruct& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opBufferStructAsync(::std::move(iceP_s), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_shutdown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->shutdownAsync(inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_TestIntf_ops, iceC_Test_TestIntf_ops + 43, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_TestIntf_ops)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_opBoolArray(in, current);
        }
        case 5:
        {
            return _iceD_opBoolBuffer(in, current);
        }
        case 6:
        {
            return _iceD_opBoolList(in, current);
        }
        case 7:
        {
            return _iceD_opBoolRange(in, current);
        }
        case 8:
        {
            return _iceD_opBoolSeq(in, current);
        }
        case 9:
        {
            return _iceD_opBufferStruct(in, current);
        }
        case 10:
        {
            return _iceD_opByteArray(in, current);
        }
        case 11:
        {
            return _iceD_opByteList(in, current);
        }
        case 12:
        {
            return _iceD_opByteRange(in, current);
        }
        case 13:
        {
            return _iceD_opByteRangeType(in, current);
        }
        case 14:
        {
            return _iceD_opByteSeq(in, current);
        }
        case 15:
        {
            return _iceD_opCList(in, current);
        }
        case 16:
        {
            return _iceD_opCSeq(in, current);
        }
        case 17:
        {
            return _iceD_opClassStruct(in, current);
        }
        case 18:
        {
            return _iceD_opCustomIntStringDict(in, current);
        }
        case 19:
        {
            return _iceD_opDPrxList(in, current);
        }
        case 20:
        {
            return _iceD_opDPrxSeq(in, current);
        }
        case 21:
        {
            return _iceD_opDoubleArray(in, current);
        }
        case 22:
        {
            return _iceD_opEList(in, current);
        }
        case 23:
        {
            return _iceD_opESeq(in, current);
        }
        case 24:
        {
            return _iceD_opFixedList(in, current);
        }
        case 25:
        {
            return _iceD_opFixedSeq(in, current);
        }
        case 26:
        {
            return _iceD_opIntStringDict(in, current);
        }
        case 27:
        {
            return _iceD_opMyByteSeq(in, current);
        }
        case 28:
        {
            return _iceD_opOutArrayByteSeq(in, current);
        }
        case 29:
        {
            return _iceD_opOutRangeByteSeq(in, current);
        }
        case 30:
        {
            return _iceD_opShortBuffer(in, current);
        }
        case 31:
        {
            return _iceD_opString(in, current);
        }
        case 32:
        {
            return _iceD_opStringList(in, current);
        }
        case 33:
        {
            return _iceD_opStringSeq(in, current);
        }
        case 34:
        {
            return _iceD_opStringStringDictList(in, current);
        }
        case 35:
        {
            return _iceD_opStringStringDictSeq(in, current);
        }
        case 36:
        {
            return _iceD_opVarDict(in, current);
        }
        case 37:
        {
            return _iceD_opVariableArray(in, current);
        }
        case 38:
        {
            return _iceD_opVariableList(in, current);
        }
        case 39:
        {
            return _iceD_opVariableRange(in, current);
        }
        case 40:
        {
            return _iceD_opVariableRangeType(in, current);
        }
        case 41:
        {
            return _iceD_opVariableSeq(in, current);
        }
        case 42:
        {
            return _iceD_shutdown(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

Test::C::~C()
{
}

const ::std::string&
Test::C::ice_staticId()
{
    static const ::std::string typeId = "::Test::C";
    return typeId;
}

Test::DictClass::~DictClass()
{
}

const ::std::string&
Test::DictClass::ice_staticId()
{
    static const ::std::string typeId = "::Test::DictClass";
    return typeId;
}

const ::std::string&
Test::DPrx::ice_staticId()
{
    return D::ice_staticId();
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opDoubleArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpDoubleArrayResult>>& outAsync, const ::std::pair<const double*, const double*>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opDoubleArray_name);
    outAsync->invoke(iceC_Test_TestIntf_opDoubleArray_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpDoubleArrayResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opBoolArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolArrayResult>>& outAsync, const ::std::pair<const bool*, const bool*>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolArray_name);
    outAsync->invoke(iceC_Test_TestIntf_opBoolArray_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpBoolArrayResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

::std::function<void()>
Test::TestIntfPrx::opByteArrayAsync(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& iceP_inSeq,
                                    ::std::function<void (::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>, ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteArray_name);
    ::std::function<void(::Ice::InputStream*)> read;
    if(response)
    {
        read = [response](::Ice::InputStream* istr)
        {
            istr->startEncapsulation();
            ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> iceP_outSeq;
            ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> ret;
            istr->readAll(iceP_outSeq, ret);
            istr->endEncapsulation();
            try
            {
                response(ret, iceP_outSeq);
            }
            catch(...)
            {
                throw ::std::current_exception();
            }
        };
    }
    auto outAsync = ::std::make_shared<::IceInternal::CustomLambdaOutgoing>(shared_from_this(), read, ex, sent);

    outAsync->invoke(iceC_Test_TestIntf_opByteArray_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr);
    return [outAsync]() { outAsync->cancel(); };
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opByteArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteArrayResult>>& outAsync, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteArray_name);
    outAsync->invoke(iceC_Test_TestIntf_opByteArray_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpByteArrayResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opVariableArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpVariableArrayResult>>& outAsync, const ::std::pair<const Variable*, const Variable*>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opVariableArray_name);
    outAsync->invoke(iceC_Test_TestIntf_opVariableArray_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpVariableArrayResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opBoolRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolRangeResult>>& outAsync, const BoolSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolRange_name);
    outAsync->invoke(iceC_Test_TestIntf_opBoolRange_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpBoolRangeResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opByteRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteRangeResult>>& outAsync, const ByteList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteRange_name);
    outAsync->invoke(iceC_Test_TestIntf_opByteRange_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpByteRangeResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opVariableRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpVariableRangeResult>>& outAsync, const VariableList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opVariableRange_name);
    outAsync->invoke(iceC_Test_TestIntf_opVariableRange_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpVariableRangeResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opByteRangeType(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteRangeTypeResult>>& outAsync, const ByteList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteRangeType_name);
    outAsync->invoke(iceC_Test_TestIntf_opByteRangeType_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpByteRangeTypeResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opVariableRangeType(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpVariableRangeTypeResult>>& outAsync, const VariableList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opVariableRangeType_name);
    outAsync->invoke(iceC_Test_TestIntf_opVariableRangeType_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpVariableRangeTypeResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opBoolSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolSeqResult>>& outAsync, const std::deque<bool>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opBoolSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpBoolSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opBoolList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolListResult>>& outAsync, const BoolList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolList_name);
    outAsync->invoke(iceC_Test_TestIntf_opBoolList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpBoolListResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteSeqResult>>& outAsync, const std::deque< ::Ice::Byte>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opByteSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpByteSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opByteList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteListResult>>& outAsync, const ByteList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteList_name);
    outAsync->invoke(iceC_Test_TestIntf_opByteList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpByteListResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opMyByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpMyByteSeqResult>>& outAsync, const MyByteSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opMyByteSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opMyByteSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpMyByteSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

::std::function<void()>
Test::TestIntfPrx::opStringAsync(const Util::string_view& iceP_inString,
                                 ::std::function<void (Util::string_view, Util::string_view)> response,
                                 ::std::function<void(::std::exception_ptr)> ex,
                                 ::std::function<void(bool)> sent,
                                 const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opString_name);
    ::std::function<void(::Ice::InputStream*)> read;
    if(response)
    {
        read = [response](::Ice::InputStream* istr)
        {
            istr->startEncapsulation();
            Util::string_view iceP_outString;
            Util::string_view ret;
            istr->readAll(iceP_outString, ret);
            istr->endEncapsulation();
            try
            {
                response(ret, iceP_outString);
            }
            catch(...)
            {
                throw ::std::current_exception();
            }
        };
    }
    auto outAsync = ::std::make_shared<::IceInternal::CustomLambdaOutgoing>(shared_from_this(), read, ex, sent);

    outAsync->invoke(iceC_Test_TestIntf_opString_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inString);
        },
        nullptr);
    return [outAsync]() { outAsync->cancel(); };
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opString(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringResult>>& outAsync, const Util::string_view& iceP_inString, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opString_name);
    outAsync->invoke(iceC_Test_TestIntf_opString_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inString);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpStringResult v;
            istr->readAll(v.outString, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opStringSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringSeqResult>>& outAsync, const std::deque<std::string>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opStringSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opStringSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpStringSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opStringList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringListResult>>& outAsync, const StringList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opStringList_name);
    outAsync->invoke(iceC_Test_TestIntf_opStringList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpStringListResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opFixedSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpFixedSeqResult>>& outAsync, const std::deque< ::Test::Fixed>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opFixedSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opFixedSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpFixedSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opFixedList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpFixedListResult>>& outAsync, const FixedList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opFixedList_name);
    outAsync->invoke(iceC_Test_TestIntf_opFixedList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpFixedListResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opVariableSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpVariableSeqResult>>& outAsync, const std::deque< ::Test::Variable>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opVariableSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opVariableSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpVariableSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opVariableList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpVariableListResult>>& outAsync, const VariableList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opVariableList_name);
    outAsync->invoke(iceC_Test_TestIntf_opVariableList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpVariableListResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opStringStringDictSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringStringDictSeqResult>>& outAsync, const std::deque< ::Test::StringStringDict>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opStringStringDictSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opStringStringDictSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpStringStringDictSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opStringStringDictList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringStringDictListResult>>& outAsync, const StringStringDictList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opStringStringDictList_name);
    outAsync->invoke(iceC_Test_TestIntf_opStringStringDictList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpStringStringDictListResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opESeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpESeqResult>>& outAsync, const std::deque< ::Test::E>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opESeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opESeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpESeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opEList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpEListResult>>& outAsync, const EList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opEList_name);
    outAsync->invoke(iceC_Test_TestIntf_opEList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpEListResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opDPrxSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpDPrxSeqResult>>& outAsync, const std::deque<std::shared_ptr<::Test::DPrx>>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opDPrxSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opDPrxSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpDPrxSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opDPrxList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpDPrxListResult>>& outAsync, const DPrxList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opDPrxList_name);
    outAsync->invoke(iceC_Test_TestIntf_opDPrxList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpDPrxListResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opCSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpCSeqResult>>& outAsync, const std::deque<std::shared_ptr<Test::C>>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opCSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opCSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpCSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opCList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpCListResult>>& outAsync, const CList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opCList_name);
    outAsync->invoke(iceC_Test_TestIntf_opCList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpCListResult v;
            istr->readAll(v.outSeq, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opClassStruct(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpClassStructResult>>& outAsync, const ClassStruct& iceP_inS, const ClassStructSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opClassStruct_name);
    outAsync->invoke(iceC_Test_TestIntf_opClassStruct_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inS, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpClassStructResult v;
            istr->readAll(v.outS, v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

::std::function<void()>
Test::TestIntfPrx::opOutArrayByteSeqAsync(const ByteSeq& iceP_org,
                                          ::std::function<void (::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>)> response,
                                          ::std::function<void(::std::exception_ptr)> ex,
                                          ::std::function<void(bool)> sent,
                                          const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOutArrayByteSeq_name);
    ::std::function<void(::Ice::InputStream*)> read;
    if(response)
    {
        read = [response](::Ice::InputStream* istr)
        {
            istr->startEncapsulation();
            ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> iceP_copy;
            istr->readAll(iceP_copy);
            istr->endEncapsulation();
            try
            {
                response(iceP_copy);
            }
            catch(...)
            {
                throw ::std::current_exception();
            }
        };
    }
    auto outAsync = ::std::make_shared<::IceInternal::CustomLambdaOutgoing>(shared_from_this(), read, ex, sent);

    outAsync->invoke(iceC_Test_TestIntf_opOutArrayByteSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_org);
        },
        nullptr);
    return [outAsync]() { outAsync->cancel(); };
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOutArrayByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::ByteSeq>>& outAsync, const ByteSeq& iceP_org, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOutArrayByteSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOutArrayByteSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_org);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOutRangeByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::ByteSeq>>& outAsync, const ByteSeq& iceP_org, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOutRangeByteSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOutRangeByteSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_org);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opIntStringDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpIntStringDictResult>>& outAsync, const IntStringDict& iceP_idict, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opIntStringDict_name);
    outAsync->invoke(iceC_Test_TestIntf_opIntStringDict_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_idict);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpIntStringDictResult v;
            istr->readAll(v.odict, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opVarDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpVarDictResult>>& outAsync, const ::Test::CustomMap<std::string, ::Ice::Int>& iceP_idict, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opVarDict_name);
    outAsync->invoke(iceC_Test_TestIntf_opVarDict_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_idict);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpVarDictResult v;
            istr->readAll(v.odict, v.returnValue);
            return v;
        });
}
/// \endcond

::std::function<void()>
Test::TestIntfPrx::opCustomIntStringDictAsync(const ::std::map< ::Ice::Int, ::Util::string_view>& iceP_idict,
                                              ::std::function<void (::std::map< ::Ice::Int, ::Util::string_view>, ::std::map< ::Ice::Int, ::Util::string_view>)> response,
                                              ::std::function<void(::std::exception_ptr)> ex,
                                              ::std::function<void(bool)> sent,
                                              const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opCustomIntStringDict_name);
    ::std::function<void(::Ice::InputStream*)> read;
    if(response)
    {
        read = [response](::Ice::InputStream* istr)
        {
            istr->startEncapsulation();
            ::std::map< ::Ice::Int, ::Util::string_view> iceP_odict;
            ::std::map< ::Ice::Int, ::Util::string_view> ret;
            istr->readAll(iceP_odict, ret);
            istr->endEncapsulation();
            try
            {
                response(ret, iceP_odict);
            }
            catch(...)
            {
                throw ::std::current_exception();
            }
        };
    }
    auto outAsync = ::std::make_shared<::IceInternal::CustomLambdaOutgoing>(shared_from_this(), read, ex, sent);

    outAsync->invoke(iceC_Test_TestIntf_opCustomIntStringDict_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_idict);
        },
        nullptr);
    return [outAsync]() { outAsync->cancel(); };
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opCustomIntStringDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpCustomIntStringDictResult>>& outAsync, const ::std::map< ::Ice::Int, ::Util::string_view>& iceP_idict, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opCustomIntStringDict_name);
    outAsync->invoke(iceC_Test_TestIntf_opCustomIntStringDict_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_idict);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpCustomIntStringDictResult v;
            istr->readAll(v.odict, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opShortBuffer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpShortBufferResult>>& outAsync, const ShortBuffer& iceP_inS, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opShortBuffer_name);
    outAsync->invoke(iceC_Test_TestIntf_opShortBuffer_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inS);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpShortBufferResult v;
            istr->readAll(v.outS, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opBoolBuffer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolBufferResult>>& outAsync, const ::Test::CustomBuffer<bool>& iceP_inS, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolBuffer_name);
    outAsync->invoke(iceC_Test_TestIntf_opBoolBuffer_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inS);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpBoolBufferResult v;
            istr->readAll(v.outS, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opBufferStruct(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::BufferStruct>>& outAsync, const BufferStruct& iceP_s, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBufferStruct_name);
    outAsync->invoke(iceC_Test_TestIntf_opBufferStruct_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_s);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_TestIntf_shutdown_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

const ::std::string&
Test::TestIntfPrx::ice_staticId()
{
    return TestIntf::ice_staticId();
}

namespace Ice
{
}
