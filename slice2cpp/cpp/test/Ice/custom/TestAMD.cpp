//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `TestAMD.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#define ICE_BUILDING_GENERATED_CODE
#include <TestAMD.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace
{

const ::IceInternal::DefaultValueFactoryInit<::Test::C> iceC_Test_C_init("::Test::C");

const ::IceInternal::DefaultValueFactoryInit<::Test::DictClass> iceC_Test_DictClass_init("::Test::DictClass");

}

::std::string_view
Test::DPrx::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::Test::D";
    return typeId;
}

::Test::DoubleSeq
Test::TestIntfPrx::opDoubleArray(const ::std::pair<const double*, const double*>& iceP_inSeq, DoubleSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<DoubleSeq, DoubleSeq>>(true, this, &TestIntfPrx::_iceI_opDoubleArray, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::DoubleSeq, ::Test::DoubleSeq>>
Test::TestIntfPrx::opDoubleArrayAsync(const ::std::pair<const double*, const double*>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<DoubleSeq, DoubleSeq>>(false, this, &TestIntfPrx::_iceI_opDoubleArray, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opDoubleArrayAsync(const ::std::pair<const double*, const double*>& iceP_inSeq, ::std::function<void(::Test::DoubleSeq, ::Test::DoubleSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<DoubleSeq, DoubleSeq>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<DoubleSeq, DoubleSeq>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opDoubleArray, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opDoubleArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<DoubleSeq, DoubleSeq>>>& outAsync, const ::std::pair<const double*, const double*>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opDoubleArray";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<DoubleSeq, DoubleSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::BoolSeq
Test::TestIntfPrx::opBoolArray(const ::std::pair<const bool*, const bool*>& iceP_inSeq, BoolSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<BoolSeq, BoolSeq>>(true, this, &TestIntfPrx::_iceI_opBoolArray, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::BoolSeq, ::Test::BoolSeq>>
Test::TestIntfPrx::opBoolArrayAsync(const ::std::pair<const bool*, const bool*>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<BoolSeq, BoolSeq>>(false, this, &TestIntfPrx::_iceI_opBoolArray, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opBoolArrayAsync(const ::std::pair<const bool*, const bool*>& iceP_inSeq, ::std::function<void(::Test::BoolSeq, ::Test::BoolSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<BoolSeq, BoolSeq>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<BoolSeq, BoolSeq>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolArray, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opBoolArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BoolSeq, BoolSeq>>>& outAsync, const ::std::pair<const bool*, const bool*>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opBoolArray";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<BoolSeq, BoolSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::ByteList
Test::TestIntfPrx::opByteArray(const ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>& iceP_inSeq, ByteList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<ByteList, ByteList>>(true, this, &TestIntfPrx::_iceI_opByteArray, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::ByteList, ::Test::ByteList>>
Test::TestIntfPrx::opByteArrayAsync(const ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ByteList, ByteList>>(false, this, &TestIntfPrx::_iceI_opByteArray, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opByteArrayAsync(const ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>& iceP_inSeq, ::std::function<void(::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>, ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>, ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>, ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceIL_opByteArray, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opByteArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteList, ByteList>>>& outAsync, const ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opByteArray";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ByteList, ByteList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

void
Test::TestIntfPrx::_iceIL_opByteArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>, ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>>>>& outAsync, const ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opByteArray";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>, ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::VariableList
Test::TestIntfPrx::opVariableArray(const ::std::pair<const Variable*, const Variable*>& iceP_inSeq, VariableList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<VariableList, VariableList>>(true, this, &TestIntfPrx::_iceI_opVariableArray, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::VariableList, ::Test::VariableList>>
Test::TestIntfPrx::opVariableArrayAsync(const ::std::pair<const Variable*, const Variable*>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<VariableList, VariableList>>(false, this, &TestIntfPrx::_iceI_opVariableArray, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opVariableArrayAsync(const ::std::pair<const Variable*, const Variable*>& iceP_inSeq, ::std::function<void(::Test::VariableList, ::Test::VariableList)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<VariableList, VariableList>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<VariableList, VariableList>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opVariableArray, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opVariableArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<VariableList, VariableList>>>& outAsync, const ::std::pair<const Variable*, const Variable*>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opVariableArray";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<VariableList, VariableList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

std::deque<bool>
Test::TestIntfPrx::opBoolSeq(const std::deque<bool>& iceP_inSeq, std::deque<bool>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<bool>, std::deque<bool>>>(true, this, &TestIntfPrx::_iceI_opBoolSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<std::deque<bool>, std::deque<bool>>>
Test::TestIntfPrx::opBoolSeqAsync(const std::deque<bool>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<bool>, std::deque<bool>>>(false, this, &TestIntfPrx::_iceI_opBoolSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opBoolSeqAsync(const std::deque<bool>& iceP_inSeq, ::std::function<void(std::deque<bool>, std::deque<bool>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<std::deque<bool>, std::deque<bool>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<std::deque<bool>, std::deque<bool>>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opBoolSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque<bool>, std::deque<bool>>>>& outAsync, const std::deque<bool>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opBoolSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::deque<bool>, std::deque<bool>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::BoolList
Test::TestIntfPrx::opBoolList(const BoolList& iceP_inSeq, BoolList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<BoolList, BoolList>>(true, this, &TestIntfPrx::_iceI_opBoolList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::BoolList, ::Test::BoolList>>
Test::TestIntfPrx::opBoolListAsync(const BoolList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<BoolList, BoolList>>(false, this, &TestIntfPrx::_iceI_opBoolList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opBoolListAsync(const BoolList& iceP_inSeq, ::std::function<void(::Test::BoolList, ::Test::BoolList)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<BoolList, BoolList>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<BoolList, BoolList>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolList, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opBoolList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BoolList, BoolList>>>& outAsync, const BoolList& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opBoolList";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<BoolList, BoolList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

std::deque<std::uint8_t>
Test::TestIntfPrx::opByteSeq(const std::deque<std::uint8_t>& iceP_inSeq, std::deque<std::uint8_t>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<std::uint8_t>, std::deque<std::uint8_t>>>(true, this, &TestIntfPrx::_iceI_opByteSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<std::deque<std::uint8_t>, std::deque<std::uint8_t>>>
Test::TestIntfPrx::opByteSeqAsync(const std::deque<std::uint8_t>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<std::uint8_t>, std::deque<std::uint8_t>>>(false, this, &TestIntfPrx::_iceI_opByteSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opByteSeqAsync(const std::deque<std::uint8_t>& iceP_inSeq, ::std::function<void(std::deque<std::uint8_t>, std::deque<std::uint8_t>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<std::deque<std::uint8_t>, std::deque<std::uint8_t>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<std::deque<std::uint8_t>, std::deque<std::uint8_t>>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opByteSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque<std::uint8_t>, std::deque<std::uint8_t>>>>& outAsync, const std::deque<std::uint8_t>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opByteSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::deque<std::uint8_t>, std::deque<std::uint8_t>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::ByteList
Test::TestIntfPrx::opByteList(const ByteList& iceP_inSeq, ByteList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<ByteList, ByteList>>(true, this, &TestIntfPrx::_iceI_opByteList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::ByteList, ::Test::ByteList>>
Test::TestIntfPrx::opByteListAsync(const ByteList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ByteList, ByteList>>(false, this, &TestIntfPrx::_iceI_opByteList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opByteListAsync(const ByteList& iceP_inSeq, ::std::function<void(::Test::ByteList, ::Test::ByteList)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<ByteList, ByteList>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ByteList, ByteList>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opByteList, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opByteList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteList, ByteList>>>& outAsync, const ByteList& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opByteList";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ByteList, ByteList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

MyByteSeq
Test::TestIntfPrx::opMyByteSeq(const MyByteSeq& iceP_inSeq, MyByteSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<MyByteSeq, MyByteSeq>>(true, this, &TestIntfPrx::_iceI_opMyByteSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<MyByteSeq, MyByteSeq>>
Test::TestIntfPrx::opMyByteSeqAsync(const MyByteSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<MyByteSeq, MyByteSeq>>(false, this, &TestIntfPrx::_iceI_opMyByteSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opMyByteSeqAsync(const MyByteSeq& iceP_inSeq, ::std::function<void(MyByteSeq, MyByteSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<MyByteSeq, MyByteSeq>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<MyByteSeq, MyByteSeq>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opMyByteSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opMyByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<MyByteSeq, MyByteSeq>>>& outAsync, const MyByteSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opMyByteSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<MyByteSeq, MyByteSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

std::deque<std::string>
Test::TestIntfPrx::opStringSeq(const std::deque<std::string>& iceP_inSeq, std::deque<std::string>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<std::string>, std::deque<std::string>>>(true, this, &TestIntfPrx::_iceI_opStringSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<std::deque<std::string>, std::deque<std::string>>>
Test::TestIntfPrx::opStringSeqAsync(const std::deque<std::string>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<std::string>, std::deque<std::string>>>(false, this, &TestIntfPrx::_iceI_opStringSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opStringSeqAsync(const std::deque<std::string>& iceP_inSeq, ::std::function<void(std::deque<std::string>, std::deque<std::string>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<std::deque<std::string>, std::deque<std::string>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<std::deque<std::string>, std::deque<std::string>>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opStringSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque<std::string>, std::deque<std::string>>>>& outAsync, const std::deque<std::string>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opStringSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::deque<std::string>, std::deque<std::string>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::StringList
Test::TestIntfPrx::opStringList(const StringList& iceP_inSeq, StringList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<StringList, StringList>>(true, this, &TestIntfPrx::_iceI_opStringList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::StringList, ::Test::StringList>>
Test::TestIntfPrx::opStringListAsync(const StringList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<StringList, StringList>>(false, this, &TestIntfPrx::_iceI_opStringList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opStringListAsync(const StringList& iceP_inSeq, ::std::function<void(::Test::StringList, ::Test::StringList)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<StringList, StringList>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<StringList, StringList>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringList, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opStringList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringList, StringList>>>& outAsync, const StringList& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opStringList";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<StringList, StringList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

std::deque<::Test::Fixed>
Test::TestIntfPrx::opFixedSeq(const std::deque<::Test::Fixed>& iceP_inSeq, std::deque<::Test::Fixed>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<::Test::Fixed>, std::deque<::Test::Fixed>>>(true, this, &TestIntfPrx::_iceI_opFixedSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<std::deque<::Test::Fixed>, std::deque<::Test::Fixed>>>
Test::TestIntfPrx::opFixedSeqAsync(const std::deque<::Test::Fixed>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<::Test::Fixed>, std::deque<::Test::Fixed>>>(false, this, &TestIntfPrx::_iceI_opFixedSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opFixedSeqAsync(const std::deque<::Test::Fixed>& iceP_inSeq, ::std::function<void(std::deque<::Test::Fixed>, std::deque<::Test::Fixed>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<std::deque<::Test::Fixed>, std::deque<::Test::Fixed>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<std::deque<::Test::Fixed>, std::deque<::Test::Fixed>>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opFixedSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opFixedSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque<::Test::Fixed>, std::deque<::Test::Fixed>>>>& outAsync, const std::deque<::Test::Fixed>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opFixedSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::deque<::Test::Fixed>, std::deque<::Test::Fixed>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::FixedList
Test::TestIntfPrx::opFixedList(const FixedList& iceP_inSeq, FixedList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<FixedList, FixedList>>(true, this, &TestIntfPrx::_iceI_opFixedList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::FixedList, ::Test::FixedList>>
Test::TestIntfPrx::opFixedListAsync(const FixedList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<FixedList, FixedList>>(false, this, &TestIntfPrx::_iceI_opFixedList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opFixedListAsync(const FixedList& iceP_inSeq, ::std::function<void(::Test::FixedList, ::Test::FixedList)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<FixedList, FixedList>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<FixedList, FixedList>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opFixedList, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opFixedList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<FixedList, FixedList>>>& outAsync, const FixedList& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opFixedList";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<FixedList, FixedList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

std::deque<::Test::Variable>
Test::TestIntfPrx::opVariableSeq(const std::deque<::Test::Variable>& iceP_inSeq, std::deque<::Test::Variable>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<::Test::Variable>, std::deque<::Test::Variable>>>(true, this, &TestIntfPrx::_iceI_opVariableSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<std::deque<::Test::Variable>, std::deque<::Test::Variable>>>
Test::TestIntfPrx::opVariableSeqAsync(const std::deque<::Test::Variable>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<::Test::Variable>, std::deque<::Test::Variable>>>(false, this, &TestIntfPrx::_iceI_opVariableSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opVariableSeqAsync(const std::deque<::Test::Variable>& iceP_inSeq, ::std::function<void(std::deque<::Test::Variable>, std::deque<::Test::Variable>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<std::deque<::Test::Variable>, std::deque<::Test::Variable>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<std::deque<::Test::Variable>, std::deque<::Test::Variable>>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opVariableSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opVariableSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque<::Test::Variable>, std::deque<::Test::Variable>>>>& outAsync, const std::deque<::Test::Variable>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opVariableSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::deque<::Test::Variable>, std::deque<::Test::Variable>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::VariableList
Test::TestIntfPrx::opVariableList(const VariableList& iceP_inSeq, VariableList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<VariableList, VariableList>>(true, this, &TestIntfPrx::_iceI_opVariableList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::VariableList, ::Test::VariableList>>
Test::TestIntfPrx::opVariableListAsync(const VariableList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<VariableList, VariableList>>(false, this, &TestIntfPrx::_iceI_opVariableList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opVariableListAsync(const VariableList& iceP_inSeq, ::std::function<void(::Test::VariableList, ::Test::VariableList)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<VariableList, VariableList>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<VariableList, VariableList>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opVariableList, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opVariableList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<VariableList, VariableList>>>& outAsync, const VariableList& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opVariableList";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<VariableList, VariableList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

std::deque<::Test::StringStringDict>
Test::TestIntfPrx::opStringStringDictSeq(const std::deque<::Test::StringStringDict>& iceP_inSeq, std::deque<::Test::StringStringDict>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<::Test::StringStringDict>, std::deque<::Test::StringStringDict>>>(true, this, &TestIntfPrx::_iceI_opStringStringDictSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<std::deque<::Test::StringStringDict>, std::deque<::Test::StringStringDict>>>
Test::TestIntfPrx::opStringStringDictSeqAsync(const std::deque<::Test::StringStringDict>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<::Test::StringStringDict>, std::deque<::Test::StringStringDict>>>(false, this, &TestIntfPrx::_iceI_opStringStringDictSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opStringStringDictSeqAsync(const std::deque<::Test::StringStringDict>& iceP_inSeq, ::std::function<void(std::deque<::Test::StringStringDict>, std::deque<::Test::StringStringDict>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<std::deque<::Test::StringStringDict>, std::deque<::Test::StringStringDict>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<std::deque<::Test::StringStringDict>, std::deque<::Test::StringStringDict>>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringStringDictSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opStringStringDictSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque<::Test::StringStringDict>, std::deque<::Test::StringStringDict>>>>& outAsync, const std::deque<::Test::StringStringDict>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opStringStringDictSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::deque<::Test::StringStringDict>, std::deque<::Test::StringStringDict>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::StringStringDictList
Test::TestIntfPrx::opStringStringDictList(const StringStringDictList& iceP_inSeq, StringStringDictList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<StringStringDictList, StringStringDictList>>(true, this, &TestIntfPrx::_iceI_opStringStringDictList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::StringStringDictList, ::Test::StringStringDictList>>
Test::TestIntfPrx::opStringStringDictListAsync(const StringStringDictList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<StringStringDictList, StringStringDictList>>(false, this, &TestIntfPrx::_iceI_opStringStringDictList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opStringStringDictListAsync(const StringStringDictList& iceP_inSeq, ::std::function<void(::Test::StringStringDictList, ::Test::StringStringDictList)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<StringStringDictList, StringStringDictList>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<StringStringDictList, StringStringDictList>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringStringDictList, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opStringStringDictList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringStringDictList, StringStringDictList>>>& outAsync, const StringStringDictList& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opStringStringDictList";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<StringStringDictList, StringStringDictList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

std::deque<::Test::E>
Test::TestIntfPrx::opESeq(const std::deque<::Test::E>& iceP_inSeq, std::deque<::Test::E>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<::Test::E>, std::deque<::Test::E>>>(true, this, &TestIntfPrx::_iceI_opESeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<std::deque<::Test::E>, std::deque<::Test::E>>>
Test::TestIntfPrx::opESeqAsync(const std::deque<::Test::E>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<::Test::E>, std::deque<::Test::E>>>(false, this, &TestIntfPrx::_iceI_opESeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opESeqAsync(const std::deque<::Test::E>& iceP_inSeq, ::std::function<void(std::deque<::Test::E>, std::deque<::Test::E>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<std::deque<::Test::E>, std::deque<::Test::E>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<std::deque<::Test::E>, std::deque<::Test::E>>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opESeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opESeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque<::Test::E>, std::deque<::Test::E>>>>& outAsync, const std::deque<::Test::E>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opESeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::deque<::Test::E>, std::deque<::Test::E>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::EList
Test::TestIntfPrx::opEList(const EList& iceP_inSeq, EList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<EList, EList>>(true, this, &TestIntfPrx::_iceI_opEList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::EList, ::Test::EList>>
Test::TestIntfPrx::opEListAsync(const EList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<EList, EList>>(false, this, &TestIntfPrx::_iceI_opEList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opEListAsync(const EList& iceP_inSeq, ::std::function<void(::Test::EList, ::Test::EList)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<EList, EList>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<EList, EList>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opEList, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opEList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<EList, EList>>>& outAsync, const EList& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opEList";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<EList, EList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

std::deque<::std::optional<::Test::DPrx>>
Test::TestIntfPrx::opDPrxSeq(const std::deque<::std::optional<::Test::DPrx>>& iceP_inSeq, std::deque<::std::optional<::Test::DPrx>>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<::std::optional<::Test::DPrx>>, std::deque<::std::optional<::Test::DPrx>>>>(true, this, &TestIntfPrx::_iceI_opDPrxSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<std::deque<::std::optional<::Test::DPrx>>, std::deque<::std::optional<::Test::DPrx>>>>
Test::TestIntfPrx::opDPrxSeqAsync(const std::deque<::std::optional<::Test::DPrx>>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<::std::optional<::Test::DPrx>>, std::deque<::std::optional<::Test::DPrx>>>>(false, this, &TestIntfPrx::_iceI_opDPrxSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opDPrxSeqAsync(const std::deque<::std::optional<::Test::DPrx>>& iceP_inSeq, ::std::function<void(std::deque<::std::optional<::Test::DPrx>>, std::deque<::std::optional<::Test::DPrx>>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<std::deque<::std::optional<::Test::DPrx>>, std::deque<::std::optional<::Test::DPrx>>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<std::deque<::std::optional<::Test::DPrx>>, std::deque<::std::optional<::Test::DPrx>>>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opDPrxSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opDPrxSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque<::std::optional<::Test::DPrx>>, std::deque<::std::optional<::Test::DPrx>>>>>& outAsync, const std::deque<::std::optional<::Test::DPrx>>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opDPrxSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::deque<::std::optional<::Test::DPrx>>, std::deque<::std::optional<::Test::DPrx>>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::DPrxList
Test::TestIntfPrx::opDPrxList(const DPrxList& iceP_inSeq, DPrxList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<DPrxList, DPrxList>>(true, this, &TestIntfPrx::_iceI_opDPrxList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::DPrxList, ::Test::DPrxList>>
Test::TestIntfPrx::opDPrxListAsync(const DPrxList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<DPrxList, DPrxList>>(false, this, &TestIntfPrx::_iceI_opDPrxList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opDPrxListAsync(const DPrxList& iceP_inSeq, ::std::function<void(::Test::DPrxList, ::Test::DPrxList)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<DPrxList, DPrxList>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<DPrxList, DPrxList>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opDPrxList, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opDPrxList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<DPrxList, DPrxList>>>& outAsync, const DPrxList& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opDPrxList";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<DPrxList, DPrxList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

std::deque<std::shared_ptr<Test::C>>
Test::TestIntfPrx::opCSeq(const std::deque<std::shared_ptr<Test::C>>& iceP_inSeq, std::deque<std::shared_ptr<Test::C>>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>>>(true, this, &TestIntfPrx::_iceI_opCSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>>>
Test::TestIntfPrx::opCSeqAsync(const std::deque<std::shared_ptr<Test::C>>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>>>(false, this, &TestIntfPrx::_iceI_opCSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opCSeqAsync(const std::deque<std::shared_ptr<Test::C>>& iceP_inSeq, ::std::function<void(std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opCSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opCSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>>>>& outAsync, const std::deque<std::shared_ptr<Test::C>>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opCSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::CList
Test::TestIntfPrx::opCList(const CList& iceP_inSeq, CList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<CList, CList>>(true, this, &TestIntfPrx::_iceI_opCList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::CList, ::Test::CList>>
Test::TestIntfPrx::opCListAsync(const CList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<CList, CList>>(false, this, &TestIntfPrx::_iceI_opCList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opCListAsync(const CList& iceP_inSeq, ::std::function<void(::Test::CList, ::Test::CList)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<CList, CList>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<CList, CList>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opCList, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opCList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<CList, CList>>>& outAsync, const CList& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opCList";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<CList, CList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

void
Test::TestIntfPrx::opOutArrayByteSeq(const ByteSeq& iceP_org, ByteSeq& iceP_copy, const ::Ice::Context& context) const
{
    iceP_copy = ::IceInternal::makePromiseOutgoing<ByteSeq>(true, this, &TestIntfPrx::_iceI_opOutArrayByteSeq, iceP_org, context).get();
}

::std::future<::Test::ByteSeq>
Test::TestIntfPrx::opOutArrayByteSeqAsync(const ByteSeq& iceP_org, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<ByteSeq>(false, this, &TestIntfPrx::_iceI_opOutArrayByteSeq, iceP_org, context);
}

::std::function<void()>
Test::TestIntfPrx::opOutArrayByteSeqAsync(const ByteSeq& iceP_org, ::std::function<void(::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceIL_opOutArrayByteSeq, iceP_org, context);
}

void
Test::TestIntfPrx::_iceI_opOutArrayByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ByteSeq>>& outAsync, const ByteSeq& iceP_org, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOutArrayByteSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_org);
        },
        nullptr);
}

void
Test::TestIntfPrx::_iceIL_opOutArrayByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>>>& outAsync, const ByteSeq& iceP_org, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOutArrayByteSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_org);
        },
        nullptr);
}

::Test::IntStringDict
Test::TestIntfPrx::opIntStringDict(const IntStringDict& iceP_idict, IntStringDict& iceP_odict, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<IntStringDict, IntStringDict>>(true, this, &TestIntfPrx::_iceI_opIntStringDict, iceP_idict, context).get();
    iceP_odict = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::IntStringDict, ::Test::IntStringDict>>
Test::TestIntfPrx::opIntStringDictAsync(const IntStringDict& iceP_idict, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<IntStringDict, IntStringDict>>(false, this, &TestIntfPrx::_iceI_opIntStringDict, iceP_idict, context);
}

::std::function<void()>
Test::TestIntfPrx::opIntStringDictAsync(const IntStringDict& iceP_idict, ::std::function<void(::Test::IntStringDict, ::Test::IntStringDict)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<IntStringDict, IntStringDict>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<IntStringDict, IntStringDict>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opIntStringDict, iceP_idict, context);
}

void
Test::TestIntfPrx::_iceI_opIntStringDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<IntStringDict, IntStringDict>>>& outAsync, const IntStringDict& iceP_idict, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opIntStringDict";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_idict);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<IntStringDict, IntStringDict> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::CustomMap< int64_t, int64_t>
Test::TestIntfPrx::opVarDict(const ::Test::CustomMap<std::string, std::int32_t>& iceP_idict, ::Test::CustomMap<std::string, std::int32_t>& iceP_odict, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::Test::CustomMap< int64_t, int64_t>, ::Test::CustomMap<std::string, std::int32_t>>>(true, this, &TestIntfPrx::_iceI_opVarDict, iceP_idict, context).get();
    iceP_odict = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::CustomMap< int64_t, int64_t>, ::Test::CustomMap<std::string, std::int32_t>>>
Test::TestIntfPrx::opVarDictAsync(const ::Test::CustomMap<std::string, std::int32_t>& iceP_idict, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::Test::CustomMap< int64_t, int64_t>, ::Test::CustomMap<std::string, std::int32_t>>>(false, this, &TestIntfPrx::_iceI_opVarDict, iceP_idict, context);
}

::std::function<void()>
Test::TestIntfPrx::opVarDictAsync(const ::Test::CustomMap<std::string, std::int32_t>& iceP_idict, ::std::function<void(::Test::CustomMap< int64_t, int64_t>, ::Test::CustomMap<std::string, std::int32_t>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::Test::CustomMap< int64_t, int64_t>, ::Test::CustomMap<std::string, std::int32_t>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::Test::CustomMap< int64_t, int64_t>, ::Test::CustomMap<std::string, std::int32_t>>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opVarDict, iceP_idict, context);
}

void
Test::TestIntfPrx::_iceI_opVarDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::Test::CustomMap< int64_t, int64_t>, ::Test::CustomMap<std::string, std::int32_t>>>>& outAsync, const ::Test::CustomMap<std::string, std::int32_t>& iceP_idict, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opVarDict";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_idict);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::Test::CustomMap< int64_t, int64_t>, ::Test::CustomMap<std::string, std::int32_t>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::ShortBuffer
Test::TestIntfPrx::opShortBuffer(const ShortBuffer& iceP_inS, ShortBuffer& iceP_outS, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<ShortBuffer, ShortBuffer>>(true, this, &TestIntfPrx::_iceI_opShortBuffer, iceP_inS, context).get();
    iceP_outS = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::ShortBuffer, ::Test::ShortBuffer>>
Test::TestIntfPrx::opShortBufferAsync(const ShortBuffer& iceP_inS, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ShortBuffer, ShortBuffer>>(false, this, &TestIntfPrx::_iceI_opShortBuffer, iceP_inS, context);
}

::std::function<void()>
Test::TestIntfPrx::opShortBufferAsync(const ShortBuffer& iceP_inS, ::std::function<void(::Test::ShortBuffer, ::Test::ShortBuffer)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<ShortBuffer, ShortBuffer>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ShortBuffer, ShortBuffer>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opShortBuffer, iceP_inS, context);
}

void
Test::TestIntfPrx::_iceI_opShortBuffer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ShortBuffer, ShortBuffer>>>& outAsync, const ShortBuffer& iceP_inS, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opShortBuffer";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inS);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ShortBuffer, ShortBuffer> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::CustomBuffer<bool>
Test::TestIntfPrx::opBoolBuffer(const ::Test::CustomBuffer<bool>& iceP_inS, ::Test::CustomBuffer<bool>& iceP_outS, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>>>(true, this, &TestIntfPrx::_iceI_opBoolBuffer, iceP_inS, context).get();
    iceP_outS = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>>>
Test::TestIntfPrx::opBoolBufferAsync(const ::Test::CustomBuffer<bool>& iceP_inS, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>>>(false, this, &TestIntfPrx::_iceI_opBoolBuffer, iceP_inS, context);
}

::std::function<void()>
Test::TestIntfPrx::opBoolBufferAsync(const ::Test::CustomBuffer<bool>& iceP_inS, ::std::function<void(::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolBuffer, iceP_inS, context);
}

void
Test::TestIntfPrx::_iceI_opBoolBuffer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>>>>& outAsync, const ::Test::CustomBuffer<bool>& iceP_inS, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opBoolBuffer";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inS);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::BufferStruct
Test::TestIntfPrx::opBufferStruct(const BufferStruct& iceP_s, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<BufferStruct>(true, this, &TestIntfPrx::_iceI_opBufferStruct, iceP_s, context).get();
}

::std::future<::Test::BufferStruct>
Test::TestIntfPrx::opBufferStructAsync(const BufferStruct& iceP_s, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<BufferStruct>(false, this, &TestIntfPrx::_iceI_opBufferStruct, iceP_s, context);
}

::std::function<void()>
Test::TestIntfPrx::opBufferStructAsync(const BufferStruct& iceP_s, ::std::function<void(::Test::BufferStruct)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<BufferStruct>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBufferStruct, iceP_s, context);
}

void
Test::TestIntfPrx::_iceI_opBufferStruct(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<BufferStruct>>& outAsync, const BufferStruct& iceP_s, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opBufferStruct";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_s);
        },
        nullptr);
}

void
Test::TestIntfPrx::shutdown(const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_shutdown, context).get();
}

::std::future<void>
Test::TestIntfPrx::shutdownAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &TestIntfPrx::_iceI_shutdown, context);
}

::std::function<void()>
Test::TestIntfPrx::shutdownAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_shutdown, context);
}

void
Test::TestIntfPrx::_iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "shutdown";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}

::std::string_view
Test::TestIntfPrx::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::Test::TestIntf";
    return typeId;
}

Test::C::~C()
{
}

::std::string_view
Test::C::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::Test::C";
    return typeId;
}

Test::DictClass::~DictClass()
{
}

::std::string_view
Test::DictClass::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::Test::DictClass";
    return typeId;
}

::std::vector<::std::string>
Test::D::ice_ids(const ::Ice::Current&) const
{
    static const ::std::vector<::std::string> allTypeIds = {"::Ice::Object", "::Test::D"};
    return allTypeIds;
}

::std::string
Test::D::ice_id(const ::Ice::Current&) const
{
    return ::std::string{ice_staticId()};
}

::std::string_view
Test::D::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::Test::D";
    return typeId;
}

::std::vector<::std::string>
Test::TestIntf::ice_ids(const ::Ice::Current&) const
{
    static const ::std::vector<::std::string> allTypeIds = {"::Ice::Object", "::Test::TestIntf"};
    return allTypeIds;
}

::std::string
Test::TestIntf::ice_id(const ::Ice::Current&) const
{
    return ::std::string{ice_staticId()};
}

::std::string_view
Test::TestIntf::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::Test::TestIntf";
    return typeId;
}

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDoubleArray(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    ::std::pair<const double*, const double*> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const DoubleSeq& ret, const DoubleSeq& iceP_outSeq)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opDoubleArrayAsync(::std::move(iceP_inSeq), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolArray(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    ::std::pair<const bool*, const bool*> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const BoolSeq& ret, const BoolSeq& iceP_outSeq)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opBoolArrayAsync(::std::move(iceP_inSeq), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteArray(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>& ret, const ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>& iceP_outSeq)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opByteArrayAsync(::std::move(iceP_inSeq), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVariableArray(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    ::std::pair<const Variable*, const Variable*> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const VariableList& ret, const VariableList& iceP_outSeq)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opVariableArrayAsync(::std::move(iceP_inSeq), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolSeq(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    std::deque<bool> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const std::deque<bool>& ret, const std::deque<bool>& iceP_outSeq)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opBoolSeqAsync(::std::move(iceP_inSeq), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolList(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    BoolList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const BoolList& ret, const BoolList& iceP_outSeq)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opBoolListAsync(::std::move(iceP_inSeq), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteSeq(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    std::deque<std::uint8_t> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const std::deque<std::uint8_t>& ret, const std::deque<std::uint8_t>& iceP_outSeq)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opByteSeqAsync(::std::move(iceP_inSeq), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteList(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    ByteList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const ByteList& ret, const ByteList& iceP_outSeq)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opByteListAsync(::std::move(iceP_inSeq), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opMyByteSeq(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    MyByteSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const MyByteSeq& ret, const MyByteSeq& iceP_outSeq)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opMyByteSeqAsync(::std::move(iceP_inSeq), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringSeq(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    std::deque<std::string> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const std::deque<std::string>& ret, const std::deque<std::string>& iceP_outSeq)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opStringSeqAsync(::std::move(iceP_inSeq), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringList(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    StringList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const StringList& ret, const StringList& iceP_outSeq)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opStringListAsync(::std::move(iceP_inSeq), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opFixedSeq(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    std::deque<::Test::Fixed> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const std::deque<::Test::Fixed>& ret, const std::deque<::Test::Fixed>& iceP_outSeq)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opFixedSeqAsync(::std::move(iceP_inSeq), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opFixedList(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    FixedList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const FixedList& ret, const FixedList& iceP_outSeq)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opFixedListAsync(::std::move(iceP_inSeq), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVariableSeq(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    std::deque<::Test::Variable> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const std::deque<::Test::Variable>& ret, const std::deque<::Test::Variable>& iceP_outSeq)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opVariableSeqAsync(::std::move(iceP_inSeq), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVariableList(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    VariableList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const VariableList& ret, const VariableList& iceP_outSeq)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opVariableListAsync(::std::move(iceP_inSeq), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringStringDictSeq(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    std::deque<::Test::StringStringDict> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const std::deque<::Test::StringStringDict>& ret, const std::deque<::Test::StringStringDict>& iceP_outSeq)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opStringStringDictSeqAsync(::std::move(iceP_inSeq), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringStringDictList(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    StringStringDictList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const StringStringDictList& ret, const StringStringDictList& iceP_outSeq)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opStringStringDictListAsync(::std::move(iceP_inSeq), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opESeq(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    std::deque<::Test::E> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const std::deque<::Test::E>& ret, const std::deque<::Test::E>& iceP_outSeq)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opESeqAsync(::std::move(iceP_inSeq), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opEList(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    EList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const EList& ret, const EList& iceP_outSeq)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opEListAsync(::std::move(iceP_inSeq), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDPrxSeq(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    std::deque<::std::optional<::Test::DPrx>> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const std::deque<::std::optional<::Test::DPrx>>& ret, const std::deque<::std::optional<::Test::DPrx>>& iceP_outSeq)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opDPrxSeqAsync(::std::move(iceP_inSeq), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDPrxList(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    DPrxList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const DPrxList& ret, const DPrxList& iceP_outSeq)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opDPrxListAsync(::std::move(iceP_inSeq), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opCSeq(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    std::deque<std::shared_ptr<Test::C>> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->readPendingValues();
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const std::deque<std::shared_ptr<Test::C>>& ret, const std::deque<std::shared_ptr<Test::C>>& iceP_outSeq)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        ostr->writePendingValues();
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opCSeqAsync(::std::move(iceP_inSeq), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opCList(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    CList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->readPendingValues();
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const CList& ret, const CList& iceP_outSeq)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        ostr->writePendingValues();
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opCListAsync(::std::move(iceP_inSeq), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOutArrayByteSeq(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    ByteSeq iceP_org;
    istr->readAll(iceP_org);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>& iceP_copy)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_copy);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opOutArrayByteSeqAsync(::std::move(iceP_org), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opIntStringDict(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    IntStringDict iceP_idict;
    istr->readAll(iceP_idict);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const IntStringDict& ret, const IntStringDict& iceP_odict)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_odict, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opIntStringDictAsync(::std::move(iceP_idict), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVarDict(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    ::Test::CustomMap<std::string, std::int32_t> iceP_idict;
    istr->readAll(iceP_idict);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const ::Test::CustomMap< int64_t, int64_t>& ret, const ::Test::CustomMap<std::string, std::int32_t>& iceP_odict)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_odict, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opVarDictAsync(::std::move(iceP_idict), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opShortBuffer(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    ShortBuffer iceP_inS;
    istr->readAll(iceP_inS);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const ShortBuffer& ret, const ShortBuffer& iceP_outS)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_outS, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opShortBufferAsync(::std::move(iceP_inS), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolBuffer(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    ::Test::CustomBuffer<bool> iceP_inS;
    istr->readAll(iceP_inS);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const ::Test::CustomBuffer<bool>& ret, const ::Test::CustomBuffer<bool>& iceP_outS)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_outS, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opBoolBufferAsync(::std::move(iceP_inS), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBufferStruct(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    BufferStruct iceP_s;
    istr->readAll(iceP_s);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const BufferStruct& ret)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opBufferStructAsync(::std::move(iceP_s), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_shutdown(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    incoming.readEmptyParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    try
    {
        this->shutdownAsync([incomingPtr] { incomingPtr->response(); }, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceDispatch(::IceInternal::Incoming& incoming)
{
    static constexpr ::std::string_view allOperations[] = {"ice_id", "ice_ids", "ice_isA", "ice_ping", "opBoolArray", "opBoolBuffer", "opBoolList", "opBoolSeq", "opBufferStruct", "opByteArray", "opByteList", "opByteSeq", "opCList", "opCSeq", "opDPrxList", "opDPrxSeq", "opDoubleArray", "opEList", "opESeq", "opFixedList", "opFixedSeq", "opIntStringDict", "opMyByteSeq", "opOutArrayByteSeq", "opShortBuffer", "opStringList", "opStringSeq", "opStringStringDictList", "opStringStringDictSeq", "opVarDict", "opVariableArray", "opVariableList", "opVariableSeq", "shutdown"};

    const ::Ice::Current& current = incoming.current();
    ::std::pair<const ::std::string_view*, const ::std::string_view*> r = ::std::equal_range(allOperations, allOperations + 34, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - allOperations)
    {
        case 0:
        {
            return _iceD_ice_id(incoming);
        }
        case 1:
        {
            return _iceD_ice_ids(incoming);
        }
        case 2:
        {
            return _iceD_ice_isA(incoming);
        }
        case 3:
        {
            return _iceD_ice_ping(incoming);
        }
        case 4:
        {
            return _iceD_opBoolArray(incoming);
        }
        case 5:
        {
            return _iceD_opBoolBuffer(incoming);
        }
        case 6:
        {
            return _iceD_opBoolList(incoming);
        }
        case 7:
        {
            return _iceD_opBoolSeq(incoming);
        }
        case 8:
        {
            return _iceD_opBufferStruct(incoming);
        }
        case 9:
        {
            return _iceD_opByteArray(incoming);
        }
        case 10:
        {
            return _iceD_opByteList(incoming);
        }
        case 11:
        {
            return _iceD_opByteSeq(incoming);
        }
        case 12:
        {
            return _iceD_opCList(incoming);
        }
        case 13:
        {
            return _iceD_opCSeq(incoming);
        }
        case 14:
        {
            return _iceD_opDPrxList(incoming);
        }
        case 15:
        {
            return _iceD_opDPrxSeq(incoming);
        }
        case 16:
        {
            return _iceD_opDoubleArray(incoming);
        }
        case 17:
        {
            return _iceD_opEList(incoming);
        }
        case 18:
        {
            return _iceD_opESeq(incoming);
        }
        case 19:
        {
            return _iceD_opFixedList(incoming);
        }
        case 20:
        {
            return _iceD_opFixedSeq(incoming);
        }
        case 21:
        {
            return _iceD_opIntStringDict(incoming);
        }
        case 22:
        {
            return _iceD_opMyByteSeq(incoming);
        }
        case 23:
        {
            return _iceD_opOutArrayByteSeq(incoming);
        }
        case 24:
        {
            return _iceD_opShortBuffer(incoming);
        }
        case 25:
        {
            return _iceD_opStringList(incoming);
        }
        case 26:
        {
            return _iceD_opStringSeq(incoming);
        }
        case 27:
        {
            return _iceD_opStringStringDictList(incoming);
        }
        case 28:
        {
            return _iceD_opStringStringDictSeq(incoming);
        }
        case 29:
        {
            return _iceD_opVarDict(incoming);
        }
        case 30:
        {
            return _iceD_opVariableArray(incoming);
        }
        case 31:
        {
            return _iceD_opVariableList(incoming);
        }
        case 32:
        {
            return _iceD_opVariableSeq(incoming);
        }
        case 33:
        {
            return _iceD_shutdown(incoming);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond
