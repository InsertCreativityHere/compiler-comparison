//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `TestAMD.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#define ICE_BUILDING_GENERATED_CODE
#include <TestAMD.h>
#include <Ice/OutgoingAsync.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace
{

const ::IceInternal::DefaultValueFactoryInit<::Test::C> iceC_Test_C_init("::Test::C");

const ::std::string iceC_Test_D_ids[2] =
{
    "::Ice::Object",
    "::Test::D"
};
const ::std::string iceC_Test_D_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

const ::IceInternal::DefaultValueFactoryInit<::Test::DictClass> iceC_Test_DictClass_init("::Test::DictClass");

const ::std::string iceC_Test_TestIntf_ids[2] =
{
    "::Ice::Object",
    "::Test::TestIntf"
};
const ::std::string iceC_Test_TestIntf_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "opBoolArray",
    "opBoolBuffer",
    "opBoolList",
    "opBoolRange",
    "opBoolSeq",
    "opBufferStruct",
    "opByteArray",
    "opByteList",
    "opByteRange",
    "opByteRangeType",
    "opByteSeq",
    "opCList",
    "opCSeq",
    "opClassStruct",
    "opCustomIntStringDict",
    "opDPrxList",
    "opDPrxSeq",
    "opDoubleArray",
    "opEList",
    "opESeq",
    "opFixedList",
    "opFixedSeq",
    "opIntStringDict",
    "opMyByteSeq",
    "opOutArrayByteSeq",
    "opOutRangeByteSeq",
    "opShortBuffer",
    "opString",
    "opStringList",
    "opStringSeq",
    "opStringStringDictList",
    "opStringStringDictSeq",
    "opVarDict",
    "opVariableArray",
    "opVariableList",
    "opVariableRange",
    "opVariableRangeType",
    "opVariableSeq",
    "shutdown"
};
const ::std::string iceC_Test_TestIntf_opDoubleArray_name = "opDoubleArray";
const ::std::string iceC_Test_TestIntf_opBoolArray_name = "opBoolArray";
const ::std::string iceC_Test_TestIntf_opByteArray_name = "opByteArray";
const ::std::string iceC_Test_TestIntf_opVariableArray_name = "opVariableArray";
const ::std::string iceC_Test_TestIntf_opBoolRange_name = "opBoolRange";
const ::std::string iceC_Test_TestIntf_opByteRange_name = "opByteRange";
const ::std::string iceC_Test_TestIntf_opVariableRange_name = "opVariableRange";
const ::std::string iceC_Test_TestIntf_opByteRangeType_name = "opByteRangeType";
const ::std::string iceC_Test_TestIntf_opVariableRangeType_name = "opVariableRangeType";
const ::std::string iceC_Test_TestIntf_opBoolSeq_name = "opBoolSeq";
const ::std::string iceC_Test_TestIntf_opBoolList_name = "opBoolList";
const ::std::string iceC_Test_TestIntf_opByteSeq_name = "opByteSeq";
const ::std::string iceC_Test_TestIntf_opByteList_name = "opByteList";
const ::std::string iceC_Test_TestIntf_opMyByteSeq_name = "opMyByteSeq";
const ::std::string iceC_Test_TestIntf_opString_name = "opString";
const ::std::string iceC_Test_TestIntf_opStringSeq_name = "opStringSeq";
const ::std::string iceC_Test_TestIntf_opStringList_name = "opStringList";
const ::std::string iceC_Test_TestIntf_opFixedSeq_name = "opFixedSeq";
const ::std::string iceC_Test_TestIntf_opFixedList_name = "opFixedList";
const ::std::string iceC_Test_TestIntf_opVariableSeq_name = "opVariableSeq";
const ::std::string iceC_Test_TestIntf_opVariableList_name = "opVariableList";
const ::std::string iceC_Test_TestIntf_opStringStringDictSeq_name = "opStringStringDictSeq";
const ::std::string iceC_Test_TestIntf_opStringStringDictList_name = "opStringStringDictList";
const ::std::string iceC_Test_TestIntf_opESeq_name = "opESeq";
const ::std::string iceC_Test_TestIntf_opEList_name = "opEList";
const ::std::string iceC_Test_TestIntf_opDPrxSeq_name = "opDPrxSeq";
const ::std::string iceC_Test_TestIntf_opDPrxList_name = "opDPrxList";
const ::std::string iceC_Test_TestIntf_opCSeq_name = "opCSeq";
const ::std::string iceC_Test_TestIntf_opCList_name = "opCList";
const ::std::string iceC_Test_TestIntf_opClassStruct_name = "opClassStruct";
const ::std::string iceC_Test_TestIntf_opOutArrayByteSeq_name = "opOutArrayByteSeq";
const ::std::string iceC_Test_TestIntf_opOutRangeByteSeq_name = "opOutRangeByteSeq";
const ::std::string iceC_Test_TestIntf_opIntStringDict_name = "opIntStringDict";
const ::std::string iceC_Test_TestIntf_opVarDict_name = "opVarDict";
const ::std::string iceC_Test_TestIntf_opCustomIntStringDict_name = "opCustomIntStringDict";
const ::std::string iceC_Test_TestIntf_opShortBuffer_name = "opShortBuffer";
const ::std::string iceC_Test_TestIntf_opBoolBuffer_name = "opBoolBuffer";
const ::std::string iceC_Test_TestIntf_opBufferStruct_name = "opBufferStruct";
const ::std::string iceC_Test_TestIntf_shutdown_name = "shutdown";

}

const ::std::string&
Test::DPrx::ice_staticId()
{
    static const ::std::string typeId = "::Test::D";
    return typeId;
}

::Test::DoubleSeq
Test::TestIntfPrx::opDoubleArray(const ::std::pair<const double*, const double*>& iceP_inSeq, DoubleSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<DoubleSeq, DoubleSeq>>(true, this, &TestIntfPrx::_iceI_opDoubleArray, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::DoubleSeq, ::Test::DoubleSeq>>
Test::TestIntfPrx::opDoubleArrayAsync(const ::std::pair<const double*, const double*>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<DoubleSeq, DoubleSeq>>(false, this, &TestIntfPrx::_iceI_opDoubleArray, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opDoubleArrayAsync(const ::std::pair<const double*, const double*>& iceP_inSeq,
                                      ::std::function<void (::Test::DoubleSeq, ::Test::DoubleSeq)> response,
                                      ::std::function<void(::std::exception_ptr)> ex,
                                      ::std::function<void(bool)> sent,
                                      const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<DoubleSeq, DoubleSeq>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<DoubleSeq, DoubleSeq>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opDoubleArray, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opDoubleArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<DoubleSeq, DoubleSeq>>>& outAsync, const ::std::pair<const double*, const double*>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opDoubleArray_name);
    outAsync->invoke(iceC_Test_TestIntf_opDoubleArray_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<DoubleSeq, DoubleSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::BoolSeq
Test::TestIntfPrx::opBoolArray(const ::std::pair<const bool*, const bool*>& iceP_inSeq, BoolSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<BoolSeq, BoolSeq>>(true, this, &TestIntfPrx::_iceI_opBoolArray, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::BoolSeq, ::Test::BoolSeq>>
Test::TestIntfPrx::opBoolArrayAsync(const ::std::pair<const bool*, const bool*>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<BoolSeq, BoolSeq>>(false, this, &TestIntfPrx::_iceI_opBoolArray, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opBoolArrayAsync(const ::std::pair<const bool*, const bool*>& iceP_inSeq,
                                    ::std::function<void (::Test::BoolSeq, ::Test::BoolSeq)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<BoolSeq, BoolSeq>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<BoolSeq, BoolSeq>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolArray, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opBoolArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BoolSeq, BoolSeq>>>& outAsync, const ::std::pair<const bool*, const bool*>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolArray_name);
    outAsync->invoke(iceC_Test_TestIntf_opBoolArray_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<BoolSeq, BoolSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::ByteList
Test::TestIntfPrx::opByteArray(const ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>& iceP_inSeq, ByteList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<ByteList, ByteList>>(true, this, &TestIntfPrx::_iceI_opByteArray, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::ByteList, ::Test::ByteList>>
Test::TestIntfPrx::opByteArrayAsync(const ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ByteList, ByteList>>(false, this, &TestIntfPrx::_iceI_opByteArray, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opByteArrayAsync(const ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>& iceP_inSeq,
                                    ::std::function<void (::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>, ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteArray_name);
    ::std::function<void(::Ice::InputStream*)> read;
    if(response)
    {
        read = [response](::Ice::InputStream* istr)
        {
            istr->startEncapsulation();
            ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*> iceP_outSeq;
            ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*> ret;
            istr->readAll(iceP_outSeq, ret);
            istr->endEncapsulation();
            try
            {
                response(ret, iceP_outSeq);
            }
            catch(...)
            {
                throw ::std::current_exception();
            }
        };
    }
    auto outAsync = ::std::make_shared<::IceInternal::CustomLambdaOutgoing>(*this, read, ex, sent);

    outAsync->invoke(iceC_Test_TestIntf_opByteArray_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr);
    return [outAsync]() { outAsync->cancel(); };
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opByteArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteList, ByteList>>>& outAsync, const ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteArray_name);
    outAsync->invoke(iceC_Test_TestIntf_opByteArray_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ByteList, ByteList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::VariableList
Test::TestIntfPrx::opVariableArray(const ::std::pair<const Variable*, const Variable*>& iceP_inSeq, VariableList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<VariableList, VariableList>>(true, this, &TestIntfPrx::_iceI_opVariableArray, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::VariableList, ::Test::VariableList>>
Test::TestIntfPrx::opVariableArrayAsync(const ::std::pair<const Variable*, const Variable*>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<VariableList, VariableList>>(false, this, &TestIntfPrx::_iceI_opVariableArray, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opVariableArrayAsync(const ::std::pair<const Variable*, const Variable*>& iceP_inSeq,
                                        ::std::function<void (::Test::VariableList, ::Test::VariableList)> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<VariableList, VariableList>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<VariableList, VariableList>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opVariableArray, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opVariableArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<VariableList, VariableList>>>& outAsync, const ::std::pair<const Variable*, const Variable*>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opVariableArray_name);
    outAsync->invoke(iceC_Test_TestIntf_opVariableArray_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<VariableList, VariableList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::BoolSeq
Test::TestIntfPrx::opBoolRange(const BoolSeq& iceP_inSeq, BoolSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<BoolSeq, BoolSeq>>(true, this, &TestIntfPrx::_iceI_opBoolRange, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::BoolSeq, ::Test::BoolSeq>>
Test::TestIntfPrx::opBoolRangeAsync(const BoolSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<BoolSeq, BoolSeq>>(false, this, &TestIntfPrx::_iceI_opBoolRange, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opBoolRangeAsync(const BoolSeq& iceP_inSeq,
                                    ::std::function<void (::Test::BoolSeq, ::Test::BoolSeq)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<BoolSeq, BoolSeq>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<BoolSeq, BoolSeq>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolRange, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opBoolRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BoolSeq, BoolSeq>>>& outAsync, const BoolSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolRange_name);
    outAsync->invoke(iceC_Test_TestIntf_opBoolRange_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<BoolSeq, BoolSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::ByteList
Test::TestIntfPrx::opByteRange(const ByteList& iceP_inSeq, ByteList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<ByteList, ByteList>>(true, this, &TestIntfPrx::_iceI_opByteRange, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::ByteList, ::Test::ByteList>>
Test::TestIntfPrx::opByteRangeAsync(const ByteList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ByteList, ByteList>>(false, this, &TestIntfPrx::_iceI_opByteRange, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opByteRangeAsync(const ByteList& iceP_inSeq,
                                    ::std::function<void (::Test::ByteList, ::Test::ByteList)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<ByteList, ByteList>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ByteList, ByteList>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opByteRange, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opByteRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteList, ByteList>>>& outAsync, const ByteList& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteRange_name);
    outAsync->invoke(iceC_Test_TestIntf_opByteRange_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ByteList, ByteList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::VariableList
Test::TestIntfPrx::opVariableRange(const VariableList& iceP_inSeq, VariableList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<VariableList, VariableList>>(true, this, &TestIntfPrx::_iceI_opVariableRange, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::VariableList, ::Test::VariableList>>
Test::TestIntfPrx::opVariableRangeAsync(const VariableList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<VariableList, VariableList>>(false, this, &TestIntfPrx::_iceI_opVariableRange, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opVariableRangeAsync(const VariableList& iceP_inSeq,
                                        ::std::function<void (::Test::VariableList, ::Test::VariableList)> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<VariableList, VariableList>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<VariableList, VariableList>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opVariableRange, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opVariableRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<VariableList, VariableList>>>& outAsync, const VariableList& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opVariableRange_name);
    outAsync->invoke(iceC_Test_TestIntf_opVariableRange_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<VariableList, VariableList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::ByteList
Test::TestIntfPrx::opByteRangeType(const ByteList& iceP_inSeq, ByteList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<ByteList, ByteList>>(true, this, &TestIntfPrx::_iceI_opByteRangeType, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::ByteList, ::Test::ByteList>>
Test::TestIntfPrx::opByteRangeTypeAsync(const ByteList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ByteList, ByteList>>(false, this, &TestIntfPrx::_iceI_opByteRangeType, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opByteRangeTypeAsync(const ByteList& iceP_inSeq,
                                        ::std::function<void (::Test::ByteList, ::Test::ByteList)> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<ByteList, ByteList>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ByteList, ByteList>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opByteRangeType, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opByteRangeType(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteList, ByteList>>>& outAsync, const ByteList& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteRangeType_name);
    outAsync->invoke(iceC_Test_TestIntf_opByteRangeType_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ByteList, ByteList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::VariableList
Test::TestIntfPrx::opVariableRangeType(const VariableList& iceP_inSeq, VariableList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<VariableList, VariableList>>(true, this, &TestIntfPrx::_iceI_opVariableRangeType, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::VariableList, ::Test::VariableList>>
Test::TestIntfPrx::opVariableRangeTypeAsync(const VariableList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<VariableList, VariableList>>(false, this, &TestIntfPrx::_iceI_opVariableRangeType, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opVariableRangeTypeAsync(const VariableList& iceP_inSeq,
                                            ::std::function<void (::Test::VariableList, ::Test::VariableList)> response,
                                            ::std::function<void(::std::exception_ptr)> ex,
                                            ::std::function<void(bool)> sent,
                                            const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<VariableList, VariableList>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<VariableList, VariableList>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opVariableRangeType, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opVariableRangeType(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<VariableList, VariableList>>>& outAsync, const VariableList& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opVariableRangeType_name);
    outAsync->invoke(iceC_Test_TestIntf_opVariableRangeType_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<VariableList, VariableList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

std::deque<bool>
Test::TestIntfPrx::opBoolSeq(const std::deque<bool>& iceP_inSeq, std::deque<bool>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<bool>, std::deque<bool>>>(true, this, &TestIntfPrx::_iceI_opBoolSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::deque<bool>, std::deque<bool>>>
Test::TestIntfPrx::opBoolSeqAsync(const std::deque<bool>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<bool>, std::deque<bool>>>(false, this, &TestIntfPrx::_iceI_opBoolSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opBoolSeqAsync(const std::deque<bool>& iceP_inSeq,
                                  ::std::function<void (std::deque<bool>, std::deque<bool>)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::deque<bool>, std::deque<bool>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<std::deque<bool>, std::deque<bool>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opBoolSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque<bool>, std::deque<bool>>>>& outAsync, const std::deque<bool>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opBoolSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::deque<bool>, std::deque<bool>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::BoolList
Test::TestIntfPrx::opBoolList(const BoolList& iceP_inSeq, BoolList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<BoolList, BoolList>>(true, this, &TestIntfPrx::_iceI_opBoolList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::BoolList, ::Test::BoolList>>
Test::TestIntfPrx::opBoolListAsync(const BoolList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<BoolList, BoolList>>(false, this, &TestIntfPrx::_iceI_opBoolList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opBoolListAsync(const BoolList& iceP_inSeq,
                                   ::std::function<void (::Test::BoolList, ::Test::BoolList)> response,
                                   ::std::function<void(::std::exception_ptr)> ex,
                                   ::std::function<void(bool)> sent,
                                   const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<BoolList, BoolList>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<BoolList, BoolList>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolList, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opBoolList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BoolList, BoolList>>>& outAsync, const BoolList& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolList_name);
    outAsync->invoke(iceC_Test_TestIntf_opBoolList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<BoolList, BoolList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

std::deque< ::Ice::Byte>
Test::TestIntfPrx::opByteSeq(const std::deque< ::Ice::Byte>& iceP_inSeq, std::deque< ::Ice::Byte>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque< ::Ice::Byte>, std::deque< ::Ice::Byte>>>(true, this, &TestIntfPrx::_iceI_opByteSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::deque< ::Ice::Byte>, std::deque< ::Ice::Byte>>>
Test::TestIntfPrx::opByteSeqAsync(const std::deque< ::Ice::Byte>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque< ::Ice::Byte>, std::deque< ::Ice::Byte>>>(false, this, &TestIntfPrx::_iceI_opByteSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opByteSeqAsync(const std::deque< ::Ice::Byte>& iceP_inSeq,
                                  ::std::function<void (std::deque< ::Ice::Byte>, std::deque< ::Ice::Byte>)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::deque< ::Ice::Byte>, std::deque< ::Ice::Byte>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<std::deque< ::Ice::Byte>, std::deque< ::Ice::Byte>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opByteSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque< ::Ice::Byte>, std::deque< ::Ice::Byte>>>>& outAsync, const std::deque< ::Ice::Byte>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opByteSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::deque< ::Ice::Byte>, std::deque< ::Ice::Byte>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::ByteList
Test::TestIntfPrx::opByteList(const ByteList& iceP_inSeq, ByteList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<ByteList, ByteList>>(true, this, &TestIntfPrx::_iceI_opByteList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::ByteList, ::Test::ByteList>>
Test::TestIntfPrx::opByteListAsync(const ByteList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ByteList, ByteList>>(false, this, &TestIntfPrx::_iceI_opByteList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opByteListAsync(const ByteList& iceP_inSeq,
                                   ::std::function<void (::Test::ByteList, ::Test::ByteList)> response,
                                   ::std::function<void(::std::exception_ptr)> ex,
                                   ::std::function<void(bool)> sent,
                                   const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<ByteList, ByteList>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ByteList, ByteList>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opByteList, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opByteList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteList, ByteList>>>& outAsync, const ByteList& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteList_name);
    outAsync->invoke(iceC_Test_TestIntf_opByteList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ByteList, ByteList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

MyByteSeq
Test::TestIntfPrx::opMyByteSeq(const MyByteSeq& iceP_inSeq, MyByteSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<MyByteSeq, MyByteSeq>>(true, this, &TestIntfPrx::_iceI_opMyByteSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<MyByteSeq, MyByteSeq>>
Test::TestIntfPrx::opMyByteSeqAsync(const MyByteSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<MyByteSeq, MyByteSeq>>(false, this, &TestIntfPrx::_iceI_opMyByteSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opMyByteSeqAsync(const MyByteSeq& iceP_inSeq,
                                    ::std::function<void (MyByteSeq, MyByteSeq)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<MyByteSeq, MyByteSeq>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<MyByteSeq, MyByteSeq>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opMyByteSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opMyByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<MyByteSeq, MyByteSeq>>>& outAsync, const MyByteSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opMyByteSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opMyByteSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<MyByteSeq, MyByteSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::std::string
Test::TestIntfPrx::opString(const Util::string_view& iceP_inString, ::std::string& iceP_outString, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::string, ::std::string>>(true, this, &TestIntfPrx::_iceI_opString, iceP_inString, context).get();
    iceP_outString = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::std::string, ::std::string>>
Test::TestIntfPrx::opStringAsync(const Util::string_view& iceP_inString, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::string, ::std::string>>(false, this, &TestIntfPrx::_iceI_opString, iceP_inString, context);
}

::std::function<void()>
Test::TestIntfPrx::opStringAsync(const Util::string_view& iceP_inString,
                                 ::std::function<void (Util::string_view, Util::string_view)> response,
                                 ::std::function<void(::std::exception_ptr)> ex,
                                 ::std::function<void(bool)> sent,
                                 const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opString_name);
    ::std::function<void(::Ice::InputStream*)> read;
    if(response)
    {
        read = [response](::Ice::InputStream* istr)
        {
            istr->startEncapsulation();
            Util::string_view iceP_outString;
            Util::string_view ret;
            istr->readAll(iceP_outString, ret);
            istr->endEncapsulation();
            try
            {
                response(ret, iceP_outString);
            }
            catch(...)
            {
                throw ::std::current_exception();
            }
        };
    }
    auto outAsync = ::std::make_shared<::IceInternal::CustomLambdaOutgoing>(*this, read, ex, sent);

    outAsync->invoke(iceC_Test_TestIntf_opString_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inString);
        },
        nullptr);
    return [outAsync]() { outAsync->cancel(); };
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opString(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::string, ::std::string>>>& outAsync, const Util::string_view& iceP_inString, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opString_name);
    outAsync->invoke(iceC_Test_TestIntf_opString_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inString);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::string, ::std::string> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

std::deque<std::string>
Test::TestIntfPrx::opStringSeq(const std::deque<std::string>& iceP_inSeq, std::deque<std::string>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<std::string>, std::deque<std::string>>>(true, this, &TestIntfPrx::_iceI_opStringSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::deque<std::string>, std::deque<std::string>>>
Test::TestIntfPrx::opStringSeqAsync(const std::deque<std::string>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<std::string>, std::deque<std::string>>>(false, this, &TestIntfPrx::_iceI_opStringSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opStringSeqAsync(const std::deque<std::string>& iceP_inSeq,
                                    ::std::function<void (std::deque<std::string>, std::deque<std::string>)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::deque<std::string>, std::deque<std::string>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<std::deque<std::string>, std::deque<std::string>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opStringSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque<std::string>, std::deque<std::string>>>>& outAsync, const std::deque<std::string>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opStringSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opStringSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::deque<std::string>, std::deque<std::string>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::StringList
Test::TestIntfPrx::opStringList(const StringList& iceP_inSeq, StringList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<StringList, StringList>>(true, this, &TestIntfPrx::_iceI_opStringList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::StringList, ::Test::StringList>>
Test::TestIntfPrx::opStringListAsync(const StringList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<StringList, StringList>>(false, this, &TestIntfPrx::_iceI_opStringList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opStringListAsync(const StringList& iceP_inSeq,
                                     ::std::function<void (::Test::StringList, ::Test::StringList)> response,
                                     ::std::function<void(::std::exception_ptr)> ex,
                                     ::std::function<void(bool)> sent,
                                     const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<StringList, StringList>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<StringList, StringList>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringList, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opStringList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringList, StringList>>>& outAsync, const StringList& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opStringList_name);
    outAsync->invoke(iceC_Test_TestIntf_opStringList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<StringList, StringList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

std::deque< ::Test::Fixed>
Test::TestIntfPrx::opFixedSeq(const std::deque< ::Test::Fixed>& iceP_inSeq, std::deque< ::Test::Fixed>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque< ::Test::Fixed>, std::deque< ::Test::Fixed>>>(true, this, &TestIntfPrx::_iceI_opFixedSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::deque< ::Test::Fixed>, std::deque< ::Test::Fixed>>>
Test::TestIntfPrx::opFixedSeqAsync(const std::deque< ::Test::Fixed>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque< ::Test::Fixed>, std::deque< ::Test::Fixed>>>(false, this, &TestIntfPrx::_iceI_opFixedSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opFixedSeqAsync(const std::deque< ::Test::Fixed>& iceP_inSeq,
                                   ::std::function<void (std::deque< ::Test::Fixed>, std::deque< ::Test::Fixed>)> response,
                                   ::std::function<void(::std::exception_ptr)> ex,
                                   ::std::function<void(bool)> sent,
                                   const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::deque< ::Test::Fixed>, std::deque< ::Test::Fixed>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<std::deque< ::Test::Fixed>, std::deque< ::Test::Fixed>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opFixedSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opFixedSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque< ::Test::Fixed>, std::deque< ::Test::Fixed>>>>& outAsync, const std::deque< ::Test::Fixed>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opFixedSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opFixedSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::deque< ::Test::Fixed>, std::deque< ::Test::Fixed>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::FixedList
Test::TestIntfPrx::opFixedList(const FixedList& iceP_inSeq, FixedList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<FixedList, FixedList>>(true, this, &TestIntfPrx::_iceI_opFixedList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::FixedList, ::Test::FixedList>>
Test::TestIntfPrx::opFixedListAsync(const FixedList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<FixedList, FixedList>>(false, this, &TestIntfPrx::_iceI_opFixedList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opFixedListAsync(const FixedList& iceP_inSeq,
                                    ::std::function<void (::Test::FixedList, ::Test::FixedList)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<FixedList, FixedList>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<FixedList, FixedList>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opFixedList, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opFixedList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<FixedList, FixedList>>>& outAsync, const FixedList& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opFixedList_name);
    outAsync->invoke(iceC_Test_TestIntf_opFixedList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<FixedList, FixedList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

std::deque< ::Test::Variable>
Test::TestIntfPrx::opVariableSeq(const std::deque< ::Test::Variable>& iceP_inSeq, std::deque< ::Test::Variable>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque< ::Test::Variable>, std::deque< ::Test::Variable>>>(true, this, &TestIntfPrx::_iceI_opVariableSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::deque< ::Test::Variable>, std::deque< ::Test::Variable>>>
Test::TestIntfPrx::opVariableSeqAsync(const std::deque< ::Test::Variable>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque< ::Test::Variable>, std::deque< ::Test::Variable>>>(false, this, &TestIntfPrx::_iceI_opVariableSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opVariableSeqAsync(const std::deque< ::Test::Variable>& iceP_inSeq,
                                      ::std::function<void (std::deque< ::Test::Variable>, std::deque< ::Test::Variable>)> response,
                                      ::std::function<void(::std::exception_ptr)> ex,
                                      ::std::function<void(bool)> sent,
                                      const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::deque< ::Test::Variable>, std::deque< ::Test::Variable>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<std::deque< ::Test::Variable>, std::deque< ::Test::Variable>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opVariableSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opVariableSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque< ::Test::Variable>, std::deque< ::Test::Variable>>>>& outAsync, const std::deque< ::Test::Variable>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opVariableSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opVariableSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::deque< ::Test::Variable>, std::deque< ::Test::Variable>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::VariableList
Test::TestIntfPrx::opVariableList(const VariableList& iceP_inSeq, VariableList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<VariableList, VariableList>>(true, this, &TestIntfPrx::_iceI_opVariableList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::VariableList, ::Test::VariableList>>
Test::TestIntfPrx::opVariableListAsync(const VariableList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<VariableList, VariableList>>(false, this, &TestIntfPrx::_iceI_opVariableList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opVariableListAsync(const VariableList& iceP_inSeq,
                                       ::std::function<void (::Test::VariableList, ::Test::VariableList)> response,
                                       ::std::function<void(::std::exception_ptr)> ex,
                                       ::std::function<void(bool)> sent,
                                       const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<VariableList, VariableList>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<VariableList, VariableList>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opVariableList, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opVariableList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<VariableList, VariableList>>>& outAsync, const VariableList& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opVariableList_name);
    outAsync->invoke(iceC_Test_TestIntf_opVariableList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<VariableList, VariableList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

std::deque< ::Test::StringStringDict>
Test::TestIntfPrx::opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& iceP_inSeq, std::deque< ::Test::StringStringDict>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque< ::Test::StringStringDict>, std::deque< ::Test::StringStringDict>>>(true, this, &TestIntfPrx::_iceI_opStringStringDictSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::deque< ::Test::StringStringDict>, std::deque< ::Test::StringStringDict>>>
Test::TestIntfPrx::opStringStringDictSeqAsync(const std::deque< ::Test::StringStringDict>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque< ::Test::StringStringDict>, std::deque< ::Test::StringStringDict>>>(false, this, &TestIntfPrx::_iceI_opStringStringDictSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opStringStringDictSeqAsync(const std::deque< ::Test::StringStringDict>& iceP_inSeq,
                                              ::std::function<void (std::deque< ::Test::StringStringDict>, std::deque< ::Test::StringStringDict>)> response,
                                              ::std::function<void(::std::exception_ptr)> ex,
                                              ::std::function<void(bool)> sent,
                                              const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::deque< ::Test::StringStringDict>, std::deque< ::Test::StringStringDict>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<std::deque< ::Test::StringStringDict>, std::deque< ::Test::StringStringDict>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringStringDictSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opStringStringDictSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque< ::Test::StringStringDict>, std::deque< ::Test::StringStringDict>>>>& outAsync, const std::deque< ::Test::StringStringDict>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opStringStringDictSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opStringStringDictSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::deque< ::Test::StringStringDict>, std::deque< ::Test::StringStringDict>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::StringStringDictList
Test::TestIntfPrx::opStringStringDictList(const StringStringDictList& iceP_inSeq, StringStringDictList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<StringStringDictList, StringStringDictList>>(true, this, &TestIntfPrx::_iceI_opStringStringDictList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::StringStringDictList, ::Test::StringStringDictList>>
Test::TestIntfPrx::opStringStringDictListAsync(const StringStringDictList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<StringStringDictList, StringStringDictList>>(false, this, &TestIntfPrx::_iceI_opStringStringDictList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opStringStringDictListAsync(const StringStringDictList& iceP_inSeq,
                                               ::std::function<void (::Test::StringStringDictList, ::Test::StringStringDictList)> response,
                                               ::std::function<void(::std::exception_ptr)> ex,
                                               ::std::function<void(bool)> sent,
                                               const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<StringStringDictList, StringStringDictList>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<StringStringDictList, StringStringDictList>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringStringDictList, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opStringStringDictList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringStringDictList, StringStringDictList>>>& outAsync, const StringStringDictList& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opStringStringDictList_name);
    outAsync->invoke(iceC_Test_TestIntf_opStringStringDictList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<StringStringDictList, StringStringDictList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

std::deque< ::Test::E>
Test::TestIntfPrx::opESeq(const std::deque< ::Test::E>& iceP_inSeq, std::deque< ::Test::E>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque< ::Test::E>, std::deque< ::Test::E>>>(true, this, &TestIntfPrx::_iceI_opESeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::deque< ::Test::E>, std::deque< ::Test::E>>>
Test::TestIntfPrx::opESeqAsync(const std::deque< ::Test::E>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque< ::Test::E>, std::deque< ::Test::E>>>(false, this, &TestIntfPrx::_iceI_opESeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opESeqAsync(const std::deque< ::Test::E>& iceP_inSeq,
                               ::std::function<void (std::deque< ::Test::E>, std::deque< ::Test::E>)> response,
                               ::std::function<void(::std::exception_ptr)> ex,
                               ::std::function<void(bool)> sent,
                               const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::deque< ::Test::E>, std::deque< ::Test::E>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<std::deque< ::Test::E>, std::deque< ::Test::E>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opESeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opESeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque< ::Test::E>, std::deque< ::Test::E>>>>& outAsync, const std::deque< ::Test::E>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opESeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opESeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::deque< ::Test::E>, std::deque< ::Test::E>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::EList
Test::TestIntfPrx::opEList(const EList& iceP_inSeq, EList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<EList, EList>>(true, this, &TestIntfPrx::_iceI_opEList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::EList, ::Test::EList>>
Test::TestIntfPrx::opEListAsync(const EList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<EList, EList>>(false, this, &TestIntfPrx::_iceI_opEList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opEListAsync(const EList& iceP_inSeq,
                                ::std::function<void (::Test::EList, ::Test::EList)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<EList, EList>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<EList, EList>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opEList, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opEList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<EList, EList>>>& outAsync, const EList& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opEList_name);
    outAsync->invoke(iceC_Test_TestIntf_opEList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<EList, EList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

std::deque<::Test::DPrxPtr>
Test::TestIntfPrx::opDPrxSeq(const std::deque<::Test::DPrxPtr>& iceP_inSeq, std::deque<::Test::DPrxPtr>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<::Test::DPrxPtr>, std::deque<::Test::DPrxPtr>>>(true, this, &TestIntfPrx::_iceI_opDPrxSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::deque<::Test::DPrxPtr>, std::deque<::Test::DPrxPtr>>>
Test::TestIntfPrx::opDPrxSeqAsync(const std::deque<::Test::DPrxPtr>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<::Test::DPrxPtr>, std::deque<::Test::DPrxPtr>>>(false, this, &TestIntfPrx::_iceI_opDPrxSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opDPrxSeqAsync(const std::deque<::Test::DPrxPtr>& iceP_inSeq,
                                  ::std::function<void (std::deque<::Test::DPrxPtr>, std::deque<::Test::DPrxPtr>)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::deque<::Test::DPrxPtr>, std::deque<::Test::DPrxPtr>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<std::deque<::Test::DPrxPtr>, std::deque<::Test::DPrxPtr>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opDPrxSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opDPrxSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque<::Test::DPrxPtr>, std::deque<::Test::DPrxPtr>>>>& outAsync, const std::deque<::Test::DPrxPtr>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opDPrxSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opDPrxSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::deque<::Test::DPrxPtr>, std::deque<::Test::DPrxPtr>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::DPrxList
Test::TestIntfPrx::opDPrxList(const DPrxList& iceP_inSeq, DPrxList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<DPrxList, DPrxList>>(true, this, &TestIntfPrx::_iceI_opDPrxList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::DPrxList, ::Test::DPrxList>>
Test::TestIntfPrx::opDPrxListAsync(const DPrxList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<DPrxList, DPrxList>>(false, this, &TestIntfPrx::_iceI_opDPrxList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opDPrxListAsync(const DPrxList& iceP_inSeq,
                                   ::std::function<void (::Test::DPrxList, ::Test::DPrxList)> response,
                                   ::std::function<void(::std::exception_ptr)> ex,
                                   ::std::function<void(bool)> sent,
                                   const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<DPrxList, DPrxList>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<DPrxList, DPrxList>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opDPrxList, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opDPrxList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<DPrxList, DPrxList>>>& outAsync, const DPrxList& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opDPrxList_name);
    outAsync->invoke(iceC_Test_TestIntf_opDPrxList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<DPrxList, DPrxList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

std::deque<std::shared_ptr<Test::C>>
Test::TestIntfPrx::opCSeq(const std::deque<std::shared_ptr<Test::C>>& iceP_inSeq, std::deque<std::shared_ptr<Test::C>>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>>>(true, this, &TestIntfPrx::_iceI_opCSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>>>
Test::TestIntfPrx::opCSeqAsync(const std::deque<std::shared_ptr<Test::C>>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>>>(false, this, &TestIntfPrx::_iceI_opCSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opCSeqAsync(const std::deque<std::shared_ptr<Test::C>>& iceP_inSeq,
                               ::std::function<void (std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>)> response,
                               ::std::function<void(::std::exception_ptr)> ex,
                               ::std::function<void(bool)> sent,
                               const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opCSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opCSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>>>>& outAsync, const std::deque<std::shared_ptr<Test::C>>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opCSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opCSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

::Test::CList
Test::TestIntfPrx::opCList(const CList& iceP_inSeq, CList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<CList, CList>>(true, this, &TestIntfPrx::_iceI_opCList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::CList, ::Test::CList>>
Test::TestIntfPrx::opCListAsync(const CList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<CList, CList>>(false, this, &TestIntfPrx::_iceI_opCList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opCListAsync(const CList& iceP_inSeq,
                                ::std::function<void (::Test::CList, ::Test::CList)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<CList, CList>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<CList, CList>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opCList, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opCList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<CList, CList>>>& outAsync, const CList& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opCList_name);
    outAsync->invoke(iceC_Test_TestIntf_opCList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<CList, CList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

::Test::ClassStruct
Test::TestIntfPrx::opClassStruct(const ClassStruct& iceP_inS, const ClassStructSeq& iceP_inSeq, ClassStruct& iceP_outS, ClassStructSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<ClassStruct, ClassStruct, ClassStructSeq>>(true, this, &TestIntfPrx::_iceI_opClassStruct, iceP_inS, iceP_inSeq, context).get();
    iceP_outS = ::std::move(::std::get<1>(_result));
    iceP_outSeq = ::std::move(::std::get<2>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::ClassStruct, ::Test::ClassStruct, ::Test::ClassStructSeq>>
Test::TestIntfPrx::opClassStructAsync(const ClassStruct& iceP_inS, const ClassStructSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ClassStruct, ClassStruct, ClassStructSeq>>(false, this, &TestIntfPrx::_iceI_opClassStruct, iceP_inS, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opClassStructAsync(const ClassStruct& iceP_inS, const ClassStructSeq& iceP_inSeq,
                                      ::std::function<void (::Test::ClassStruct, ::Test::ClassStruct, ::Test::ClassStructSeq)> response,
                                      ::std::function<void(::std::exception_ptr)> ex,
                                      ::std::function<void(bool)> sent,
                                      const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<ClassStruct, ClassStruct, ClassStructSeq>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)), ::std::move(::std::get<2>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ClassStruct, ClassStruct, ClassStructSeq>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opClassStruct, iceP_inS, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opClassStruct(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ClassStruct, ClassStruct, ClassStructSeq>>>& outAsync, const ClassStruct& iceP_inS, const ClassStructSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opClassStruct_name);
    outAsync->invoke(iceC_Test_TestIntf_opClassStruct_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inS, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ClassStruct, ClassStruct, ClassStructSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<2>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

void
Test::TestIntfPrx::opOutArrayByteSeq(const ByteSeq& iceP_org, ByteSeq& iceP_copy, const ::Ice::Context& context) const
{
    iceP_copy = ::IceInternal::makePromiseOutgoing<ByteSeq>(true, this, &TestIntfPrx::_iceI_opOutArrayByteSeq, iceP_org, context).get();
}

::std::future<::Test::ByteSeq>
Test::TestIntfPrx::opOutArrayByteSeqAsync(const ByteSeq& iceP_org, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<ByteSeq>(false, this, &TestIntfPrx::_iceI_opOutArrayByteSeq, iceP_org, context);
}

::std::function<void()>
Test::TestIntfPrx::opOutArrayByteSeqAsync(const ByteSeq& iceP_org,
                                          ::std::function<void (::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>)> response,
                                          ::std::function<void(::std::exception_ptr)> ex,
                                          ::std::function<void(bool)> sent,
                                          const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOutArrayByteSeq_name);
    ::std::function<void(::Ice::InputStream*)> read;
    if(response)
    {
        read = [response](::Ice::InputStream* istr)
        {
            istr->startEncapsulation();
            ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*> iceP_copy;
            istr->readAll(iceP_copy);
            istr->endEncapsulation();
            try
            {
                response(iceP_copy);
            }
            catch(...)
            {
                throw ::std::current_exception();
            }
        };
    }
    auto outAsync = ::std::make_shared<::IceInternal::CustomLambdaOutgoing>(*this, read, ex, sent);

    outAsync->invoke(iceC_Test_TestIntf_opOutArrayByteSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_org);
        },
        nullptr);
    return [outAsync]() { outAsync->cancel(); };
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOutArrayByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ByteSeq>>& outAsync, const ByteSeq& iceP_org, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOutArrayByteSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOutArrayByteSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_org);
        },
        nullptr);
}
/// \endcond

void
Test::TestIntfPrx::opOutRangeByteSeq(const ByteSeq& iceP_org, ByteSeq& iceP_copy, const ::Ice::Context& context) const
{
    iceP_copy = ::IceInternal::makePromiseOutgoing<ByteSeq>(true, this, &TestIntfPrx::_iceI_opOutRangeByteSeq, iceP_org, context).get();
}

::std::future<::Test::ByteSeq>
Test::TestIntfPrx::opOutRangeByteSeqAsync(const ByteSeq& iceP_org, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<ByteSeq>(false, this, &TestIntfPrx::_iceI_opOutRangeByteSeq, iceP_org, context);
}

::std::function<void()>
Test::TestIntfPrx::opOutRangeByteSeqAsync(const ByteSeq& iceP_org,
                                          ::std::function<void (::Test::ByteSeq)> response,
                                          ::std::function<void(::std::exception_ptr)> ex,
                                          ::std::function<void(bool)> sent,
                                          const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<ByteSeq>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOutRangeByteSeq, iceP_org, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOutRangeByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ByteSeq>>& outAsync, const ByteSeq& iceP_org, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOutRangeByteSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOutRangeByteSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_org);
        },
        nullptr);
}
/// \endcond

::Test::IntStringDict
Test::TestIntfPrx::opIntStringDict(const IntStringDict& iceP_idict, IntStringDict& iceP_odict, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<IntStringDict, IntStringDict>>(true, this, &TestIntfPrx::_iceI_opIntStringDict, iceP_idict, context).get();
    iceP_odict = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::IntStringDict, ::Test::IntStringDict>>
Test::TestIntfPrx::opIntStringDictAsync(const IntStringDict& iceP_idict, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<IntStringDict, IntStringDict>>(false, this, &TestIntfPrx::_iceI_opIntStringDict, iceP_idict, context);
}

::std::function<void()>
Test::TestIntfPrx::opIntStringDictAsync(const IntStringDict& iceP_idict,
                                        ::std::function<void (::Test::IntStringDict, ::Test::IntStringDict)> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<IntStringDict, IntStringDict>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<IntStringDict, IntStringDict>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opIntStringDict, iceP_idict, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opIntStringDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<IntStringDict, IntStringDict>>>& outAsync, const IntStringDict& iceP_idict, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opIntStringDict_name);
    outAsync->invoke(iceC_Test_TestIntf_opIntStringDict_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_idict);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<IntStringDict, IntStringDict> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::CustomMap< int64_t, int64_t>
Test::TestIntfPrx::opVarDict(const ::Test::CustomMap<std::string, std::int32_t>& iceP_idict, ::Test::CustomMap<std::string, std::int32_t>& iceP_odict, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<::Test::CustomMap< int64_t, int64_t>, ::Test::CustomMap<std::string, std::int32_t>>>(true, this, &TestIntfPrx::_iceI_opVarDict, iceP_idict, context).get();
    iceP_odict = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::CustomMap< int64_t, int64_t>, ::Test::CustomMap<std::string, std::int32_t>>>
Test::TestIntfPrx::opVarDictAsync(const ::Test::CustomMap<std::string, std::int32_t>& iceP_idict, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::Test::CustomMap< int64_t, int64_t>, ::Test::CustomMap<std::string, std::int32_t>>>(false, this, &TestIntfPrx::_iceI_opVarDict, iceP_idict, context);
}

::std::function<void()>
Test::TestIntfPrx::opVarDictAsync(const ::Test::CustomMap<std::string, std::int32_t>& iceP_idict,
                                  ::std::function<void (::Test::CustomMap< int64_t, int64_t>, ::Test::CustomMap<std::string, std::int32_t>)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<::Test::CustomMap< int64_t, int64_t>, ::Test::CustomMap<std::string, std::int32_t>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::Test::CustomMap< int64_t, int64_t>, ::Test::CustomMap<std::string, std::int32_t>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opVarDict, iceP_idict, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opVarDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::Test::CustomMap< int64_t, int64_t>, ::Test::CustomMap<std::string, std::int32_t>>>>& outAsync, const ::Test::CustomMap<std::string, std::int32_t>& iceP_idict, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opVarDict_name);
    outAsync->invoke(iceC_Test_TestIntf_opVarDict_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_idict);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::Test::CustomMap< int64_t, int64_t>, ::Test::CustomMap<std::string, std::int32_t>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::CustomMap<std::int32_t, std::string>
Test::TestIntfPrx::opCustomIntStringDict(const ::std::map<std::int32_t, ::Util::string_view>& iceP_idict, ::Test::CustomMap<std::int32_t, std::string>& iceP_odict, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<::Test::CustomMap<std::int32_t, std::string>, ::Test::CustomMap<std::int32_t, std::string>>>(true, this, &TestIntfPrx::_iceI_opCustomIntStringDict, iceP_idict, context).get();
    iceP_odict = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::CustomMap<std::int32_t, std::string>, ::Test::CustomMap<std::int32_t, std::string>>>
Test::TestIntfPrx::opCustomIntStringDictAsync(const ::std::map<std::int32_t, ::Util::string_view>& iceP_idict, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::Test::CustomMap<std::int32_t, std::string>, ::Test::CustomMap<std::int32_t, std::string>>>(false, this, &TestIntfPrx::_iceI_opCustomIntStringDict, iceP_idict, context);
}

::std::function<void()>
Test::TestIntfPrx::opCustomIntStringDictAsync(const ::std::map<std::int32_t, ::Util::string_view>& iceP_idict,
                                              ::std::function<void (::std::map<std::int32_t, ::Util::string_view>, ::std::map<std::int32_t, ::Util::string_view>)> response,
                                              ::std::function<void(::std::exception_ptr)> ex,
                                              ::std::function<void(bool)> sent,
                                              const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opCustomIntStringDict_name);
    ::std::function<void(::Ice::InputStream*)> read;
    if(response)
    {
        read = [response](::Ice::InputStream* istr)
        {
            istr->startEncapsulation();
            ::std::map<std::int32_t, ::Util::string_view> iceP_odict;
            ::std::map<std::int32_t, ::Util::string_view> ret;
            istr->readAll(iceP_odict, ret);
            istr->endEncapsulation();
            try
            {
                response(ret, iceP_odict);
            }
            catch(...)
            {
                throw ::std::current_exception();
            }
        };
    }
    auto outAsync = ::std::make_shared<::IceInternal::CustomLambdaOutgoing>(*this, read, ex, sent);

    outAsync->invoke(iceC_Test_TestIntf_opCustomIntStringDict_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_idict);
        },
        nullptr);
    return [outAsync]() { outAsync->cancel(); };
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opCustomIntStringDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::Test::CustomMap<std::int32_t, std::string>, ::Test::CustomMap<std::int32_t, std::string>>>>& outAsync, const ::std::map<std::int32_t, ::Util::string_view>& iceP_idict, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opCustomIntStringDict_name);
    outAsync->invoke(iceC_Test_TestIntf_opCustomIntStringDict_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_idict);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::Test::CustomMap<std::int32_t, std::string>, ::Test::CustomMap<std::int32_t, std::string>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::ShortBuffer
Test::TestIntfPrx::opShortBuffer(const ShortBuffer& iceP_inS, ShortBuffer& iceP_outS, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<ShortBuffer, ShortBuffer>>(true, this, &TestIntfPrx::_iceI_opShortBuffer, iceP_inS, context).get();
    iceP_outS = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::ShortBuffer, ::Test::ShortBuffer>>
Test::TestIntfPrx::opShortBufferAsync(const ShortBuffer& iceP_inS, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ShortBuffer, ShortBuffer>>(false, this, &TestIntfPrx::_iceI_opShortBuffer, iceP_inS, context);
}

::std::function<void()>
Test::TestIntfPrx::opShortBufferAsync(const ShortBuffer& iceP_inS,
                                      ::std::function<void (::Test::ShortBuffer, ::Test::ShortBuffer)> response,
                                      ::std::function<void(::std::exception_ptr)> ex,
                                      ::std::function<void(bool)> sent,
                                      const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<ShortBuffer, ShortBuffer>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ShortBuffer, ShortBuffer>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opShortBuffer, iceP_inS, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opShortBuffer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ShortBuffer, ShortBuffer>>>& outAsync, const ShortBuffer& iceP_inS, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opShortBuffer_name);
    outAsync->invoke(iceC_Test_TestIntf_opShortBuffer_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inS);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ShortBuffer, ShortBuffer> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::CustomBuffer<bool>
Test::TestIntfPrx::opBoolBuffer(const ::Test::CustomBuffer<bool>& iceP_inS, ::Test::CustomBuffer<bool>& iceP_outS, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>>>(true, this, &TestIntfPrx::_iceI_opBoolBuffer, iceP_inS, context).get();
    iceP_outS = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>>>
Test::TestIntfPrx::opBoolBufferAsync(const ::Test::CustomBuffer<bool>& iceP_inS, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>>>(false, this, &TestIntfPrx::_iceI_opBoolBuffer, iceP_inS, context);
}

::std::function<void()>
Test::TestIntfPrx::opBoolBufferAsync(const ::Test::CustomBuffer<bool>& iceP_inS,
                                     ::std::function<void (::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>)> response,
                                     ::std::function<void(::std::exception_ptr)> ex,
                                     ::std::function<void(bool)> sent,
                                     const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolBuffer, iceP_inS, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opBoolBuffer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>>>>& outAsync, const ::Test::CustomBuffer<bool>& iceP_inS, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolBuffer_name);
    outAsync->invoke(iceC_Test_TestIntf_opBoolBuffer_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inS);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::BufferStruct
Test::TestIntfPrx::opBufferStruct(const BufferStruct& iceP_s, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<BufferStruct>(true, this, &TestIntfPrx::_iceI_opBufferStruct, iceP_s, context).get();
}

::std::future<::Test::BufferStruct>
Test::TestIntfPrx::opBufferStructAsync(const BufferStruct& iceP_s, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<BufferStruct>(false, this, &TestIntfPrx::_iceI_opBufferStruct, iceP_s, context);
}

::std::function<void()>
Test::TestIntfPrx::opBufferStructAsync(const BufferStruct& iceP_s,
                                       ::std::function<void (::Test::BufferStruct)> response,
                                       ::std::function<void(::std::exception_ptr)> ex,
                                       ::std::function<void(bool)> sent,
                                       const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<BufferStruct>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBufferStruct, iceP_s, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opBufferStruct(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<BufferStruct>>& outAsync, const BufferStruct& iceP_s, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBufferStruct_name);
    outAsync->invoke(iceC_Test_TestIntf_opBufferStruct_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_s);
        },
        nullptr);
}
/// \endcond

void
Test::TestIntfPrx::shutdown(const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_shutdown, context).get();
}

::std::future<void>
Test::TestIntfPrx::shutdownAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &TestIntfPrx::_iceI_shutdown, context);
}

::std::function<void()>
Test::TestIntfPrx::shutdownAsync(::std::function<void ()> response,
                                 ::std::function<void(::std::exception_ptr)> ex,
                                 ::std::function<void(bool)> sent,
                                 const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_shutdown, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context) const
{
    outAsync->invoke(iceC_Test_TestIntf_shutdown_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

const ::std::string&
Test::TestIntfPrx::ice_staticId()
{
    static const ::std::string typeId = "::Test::TestIntf";
    return typeId;
}

Test::C::~C()
{
}

const ::std::string&
Test::C::ice_staticId()
{
    static const ::std::string typeId = "::Test::C";
    return typeId;
}

Test::DictClass::~DictClass()
{
}

const ::std::string&
Test::DictClass::ice_staticId()
{
    static const ::std::string typeId = "::Test::DictClass";
    return typeId;
}

bool
Test::D::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_D_ids, iceC_Test_D_ids + 2, s);
}

::std::vector<::std::string>
Test::D::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_D_ids[0], &iceC_Test_D_ids[2]);
}

::std::string
Test::D::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::D::ice_staticId()
{
    static const ::std::string typeId = "::Test::D";
    return typeId;
}

bool
Test::TestIntf::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_TestIntf_ids, iceC_Test_TestIntf_ids + 2, s);
}

::std::vector<::std::string>
Test::TestIntf::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_TestIntf_ids[0], &iceC_Test_TestIntf_ids[2]);
}

::std::string
Test::TestIntf::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::TestIntf::ice_staticId()
{
    static const ::std::string typeId = "::Test::TestIntf";
    return typeId;
}

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDoubleArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::pair<const double*, const double*> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const DoubleSeq& ret, const DoubleSeq& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opDoubleArrayAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::pair<const bool*, const bool*> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const BoolSeq& ret, const BoolSeq& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opBoolArrayAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>& ret, const ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opByteArrayAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVariableArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::pair<const Variable*, const Variable*> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const VariableList& ret, const VariableList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opVariableArrayAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    BoolSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const BoolSeq& ret, const BoolSeq& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opBoolRangeAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ByteList& ret, const ByteList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opByteRangeAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVariableRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    VariableList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const VariableList& ret, const VariableList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opVariableRangeAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteRangeType(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ByteList& ret, const ByteList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opByteRangeTypeAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVariableRangeType(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    VariableList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const VariableList& ret, const VariableList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opVariableRangeTypeAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque<bool> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const std::deque<bool>& ret, const std::deque<bool>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opBoolSeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    BoolList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const BoolList& ret, const BoolList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opBoolListAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque< ::Ice::Byte> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const std::deque< ::Ice::Byte>& ret, const std::deque< ::Ice::Byte>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opByteSeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ByteList& ret, const ByteList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opByteListAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opMyByteSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    MyByteSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const MyByteSeq& ret, const MyByteSeq& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opMyByteSeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opString(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    Util::string_view iceP_inString;
    istr->readAll(iceP_inString);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const Util::string_view& ret, const Util::string_view& iceP_outString)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outString, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opStringAsync(::std::move(iceP_inString), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque<std::string> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const std::deque<std::string>& ret, const std::deque<std::string>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opStringSeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const StringList& ret, const StringList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opStringListAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opFixedSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque< ::Test::Fixed> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const std::deque< ::Test::Fixed>& ret, const std::deque< ::Test::Fixed>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opFixedSeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opFixedList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    FixedList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const FixedList& ret, const FixedList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opFixedListAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVariableSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque< ::Test::Variable> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const std::deque< ::Test::Variable>& ret, const std::deque< ::Test::Variable>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opVariableSeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVariableList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    VariableList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const VariableList& ret, const VariableList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opVariableListAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringStringDictSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque< ::Test::StringStringDict> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const std::deque< ::Test::StringStringDict>& ret, const std::deque< ::Test::StringStringDict>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opStringStringDictSeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringStringDictList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringStringDictList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const StringStringDictList& ret, const StringStringDictList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opStringStringDictListAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opESeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque< ::Test::E> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const std::deque< ::Test::E>& ret, const std::deque< ::Test::E>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opESeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opEList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    EList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const EList& ret, const EList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opEListAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDPrxSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque<::Test::DPrxPtr> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const std::deque<::Test::DPrxPtr>& ret, const std::deque<::Test::DPrxPtr>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opDPrxSeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDPrxList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    DPrxList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const DPrxList& ret, const DPrxList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opDPrxListAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opCSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque<std::shared_ptr<Test::C>> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->readPendingValues();
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const std::deque<std::shared_ptr<Test::C>>& ret, const std::deque<std::shared_ptr<Test::C>>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->opCSeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opCList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    CList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->readPendingValues();
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const CList& ret, const CList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->opCListAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opClassStruct(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ClassStruct iceP_inS;
    ClassStructSeq iceP_inSeq;
    istr->readAll(iceP_inS, iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ClassStruct& ret, const ClassStruct& iceP_outS, const ClassStructSeq& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outS, iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opClassStructAsync(::std::move(iceP_inS), ::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOutArrayByteSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteSeq iceP_org;
    istr->readAll(iceP_org);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>& iceP_copy)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_copy);
        inA->endWriteParams();
        inA->completed();
    };
    this->opOutArrayByteSeqAsync(::std::move(iceP_org), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOutRangeByteSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteSeq iceP_org;
    istr->readAll(iceP_org);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ByteSeq& iceP_copy)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_copy);
        inA->endWriteParams();
        inA->completed();
    };
    this->opOutRangeByteSeqAsync(::std::move(iceP_org), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opIntStringDict(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    IntStringDict iceP_idict;
    istr->readAll(iceP_idict);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const IntStringDict& ret, const IntStringDict& iceP_odict)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_odict, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opIntStringDictAsync(::std::move(iceP_idict), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVarDict(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::Test::CustomMap<std::string, std::int32_t> iceP_idict;
    istr->readAll(iceP_idict);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::Test::CustomMap< int64_t, int64_t>& ret, const ::Test::CustomMap<std::string, std::int32_t>& iceP_odict)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_odict, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opVarDictAsync(::std::move(iceP_idict), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opCustomIntStringDict(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::map<std::int32_t, ::Util::string_view> iceP_idict;
    istr->readAll(iceP_idict);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::map<std::int32_t, ::Util::string_view>& ret, const ::std::map<std::int32_t, ::Util::string_view>& iceP_odict)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_odict, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opCustomIntStringDictAsync(::std::move(iceP_idict), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opShortBuffer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ShortBuffer iceP_inS;
    istr->readAll(iceP_inS);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ShortBuffer& ret, const ShortBuffer& iceP_outS)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outS, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opShortBufferAsync(::std::move(iceP_inS), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolBuffer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::Test::CustomBuffer<bool> iceP_inS;
    istr->readAll(iceP_inS);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::Test::CustomBuffer<bool>& ret, const ::Test::CustomBuffer<bool>& iceP_outS)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outS, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opBoolBufferAsync(::std::move(iceP_inS), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBufferStruct(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    BufferStruct iceP_s;
    istr->readAll(iceP_s);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const BufferStruct& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opBufferStructAsync(::std::move(iceP_s), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_shutdown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->shutdownAsync(inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_TestIntf_ops, iceC_Test_TestIntf_ops + 43, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_TestIntf_ops)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_opBoolArray(in, current);
        }
        case 5:
        {
            return _iceD_opBoolBuffer(in, current);
        }
        case 6:
        {
            return _iceD_opBoolList(in, current);
        }
        case 7:
        {
            return _iceD_opBoolRange(in, current);
        }
        case 8:
        {
            return _iceD_opBoolSeq(in, current);
        }
        case 9:
        {
            return _iceD_opBufferStruct(in, current);
        }
        case 10:
        {
            return _iceD_opByteArray(in, current);
        }
        case 11:
        {
            return _iceD_opByteList(in, current);
        }
        case 12:
        {
            return _iceD_opByteRange(in, current);
        }
        case 13:
        {
            return _iceD_opByteRangeType(in, current);
        }
        case 14:
        {
            return _iceD_opByteSeq(in, current);
        }
        case 15:
        {
            return _iceD_opCList(in, current);
        }
        case 16:
        {
            return _iceD_opCSeq(in, current);
        }
        case 17:
        {
            return _iceD_opClassStruct(in, current);
        }
        case 18:
        {
            return _iceD_opCustomIntStringDict(in, current);
        }
        case 19:
        {
            return _iceD_opDPrxList(in, current);
        }
        case 20:
        {
            return _iceD_opDPrxSeq(in, current);
        }
        case 21:
        {
            return _iceD_opDoubleArray(in, current);
        }
        case 22:
        {
            return _iceD_opEList(in, current);
        }
        case 23:
        {
            return _iceD_opESeq(in, current);
        }
        case 24:
        {
            return _iceD_opFixedList(in, current);
        }
        case 25:
        {
            return _iceD_opFixedSeq(in, current);
        }
        case 26:
        {
            return _iceD_opIntStringDict(in, current);
        }
        case 27:
        {
            return _iceD_opMyByteSeq(in, current);
        }
        case 28:
        {
            return _iceD_opOutArrayByteSeq(in, current);
        }
        case 29:
        {
            return _iceD_opOutRangeByteSeq(in, current);
        }
        case 30:
        {
            return _iceD_opShortBuffer(in, current);
        }
        case 31:
        {
            return _iceD_opString(in, current);
        }
        case 32:
        {
            return _iceD_opStringList(in, current);
        }
        case 33:
        {
            return _iceD_opStringSeq(in, current);
        }
        case 34:
        {
            return _iceD_opStringStringDictList(in, current);
        }
        case 35:
        {
            return _iceD_opStringStringDictSeq(in, current);
        }
        case 36:
        {
            return _iceD_opVarDict(in, current);
        }
        case 37:
        {
            return _iceD_opVariableArray(in, current);
        }
        case 38:
        {
            return _iceD_opVariableList(in, current);
        }
        case 39:
        {
            return _iceD_opVariableRange(in, current);
        }
        case 40:
        {
            return _iceD_opVariableRangeType(in, current);
        }
        case 41:
        {
            return _iceD_opVariableSeq(in, current);
        }
        case 42:
        {
            return _iceD_shutdown(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond
