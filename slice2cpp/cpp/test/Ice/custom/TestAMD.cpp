//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `TestAMD.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#define ICE_BUILDING_GENERATED_CODE
#include <TestAMD.h>
#include <Ice/OutgoingAsync.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace
{

const ::IceInternal::DefaultValueFactoryInit<::Test::C> iceC_Test_C_init("::Test::C");

const ::IceInternal::DefaultValueFactoryInit<::Test::DictClass> iceC_Test_DictClass_init("::Test::DictClass");

}

::std::string_view
Test::DPrx::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::Test::D";
    return typeId;
}

::Test::DoubleSeq
Test::TestIntfPrx::opDoubleArray(const ::std::pair<const double*, const double*>& iceP_inSeq, DoubleSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<DoubleSeq, DoubleSeq>>(true, this, &TestIntfPrx::_iceI_opDoubleArray, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::DoubleSeq, ::Test::DoubleSeq>>
Test::TestIntfPrx::opDoubleArrayAsync(const ::std::pair<const double*, const double*>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<DoubleSeq, DoubleSeq>>(false, this, &TestIntfPrx::_iceI_opDoubleArray, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opDoubleArrayAsync(const ::std::pair<const double*, const double*>& iceP_inSeq,
                                      ::std::function<void (::Test::DoubleSeq, ::Test::DoubleSeq)> response,
                                      ::std::function<void(::std::exception_ptr)> ex,
                                      ::std::function<void(bool)> sent,
                                      const ::Ice::Context& context) const
{
    auto _responseCb = [_response = ::std::move(response)](::std::tuple<DoubleSeq, DoubleSeq>&& _result)
    {
        ::std::apply(::std::move(_response), ::std::move(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<DoubleSeq, DoubleSeq>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opDoubleArray, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opDoubleArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<DoubleSeq, DoubleSeq>>>& outAsync, const ::std::pair<const double*, const double*>& iceP_inSeq, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opDoubleArray";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<DoubleSeq, DoubleSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::BoolSeq
Test::TestIntfPrx::opBoolArray(const ::std::pair<const bool*, const bool*>& iceP_inSeq, BoolSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<BoolSeq, BoolSeq>>(true, this, &TestIntfPrx::_iceI_opBoolArray, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::BoolSeq, ::Test::BoolSeq>>
Test::TestIntfPrx::opBoolArrayAsync(const ::std::pair<const bool*, const bool*>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<BoolSeq, BoolSeq>>(false, this, &TestIntfPrx::_iceI_opBoolArray, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opBoolArrayAsync(const ::std::pair<const bool*, const bool*>& iceP_inSeq,
                                    ::std::function<void (::Test::BoolSeq, ::Test::BoolSeq)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    auto _responseCb = [_response = ::std::move(response)](::std::tuple<BoolSeq, BoolSeq>&& _result)
    {
        ::std::apply(::std::move(_response), ::std::move(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<BoolSeq, BoolSeq>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolArray, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opBoolArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BoolSeq, BoolSeq>>>& outAsync, const ::std::pair<const bool*, const bool*>& iceP_inSeq, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opBoolArray";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<BoolSeq, BoolSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::ByteList
Test::TestIntfPrx::opByteArray(const ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>& iceP_inSeq, ByteList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<ByteList, ByteList>>(true, this, &TestIntfPrx::_iceI_opByteArray, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::ByteList, ::Test::ByteList>>
Test::TestIntfPrx::opByteArrayAsync(const ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ByteList, ByteList>>(false, this, &TestIntfPrx::_iceI_opByteArray, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opByteArrayAsync(const ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>& iceP_inSeq,
                                    ::std::function<void (::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>, ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opByteArray";

    _checkTwowayOnly(operationName);
    ::std::function<void(::Ice::InputStream*)> read;
    if(response)
    {
        read = [response](::Ice::InputStream* istr)
        {
            istr->startEncapsulation();
            ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*> iceP_outSeq;
            ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*> ret;
            istr->readAll(iceP_outSeq, ret);
            istr->endEncapsulation();
            try
            {
                response(ret, iceP_outSeq);
            }
            catch(...)
            {
                throw ::std::current_exception();
            }
        };
    }
    auto outAsync = ::std::make_shared<::IceInternal::CustomLambdaOutgoing>(*this, read, ex, sent);

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr);
    return [outAsync]() { outAsync->cancel(); };
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opByteArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteList, ByteList>>>& outAsync, const ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>& iceP_inSeq, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opByteArray";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ByteList, ByteList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::VariableList
Test::TestIntfPrx::opVariableArray(const ::std::pair<const Variable*, const Variable*>& iceP_inSeq, VariableList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<VariableList, VariableList>>(true, this, &TestIntfPrx::_iceI_opVariableArray, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::VariableList, ::Test::VariableList>>
Test::TestIntfPrx::opVariableArrayAsync(const ::std::pair<const Variable*, const Variable*>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<VariableList, VariableList>>(false, this, &TestIntfPrx::_iceI_opVariableArray, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opVariableArrayAsync(const ::std::pair<const Variable*, const Variable*>& iceP_inSeq,
                                        ::std::function<void (::Test::VariableList, ::Test::VariableList)> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context) const
{
    auto _responseCb = [_response = ::std::move(response)](::std::tuple<VariableList, VariableList>&& _result)
    {
        ::std::apply(::std::move(_response), ::std::move(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<VariableList, VariableList>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opVariableArray, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opVariableArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<VariableList, VariableList>>>& outAsync, const ::std::pair<const Variable*, const Variable*>& iceP_inSeq, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opVariableArray";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<VariableList, VariableList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

std::deque<bool>
Test::TestIntfPrx::opBoolSeq(const std::deque<bool>& iceP_inSeq, std::deque<bool>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<bool>, std::deque<bool>>>(true, this, &TestIntfPrx::_iceI_opBoolSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::deque<bool>, std::deque<bool>>>
Test::TestIntfPrx::opBoolSeqAsync(const std::deque<bool>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<bool>, std::deque<bool>>>(false, this, &TestIntfPrx::_iceI_opBoolSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opBoolSeqAsync(const std::deque<bool>& iceP_inSeq,
                                  ::std::function<void (std::deque<bool>, std::deque<bool>)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [_response = ::std::move(response)](::std::tuple<std::deque<bool>, std::deque<bool>>&& _result)
    {
        ::std::apply(::std::move(_response), ::std::move(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<std::deque<bool>, std::deque<bool>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opBoolSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque<bool>, std::deque<bool>>>>& outAsync, const std::deque<bool>& iceP_inSeq, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opBoolSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::deque<bool>, std::deque<bool>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::BoolList
Test::TestIntfPrx::opBoolList(const BoolList& iceP_inSeq, BoolList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<BoolList, BoolList>>(true, this, &TestIntfPrx::_iceI_opBoolList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::BoolList, ::Test::BoolList>>
Test::TestIntfPrx::opBoolListAsync(const BoolList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<BoolList, BoolList>>(false, this, &TestIntfPrx::_iceI_opBoolList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opBoolListAsync(const BoolList& iceP_inSeq,
                                   ::std::function<void (::Test::BoolList, ::Test::BoolList)> response,
                                   ::std::function<void(::std::exception_ptr)> ex,
                                   ::std::function<void(bool)> sent,
                                   const ::Ice::Context& context) const
{
    auto _responseCb = [_response = ::std::move(response)](::std::tuple<BoolList, BoolList>&& _result)
    {
        ::std::apply(::std::move(_response), ::std::move(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<BoolList, BoolList>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolList, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opBoolList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BoolList, BoolList>>>& outAsync, const BoolList& iceP_inSeq, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opBoolList";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<BoolList, BoolList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

std::deque< ::Ice::Byte>
Test::TestIntfPrx::opByteSeq(const std::deque< ::Ice::Byte>& iceP_inSeq, std::deque< ::Ice::Byte>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque< ::Ice::Byte>, std::deque< ::Ice::Byte>>>(true, this, &TestIntfPrx::_iceI_opByteSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::deque< ::Ice::Byte>, std::deque< ::Ice::Byte>>>
Test::TestIntfPrx::opByteSeqAsync(const std::deque< ::Ice::Byte>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque< ::Ice::Byte>, std::deque< ::Ice::Byte>>>(false, this, &TestIntfPrx::_iceI_opByteSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opByteSeqAsync(const std::deque< ::Ice::Byte>& iceP_inSeq,
                                  ::std::function<void (std::deque< ::Ice::Byte>, std::deque< ::Ice::Byte>)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [_response = ::std::move(response)](::std::tuple<std::deque< ::Ice::Byte>, std::deque< ::Ice::Byte>>&& _result)
    {
        ::std::apply(::std::move(_response), ::std::move(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<std::deque< ::Ice::Byte>, std::deque< ::Ice::Byte>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opByteSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque< ::Ice::Byte>, std::deque< ::Ice::Byte>>>>& outAsync, const std::deque< ::Ice::Byte>& iceP_inSeq, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opByteSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::deque< ::Ice::Byte>, std::deque< ::Ice::Byte>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::ByteList
Test::TestIntfPrx::opByteList(const ByteList& iceP_inSeq, ByteList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<ByteList, ByteList>>(true, this, &TestIntfPrx::_iceI_opByteList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::ByteList, ::Test::ByteList>>
Test::TestIntfPrx::opByteListAsync(const ByteList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ByteList, ByteList>>(false, this, &TestIntfPrx::_iceI_opByteList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opByteListAsync(const ByteList& iceP_inSeq,
                                   ::std::function<void (::Test::ByteList, ::Test::ByteList)> response,
                                   ::std::function<void(::std::exception_ptr)> ex,
                                   ::std::function<void(bool)> sent,
                                   const ::Ice::Context& context) const
{
    auto _responseCb = [_response = ::std::move(response)](::std::tuple<ByteList, ByteList>&& _result)
    {
        ::std::apply(::std::move(_response), ::std::move(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ByteList, ByteList>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opByteList, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opByteList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteList, ByteList>>>& outAsync, const ByteList& iceP_inSeq, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opByteList";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ByteList, ByteList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

MyByteSeq
Test::TestIntfPrx::opMyByteSeq(const MyByteSeq& iceP_inSeq, MyByteSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<MyByteSeq, MyByteSeq>>(true, this, &TestIntfPrx::_iceI_opMyByteSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<MyByteSeq, MyByteSeq>>
Test::TestIntfPrx::opMyByteSeqAsync(const MyByteSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<MyByteSeq, MyByteSeq>>(false, this, &TestIntfPrx::_iceI_opMyByteSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opMyByteSeqAsync(const MyByteSeq& iceP_inSeq,
                                    ::std::function<void (MyByteSeq, MyByteSeq)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    auto _responseCb = [_response = ::std::move(response)](::std::tuple<MyByteSeq, MyByteSeq>&& _result)
    {
        ::std::apply(::std::move(_response), ::std::move(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<MyByteSeq, MyByteSeq>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opMyByteSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opMyByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<MyByteSeq, MyByteSeq>>>& outAsync, const MyByteSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opMyByteSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<MyByteSeq, MyByteSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

std::deque<std::string>
Test::TestIntfPrx::opStringSeq(const std::deque<std::string>& iceP_inSeq, std::deque<std::string>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<std::string>, std::deque<std::string>>>(true, this, &TestIntfPrx::_iceI_opStringSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::deque<std::string>, std::deque<std::string>>>
Test::TestIntfPrx::opStringSeqAsync(const std::deque<std::string>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<std::string>, std::deque<std::string>>>(false, this, &TestIntfPrx::_iceI_opStringSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opStringSeqAsync(const std::deque<std::string>& iceP_inSeq,
                                    ::std::function<void (std::deque<std::string>, std::deque<std::string>)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    auto _responseCb = [_response = ::std::move(response)](::std::tuple<std::deque<std::string>, std::deque<std::string>>&& _result)
    {
        ::std::apply(::std::move(_response), ::std::move(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<std::deque<std::string>, std::deque<std::string>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opStringSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque<std::string>, std::deque<std::string>>>>& outAsync, const std::deque<std::string>& iceP_inSeq, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opStringSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::deque<std::string>, std::deque<std::string>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::StringList
Test::TestIntfPrx::opStringList(const StringList& iceP_inSeq, StringList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<StringList, StringList>>(true, this, &TestIntfPrx::_iceI_opStringList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::StringList, ::Test::StringList>>
Test::TestIntfPrx::opStringListAsync(const StringList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<StringList, StringList>>(false, this, &TestIntfPrx::_iceI_opStringList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opStringListAsync(const StringList& iceP_inSeq,
                                     ::std::function<void (::Test::StringList, ::Test::StringList)> response,
                                     ::std::function<void(::std::exception_ptr)> ex,
                                     ::std::function<void(bool)> sent,
                                     const ::Ice::Context& context) const
{
    auto _responseCb = [_response = ::std::move(response)](::std::tuple<StringList, StringList>&& _result)
    {
        ::std::apply(::std::move(_response), ::std::move(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<StringList, StringList>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringList, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opStringList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringList, StringList>>>& outAsync, const StringList& iceP_inSeq, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opStringList";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<StringList, StringList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

std::deque< ::Test::Fixed>
Test::TestIntfPrx::opFixedSeq(const std::deque< ::Test::Fixed>& iceP_inSeq, std::deque< ::Test::Fixed>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque< ::Test::Fixed>, std::deque< ::Test::Fixed>>>(true, this, &TestIntfPrx::_iceI_opFixedSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::deque< ::Test::Fixed>, std::deque< ::Test::Fixed>>>
Test::TestIntfPrx::opFixedSeqAsync(const std::deque< ::Test::Fixed>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque< ::Test::Fixed>, std::deque< ::Test::Fixed>>>(false, this, &TestIntfPrx::_iceI_opFixedSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opFixedSeqAsync(const std::deque< ::Test::Fixed>& iceP_inSeq,
                                   ::std::function<void (std::deque< ::Test::Fixed>, std::deque< ::Test::Fixed>)> response,
                                   ::std::function<void(::std::exception_ptr)> ex,
                                   ::std::function<void(bool)> sent,
                                   const ::Ice::Context& context) const
{
    auto _responseCb = [_response = ::std::move(response)](::std::tuple<std::deque< ::Test::Fixed>, std::deque< ::Test::Fixed>>&& _result)
    {
        ::std::apply(::std::move(_response), ::std::move(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<std::deque< ::Test::Fixed>, std::deque< ::Test::Fixed>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opFixedSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opFixedSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque< ::Test::Fixed>, std::deque< ::Test::Fixed>>>>& outAsync, const std::deque< ::Test::Fixed>& iceP_inSeq, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opFixedSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::deque< ::Test::Fixed>, std::deque< ::Test::Fixed>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::FixedList
Test::TestIntfPrx::opFixedList(const FixedList& iceP_inSeq, FixedList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<FixedList, FixedList>>(true, this, &TestIntfPrx::_iceI_opFixedList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::FixedList, ::Test::FixedList>>
Test::TestIntfPrx::opFixedListAsync(const FixedList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<FixedList, FixedList>>(false, this, &TestIntfPrx::_iceI_opFixedList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opFixedListAsync(const FixedList& iceP_inSeq,
                                    ::std::function<void (::Test::FixedList, ::Test::FixedList)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    auto _responseCb = [_response = ::std::move(response)](::std::tuple<FixedList, FixedList>&& _result)
    {
        ::std::apply(::std::move(_response), ::std::move(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<FixedList, FixedList>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opFixedList, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opFixedList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<FixedList, FixedList>>>& outAsync, const FixedList& iceP_inSeq, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opFixedList";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<FixedList, FixedList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

std::deque< ::Test::Variable>
Test::TestIntfPrx::opVariableSeq(const std::deque< ::Test::Variable>& iceP_inSeq, std::deque< ::Test::Variable>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque< ::Test::Variable>, std::deque< ::Test::Variable>>>(true, this, &TestIntfPrx::_iceI_opVariableSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::deque< ::Test::Variable>, std::deque< ::Test::Variable>>>
Test::TestIntfPrx::opVariableSeqAsync(const std::deque< ::Test::Variable>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque< ::Test::Variable>, std::deque< ::Test::Variable>>>(false, this, &TestIntfPrx::_iceI_opVariableSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opVariableSeqAsync(const std::deque< ::Test::Variable>& iceP_inSeq,
                                      ::std::function<void (std::deque< ::Test::Variable>, std::deque< ::Test::Variable>)> response,
                                      ::std::function<void(::std::exception_ptr)> ex,
                                      ::std::function<void(bool)> sent,
                                      const ::Ice::Context& context) const
{
    auto _responseCb = [_response = ::std::move(response)](::std::tuple<std::deque< ::Test::Variable>, std::deque< ::Test::Variable>>&& _result)
    {
        ::std::apply(::std::move(_response), ::std::move(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<std::deque< ::Test::Variable>, std::deque< ::Test::Variable>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opVariableSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opVariableSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque< ::Test::Variable>, std::deque< ::Test::Variable>>>>& outAsync, const std::deque< ::Test::Variable>& iceP_inSeq, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opVariableSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::deque< ::Test::Variable>, std::deque< ::Test::Variable>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::VariableList
Test::TestIntfPrx::opVariableList(const VariableList& iceP_inSeq, VariableList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<VariableList, VariableList>>(true, this, &TestIntfPrx::_iceI_opVariableList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::VariableList, ::Test::VariableList>>
Test::TestIntfPrx::opVariableListAsync(const VariableList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<VariableList, VariableList>>(false, this, &TestIntfPrx::_iceI_opVariableList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opVariableListAsync(const VariableList& iceP_inSeq,
                                       ::std::function<void (::Test::VariableList, ::Test::VariableList)> response,
                                       ::std::function<void(::std::exception_ptr)> ex,
                                       ::std::function<void(bool)> sent,
                                       const ::Ice::Context& context) const
{
    auto _responseCb = [_response = ::std::move(response)](::std::tuple<VariableList, VariableList>&& _result)
    {
        ::std::apply(::std::move(_response), ::std::move(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<VariableList, VariableList>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opVariableList, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opVariableList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<VariableList, VariableList>>>& outAsync, const VariableList& iceP_inSeq, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opVariableList";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<VariableList, VariableList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

std::deque< ::Test::StringStringDict>
Test::TestIntfPrx::opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& iceP_inSeq, std::deque< ::Test::StringStringDict>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque< ::Test::StringStringDict>, std::deque< ::Test::StringStringDict>>>(true, this, &TestIntfPrx::_iceI_opStringStringDictSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::deque< ::Test::StringStringDict>, std::deque< ::Test::StringStringDict>>>
Test::TestIntfPrx::opStringStringDictSeqAsync(const std::deque< ::Test::StringStringDict>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque< ::Test::StringStringDict>, std::deque< ::Test::StringStringDict>>>(false, this, &TestIntfPrx::_iceI_opStringStringDictSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opStringStringDictSeqAsync(const std::deque< ::Test::StringStringDict>& iceP_inSeq,
                                              ::std::function<void (std::deque< ::Test::StringStringDict>, std::deque< ::Test::StringStringDict>)> response,
                                              ::std::function<void(::std::exception_ptr)> ex,
                                              ::std::function<void(bool)> sent,
                                              const ::Ice::Context& context) const
{
    auto _responseCb = [_response = ::std::move(response)](::std::tuple<std::deque< ::Test::StringStringDict>, std::deque< ::Test::StringStringDict>>&& _result)
    {
        ::std::apply(::std::move(_response), ::std::move(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<std::deque< ::Test::StringStringDict>, std::deque< ::Test::StringStringDict>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringStringDictSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opStringStringDictSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque< ::Test::StringStringDict>, std::deque< ::Test::StringStringDict>>>>& outAsync, const std::deque< ::Test::StringStringDict>& iceP_inSeq, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opStringStringDictSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::deque< ::Test::StringStringDict>, std::deque< ::Test::StringStringDict>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::StringStringDictList
Test::TestIntfPrx::opStringStringDictList(const StringStringDictList& iceP_inSeq, StringStringDictList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<StringStringDictList, StringStringDictList>>(true, this, &TestIntfPrx::_iceI_opStringStringDictList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::StringStringDictList, ::Test::StringStringDictList>>
Test::TestIntfPrx::opStringStringDictListAsync(const StringStringDictList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<StringStringDictList, StringStringDictList>>(false, this, &TestIntfPrx::_iceI_opStringStringDictList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opStringStringDictListAsync(const StringStringDictList& iceP_inSeq,
                                               ::std::function<void (::Test::StringStringDictList, ::Test::StringStringDictList)> response,
                                               ::std::function<void(::std::exception_ptr)> ex,
                                               ::std::function<void(bool)> sent,
                                               const ::Ice::Context& context) const
{
    auto _responseCb = [_response = ::std::move(response)](::std::tuple<StringStringDictList, StringStringDictList>&& _result)
    {
        ::std::apply(::std::move(_response), ::std::move(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<StringStringDictList, StringStringDictList>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringStringDictList, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opStringStringDictList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringStringDictList, StringStringDictList>>>& outAsync, const StringStringDictList& iceP_inSeq, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opStringStringDictList";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<StringStringDictList, StringStringDictList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

std::deque< ::Test::E>
Test::TestIntfPrx::opESeq(const std::deque< ::Test::E>& iceP_inSeq, std::deque< ::Test::E>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque< ::Test::E>, std::deque< ::Test::E>>>(true, this, &TestIntfPrx::_iceI_opESeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::deque< ::Test::E>, std::deque< ::Test::E>>>
Test::TestIntfPrx::opESeqAsync(const std::deque< ::Test::E>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque< ::Test::E>, std::deque< ::Test::E>>>(false, this, &TestIntfPrx::_iceI_opESeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opESeqAsync(const std::deque< ::Test::E>& iceP_inSeq,
                               ::std::function<void (std::deque< ::Test::E>, std::deque< ::Test::E>)> response,
                               ::std::function<void(::std::exception_ptr)> ex,
                               ::std::function<void(bool)> sent,
                               const ::Ice::Context& context) const
{
    auto _responseCb = [_response = ::std::move(response)](::std::tuple<std::deque< ::Test::E>, std::deque< ::Test::E>>&& _result)
    {
        ::std::apply(::std::move(_response), ::std::move(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<std::deque< ::Test::E>, std::deque< ::Test::E>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opESeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opESeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque< ::Test::E>, std::deque< ::Test::E>>>>& outAsync, const std::deque< ::Test::E>& iceP_inSeq, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opESeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::deque< ::Test::E>, std::deque< ::Test::E>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::EList
Test::TestIntfPrx::opEList(const EList& iceP_inSeq, EList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<EList, EList>>(true, this, &TestIntfPrx::_iceI_opEList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::EList, ::Test::EList>>
Test::TestIntfPrx::opEListAsync(const EList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<EList, EList>>(false, this, &TestIntfPrx::_iceI_opEList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opEListAsync(const EList& iceP_inSeq,
                                ::std::function<void (::Test::EList, ::Test::EList)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [_response = ::std::move(response)](::std::tuple<EList, EList>&& _result)
    {
        ::std::apply(::std::move(_response), ::std::move(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<EList, EList>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opEList, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opEList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<EList, EList>>>& outAsync, const EList& iceP_inSeq, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opEList";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<EList, EList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

std::deque<::Test::DPrxPtr>
Test::TestIntfPrx::opDPrxSeq(const std::deque<::Test::DPrxPtr>& iceP_inSeq, std::deque<::Test::DPrxPtr>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<::Test::DPrxPtr>, std::deque<::Test::DPrxPtr>>>(true, this, &TestIntfPrx::_iceI_opDPrxSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::deque<::Test::DPrxPtr>, std::deque<::Test::DPrxPtr>>>
Test::TestIntfPrx::opDPrxSeqAsync(const std::deque<::Test::DPrxPtr>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<::Test::DPrxPtr>, std::deque<::Test::DPrxPtr>>>(false, this, &TestIntfPrx::_iceI_opDPrxSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opDPrxSeqAsync(const std::deque<::Test::DPrxPtr>& iceP_inSeq,
                                  ::std::function<void (std::deque<::Test::DPrxPtr>, std::deque<::Test::DPrxPtr>)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [_response = ::std::move(response)](::std::tuple<std::deque<::Test::DPrxPtr>, std::deque<::Test::DPrxPtr>>&& _result)
    {
        ::std::apply(::std::move(_response), ::std::move(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<std::deque<::Test::DPrxPtr>, std::deque<::Test::DPrxPtr>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opDPrxSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opDPrxSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque<::Test::DPrxPtr>, std::deque<::Test::DPrxPtr>>>>& outAsync, const std::deque<::Test::DPrxPtr>& iceP_inSeq, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opDPrxSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::deque<::Test::DPrxPtr>, std::deque<::Test::DPrxPtr>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::DPrxList
Test::TestIntfPrx::opDPrxList(const DPrxList& iceP_inSeq, DPrxList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<DPrxList, DPrxList>>(true, this, &TestIntfPrx::_iceI_opDPrxList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::DPrxList, ::Test::DPrxList>>
Test::TestIntfPrx::opDPrxListAsync(const DPrxList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<DPrxList, DPrxList>>(false, this, &TestIntfPrx::_iceI_opDPrxList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opDPrxListAsync(const DPrxList& iceP_inSeq,
                                   ::std::function<void (::Test::DPrxList, ::Test::DPrxList)> response,
                                   ::std::function<void(::std::exception_ptr)> ex,
                                   ::std::function<void(bool)> sent,
                                   const ::Ice::Context& context) const
{
    auto _responseCb = [_response = ::std::move(response)](::std::tuple<DPrxList, DPrxList>&& _result)
    {
        ::std::apply(::std::move(_response), ::std::move(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<DPrxList, DPrxList>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opDPrxList, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opDPrxList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<DPrxList, DPrxList>>>& outAsync, const DPrxList& iceP_inSeq, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opDPrxList";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<DPrxList, DPrxList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

std::deque<std::shared_ptr<Test::C>>
Test::TestIntfPrx::opCSeq(const std::deque<std::shared_ptr<Test::C>>& iceP_inSeq, std::deque<std::shared_ptr<Test::C>>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>>>(true, this, &TestIntfPrx::_iceI_opCSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>>>
Test::TestIntfPrx::opCSeqAsync(const std::deque<std::shared_ptr<Test::C>>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>>>(false, this, &TestIntfPrx::_iceI_opCSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opCSeqAsync(const std::deque<std::shared_ptr<Test::C>>& iceP_inSeq,
                               ::std::function<void (std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>)> response,
                               ::std::function<void(::std::exception_ptr)> ex,
                               ::std::function<void(bool)> sent,
                               const ::Ice::Context& context) const
{
    auto _responseCb = [_response = ::std::move(response)](::std::tuple<std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>>&& _result)
    {
        ::std::apply(::std::move(_response), ::std::move(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opCSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opCSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>>>>& outAsync, const std::deque<std::shared_ptr<Test::C>>& iceP_inSeq, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opCSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

::Test::CList
Test::TestIntfPrx::opCList(const CList& iceP_inSeq, CList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<CList, CList>>(true, this, &TestIntfPrx::_iceI_opCList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::CList, ::Test::CList>>
Test::TestIntfPrx::opCListAsync(const CList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<CList, CList>>(false, this, &TestIntfPrx::_iceI_opCList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opCListAsync(const CList& iceP_inSeq,
                                ::std::function<void (::Test::CList, ::Test::CList)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [_response = ::std::move(response)](::std::tuple<CList, CList>&& _result)
    {
        ::std::apply(::std::move(_response), ::std::move(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<CList, CList>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opCList, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opCList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<CList, CList>>>& outAsync, const CList& iceP_inSeq, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opCList";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<CList, CList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

void
Test::TestIntfPrx::opOutArrayByteSeq(const ByteSeq& iceP_org, ByteSeq& iceP_copy, const ::Ice::Context& context) const
{
    iceP_copy = ::IceInternal::makePromiseOutgoing<ByteSeq>(true, this, &TestIntfPrx::_iceI_opOutArrayByteSeq, iceP_org, context).get();
}

::std::future<::Test::ByteSeq>
Test::TestIntfPrx::opOutArrayByteSeqAsync(const ByteSeq& iceP_org, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<ByteSeq>(false, this, &TestIntfPrx::_iceI_opOutArrayByteSeq, iceP_org, context);
}

::std::function<void()>
Test::TestIntfPrx::opOutArrayByteSeqAsync(const ByteSeq& iceP_org,
                                          ::std::function<void (::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>)> response,
                                          ::std::function<void(::std::exception_ptr)> ex,
                                          ::std::function<void(bool)> sent,
                                          const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opOutArrayByteSeq";

    _checkTwowayOnly(operationName);
    ::std::function<void(::Ice::InputStream*)> read;
    if(response)
    {
        read = [response](::Ice::InputStream* istr)
        {
            istr->startEncapsulation();
            ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*> iceP_copy;
            istr->readAll(iceP_copy);
            istr->endEncapsulation();
            try
            {
                response(iceP_copy);
            }
            catch(...)
            {
                throw ::std::current_exception();
            }
        };
    }
    auto outAsync = ::std::make_shared<::IceInternal::CustomLambdaOutgoing>(*this, read, ex, sent);

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_org);
        },
        nullptr);
    return [outAsync]() { outAsync->cancel(); };
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOutArrayByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ByteSeq>>& outAsync, const ByteSeq& iceP_org, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opOutArrayByteSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_org);
        },
        nullptr);
}
/// \endcond

::Test::IntStringDict
Test::TestIntfPrx::opIntStringDict(const IntStringDict& iceP_idict, IntStringDict& iceP_odict, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<IntStringDict, IntStringDict>>(true, this, &TestIntfPrx::_iceI_opIntStringDict, iceP_idict, context).get();
    iceP_odict = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::IntStringDict, ::Test::IntStringDict>>
Test::TestIntfPrx::opIntStringDictAsync(const IntStringDict& iceP_idict, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<IntStringDict, IntStringDict>>(false, this, &TestIntfPrx::_iceI_opIntStringDict, iceP_idict, context);
}

::std::function<void()>
Test::TestIntfPrx::opIntStringDictAsync(const IntStringDict& iceP_idict,
                                        ::std::function<void (::Test::IntStringDict, ::Test::IntStringDict)> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context) const
{
    auto _responseCb = [_response = ::std::move(response)](::std::tuple<IntStringDict, IntStringDict>&& _result)
    {
        ::std::apply(::std::move(_response), ::std::move(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<IntStringDict, IntStringDict>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opIntStringDict, iceP_idict, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opIntStringDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<IntStringDict, IntStringDict>>>& outAsync, const IntStringDict& iceP_idict, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opIntStringDict";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_idict);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<IntStringDict, IntStringDict> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::CustomMap< int64_t, int64_t>
Test::TestIntfPrx::opVarDict(const ::Test::CustomMap<std::string, std::int32_t>& iceP_idict, ::Test::CustomMap<std::string, std::int32_t>& iceP_odict, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<::Test::CustomMap< int64_t, int64_t>, ::Test::CustomMap<std::string, std::int32_t>>>(true, this, &TestIntfPrx::_iceI_opVarDict, iceP_idict, context).get();
    iceP_odict = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::CustomMap< int64_t, int64_t>, ::Test::CustomMap<std::string, std::int32_t>>>
Test::TestIntfPrx::opVarDictAsync(const ::Test::CustomMap<std::string, std::int32_t>& iceP_idict, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::Test::CustomMap< int64_t, int64_t>, ::Test::CustomMap<std::string, std::int32_t>>>(false, this, &TestIntfPrx::_iceI_opVarDict, iceP_idict, context);
}

::std::function<void()>
Test::TestIntfPrx::opVarDictAsync(const ::Test::CustomMap<std::string, std::int32_t>& iceP_idict,
                                  ::std::function<void (::Test::CustomMap< int64_t, int64_t>, ::Test::CustomMap<std::string, std::int32_t>)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [_response = ::std::move(response)](::std::tuple<::Test::CustomMap< int64_t, int64_t>, ::Test::CustomMap<std::string, std::int32_t>>&& _result)
    {
        ::std::apply(::std::move(_response), ::std::move(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::Test::CustomMap< int64_t, int64_t>, ::Test::CustomMap<std::string, std::int32_t>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opVarDict, iceP_idict, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opVarDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::Test::CustomMap< int64_t, int64_t>, ::Test::CustomMap<std::string, std::int32_t>>>>& outAsync, const ::Test::CustomMap<std::string, std::int32_t>& iceP_idict, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opVarDict";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_idict);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::Test::CustomMap< int64_t, int64_t>, ::Test::CustomMap<std::string, std::int32_t>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::ShortBuffer
Test::TestIntfPrx::opShortBuffer(const ShortBuffer& iceP_inS, ShortBuffer& iceP_outS, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<ShortBuffer, ShortBuffer>>(true, this, &TestIntfPrx::_iceI_opShortBuffer, iceP_inS, context).get();
    iceP_outS = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::ShortBuffer, ::Test::ShortBuffer>>
Test::TestIntfPrx::opShortBufferAsync(const ShortBuffer& iceP_inS, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ShortBuffer, ShortBuffer>>(false, this, &TestIntfPrx::_iceI_opShortBuffer, iceP_inS, context);
}

::std::function<void()>
Test::TestIntfPrx::opShortBufferAsync(const ShortBuffer& iceP_inS,
                                      ::std::function<void (::Test::ShortBuffer, ::Test::ShortBuffer)> response,
                                      ::std::function<void(::std::exception_ptr)> ex,
                                      ::std::function<void(bool)> sent,
                                      const ::Ice::Context& context) const
{
    auto _responseCb = [_response = ::std::move(response)](::std::tuple<ShortBuffer, ShortBuffer>&& _result)
    {
        ::std::apply(::std::move(_response), ::std::move(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ShortBuffer, ShortBuffer>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opShortBuffer, iceP_inS, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opShortBuffer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ShortBuffer, ShortBuffer>>>& outAsync, const ShortBuffer& iceP_inS, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opShortBuffer";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inS);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ShortBuffer, ShortBuffer> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::CustomBuffer<bool>
Test::TestIntfPrx::opBoolBuffer(const ::Test::CustomBuffer<bool>& iceP_inS, ::Test::CustomBuffer<bool>& iceP_outS, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>>>(true, this, &TestIntfPrx::_iceI_opBoolBuffer, iceP_inS, context).get();
    iceP_outS = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>>>
Test::TestIntfPrx::opBoolBufferAsync(const ::Test::CustomBuffer<bool>& iceP_inS, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>>>(false, this, &TestIntfPrx::_iceI_opBoolBuffer, iceP_inS, context);
}

::std::function<void()>
Test::TestIntfPrx::opBoolBufferAsync(const ::Test::CustomBuffer<bool>& iceP_inS,
                                     ::std::function<void (::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>)> response,
                                     ::std::function<void(::std::exception_ptr)> ex,
                                     ::std::function<void(bool)> sent,
                                     const ::Ice::Context& context) const
{
    auto _responseCb = [_response = ::std::move(response)](::std::tuple<::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>>&& _result)
    {
        ::std::apply(::std::move(_response), ::std::move(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolBuffer, iceP_inS, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opBoolBuffer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>>>>& outAsync, const ::Test::CustomBuffer<bool>& iceP_inS, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opBoolBuffer";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inS);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::BufferStruct
Test::TestIntfPrx::opBufferStruct(const BufferStruct& iceP_s, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<BufferStruct>(true, this, &TestIntfPrx::_iceI_opBufferStruct, iceP_s, context).get();
}

::std::future<::Test::BufferStruct>
Test::TestIntfPrx::opBufferStructAsync(const BufferStruct& iceP_s, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<BufferStruct>(false, this, &TestIntfPrx::_iceI_opBufferStruct, iceP_s, context);
}

::std::function<void()>
Test::TestIntfPrx::opBufferStructAsync(const BufferStruct& iceP_s,
                                       ::std::function<void (::Test::BufferStruct)> response,
                                       ::std::function<void(::std::exception_ptr)> ex,
                                       ::std::function<void(bool)> sent,
                                       const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<BufferStruct>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBufferStruct, iceP_s, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opBufferStruct(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<BufferStruct>>& outAsync, const BufferStruct& iceP_s, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opBufferStruct";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_s);
        },
        nullptr);
}
/// \endcond

void
Test::TestIntfPrx::shutdown(const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_shutdown, context).get();
}

::std::future<void>
Test::TestIntfPrx::shutdownAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &TestIntfPrx::_iceI_shutdown, context);
}

::std::function<void()>
Test::TestIntfPrx::shutdownAsync(::std::function<void ()> response,
                                 ::std::function<void(::std::exception_ptr)> ex,
                                 ::std::function<void(bool)> sent,
                                 const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_shutdown, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "shutdown";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

::std::string_view
Test::TestIntfPrx::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::Test::TestIntf";
    return typeId;
}

Test::C::~C()
{
}

::std::string_view
Test::C::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::Test::C";
    return typeId;
}

Test::DictClass::~DictClass()
{
}

::std::string_view
Test::DictClass::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::Test::DictClass";
    return typeId;
}

::std::vector<::std::string>
Test::D::ice_ids(const ::Ice::Current&) const
{
    static const ::std::vector<::std::string> allTypeIds = { "::Ice::Object", "::Test::D" };
    return allTypeIds;
}

::std::string
Test::D::ice_id(const ::Ice::Current&) const
{
    return ::std::string{ice_staticId()};
}

::std::string_view
Test::D::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::Test::D";
    return typeId;
}

::std::vector<::std::string>
Test::TestIntf::ice_ids(const ::Ice::Current&) const
{
    static const ::std::vector<::std::string> allTypeIds = { "::Ice::Object", "::Test::TestIntf" };
    return allTypeIds;
}

::std::string
Test::TestIntf::ice_id(const ::Ice::Current&) const
{
    return ::std::string{ice_staticId()};
}

::std::string_view
Test::TestIntf::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::Test::TestIntf";
    return typeId;
}

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDoubleArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::pair<const double*, const double*> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const DoubleSeq& ret, const DoubleSeq& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opDoubleArrayAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::pair<const bool*, const bool*> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const BoolSeq& ret, const BoolSeq& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opBoolArrayAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>& ret, const ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opByteArrayAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVariableArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::pair<const Variable*, const Variable*> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const VariableList& ret, const VariableList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opVariableArrayAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque<bool> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const std::deque<bool>& ret, const std::deque<bool>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opBoolSeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    BoolList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const BoolList& ret, const BoolList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opBoolListAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque< ::Ice::Byte> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const std::deque< ::Ice::Byte>& ret, const std::deque< ::Ice::Byte>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opByteSeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ByteList& ret, const ByteList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opByteListAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opMyByteSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    MyByteSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const MyByteSeq& ret, const MyByteSeq& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opMyByteSeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque<std::string> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const std::deque<std::string>& ret, const std::deque<std::string>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opStringSeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const StringList& ret, const StringList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opStringListAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opFixedSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque< ::Test::Fixed> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const std::deque< ::Test::Fixed>& ret, const std::deque< ::Test::Fixed>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opFixedSeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opFixedList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    FixedList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const FixedList& ret, const FixedList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opFixedListAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVariableSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque< ::Test::Variable> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const std::deque< ::Test::Variable>& ret, const std::deque< ::Test::Variable>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opVariableSeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVariableList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    VariableList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const VariableList& ret, const VariableList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opVariableListAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringStringDictSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque< ::Test::StringStringDict> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const std::deque< ::Test::StringStringDict>& ret, const std::deque< ::Test::StringStringDict>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opStringStringDictSeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringStringDictList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringStringDictList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const StringStringDictList& ret, const StringStringDictList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opStringStringDictListAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opESeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque< ::Test::E> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const std::deque< ::Test::E>& ret, const std::deque< ::Test::E>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opESeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opEList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    EList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const EList& ret, const EList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opEListAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDPrxSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque<::Test::DPrxPtr> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const std::deque<::Test::DPrxPtr>& ret, const std::deque<::Test::DPrxPtr>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opDPrxSeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDPrxList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    DPrxList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const DPrxList& ret, const DPrxList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opDPrxListAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opCSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque<std::shared_ptr<Test::C>> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->readPendingValues();
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const std::deque<std::shared_ptr<Test::C>>& ret, const std::deque<std::shared_ptr<Test::C>>& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->opCSeqAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opCList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    CList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->readPendingValues();
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const CList& ret, const CList& iceP_outSeq)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outSeq, ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->opCListAsync(::std::move(iceP_inSeq), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOutArrayByteSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteSeq iceP_org;
    istr->readAll(iceP_org);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>& iceP_copy)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_copy);
        inA->endWriteParams();
        inA->completed();
    };
    this->opOutArrayByteSeqAsync(::std::move(iceP_org), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opIntStringDict(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    IntStringDict iceP_idict;
    istr->readAll(iceP_idict);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const IntStringDict& ret, const IntStringDict& iceP_odict)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_odict, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opIntStringDictAsync(::std::move(iceP_idict), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVarDict(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::Test::CustomMap<std::string, std::int32_t> iceP_idict;
    istr->readAll(iceP_idict);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::Test::CustomMap< int64_t, int64_t>& ret, const ::Test::CustomMap<std::string, std::int32_t>& iceP_odict)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_odict, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opVarDictAsync(::std::move(iceP_idict), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opShortBuffer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ShortBuffer iceP_inS;
    istr->readAll(iceP_inS);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ShortBuffer& ret, const ShortBuffer& iceP_outS)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outS, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opShortBufferAsync(::std::move(iceP_inS), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolBuffer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::Test::CustomBuffer<bool> iceP_inS;
    istr->readAll(iceP_inS);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::Test::CustomBuffer<bool>& ret, const ::Test::CustomBuffer<bool>& iceP_outS)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_outS, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opBoolBufferAsync(::std::move(iceP_inS), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBufferStruct(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    BufferStruct iceP_s;
    istr->readAll(iceP_s);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const BufferStruct& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opBufferStructAsync(::std::move(iceP_s), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_shutdown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->shutdownAsync(inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    static constexpr ::std::string_view allOperations[] = { "ice_id", "ice_ids", "ice_isA", "ice_ping", "opBoolArray", "opBoolBuffer", "opBoolList", "opBoolSeq", "opBufferStruct", "opByteArray", "opByteList", "opByteSeq", "opCList", "opCSeq", "opDPrxList", "opDPrxSeq", "opDoubleArray", "opEList", "opESeq", "opFixedList", "opFixedSeq", "opIntStringDict", "opMyByteSeq", "opOutArrayByteSeq", "opShortBuffer", "opStringList", "opStringSeq", "opStringStringDictList", "opStringStringDictSeq", "opVarDict", "opVariableArray", "opVariableList", "opVariableSeq", "shutdown" };

    ::std::pair<const ::std::string_view*, const ::std::string_view*> r = ::std::equal_range(allOperations, allOperations + 34, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - allOperations)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_opBoolArray(in, current);
        }
        case 5:
        {
            return _iceD_opBoolBuffer(in, current);
        }
        case 6:
        {
            return _iceD_opBoolList(in, current);
        }
        case 7:
        {
            return _iceD_opBoolSeq(in, current);
        }
        case 8:
        {
            return _iceD_opBufferStruct(in, current);
        }
        case 9:
        {
            return _iceD_opByteArray(in, current);
        }
        case 10:
        {
            return _iceD_opByteList(in, current);
        }
        case 11:
        {
            return _iceD_opByteSeq(in, current);
        }
        case 12:
        {
            return _iceD_opCList(in, current);
        }
        case 13:
        {
            return _iceD_opCSeq(in, current);
        }
        case 14:
        {
            return _iceD_opDPrxList(in, current);
        }
        case 15:
        {
            return _iceD_opDPrxSeq(in, current);
        }
        case 16:
        {
            return _iceD_opDoubleArray(in, current);
        }
        case 17:
        {
            return _iceD_opEList(in, current);
        }
        case 18:
        {
            return _iceD_opESeq(in, current);
        }
        case 19:
        {
            return _iceD_opFixedList(in, current);
        }
        case 20:
        {
            return _iceD_opFixedSeq(in, current);
        }
        case 21:
        {
            return _iceD_opIntStringDict(in, current);
        }
        case 22:
        {
            return _iceD_opMyByteSeq(in, current);
        }
        case 23:
        {
            return _iceD_opOutArrayByteSeq(in, current);
        }
        case 24:
        {
            return _iceD_opShortBuffer(in, current);
        }
        case 25:
        {
            return _iceD_opStringList(in, current);
        }
        case 26:
        {
            return _iceD_opStringSeq(in, current);
        }
        case 27:
        {
            return _iceD_opStringStringDictList(in, current);
        }
        case 28:
        {
            return _iceD_opStringStringDictSeq(in, current);
        }
        case 29:
        {
            return _iceD_opVarDict(in, current);
        }
        case 30:
        {
            return _iceD_opVariableArray(in, current);
        }
        case 31:
        {
            return _iceD_opVariableList(in, current);
        }
        case 32:
        {
            return _iceD_opVariableSeq(in, current);
        }
        case 33:
        {
            return _iceD_shutdown(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond
