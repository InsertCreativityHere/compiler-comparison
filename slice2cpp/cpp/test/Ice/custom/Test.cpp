//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.9
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <Test.h>
#include <IceUtil/PushDisableWarnings.h>
#include <Ice/LocalException.h>
#include <Ice/ValueFactory.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/InputStream.h>
#include <Ice/OutputStream.h>
#include <IceUtil/PopDisableWarnings.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 9
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace
{

const ::IceInternal::DefaultValueFactoryInit<::Test::C> iceC_Test_C_init("::Test::C");

const ::std::string iceC_Test_D_ids[2] =
{
    "::Ice::Object",
    "::Test::D"
};
const ::std::string iceC_Test_D_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

const ::IceInternal::DefaultValueFactoryInit<::Test::DictClass> iceC_Test_DictClass_init("::Test::DictClass");

const ::std::string iceC_Test_TestIntf_ids[2] =
{
    "::Ice::Object",
    "::Test::TestIntf"
};
const ::std::string iceC_Test_TestIntf_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "opBoolArray",
    "opBoolBuffer",
    "opBoolDequeList",
    "opBoolDequeListArray",
    "opBoolDequeListRange",
    "opBoolList",
    "opBoolRange",
    "opBoolSeq",
    "opBufferStruct",
    "opByteArray",
    "opByteList",
    "opByteRange",
    "opByteRangeType",
    "opByteSeq",
    "opCList",
    "opCSeq",
    "opClassStruct",
    "opCustomIntStringDict",
    "opDPrxList",
    "opDPrxSeq",
    "opDoubleArray",
    "opEList",
    "opESeq",
    "opFixedList",
    "opFixedSeq",
    "opIntStringDict",
    "opMyByteSeq",
    "opOutArrayByteSeq",
    "opOutRangeByteSeq",
    "opShortBuffer",
    "opString",
    "opStringList",
    "opStringSeq",
    "opStringStringDictList",
    "opStringStringDictSeq",
    "opVarDict",
    "opVariableArray",
    "opVariableList",
    "opVariableRange",
    "opVariableRangeType",
    "opVariableSeq",
    "shutdown"
};
const ::std::string iceC_Test_TestIntf_opDoubleArray_name = "opDoubleArray";
const ::std::string iceC_Test_TestIntf_opBoolArray_name = "opBoolArray";
const ::std::string iceC_Test_TestIntf_opByteArray_name = "opByteArray";
const ::std::string iceC_Test_TestIntf_opVariableArray_name = "opVariableArray";
const ::std::string iceC_Test_TestIntf_opBoolRange_name = "opBoolRange";
const ::std::string iceC_Test_TestIntf_opByteRange_name = "opByteRange";
const ::std::string iceC_Test_TestIntf_opVariableRange_name = "opVariableRange";
const ::std::string iceC_Test_TestIntf_opByteRangeType_name = "opByteRangeType";
const ::std::string iceC_Test_TestIntf_opVariableRangeType_name = "opVariableRangeType";
const ::std::string iceC_Test_TestIntf_opBoolSeq_name = "opBoolSeq";
const ::std::string iceC_Test_TestIntf_opBoolList_name = "opBoolList";
const ::std::string iceC_Test_TestIntf_opBoolDequeList_name = "opBoolDequeList";
const ::std::string iceC_Test_TestIntf_opBoolDequeListArray_name = "opBoolDequeListArray";
const ::std::string iceC_Test_TestIntf_opBoolDequeListRange_name = "opBoolDequeListRange";
const ::std::string iceC_Test_TestIntf_opByteSeq_name = "opByteSeq";
const ::std::string iceC_Test_TestIntf_opByteList_name = "opByteList";
const ::std::string iceC_Test_TestIntf_opMyByteSeq_name = "opMyByteSeq";
const ::std::string iceC_Test_TestIntf_opString_name = "opString";
const ::std::string iceC_Test_TestIntf_opStringSeq_name = "opStringSeq";
const ::std::string iceC_Test_TestIntf_opStringList_name = "opStringList";
const ::std::string iceC_Test_TestIntf_opFixedSeq_name = "opFixedSeq";
const ::std::string iceC_Test_TestIntf_opFixedList_name = "opFixedList";
const ::std::string iceC_Test_TestIntf_opVariableSeq_name = "opVariableSeq";
const ::std::string iceC_Test_TestIntf_opVariableList_name = "opVariableList";
const ::std::string iceC_Test_TestIntf_opStringStringDictSeq_name = "opStringStringDictSeq";
const ::std::string iceC_Test_TestIntf_opStringStringDictList_name = "opStringStringDictList";
const ::std::string iceC_Test_TestIntf_opESeq_name = "opESeq";
const ::std::string iceC_Test_TestIntf_opEList_name = "opEList";
const ::std::string iceC_Test_TestIntf_opDPrxSeq_name = "opDPrxSeq";
const ::std::string iceC_Test_TestIntf_opDPrxList_name = "opDPrxList";
const ::std::string iceC_Test_TestIntf_opCSeq_name = "opCSeq";
const ::std::string iceC_Test_TestIntf_opCList_name = "opCList";
const ::std::string iceC_Test_TestIntf_opClassStruct_name = "opClassStruct";
const ::std::string iceC_Test_TestIntf_opOutArrayByteSeq_name = "opOutArrayByteSeq";
const ::std::string iceC_Test_TestIntf_opOutRangeByteSeq_name = "opOutRangeByteSeq";
const ::std::string iceC_Test_TestIntf_opIntStringDict_name = "opIntStringDict";
const ::std::string iceC_Test_TestIntf_opVarDict_name = "opVarDict";
const ::std::string iceC_Test_TestIntf_opCustomIntStringDict_name = "opCustomIntStringDict";
const ::std::string iceC_Test_TestIntf_opShortBuffer_name = "opShortBuffer";
const ::std::string iceC_Test_TestIntf_opBoolBuffer_name = "opBoolBuffer";
const ::std::string iceC_Test_TestIntf_opBufferStruct_name = "opBufferStruct";
const ::std::string iceC_Test_TestIntf_shutdown_name = "shutdown";

}

bool
Test::D::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_D_ids, iceC_Test_D_ids + 2, s);
}

::std::vector<::std::string>
Test::D::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_D_ids[0], &iceC_Test_D_ids[2]);
}

::std::string
Test::D::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::D::ice_staticId()
{
    static const ::std::string typeId = "::Test::D";
    return typeId;
}

bool
Test::TestIntf::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_TestIntf_ids, iceC_Test_TestIntf_ids + 2, s);
}

::std::vector<::std::string>
Test::TestIntf::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_TestIntf_ids[0], &iceC_Test_TestIntf_ids[2]);
}

::std::string
Test::TestIntf::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::TestIntf::ice_staticId()
{
    static const ::std::string typeId = "::Test::TestIntf";
    return typeId;
}

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDoubleArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::pair<const double*, const double*> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    DoubleSeq iceP_outSeq;
    DoubleSeq ret = this->opDoubleArray(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::pair<const bool*, const bool*> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    BoolSeq iceP_outSeq;
    BoolSeq ret = this->opBoolArray(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    ByteList iceP_outSeq;
    ByteList ret = this->opByteArray(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVariableArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::pair<const Variable*, const Variable*> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    VariableList iceP_outSeq;
    VariableList ret = this->opVariableArray(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    BoolSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    BoolSeq iceP_outSeq;
    BoolSeq ret = this->opBoolRange(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    ByteList iceP_outSeq;
    ByteList ret = this->opByteRange(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVariableRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    VariableList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    VariableList iceP_outSeq;
    VariableList ret = this->opVariableRange(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteRangeType(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    ByteList iceP_outSeq;
    ByteList ret = this->opByteRangeType(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVariableRangeType(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    VariableList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    VariableList iceP_outSeq;
    VariableList ret = this->opVariableRangeType(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque<bool> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    std::deque<bool> iceP_outSeq;
    std::deque<bool> ret = this->opBoolSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    BoolList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    BoolList iceP_outSeq;
    BoolList ret = this->opBoolList(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolDequeList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    BoolDequeList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    BoolDequeList iceP_outSeq;
    BoolDequeList ret = this->opBoolDequeList(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolDequeListArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::pair<const std::deque<bool>*, const std::deque<bool>*> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    BoolDequeList iceP_outSeq;
    BoolDequeList ret = this->opBoolDequeListArray(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolDequeListRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    BoolDequeList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    BoolDequeList iceP_outSeq;
    BoolDequeList ret = this->opBoolDequeListRange(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque< ::Ice::Byte> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    std::deque< ::Ice::Byte> iceP_outSeq;
    std::deque< ::Ice::Byte> ret = this->opByteSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    ByteList iceP_outSeq;
    ByteList ret = this->opByteList(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opMyByteSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    MyByteSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    MyByteSeq iceP_outSeq;
    MyByteSeq ret = this->opMyByteSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opString(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    Util::string_view iceP_inString;
    istr->readAll(iceP_inString);
    inS.endReadParams();
    ::std::string iceP_outString;
    ::std::string ret = this->opString(::std::move(iceP_inString), iceP_outString, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outString, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque<std::string> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    std::deque<std::string> iceP_outSeq;
    std::deque<std::string> ret = this->opStringSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    StringList iceP_outSeq;
    StringList ret = this->opStringList(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opFixedSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque< ::Test::Fixed> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    std::deque< ::Test::Fixed> iceP_outSeq;
    std::deque< ::Test::Fixed> ret = this->opFixedSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opFixedList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    FixedList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    FixedList iceP_outSeq;
    FixedList ret = this->opFixedList(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVariableSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque< ::Test::Variable> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    std::deque< ::Test::Variable> iceP_outSeq;
    std::deque< ::Test::Variable> ret = this->opVariableSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVariableList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    VariableList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    VariableList iceP_outSeq;
    VariableList ret = this->opVariableList(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringStringDictSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque< ::Test::StringStringDict> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    std::deque< ::Test::StringStringDict> iceP_outSeq;
    std::deque< ::Test::StringStringDict> ret = this->opStringStringDictSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringStringDictList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringStringDictList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    StringStringDictList iceP_outSeq;
    StringStringDictList ret = this->opStringStringDictList(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opESeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque< ::Test::E> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    std::deque< ::Test::E> iceP_outSeq;
    std::deque< ::Test::E> ret = this->opESeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opEList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    EList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    EList iceP_outSeq;
    EList ret = this->opEList(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDPrxSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque<std::shared_ptr<::Test::DPrx>> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    std::deque<std::shared_ptr<::Test::DPrx>> iceP_outSeq;
    std::deque<std::shared_ptr<::Test::DPrx>> ret = this->opDPrxSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDPrxList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    DPrxList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    DPrxList iceP_outSeq;
    DPrxList ret = this->opDPrxList(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opCSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::deque<std::shared_ptr<Test::C>> iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->readPendingValues();
    inS.endReadParams();
    std::deque<std::shared_ptr<Test::C>> iceP_outSeq;
    std::deque<std::shared_ptr<Test::C>> ret = this->opCSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opCList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    CList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->readPendingValues();
    inS.endReadParams();
    CList iceP_outSeq;
    CList ret = this->opCList(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opClassStruct(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ClassStruct iceP_inS;
    ClassStructSeq iceP_inSeq;
    istr->readAll(iceP_inS, iceP_inSeq);
    inS.endReadParams();
    ClassStruct iceP_outS;
    ClassStructSeq iceP_outSeq;
    ClassStruct ret = this->opClassStruct(::std::move(iceP_inS), ::std::move(iceP_inSeq), iceP_outS, iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outS, iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOutArrayByteSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteSeq iceP_org;
    istr->readAll(iceP_org);
    inS.endReadParams();
    ByteSeq iceP_copy;
    this->opOutArrayByteSeq(::std::move(iceP_org), iceP_copy, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_copy);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOutRangeByteSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteSeq iceP_org;
    istr->readAll(iceP_org);
    inS.endReadParams();
    ByteSeq iceP_copy;
    this->opOutRangeByteSeq(::std::move(iceP_org), iceP_copy, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_copy);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opIntStringDict(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    IntStringDict iceP_idict;
    istr->readAll(iceP_idict);
    inS.endReadParams();
    IntStringDict iceP_odict;
    IntStringDict ret = this->opIntStringDict(::std::move(iceP_idict), iceP_odict, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_odict, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVarDict(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::Test::CustomMap<std::string, ::Ice::Int> iceP_idict;
    istr->readAll(iceP_idict);
    inS.endReadParams();
    ::Test::CustomMap<std::string, ::Ice::Int> iceP_odict;
    ::Test::CustomMap< ::Ice::Long, ::Ice::Long> ret = this->opVarDict(::std::move(iceP_idict), iceP_odict, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_odict, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opCustomIntStringDict(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::map< ::Ice::Int, ::Util::string_view> iceP_idict;
    istr->readAll(iceP_idict);
    inS.endReadParams();
    ::Test::CustomMap< ::Ice::Int, std::string> iceP_odict;
    ::Test::CustomMap< ::Ice::Int, std::string> ret = this->opCustomIntStringDict(::std::move(iceP_idict), iceP_odict, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_odict, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opShortBuffer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ShortBuffer iceP_inS;
    istr->readAll(iceP_inS);
    inS.endReadParams();
    ShortBuffer iceP_outS;
    ShortBuffer ret = this->opShortBuffer(::std::move(iceP_inS), iceP_outS, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outS, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolBuffer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::Test::CustomBuffer<bool> iceP_inS;
    istr->readAll(iceP_inS);
    inS.endReadParams();
    ::Test::CustomBuffer<bool> iceP_outS;
    ::Test::CustomBuffer<bool> ret = this->opBoolBuffer(::std::move(iceP_inS), iceP_outS, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outS, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBufferStruct(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    BufferStruct iceP_s;
    istr->readAll(iceP_s);
    inS.endReadParams();
    BufferStruct ret = this->opBufferStruct(::std::move(iceP_s), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_shutdown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->shutdown(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_TestIntf_ops, iceC_Test_TestIntf_ops + 46, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_TestIntf_ops)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_opBoolArray(in, current);
        }
        case 5:
        {
            return _iceD_opBoolBuffer(in, current);
        }
        case 6:
        {
            return _iceD_opBoolDequeList(in, current);
        }
        case 7:
        {
            return _iceD_opBoolDequeListArray(in, current);
        }
        case 8:
        {
            return _iceD_opBoolDequeListRange(in, current);
        }
        case 9:
        {
            return _iceD_opBoolList(in, current);
        }
        case 10:
        {
            return _iceD_opBoolRange(in, current);
        }
        case 11:
        {
            return _iceD_opBoolSeq(in, current);
        }
        case 12:
        {
            return _iceD_opBufferStruct(in, current);
        }
        case 13:
        {
            return _iceD_opByteArray(in, current);
        }
        case 14:
        {
            return _iceD_opByteList(in, current);
        }
        case 15:
        {
            return _iceD_opByteRange(in, current);
        }
        case 16:
        {
            return _iceD_opByteRangeType(in, current);
        }
        case 17:
        {
            return _iceD_opByteSeq(in, current);
        }
        case 18:
        {
            return _iceD_opCList(in, current);
        }
        case 19:
        {
            return _iceD_opCSeq(in, current);
        }
        case 20:
        {
            return _iceD_opClassStruct(in, current);
        }
        case 21:
        {
            return _iceD_opCustomIntStringDict(in, current);
        }
        case 22:
        {
            return _iceD_opDPrxList(in, current);
        }
        case 23:
        {
            return _iceD_opDPrxSeq(in, current);
        }
        case 24:
        {
            return _iceD_opDoubleArray(in, current);
        }
        case 25:
        {
            return _iceD_opEList(in, current);
        }
        case 26:
        {
            return _iceD_opESeq(in, current);
        }
        case 27:
        {
            return _iceD_opFixedList(in, current);
        }
        case 28:
        {
            return _iceD_opFixedSeq(in, current);
        }
        case 29:
        {
            return _iceD_opIntStringDict(in, current);
        }
        case 30:
        {
            return _iceD_opMyByteSeq(in, current);
        }
        case 31:
        {
            return _iceD_opOutArrayByteSeq(in, current);
        }
        case 32:
        {
            return _iceD_opOutRangeByteSeq(in, current);
        }
        case 33:
        {
            return _iceD_opShortBuffer(in, current);
        }
        case 34:
        {
            return _iceD_opString(in, current);
        }
        case 35:
        {
            return _iceD_opStringList(in, current);
        }
        case 36:
        {
            return _iceD_opStringSeq(in, current);
        }
        case 37:
        {
            return _iceD_opStringStringDictList(in, current);
        }
        case 38:
        {
            return _iceD_opStringStringDictSeq(in, current);
        }
        case 39:
        {
            return _iceD_opVarDict(in, current);
        }
        case 40:
        {
            return _iceD_opVariableArray(in, current);
        }
        case 41:
        {
            return _iceD_opVariableList(in, current);
        }
        case 42:
        {
            return _iceD_opVariableRange(in, current);
        }
        case 43:
        {
            return _iceD_opVariableRangeType(in, current);
        }
        case 44:
        {
            return _iceD_opVariableSeq(in, current);
        }
        case 45:
        {
            return _iceD_shutdown(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

Test::C::~C()
{
}

const ::std::string&
Test::C::ice_staticId()
{
    static const ::std::string typeId = "::Test::C";
    return typeId;
}

Test::DictClass::~DictClass()
{
}

const ::std::string&
Test::DictClass::ice_staticId()
{
    static const ::std::string typeId = "::Test::DictClass";
    return typeId;
}

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::DPrx::_newInstance() const
{
    return ::IceInternal::createProxy<DPrx>();
}
/// \endcond

const ::std::string&
Test::DPrx::ice_staticId()
{
    return D::ice_staticId();
}

::std::function<void()>
Test::TestIntfPrx::opDoubleArrayAsync(const ::std::pair<const double*, const double*>& iceP_inSeq,
                                      ::std::function<void (::std::pair<const double*, const double*>, ::std::pair<const double*, const double*>)> response,
                                      ::std::function<void(::std::exception_ptr)> ex,
                                      ::std::function<void(bool)> sent,
                                      const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opDoubleArray_name);
    ::std::function<void(::Ice::InputStream*)> read;
    if(response)
    {
        read = [response](::Ice::InputStream* istr)
        {
            istr->startEncapsulation();
            ::std::pair<const double*, const double*> iceP_outSeq;
            ::std::pair<const double*, const double*> ret;
            istr->readAll(iceP_outSeq, ret);
            istr->endEncapsulation();
            try
            {
                response(ret, iceP_outSeq);
            }
            catch(...)
            {
                throw ::std::current_exception();
            }
        };
    }
    auto outAsync = ::std::make_shared<::IceInternal::CustomLambdaOutgoing>(shared_from_this(), read, ex, sent);

    outAsync->invoke(iceC_Test_TestIntf_opDoubleArray_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr);
    return [outAsync]() { outAsync->cancel(); };
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opDoubleArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpDoubleArrayResult>>& outAsync, const ::std::pair<const double*, const double*>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opDoubleArray_name);
    outAsync->invoke(iceC_Test_TestIntf_opDoubleArray_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpDoubleArrayResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

::std::function<void()>
Test::TestIntfPrx::opBoolArrayAsync(const ::std::pair<const bool*, const bool*>& iceP_inSeq,
                                    ::std::function<void (::std::pair<const bool*, const bool*>, ::std::pair<const bool*, const bool*>)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolArray_name);
    ::std::function<void(::Ice::InputStream*)> read;
    if(response)
    {
        read = [response](::Ice::InputStream* istr)
        {
            istr->startEncapsulation();
            ::std::pair<const bool*, const bool*> iceP_outSeq;
            ::std::pair<const bool*, const bool*> ret;
            istr->readAll(iceP_outSeq, ret);
            istr->endEncapsulation();
            try
            {
                response(ret, iceP_outSeq);
            }
            catch(...)
            {
                throw ::std::current_exception();
            }
        };
    }
    auto outAsync = ::std::make_shared<::IceInternal::CustomLambdaOutgoing>(shared_from_this(), read, ex, sent);

    outAsync->invoke(iceC_Test_TestIntf_opBoolArray_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr);
    return [outAsync]() { outAsync->cancel(); };
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opBoolArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolArrayResult>>& outAsync, const ::std::pair<const bool*, const bool*>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolArray_name);
    outAsync->invoke(iceC_Test_TestIntf_opBoolArray_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpBoolArrayResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

::std::function<void()>
Test::TestIntfPrx::opByteArrayAsync(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& iceP_inSeq,
                                    ::std::function<void (::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>, ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteArray_name);
    ::std::function<void(::Ice::InputStream*)> read;
    if(response)
    {
        read = [response](::Ice::InputStream* istr)
        {
            istr->startEncapsulation();
            ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> iceP_outSeq;
            ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> ret;
            istr->readAll(iceP_outSeq, ret);
            istr->endEncapsulation();
            try
            {
                response(ret, iceP_outSeq);
            }
            catch(...)
            {
                throw ::std::current_exception();
            }
        };
    }
    auto outAsync = ::std::make_shared<::IceInternal::CustomLambdaOutgoing>(shared_from_this(), read, ex, sent);

    outAsync->invoke(iceC_Test_TestIntf_opByteArray_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr);
    return [outAsync]() { outAsync->cancel(); };
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opByteArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteArrayResult>>& outAsync, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteArray_name);
    outAsync->invoke(iceC_Test_TestIntf_opByteArray_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpByteArrayResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

::std::function<void()>
Test::TestIntfPrx::opVariableArrayAsync(const ::std::pair<const Variable*, const Variable*>& iceP_inSeq,
                                        ::std::function<void (::std::pair<const ::Test::Variable*, const ::Test::Variable*>, ::std::pair<const ::Test::Variable*, const ::Test::Variable*>)> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opVariableArray_name);
    ::std::function<void(::Ice::InputStream*)> read;
    if(response)
    {
        read = [response](::Ice::InputStream* istr)
        {
            istr->startEncapsulation();
            ::std::pair<const Variable*, const Variable*> iceP_outSeq;
            ::std::pair<const Variable*, const Variable*> ret;
            istr->readAll(iceP_outSeq, ret);
            istr->endEncapsulation();
            try
            {
                response(ret, iceP_outSeq);
            }
            catch(...)
            {
                throw ::std::current_exception();
            }
        };
    }
    auto outAsync = ::std::make_shared<::IceInternal::CustomLambdaOutgoing>(shared_from_this(), read, ex, sent);

    outAsync->invoke(iceC_Test_TestIntf_opVariableArray_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr);
    return [outAsync]() { outAsync->cancel(); };
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opVariableArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpVariableArrayResult>>& outAsync, const ::std::pair<const Variable*, const Variable*>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opVariableArray_name);
    outAsync->invoke(iceC_Test_TestIntf_opVariableArray_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpVariableArrayResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opBoolRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolRangeResult>>& outAsync, const BoolSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolRange_name);
    outAsync->invoke(iceC_Test_TestIntf_opBoolRange_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpBoolRangeResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opByteRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteRangeResult>>& outAsync, const ByteList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteRange_name);
    outAsync->invoke(iceC_Test_TestIntf_opByteRange_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpByteRangeResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opVariableRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpVariableRangeResult>>& outAsync, const VariableList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opVariableRange_name);
    outAsync->invoke(iceC_Test_TestIntf_opVariableRange_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpVariableRangeResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opByteRangeType(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteRangeTypeResult>>& outAsync, const ByteList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteRangeType_name);
    outAsync->invoke(iceC_Test_TestIntf_opByteRangeType_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpByteRangeTypeResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opVariableRangeType(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpVariableRangeTypeResult>>& outAsync, const VariableList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opVariableRangeType_name);
    outAsync->invoke(iceC_Test_TestIntf_opVariableRangeType_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpVariableRangeTypeResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opBoolSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolSeqResult>>& outAsync, const std::deque<bool>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opBoolSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpBoolSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opBoolList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolListResult>>& outAsync, const BoolList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolList_name);
    outAsync->invoke(iceC_Test_TestIntf_opBoolList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpBoolListResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opBoolDequeList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolDequeListResult>>& outAsync, const BoolDequeList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolDequeList_name);
    outAsync->invoke(iceC_Test_TestIntf_opBoolDequeList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpBoolDequeListResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

::std::function<void()>
Test::TestIntfPrx::opBoolDequeListArrayAsync(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& iceP_inSeq,
                                             ::std::function<void (::std::pair<const std::deque<bool>*, const std::deque<bool>*>, ::std::pair<const std::deque<bool>*, const std::deque<bool>*>)> response,
                                             ::std::function<void(::std::exception_ptr)> ex,
                                             ::std::function<void(bool)> sent,
                                             const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolDequeListArray_name);
    ::std::function<void(::Ice::InputStream*)> read;
    if(response)
    {
        read = [response](::Ice::InputStream* istr)
        {
            istr->startEncapsulation();
            ::std::pair<const std::deque<bool>*, const std::deque<bool>*> iceP_outSeq;
            ::std::pair<const std::deque<bool>*, const std::deque<bool>*> ret;
            istr->readAll(iceP_outSeq, ret);
            istr->endEncapsulation();
            try
            {
                response(ret, iceP_outSeq);
            }
            catch(...)
            {
                throw ::std::current_exception();
            }
        };
    }
    auto outAsync = ::std::make_shared<::IceInternal::CustomLambdaOutgoing>(shared_from_this(), read, ex, sent);

    outAsync->invoke(iceC_Test_TestIntf_opBoolDequeListArray_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr);
    return [outAsync]() { outAsync->cancel(); };
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opBoolDequeListArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolDequeListArrayResult>>& outAsync, const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolDequeListArray_name);
    outAsync->invoke(iceC_Test_TestIntf_opBoolDequeListArray_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpBoolDequeListArrayResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opBoolDequeListRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolDequeListRangeResult>>& outAsync, const BoolDequeList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolDequeListRange_name);
    outAsync->invoke(iceC_Test_TestIntf_opBoolDequeListRange_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpBoolDequeListRangeResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteSeqResult>>& outAsync, const std::deque< ::Ice::Byte>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opByteSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpByteSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opByteList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteListResult>>& outAsync, const ByteList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteList_name);
    outAsync->invoke(iceC_Test_TestIntf_opByteList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpByteListResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opMyByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpMyByteSeqResult>>& outAsync, const MyByteSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opMyByteSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opMyByteSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpMyByteSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

::std::function<void()>
Test::TestIntfPrx::opStringAsync(const Util::string_view& iceP_inString,
                                 ::std::function<void (Util::string_view, Util::string_view)> response,
                                 ::std::function<void(::std::exception_ptr)> ex,
                                 ::std::function<void(bool)> sent,
                                 const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opString_name);
    ::std::function<void(::Ice::InputStream*)> read;
    if(response)
    {
        read = [response](::Ice::InputStream* istr)
        {
            istr->startEncapsulation();
            Util::string_view iceP_outString;
            Util::string_view ret;
            istr->readAll(iceP_outString, ret);
            istr->endEncapsulation();
            try
            {
                response(ret, iceP_outString);
            }
            catch(...)
            {
                throw ::std::current_exception();
            }
        };
    }
    auto outAsync = ::std::make_shared<::IceInternal::CustomLambdaOutgoing>(shared_from_this(), read, ex, sent);

    outAsync->invoke(iceC_Test_TestIntf_opString_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inString);
        },
        nullptr);
    return [outAsync]() { outAsync->cancel(); };
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opString(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringResult>>& outAsync, const Util::string_view& iceP_inString, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opString_name);
    outAsync->invoke(iceC_Test_TestIntf_opString_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inString);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpStringResult v;
            istr->readAll(v.outString, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opStringSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringSeqResult>>& outAsync, const std::deque<std::string>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opStringSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opStringSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpStringSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opStringList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringListResult>>& outAsync, const StringList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opStringList_name);
    outAsync->invoke(iceC_Test_TestIntf_opStringList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpStringListResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opFixedSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpFixedSeqResult>>& outAsync, const std::deque< ::Test::Fixed>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opFixedSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opFixedSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpFixedSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opFixedList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpFixedListResult>>& outAsync, const FixedList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opFixedList_name);
    outAsync->invoke(iceC_Test_TestIntf_opFixedList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpFixedListResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opVariableSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpVariableSeqResult>>& outAsync, const std::deque< ::Test::Variable>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opVariableSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opVariableSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpVariableSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opVariableList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpVariableListResult>>& outAsync, const VariableList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opVariableList_name);
    outAsync->invoke(iceC_Test_TestIntf_opVariableList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpVariableListResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opStringStringDictSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringStringDictSeqResult>>& outAsync, const std::deque< ::Test::StringStringDict>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opStringStringDictSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opStringStringDictSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpStringStringDictSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opStringStringDictList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringStringDictListResult>>& outAsync, const StringStringDictList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opStringStringDictList_name);
    outAsync->invoke(iceC_Test_TestIntf_opStringStringDictList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpStringStringDictListResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opESeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpESeqResult>>& outAsync, const std::deque< ::Test::E>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opESeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opESeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpESeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opEList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpEListResult>>& outAsync, const EList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opEList_name);
    outAsync->invoke(iceC_Test_TestIntf_opEList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpEListResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opDPrxSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpDPrxSeqResult>>& outAsync, const std::deque<std::shared_ptr<::Test::DPrx>>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opDPrxSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opDPrxSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpDPrxSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opDPrxList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpDPrxListResult>>& outAsync, const DPrxList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opDPrxList_name);
    outAsync->invoke(iceC_Test_TestIntf_opDPrxList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpDPrxListResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opCSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpCSeqResult>>& outAsync, const std::deque<std::shared_ptr<Test::C>>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opCSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opCSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpCSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opCList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpCListResult>>& outAsync, const CList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opCList_name);
    outAsync->invoke(iceC_Test_TestIntf_opCList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpCListResult v;
            istr->readAll(v.outSeq, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opClassStruct(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpClassStructResult>>& outAsync, const ClassStruct& iceP_inS, const ClassStructSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opClassStruct_name);
    outAsync->invoke(iceC_Test_TestIntf_opClassStruct_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inS, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpClassStructResult v;
            istr->readAll(v.outS, v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

::std::function<void()>
Test::TestIntfPrx::opOutArrayByteSeqAsync(const ByteSeq& iceP_org,
                                          ::std::function<void (::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>)> response,
                                          ::std::function<void(::std::exception_ptr)> ex,
                                          ::std::function<void(bool)> sent,
                                          const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOutArrayByteSeq_name);
    ::std::function<void(::Ice::InputStream*)> read;
    if(response)
    {
        read = [response](::Ice::InputStream* istr)
        {
            istr->startEncapsulation();
            ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> iceP_copy;
            istr->readAll(iceP_copy);
            istr->endEncapsulation();
            try
            {
                response(iceP_copy);
            }
            catch(...)
            {
                throw ::std::current_exception();
            }
        };
    }
    auto outAsync = ::std::make_shared<::IceInternal::CustomLambdaOutgoing>(shared_from_this(), read, ex, sent);

    outAsync->invoke(iceC_Test_TestIntf_opOutArrayByteSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_org);
        },
        nullptr);
    return [outAsync]() { outAsync->cancel(); };
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOutArrayByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::ByteSeq>>& outAsync, const ByteSeq& iceP_org, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOutArrayByteSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOutArrayByteSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_org);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOutRangeByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::ByteSeq>>& outAsync, const ByteSeq& iceP_org, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOutRangeByteSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOutRangeByteSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_org);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opIntStringDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpIntStringDictResult>>& outAsync, const IntStringDict& iceP_idict, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opIntStringDict_name);
    outAsync->invoke(iceC_Test_TestIntf_opIntStringDict_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_idict);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpIntStringDictResult v;
            istr->readAll(v.odict, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opVarDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpVarDictResult>>& outAsync, const ::Test::CustomMap<std::string, ::Ice::Int>& iceP_idict, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opVarDict_name);
    outAsync->invoke(iceC_Test_TestIntf_opVarDict_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_idict);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpVarDictResult v;
            istr->readAll(v.odict, v.returnValue);
            return v;
        });
}
/// \endcond

::std::function<void()>
Test::TestIntfPrx::opCustomIntStringDictAsync(const ::std::map< ::Ice::Int, ::Util::string_view>& iceP_idict,
                                              ::std::function<void (::std::map< ::Ice::Int, ::Util::string_view>, ::std::map< ::Ice::Int, ::Util::string_view>)> response,
                                              ::std::function<void(::std::exception_ptr)> ex,
                                              ::std::function<void(bool)> sent,
                                              const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opCustomIntStringDict_name);
    ::std::function<void(::Ice::InputStream*)> read;
    if(response)
    {
        read = [response](::Ice::InputStream* istr)
        {
            istr->startEncapsulation();
            ::std::map< ::Ice::Int, ::Util::string_view> iceP_odict;
            ::std::map< ::Ice::Int, ::Util::string_view> ret;
            istr->readAll(iceP_odict, ret);
            istr->endEncapsulation();
            try
            {
                response(ret, iceP_odict);
            }
            catch(...)
            {
                throw ::std::current_exception();
            }
        };
    }
    auto outAsync = ::std::make_shared<::IceInternal::CustomLambdaOutgoing>(shared_from_this(), read, ex, sent);

    outAsync->invoke(iceC_Test_TestIntf_opCustomIntStringDict_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_idict);
        },
        nullptr);
    return [outAsync]() { outAsync->cancel(); };
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opCustomIntStringDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpCustomIntStringDictResult>>& outAsync, const ::std::map< ::Ice::Int, ::Util::string_view>& iceP_idict, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opCustomIntStringDict_name);
    outAsync->invoke(iceC_Test_TestIntf_opCustomIntStringDict_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_idict);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpCustomIntStringDictResult v;
            istr->readAll(v.odict, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opShortBuffer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpShortBufferResult>>& outAsync, const ShortBuffer& iceP_inS, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opShortBuffer_name);
    outAsync->invoke(iceC_Test_TestIntf_opShortBuffer_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inS);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpShortBufferResult v;
            istr->readAll(v.outS, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opBoolBuffer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolBufferResult>>& outAsync, const ::Test::CustomBuffer<bool>& iceP_inS, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolBuffer_name);
    outAsync->invoke(iceC_Test_TestIntf_opBoolBuffer_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inS);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpBoolBufferResult v;
            istr->readAll(v.outS, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opBufferStruct(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::BufferStruct>>& outAsync, const BufferStruct& iceP_s, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBufferStruct_name);
    outAsync->invoke(iceC_Test_TestIntf_opBufferStruct_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_s);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_TestIntf_shutdown_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::TestIntfPrx::_newInstance() const
{
    return ::IceInternal::createProxy<TestIntfPrx>();
}
/// \endcond

const ::std::string&
Test::TestIntfPrx::ice_staticId()
{
    return TestIntf::ice_staticId();
}

namespace Ice
{
}

#else // C++98 mapping

namespace
{

const ::std::string iceC_Test_TestIntf_opDoubleArray_name = "opDoubleArray";

const ::std::string iceC_Test_TestIntf_opBoolArray_name = "opBoolArray";

const ::std::string iceC_Test_TestIntf_opByteArray_name = "opByteArray";

const ::std::string iceC_Test_TestIntf_opVariableArray_name = "opVariableArray";

const ::std::string iceC_Test_TestIntf_opBoolRange_name = "opBoolRange";

const ::std::string iceC_Test_TestIntf_opByteRange_name = "opByteRange";

const ::std::string iceC_Test_TestIntf_opVariableRange_name = "opVariableRange";

const ::std::string iceC_Test_TestIntf_opByteRangeType_name = "opByteRangeType";

const ::std::string iceC_Test_TestIntf_opVariableRangeType_name = "opVariableRangeType";

const ::std::string iceC_Test_TestIntf_opBoolSeq_name = "opBoolSeq";

const ::std::string iceC_Test_TestIntf_opBoolList_name = "opBoolList";

const ::std::string iceC_Test_TestIntf_opBoolDequeList_name = "opBoolDequeList";

const ::std::string iceC_Test_TestIntf_opBoolDequeListArray_name = "opBoolDequeListArray";

const ::std::string iceC_Test_TestIntf_opBoolDequeListRange_name = "opBoolDequeListRange";

const ::std::string iceC_Test_TestIntf_opByteSeq_name = "opByteSeq";

const ::std::string iceC_Test_TestIntf_opByteList_name = "opByteList";

const ::std::string iceC_Test_TestIntf_opMyByteSeq_name = "opMyByteSeq";

const ::std::string iceC_Test_TestIntf_opString_name = "opString";

const ::std::string iceC_Test_TestIntf_opStringSeq_name = "opStringSeq";

const ::std::string iceC_Test_TestIntf_opStringList_name = "opStringList";

const ::std::string iceC_Test_TestIntf_opFixedSeq_name = "opFixedSeq";

const ::std::string iceC_Test_TestIntf_opFixedList_name = "opFixedList";

const ::std::string iceC_Test_TestIntf_opVariableSeq_name = "opVariableSeq";

const ::std::string iceC_Test_TestIntf_opVariableList_name = "opVariableList";

const ::std::string iceC_Test_TestIntf_opStringStringDictSeq_name = "opStringStringDictSeq";

const ::std::string iceC_Test_TestIntf_opStringStringDictList_name = "opStringStringDictList";

const ::std::string iceC_Test_TestIntf_opESeq_name = "opESeq";

const ::std::string iceC_Test_TestIntf_opEList_name = "opEList";

const ::std::string iceC_Test_TestIntf_opDPrxSeq_name = "opDPrxSeq";

const ::std::string iceC_Test_TestIntf_opDPrxList_name = "opDPrxList";

const ::std::string iceC_Test_TestIntf_opCSeq_name = "opCSeq";

const ::std::string iceC_Test_TestIntf_opCList_name = "opCList";

const ::std::string iceC_Test_TestIntf_opClassStruct_name = "opClassStruct";

const ::std::string iceC_Test_TestIntf_opOutArrayByteSeq_name = "opOutArrayByteSeq";

const ::std::string iceC_Test_TestIntf_opOutRangeByteSeq_name = "opOutRangeByteSeq";

const ::std::string iceC_Test_TestIntf_opIntStringDict_name = "opIntStringDict";

const ::std::string iceC_Test_TestIntf_opVarDict_name = "opVarDict";

const ::std::string iceC_Test_TestIntf_opCustomIntStringDict_name = "opCustomIntStringDict";

const ::std::string iceC_Test_TestIntf_opShortBuffer_name = "opShortBuffer";

const ::std::string iceC_Test_TestIntf_opBoolBuffer_name = "opBoolBuffer";

const ::std::string iceC_Test_TestIntf_opBufferStruct_name = "opBufferStruct";

const ::std::string iceC_Test_TestIntf_shutdown_name = "shutdown";

}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(C* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< C>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new C;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::C::_newInstance() const
{
    return new C;
}
/// \endcond

const ::std::string&
IceProxy::Test::C::ice_staticId()
{
    return ::Test::C::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(D* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< D>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new D;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::D::_newInstance() const
{
    return new D;
}
/// \endcond

const ::std::string&
IceProxy::Test::D::ice_staticId()
{
    return ::Test::D::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(DictClass* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< DictClass>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new DictClass;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::DictClass::_newInstance() const
{
    return new DictClass;
}
/// \endcond

const ::std::string&
IceProxy::Test::DictClass::ice_staticId()
{
    return ::Test::DictClass::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(TestIntf* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< TestIntf>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new TestIntf;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opDoubleArray_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opDoubleArray_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opDoubleArray_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opDoubleArray_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::DoubleSeq
IceProxy::Test::TestIntf::end_opDoubleArray(::Test::DoubleSeq& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opDoubleArray_name);
    ::Test::DoubleSeq ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opDoubleArray(::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> >& iceP_outSeq, ::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> >& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opDoubleArray_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opBoolArray(const ::std::pair<const bool*, const bool*>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolArray_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opBoolArray_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opBoolArray_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opBoolArray_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BoolSeq
IceProxy::Test::TestIntf::end_opBoolArray(::Test::BoolSeq& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opBoolArray_name);
    ::Test::BoolSeq ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opBoolArray(::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> >& iceP_outSeq, ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> >& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opBoolArray_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteArray_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opByteArray_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opByteArray_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opByteArray_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ByteList
IceProxy::Test::TestIntf::end_opByteArray(::Test::ByteList& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opByteArray_name);
    ::Test::ByteList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opByteArray(::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& iceP_outSeq, ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opByteArray_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opVariableArray_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opVariableArray_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opVariableArray_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opVariableArray_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::VariableList
IceProxy::Test::TestIntf::end_opVariableArray(::Test::VariableList& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opVariableArray_name);
    ::Test::VariableList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opVariableArray(::std::vector< ::Test::Variable>& iceP_outSeq, ::std::vector< ::Test::Variable>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opVariableArray_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolRange_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opBoolRange_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opBoolRange_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opBoolRange_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BoolSeq
IceProxy::Test::TestIntf::end_opBoolRange(::Test::BoolSeq& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opBoolRange_name);
    ::Test::BoolSeq ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opBoolRange(::Test::BoolSeq& iceP_outSeq, ::Test::BoolSeq& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opBoolRange_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteRange_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opByteRange_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opByteRange_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opByteRange_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ByteList
IceProxy::Test::TestIntf::end_opByteRange(::Test::ByteList& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opByteRange_name);
    ::Test::ByteList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opByteRange(::Test::ByteList& iceP_outSeq, ::Test::ByteList& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opByteRange_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opVariableRange_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opVariableRange_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opVariableRange_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opVariableRange_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::VariableList
IceProxy::Test::TestIntf::end_opVariableRange(::Test::VariableList& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opVariableRange_name);
    ::Test::VariableList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opVariableRange(::Test::VariableList& iceP_outSeq, ::Test::VariableList& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opVariableRange_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteRangeType_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opByteRangeType_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opByteRangeType_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opByteRangeType_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ByteList
IceProxy::Test::TestIntf::end_opByteRangeType(::Test::ByteList& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opByteRangeType_name);
    ::Test::ByteList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opByteRangeType(::Test::ByteList& iceP_outSeq, ::Test::ByteList& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opByteRangeType_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opVariableRangeType_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opVariableRangeType_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opVariableRangeType_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opVariableRangeType_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::VariableList
IceProxy::Test::TestIntf::end_opVariableRangeType(::Test::VariableList& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opVariableRangeType_name);
    ::Test::VariableList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opVariableRangeType(std::deque< ::Test::Variable>& iceP_outSeq, std::deque< ::Test::Variable>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opVariableRangeType_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opBoolSeq(const std::deque<bool>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opBoolSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opBoolSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opBoolSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::deque<bool>
IceProxy::Test::TestIntf::end_opBoolSeq(std::deque<bool>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opBoolSeq_name);
    std::deque<bool> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opBoolSeq(std::deque<bool>& iceP_outSeq, std::deque<bool>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opBoolSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opBoolList(const ::Test::BoolList& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolList_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opBoolList_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opBoolList_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opBoolList_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BoolList
IceProxy::Test::TestIntf::end_opBoolList(::Test::BoolList& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opBoolList_name);
    ::Test::BoolList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opBoolList(::Test::BoolList& iceP_outSeq, ::Test::BoolList& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opBoolList_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opBoolDequeList(const ::Test::BoolDequeList& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolDequeList_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opBoolDequeList_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opBoolDequeList_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opBoolDequeList_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BoolDequeList
IceProxy::Test::TestIntf::end_opBoolDequeList(::Test::BoolDequeList& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opBoolDequeList_name);
    ::Test::BoolDequeList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opBoolDequeList(::Test::BoolDequeList& iceP_outSeq, ::Test::BoolDequeList& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opBoolDequeList_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolDequeListArray_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opBoolDequeListArray_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opBoolDequeListArray_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opBoolDequeListArray_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BoolDequeList
IceProxy::Test::TestIntf::end_opBoolDequeListArray(::Test::BoolDequeList& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opBoolDequeListArray_name);
    ::Test::BoolDequeList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opBoolDequeListArray(::std::vector<std::deque<bool> >& iceP_outSeq, ::std::vector<std::deque<bool> >& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opBoolDequeListArray_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolDequeListRange_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opBoolDequeListRange_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opBoolDequeListRange_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opBoolDequeListRange_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BoolDequeList
IceProxy::Test::TestIntf::end_opBoolDequeListRange(::Test::BoolDequeList& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opBoolDequeListRange_name);
    ::Test::BoolDequeList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opBoolDequeListRange(::Test::BoolDequeList& iceP_outSeq, ::Test::BoolDequeList& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opBoolDequeListRange_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opByteSeq(const std::deque< ::Ice::Byte>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opByteSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opByteSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opByteSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::deque< ::Ice::Byte>
IceProxy::Test::TestIntf::end_opByteSeq(std::deque< ::Ice::Byte>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opByteSeq_name);
    std::deque< ::Ice::Byte> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opByteSeq(std::deque< ::Ice::Byte>& iceP_outSeq, std::deque< ::Ice::Byte>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opByteSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opByteList(const ::Test::ByteList& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteList_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opByteList_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opByteList_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opByteList_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ByteList
IceProxy::Test::TestIntf::end_opByteList(::Test::ByteList& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opByteList_name);
    ::Test::ByteList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opByteList(::Test::ByteList& iceP_outSeq, ::Test::ByteList& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opByteList_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opMyByteSeq(const MyByteSeq& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opMyByteSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opMyByteSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opMyByteSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opMyByteSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

MyByteSeq
IceProxy::Test::TestIntf::end_opMyByteSeq(MyByteSeq& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opMyByteSeq_name);
    MyByteSeq ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opMyByteSeq(MyByteSeq& iceP_outSeq, MyByteSeq& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opMyByteSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opString(const Util::string_view& iceP_inString, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opString_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opString_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opString_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inString);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opString_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::std::string
IceProxy::Test::TestIntf::end_opString(::std::string& iceP_outString, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opString_name);
    ::std::string ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outString);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opString(Util::string_view& iceP_outString, Util::string_view& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opString_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outString);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opStringSeq(const std::deque<std::string>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opStringSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opStringSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opStringSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opStringSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::deque<std::string>
IceProxy::Test::TestIntf::end_opStringSeq(std::deque<std::string>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opStringSeq_name);
    std::deque<std::string> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opStringSeq(std::deque<std::string>& iceP_outSeq, std::deque<std::string>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opStringSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opStringList(const ::Test::StringList& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opStringList_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opStringList_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opStringList_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opStringList_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::StringList
IceProxy::Test::TestIntf::end_opStringList(::Test::StringList& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opStringList_name);
    ::Test::StringList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opStringList(::Test::StringList& iceP_outSeq, ::Test::StringList& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opStringList_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opFixedSeq(const std::deque< ::Test::Fixed>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opFixedSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opFixedSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opFixedSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opFixedSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::deque< ::Test::Fixed>
IceProxy::Test::TestIntf::end_opFixedSeq(std::deque< ::Test::Fixed>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opFixedSeq_name);
    std::deque< ::Test::Fixed> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opFixedSeq(std::deque< ::Test::Fixed>& iceP_outSeq, std::deque< ::Test::Fixed>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opFixedSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opFixedList(const ::Test::FixedList& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opFixedList_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opFixedList_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opFixedList_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opFixedList_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::FixedList
IceProxy::Test::TestIntf::end_opFixedList(::Test::FixedList& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opFixedList_name);
    ::Test::FixedList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opFixedList(::Test::FixedList& iceP_outSeq, ::Test::FixedList& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opFixedList_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opVariableSeq(const std::deque< ::Test::Variable>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opVariableSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opVariableSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opVariableSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opVariableSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::deque< ::Test::Variable>
IceProxy::Test::TestIntf::end_opVariableSeq(std::deque< ::Test::Variable>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opVariableSeq_name);
    std::deque< ::Test::Variable> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opVariableSeq(std::deque< ::Test::Variable>& iceP_outSeq, std::deque< ::Test::Variable>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opVariableSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opVariableList(const ::Test::VariableList& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opVariableList_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opVariableList_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opVariableList_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opVariableList_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::VariableList
IceProxy::Test::TestIntf::end_opVariableList(::Test::VariableList& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opVariableList_name);
    ::Test::VariableList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opVariableList(::Test::VariableList& iceP_outSeq, ::Test::VariableList& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opVariableList_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opStringStringDictSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opStringStringDictSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opStringStringDictSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opStringStringDictSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::deque< ::Test::StringStringDict>
IceProxy::Test::TestIntf::end_opStringStringDictSeq(std::deque< ::Test::StringStringDict>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opStringStringDictSeq_name);
    std::deque< ::Test::StringStringDict> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opStringStringDictSeq(std::deque< ::Test::StringStringDict>& iceP_outSeq, std::deque< ::Test::StringStringDict>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opStringStringDictSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opStringStringDictList(const ::Test::StringStringDictList& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opStringStringDictList_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opStringStringDictList_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opStringStringDictList_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opStringStringDictList_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::StringStringDictList
IceProxy::Test::TestIntf::end_opStringStringDictList(::Test::StringStringDictList& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opStringStringDictList_name);
    ::Test::StringStringDictList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opStringStringDictList(::Test::StringStringDictList& iceP_outSeq, ::Test::StringStringDictList& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opStringStringDictList_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opESeq(const std::deque< ::Test::E>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opESeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opESeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opESeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opESeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::deque< ::Test::E>
IceProxy::Test::TestIntf::end_opESeq(std::deque< ::Test::E>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opESeq_name);
    std::deque< ::Test::E> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opESeq(std::deque< ::Test::E>& iceP_outSeq, std::deque< ::Test::E>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opESeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opEList(const ::Test::EList& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opEList_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opEList_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opEList_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opEList_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::EList
IceProxy::Test::TestIntf::end_opEList(::Test::EList& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opEList_name);
    ::Test::EList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opEList(::Test::EList& iceP_outSeq, ::Test::EList& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opEList_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opDPrxSeq(const std::deque< ::Test::DPrx>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opDPrxSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opDPrxSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opDPrxSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opDPrxSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::deque< ::Test::DPrx>
IceProxy::Test::TestIntf::end_opDPrxSeq(std::deque< ::Test::DPrx>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opDPrxSeq_name);
    std::deque< ::Test::DPrx> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opDPrxSeq(std::deque< ::Test::DPrx>& iceP_outSeq, std::deque< ::Test::DPrx>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opDPrxSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opDPrxList(const ::Test::DPrxList& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opDPrxList_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opDPrxList_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opDPrxList_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opDPrxList_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::DPrxList
IceProxy::Test::TestIntf::end_opDPrxList(::Test::DPrxList& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opDPrxList_name);
    ::Test::DPrxList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opDPrxList(::Test::DPrxList& iceP_outSeq, ::Test::DPrxList& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opDPrxList_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opCSeq(const std::deque< ::Test::CPtr>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opCSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opCSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opCSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opCSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::deque< ::Test::CPtr>
IceProxy::Test::TestIntf::end_opCSeq(std::deque< ::Test::CPtr>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opCSeq_name);
    std::deque< ::Test::CPtr> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opCSeq(std::deque< ::Test::CPtr>& iceP_outSeq, std::deque< ::Test::CPtr>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opCSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opCList(const ::Test::CList& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opCList_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opCList_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opCList_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opCList_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::CList
IceProxy::Test::TestIntf::end_opCList(::Test::CList& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opCList_name);
    ::Test::CList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opCList(::Test::CList& iceP_outSeq, ::Test::CList& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opCList_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opClassStruct(const ::Test::ClassStructPtr& iceP_inS, const ::Test::ClassStructSeq& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opClassStruct_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opClassStruct_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opClassStruct_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inS);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opClassStruct_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ClassStructPtr
IceProxy::Test::TestIntf::end_opClassStruct(::Test::ClassStructPtr& iceP_outS, ::Test::ClassStructSeq& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opClassStruct_name);
    ::Test::ClassStructPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outS);
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opClassStruct(::Test::ClassStructPtr& iceP_outS, ::Test::ClassStructSeq& iceP_outSeq, ::Test::ClassStructPtr& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opClassStruct_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outS);
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opOutArrayByteSeq(const ::Test::ByteSeq& iceP_org, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOutArrayByteSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opOutArrayByteSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opOutArrayByteSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_org);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opOutArrayByteSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_opOutArrayByteSeq(::Test::ByteSeq& iceP_copy, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOutArrayByteSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_copy);
    result->_endReadParams();
}

void IceProxy::Test::TestIntf::_iceI_end_opOutArrayByteSeq(::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& iceP_copy, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOutArrayByteSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_copy);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opOutRangeByteSeq(const ::Test::ByteSeq& iceP_org, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOutRangeByteSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opOutRangeByteSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opOutRangeByteSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_org);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opOutRangeByteSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_opOutRangeByteSeq(::Test::ByteSeq& iceP_copy, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOutRangeByteSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_copy);
    result->_endReadParams();
}

void IceProxy::Test::TestIntf::_iceI_end_opOutRangeByteSeq(::Test::ByteSeq& iceP_copy, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOutRangeByteSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_copy);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opIntStringDict(const ::Test::IntStringDict& iceP_idict, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opIntStringDict_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opIntStringDict_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opIntStringDict_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_idict);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opIntStringDict_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::IntStringDict
IceProxy::Test::TestIntf::end_opIntStringDict(::Test::IntStringDict& iceP_odict, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opIntStringDict_name);
    ::Test::IntStringDict ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_odict);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opIntStringDict(::Test::IntStringDict& iceP_odict, ::Test::IntStringDict& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opIntStringDict_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_odict);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& iceP_idict, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opVarDict_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opVarDict_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opVarDict_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_idict);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opVarDict_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::CustomMap< ::Ice::Long, ::Ice::Long>
IceProxy::Test::TestIntf::end_opVarDict(::Test::CustomMap<std::string, ::Ice::Int>& iceP_odict, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opVarDict_name);
    ::Test::CustomMap< ::Ice::Long, ::Ice::Long> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_odict);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opVarDict(::Test::CustomMap<std::string, ::Ice::Int>& iceP_odict, ::Test::CustomMap< ::Ice::Long, ::Ice::Long>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opVarDict_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_odict);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opCustomIntStringDict(const ::std::map< ::Ice::Int, ::Util::string_view>& iceP_idict, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opCustomIntStringDict_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opCustomIntStringDict_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opCustomIntStringDict_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_idict);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opCustomIntStringDict_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::CustomMap< ::Ice::Int, std::string>
IceProxy::Test::TestIntf::end_opCustomIntStringDict(::Test::CustomMap< ::Ice::Int, std::string>& iceP_odict, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opCustomIntStringDict_name);
    ::Test::CustomMap< ::Ice::Int, std::string> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_odict);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opCustomIntStringDict(::std::map< ::Ice::Int, ::Util::string_view>& iceP_odict, ::std::map< ::Ice::Int, ::Util::string_view>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opCustomIntStringDict_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_odict);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opShortBuffer(const ::Test::ShortBuffer& iceP_inS, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opShortBuffer_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opShortBuffer_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opShortBuffer_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inS);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opShortBuffer_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ShortBuffer
IceProxy::Test::TestIntf::end_opShortBuffer(::Test::ShortBuffer& iceP_outS, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opShortBuffer_name);
    ::Test::ShortBuffer ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outS);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opShortBuffer(::Test::ShortBuffer& iceP_outS, ::Test::ShortBuffer& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opShortBuffer_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outS);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opBoolBuffer(const ::Test::CustomBuffer<bool>& iceP_inS, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolBuffer_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opBoolBuffer_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opBoolBuffer_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inS);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opBoolBuffer_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::CustomBuffer<bool>
IceProxy::Test::TestIntf::end_opBoolBuffer(::Test::CustomBuffer<bool>& iceP_outS, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opBoolBuffer_name);
    ::Test::CustomBuffer<bool> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outS);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opBoolBuffer(::Test::CustomBuffer<bool>& iceP_outS, ::Test::CustomBuffer<bool>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opBoolBuffer_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outS);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opBufferStruct(const ::Test::BufferStruct& iceP_s, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBufferStruct_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opBufferStruct_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opBufferStruct_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_s);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opBufferStruct_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BufferStruct
IceProxy::Test::TestIntf::end_opBufferStruct(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opBufferStruct_name);
    ::Test::BufferStruct ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_shutdown(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_shutdown_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_shutdown_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_shutdown_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_shutdown(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_TestIntf_shutdown_name);
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::TestIntf::_newInstance() const
{
    return new TestIntf;
}
/// \endcond

const ::std::string&
IceProxy::Test::TestIntf::ice_staticId()
{
    return ::Test::TestIntf::ice_staticId();
}

Test::C::~C()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(C* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::C::ice_clone() const
{
    ::Ice::Object* p = new C(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_C_ids[2] =
{
    "::Ice::Object",
    "::Test::C"
};

}

bool
Test::C::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_C_ids, iceC_Test_C_ids + 2, s);
}

::std::vector< ::std::string>
Test::C::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_C_ids[0], &iceC_Test_C_ids[2]);
}

const ::std::string&
Test::C::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::C::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::C";
    return typeId;
#else
    return iceC_Test_C_ids[1];
#endif
}

/// \cond STREAM
void
Test::C::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< C, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::C::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< C, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::C> iceC_Test_C_init("::Test::C");
}

::Ice::ValueFactoryPtr
Test::C::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::C::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(CPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = CPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(C::ice_staticId(), v);
    }
}
/// \endcond

Test::D::~D()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(D* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test_D_ids[2] =
{
    "::Ice::Object",
    "::Test::D"
};

}

bool
Test::D::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_D_ids, iceC_Test_D_ids + 2, s);
}

::std::vector< ::std::string>
Test::D::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_D_ids[0], &iceC_Test_D_ids[2]);
}

const ::std::string&
Test::D::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::D::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::D";
    return typeId;
#else
    return iceC_Test_D_ids[1];
#endif
}

/// \cond STREAM
void
Test::D::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< D, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::D::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< D, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(DPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = DPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(D::ice_staticId(), v);
    }
}
/// \endcond

Test::DictClass::~DictClass()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(DictClass* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::DictClass::ice_clone() const
{
    ::Ice::Object* p = new DictClass(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_DictClass_ids[2] =
{
    "::Ice::Object",
    "::Test::DictClass"
};

}

bool
Test::DictClass::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_DictClass_ids, iceC_Test_DictClass_ids + 2, s);
}

::std::vector< ::std::string>
Test::DictClass::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_DictClass_ids[0], &iceC_Test_DictClass_ids[2]);
}

const ::std::string&
Test::DictClass::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::DictClass::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::DictClass";
    return typeId;
#else
    return iceC_Test_DictClass_ids[1];
#endif
}

/// \cond STREAM
void
Test::DictClass::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< DictClass, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::DictClass::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< DictClass, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::DictClass> iceC_Test_DictClass_init("::Test::DictClass");
}

::Ice::ValueFactoryPtr
Test::DictClass::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::DictClass::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(DictClassPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = DictClassPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(DictClass::ice_staticId(), v);
    }
}
/// \endcond

Test::TestIntf::~TestIntf()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(TestIntf* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test_TestIntf_ids[2] =
{
    "::Ice::Object",
    "::Test::TestIntf"
};

}

bool
Test::TestIntf::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_TestIntf_ids, iceC_Test_TestIntf_ids + 2, s);
}

::std::vector< ::std::string>
Test::TestIntf::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_TestIntf_ids[0], &iceC_Test_TestIntf_ids[2]);
}

const ::std::string&
Test::TestIntf::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::TestIntf::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::TestIntf";
    return typeId;
#else
    return iceC_Test_TestIntf_ids[1];
#endif
}

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDoubleArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::pair<const ::Ice::Double*, const ::Ice::Double*> iceP_inSeq;
    ::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> > iceP_inSeq_tmp_;
    istr->read(iceP_inSeq_tmp_);
    iceP_inSeq = iceP_inSeq_tmp_.second;
    inS.endReadParams();
    DoubleSeq iceP_outSeq;
    DoubleSeq ret = this->opDoubleArray(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::pair<const bool*, const bool*> iceP_inSeq;
    ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> > iceP_inSeq_tmp_;
    istr->read(iceP_inSeq_tmp_);
    iceP_inSeq = iceP_inSeq_tmp_.second;
    inS.endReadParams();
    BoolSeq iceP_outSeq;
    BoolSeq ret = this->opBoolArray(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    ByteList iceP_outSeq;
    ByteList ret = this->opByteArray(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVariableArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::pair<const Variable*, const Variable*> iceP_inSeq;
    ::std::vector<Variable> iceP_inSeq_tmp_;
    istr->read(iceP_inSeq_tmp_);
    if(!iceP_inSeq_tmp_.empty())
    {
        iceP_inSeq.first = &iceP_inSeq_tmp_[0];
        iceP_inSeq.second = iceP_inSeq.first + iceP_inSeq_tmp_.size();
    }
    else
    {
        iceP_inSeq.first = iceP_inSeq.second = 0;
    }
    inS.endReadParams();
    VariableList iceP_outSeq;
    VariableList ret = this->opVariableArray(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::pair<BoolSeq::const_iterator, BoolSeq::const_iterator> iceP_inSeq;
    BoolSeq iceP_inSeq_tmp_;
    istr->read(iceP_inSeq_tmp_);
    iceP_inSeq.first = iceP_inSeq_tmp_.begin();
    iceP_inSeq.second = iceP_inSeq_tmp_.end();
    inS.endReadParams();
    BoolSeq iceP_outSeq;
    BoolSeq ret = this->opBoolRange(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::pair<ByteList::const_iterator, ByteList::const_iterator> iceP_inSeq;
    ByteList iceP_inSeq_tmp_;
    istr->read(iceP_inSeq_tmp_);
    iceP_inSeq.first = iceP_inSeq_tmp_.begin();
    iceP_inSeq.second = iceP_inSeq_tmp_.end();
    inS.endReadParams();
    ByteList iceP_outSeq;
    ByteList ret = this->opByteRange(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVariableRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::pair<VariableList::const_iterator, VariableList::const_iterator> iceP_inSeq;
    VariableList iceP_inSeq_tmp_;
    istr->read(iceP_inSeq_tmp_);
    iceP_inSeq.first = iceP_inSeq_tmp_.begin();
    iceP_inSeq.second = iceP_inSeq_tmp_.end();
    inS.endReadParams();
    VariableList iceP_outSeq;
    VariableList ret = this->opVariableRange(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteRangeType(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator> iceP_inSeq;
    ::Test::ByteList iceP_inSeq_tmp_;
    istr->read(iceP_inSeq_tmp_);
    iceP_inSeq.first = iceP_inSeq_tmp_.begin();
    iceP_inSeq.second = iceP_inSeq_tmp_.end();
    inS.endReadParams();
    ByteList iceP_outSeq;
    ByteList ret = this->opByteRangeType(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVariableRangeType(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator> iceP_inSeq;
    std::deque< ::Test::Variable> iceP_inSeq_tmp_;
    istr->read(iceP_inSeq_tmp_);
    iceP_inSeq.first = iceP_inSeq_tmp_.begin();
    iceP_inSeq.second = iceP_inSeq_tmp_.end();
    inS.endReadParams();
    VariableList iceP_outSeq;
    VariableList ret = this->opVariableRangeType(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::deque<bool> iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    std::deque<bool> iceP_outSeq;
    std::deque<bool> ret = this->opBoolSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    BoolList iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    BoolList iceP_outSeq;
    BoolList ret = this->opBoolList(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolDequeList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    BoolDequeList iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    BoolDequeList iceP_outSeq;
    BoolDequeList ret = this->opBoolDequeList(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolDequeListArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::pair<const std::deque<bool>*, const std::deque<bool>*> iceP_inSeq;
    ::std::vector<std::deque<bool> > iceP_inSeq_tmp_;
    istr->read(iceP_inSeq_tmp_);
    if(!iceP_inSeq_tmp_.empty())
    {
        iceP_inSeq.first = &iceP_inSeq_tmp_[0];
        iceP_inSeq.second = iceP_inSeq.first + iceP_inSeq_tmp_.size();
    }
    else
    {
        iceP_inSeq.first = iceP_inSeq.second = 0;
    }
    inS.endReadParams();
    BoolDequeList iceP_outSeq;
    BoolDequeList ret = this->opBoolDequeListArray(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolDequeListRange(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::pair<BoolDequeList::const_iterator, BoolDequeList::const_iterator> iceP_inSeq;
    BoolDequeList iceP_inSeq_tmp_;
    istr->read(iceP_inSeq_tmp_);
    iceP_inSeq.first = iceP_inSeq_tmp_.begin();
    iceP_inSeq.second = iceP_inSeq_tmp_.end();
    inS.endReadParams();
    BoolDequeList iceP_outSeq;
    BoolDequeList ret = this->opBoolDequeListRange(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::deque< ::Ice::Byte> iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    std::deque< ::Ice::Byte> iceP_outSeq;
    std::deque< ::Ice::Byte> ret = this->opByteSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ByteList iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    ByteList iceP_outSeq;
    ByteList ret = this->opByteList(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opMyByteSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    MyByteSeq iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    MyByteSeq iceP_outSeq;
    MyByteSeq ret = this->opMyByteSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opString(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    Util::string_view iceP_inString;
    istr->read(iceP_inString);
    inS.endReadParams();
    ::std::string iceP_outString;
    ::std::string ret = this->opString(iceP_inString, iceP_outString, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outString);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::deque<std::string> iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    std::deque<std::string> iceP_outSeq;
    std::deque<std::string> ret = this->opStringSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    StringList iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    StringList iceP_outSeq;
    StringList ret = this->opStringList(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opFixedSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::deque< ::Test::Fixed> iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    std::deque< ::Test::Fixed> iceP_outSeq;
    std::deque< ::Test::Fixed> ret = this->opFixedSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opFixedList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    FixedList iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    FixedList iceP_outSeq;
    FixedList ret = this->opFixedList(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVariableSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::deque< ::Test::Variable> iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    std::deque< ::Test::Variable> iceP_outSeq;
    std::deque< ::Test::Variable> ret = this->opVariableSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVariableList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    VariableList iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    VariableList iceP_outSeq;
    VariableList ret = this->opVariableList(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringStringDictSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::deque< ::Test::StringStringDict> iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    std::deque< ::Test::StringStringDict> iceP_outSeq;
    std::deque< ::Test::StringStringDict> ret = this->opStringStringDictSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringStringDictList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    StringStringDictList iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    StringStringDictList iceP_outSeq;
    StringStringDictList ret = this->opStringStringDictList(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opESeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::deque< ::Test::E> iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    std::deque< ::Test::E> iceP_outSeq;
    std::deque< ::Test::E> ret = this->opESeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opEList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    EList iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    EList iceP_outSeq;
    EList ret = this->opEList(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDPrxSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::deque< ::Test::DPrx> iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    std::deque< ::Test::DPrx> iceP_outSeq;
    std::deque< ::Test::DPrx> ret = this->opDPrxSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDPrxList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    DPrxList iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    DPrxList iceP_outSeq;
    DPrxList ret = this->opDPrxList(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opCSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::deque< ::Test::CPtr> iceP_inSeq;
    istr->read(iceP_inSeq);
    istr->readPendingValues();
    inS.endReadParams();
    std::deque< ::Test::CPtr> iceP_outSeq;
    std::deque< ::Test::CPtr> ret = this->opCSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opCList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    CList iceP_inSeq;
    istr->read(iceP_inSeq);
    istr->readPendingValues();
    inS.endReadParams();
    CList iceP_outSeq;
    CList ret = this->opCList(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opClassStruct(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ClassStructPtr iceP_inS;
    ClassStructSeq iceP_inSeq;
    istr->read(iceP_inS);
    istr->read(iceP_inSeq);
    inS.endReadParams();
    ClassStructPtr iceP_outS;
    ClassStructSeq iceP_outSeq;
    ClassStructPtr ret = this->opClassStruct(iceP_inS, iceP_inSeq, iceP_outS, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outS);
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOutArrayByteSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ByteSeq iceP_org;
    istr->read(iceP_org);
    inS.endReadParams();
    ByteSeq iceP_copy;
    this->opOutArrayByteSeq(iceP_org, iceP_copy, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_copy);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOutRangeByteSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ByteSeq iceP_org;
    istr->read(iceP_org);
    inS.endReadParams();
    ByteSeq iceP_copy;
    this->opOutRangeByteSeq(iceP_org, iceP_copy, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_copy);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opIntStringDict(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    IntStringDict iceP_idict;
    istr->read(iceP_idict);
    inS.endReadParams();
    IntStringDict iceP_odict;
    IntStringDict ret = this->opIntStringDict(iceP_idict, iceP_odict, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_odict);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opVarDict(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Test::CustomMap<std::string, ::Ice::Int> iceP_idict;
    istr->read(iceP_idict);
    inS.endReadParams();
    ::Test::CustomMap<std::string, ::Ice::Int> iceP_odict;
    ::Test::CustomMap< ::Ice::Long, ::Ice::Long> ret = this->opVarDict(iceP_idict, iceP_odict, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_odict);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opCustomIntStringDict(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::map< ::Ice::Int, ::Util::string_view> iceP_idict;
    istr->read(iceP_idict);
    inS.endReadParams();
    ::Test::CustomMap< ::Ice::Int, std::string> iceP_odict;
    ::Test::CustomMap< ::Ice::Int, std::string> ret = this->opCustomIntStringDict(iceP_idict, iceP_odict, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_odict);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opShortBuffer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ShortBuffer iceP_inS;
    istr->read(iceP_inS);
    inS.endReadParams();
    ShortBuffer iceP_outS;
    ShortBuffer ret = this->opShortBuffer(iceP_inS, iceP_outS, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outS);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolBuffer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Test::CustomBuffer<bool> iceP_inS;
    istr->read(iceP_inS);
    inS.endReadParams();
    ::Test::CustomBuffer<bool> iceP_outS;
    ::Test::CustomBuffer<bool> ret = this->opBoolBuffer(iceP_inS, iceP_outS, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outS);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBufferStruct(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    BufferStruct iceP_s;
    istr->read(iceP_s);
    inS.endReadParams();
    BufferStruct ret = this->opBufferStruct(iceP_s, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_shutdown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->shutdown(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Test_TestIntf_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "opBoolArray",
    "opBoolBuffer",
    "opBoolDequeList",
    "opBoolDequeListArray",
    "opBoolDequeListRange",
    "opBoolList",
    "opBoolRange",
    "opBoolSeq",
    "opBufferStruct",
    "opByteArray",
    "opByteList",
    "opByteRange",
    "opByteRangeType",
    "opByteSeq",
    "opCList",
    "opCSeq",
    "opClassStruct",
    "opCustomIntStringDict",
    "opDPrxList",
    "opDPrxSeq",
    "opDoubleArray",
    "opEList",
    "opESeq",
    "opFixedList",
    "opFixedSeq",
    "opIntStringDict",
    "opMyByteSeq",
    "opOutArrayByteSeq",
    "opOutRangeByteSeq",
    "opShortBuffer",
    "opString",
    "opStringList",
    "opStringSeq",
    "opStringStringDictList",
    "opStringStringDictSeq",
    "opVarDict",
    "opVariableArray",
    "opVariableList",
    "opVariableRange",
    "opVariableRangeType",
    "opVariableSeq",
    "shutdown"
};

}

/// \cond INTERNAL
bool
Test::TestIntf::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_TestIntf_all, iceC_Test_TestIntf_all + 46, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_TestIntf_all)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_opBoolArray(in, current);
        }
        case 5:
        {
            return _iceD_opBoolBuffer(in, current);
        }
        case 6:
        {
            return _iceD_opBoolDequeList(in, current);
        }
        case 7:
        {
            return _iceD_opBoolDequeListArray(in, current);
        }
        case 8:
        {
            return _iceD_opBoolDequeListRange(in, current);
        }
        case 9:
        {
            return _iceD_opBoolList(in, current);
        }
        case 10:
        {
            return _iceD_opBoolRange(in, current);
        }
        case 11:
        {
            return _iceD_opBoolSeq(in, current);
        }
        case 12:
        {
            return _iceD_opBufferStruct(in, current);
        }
        case 13:
        {
            return _iceD_opByteArray(in, current);
        }
        case 14:
        {
            return _iceD_opByteList(in, current);
        }
        case 15:
        {
            return _iceD_opByteRange(in, current);
        }
        case 16:
        {
            return _iceD_opByteRangeType(in, current);
        }
        case 17:
        {
            return _iceD_opByteSeq(in, current);
        }
        case 18:
        {
            return _iceD_opCList(in, current);
        }
        case 19:
        {
            return _iceD_opCSeq(in, current);
        }
        case 20:
        {
            return _iceD_opClassStruct(in, current);
        }
        case 21:
        {
            return _iceD_opCustomIntStringDict(in, current);
        }
        case 22:
        {
            return _iceD_opDPrxList(in, current);
        }
        case 23:
        {
            return _iceD_opDPrxSeq(in, current);
        }
        case 24:
        {
            return _iceD_opDoubleArray(in, current);
        }
        case 25:
        {
            return _iceD_opEList(in, current);
        }
        case 26:
        {
            return _iceD_opESeq(in, current);
        }
        case 27:
        {
            return _iceD_opFixedList(in, current);
        }
        case 28:
        {
            return _iceD_opFixedSeq(in, current);
        }
        case 29:
        {
            return _iceD_opIntStringDict(in, current);
        }
        case 30:
        {
            return _iceD_opMyByteSeq(in, current);
        }
        case 31:
        {
            return _iceD_opOutArrayByteSeq(in, current);
        }
        case 32:
        {
            return _iceD_opOutRangeByteSeq(in, current);
        }
        case 33:
        {
            return _iceD_opShortBuffer(in, current);
        }
        case 34:
        {
            return _iceD_opString(in, current);
        }
        case 35:
        {
            return _iceD_opStringList(in, current);
        }
        case 36:
        {
            return _iceD_opStringSeq(in, current);
        }
        case 37:
        {
            return _iceD_opStringStringDictList(in, current);
        }
        case 38:
        {
            return _iceD_opStringStringDictSeq(in, current);
        }
        case 39:
        {
            return _iceD_opVarDict(in, current);
        }
        case 40:
        {
            return _iceD_opVariableArray(in, current);
        }
        case 41:
        {
            return _iceD_opVariableList(in, current);
        }
        case 42:
        {
            return _iceD_opVariableRange(in, current);
        }
        case 43:
        {
            return _iceD_opVariableRangeType(in, current);
        }
        case 44:
        {
            return _iceD_opVariableSeq(in, current);
        }
        case 45:
        {
            return _iceD_shutdown(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Test::TestIntf::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< TestIntf, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::TestIntf::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< TestIntf, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(TestIntfPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = TestIntfPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(TestIntf::ice_staticId(), v);
    }
}
/// \endcond

namespace Ice
{
}

#endif
