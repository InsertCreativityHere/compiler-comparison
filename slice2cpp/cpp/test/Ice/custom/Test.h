//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Test_h__
#define __Test_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <IceUtil/UndefSysMacros.h>
#include <deque>
#include <list>
#include <MyByteSeq.h>
#include <CustomMap.h>
#include <CustomBuffer.h>
#include <StringView.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace Test
{

struct Fixed;
struct Variable;
class C;
class D;
class DPrx;

using DPrxPtr = ::std::optional<DPrx>;
struct ClassOtherStruct;
struct ClassStruct;
class DictClass;
struct BufferStruct;
class TestIntf;
class TestIntfPrx;

using TestIntfPrxPtr = ::std::optional<TestIntfPrx>;

}

namespace Test
{

using BoolSeq = ::std::vector<bool>;

using BoolList = std::list<bool>;

using BoolListList = std::list< ::Test::BoolList>;

using BoolListSeq = ::std::vector<BoolList>;

using BoolSeqList = std::list< ::Test::BoolSeq>;

using BoolDequeList = std::list<std::deque<bool> >;

using ByteSeq = ::std::vector<::Ice::Byte>;

using ByteList = std::list< ::Ice::Byte>;

using ByteListList = std::list< ::Test::ByteList>;

using ByteListSeq = ::std::vector<ByteList>;

using ByteSeqList = std::list< ::Test::ByteSeq>;

using StringSeq = ::std::vector<::std::string>;

using StringList = std::list<std::string>;

using StringListList = std::list< ::Test::StringList>;

using StringListSeq = ::std::vector<StringList>;

using StringSeqList = std::list< ::Test::StringSeq>;

using FixedSeq = ::std::vector<Fixed>;

using FixedList = std::list< ::Test::Fixed>;

using FixedListList = std::list< ::Test::FixedList>;

using FixedListSeq = ::std::vector<FixedList>;

using FixedSeqList = std::list< ::Test::FixedSeq>;

using VariableSeq = ::std::vector<Variable>;

using VariableList = std::list< ::Test::Variable>;

using VariableListList = std::list< ::Test::VariableList>;

using VariableListSeq = ::std::vector<VariableList>;

using VariableSeqList = std::list< ::Test::VariableSeq>;

using StringStringDict = ::std::map<::std::string, ::std::string>;

using StringStringDictSeq = ::std::vector<StringStringDict>;

using StringStringDictList = std::list< ::Test::StringStringDict>;

using StringStringDictListList = std::list< ::Test::StringStringDictList>;

using StringStringDictListSeq = ::std::vector<StringStringDictList>;

using StringStringDictSeqList = std::list< ::Test::StringStringDictSeq>;

enum class E : unsigned char
{
    E1,
    E2,
    E3
};

using ESeq = ::std::vector<E>;

using EList = std::list< ::Test::E>;

using EListList = std::list< ::Test::EList>;

using EListSeq = ::std::vector<EList>;

using ESeqList = std::list< ::Test::ESeq>;

using CSeq = ::std::vector<::std::shared_ptr<C>>;

using CList = std::list<std::shared_ptr<::Test::C>>;

using CListList = std::list< ::Test::CList>;

using CListSeq = ::std::vector<CList>;

using CSeqList = std::list< ::Test::CSeq>;

using DPrxSeq = ::std::vector<::std::optional<DPrx>>;

using DPrxList = std::list<DPrxPtr>;

using DPrxListList = std::list< ::Test::DPrxList>;

using DPrxListSeq = ::std::vector<DPrxList>;

using DPrxSeqList = std::list< ::Test::DPrxSeq>;

using DoubleSeq = ::std::vector<double>;

using ClassOtherStructSeq = ::std::vector<ClassOtherStruct>;

using ClassStructSeq = ::std::vector<ClassStruct>;

using IntStringDict = Test::CustomMap<Ice::Int, std::string>;

using LongLongDict = ::std::map<long long int, long long int>;

using StringIntDict = ::std::map<::std::string, int>;

using BoolBuffer = Test::CustomBuffer<bool>;

using ShortBuffer = Test::CustomBuffer<Ice::Short>;

using IntBuffer = Test::CustomBuffer<Ice::Int>;

using LongBuffer = Test::CustomBuffer<Ice::Long>;

using FloatBuffer = Test::CustomBuffer<Ice::Float>;

using DoubleBuffer = Test::CustomBuffer<Ice::Double>;

using ByteBuffer = Test::CustomBuffer<Ice::Byte>;

}

namespace Test
{

class DPrx : public ::Ice::Proxy<DPrx, ::Ice::ObjectPrx>
{
public:

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    explicit DPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    DPrx(const DPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    DPrx(DPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    DPrx(const ::std::shared_ptr<::Ice::Communicator>& communicator, const ::std::string& proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    DPrx& operator=(const DPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    DPrx& operator=(DPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static DPrx _fromReference(::IceInternal::ReferencePtr ref) { return DPrx(::std::move(ref)); }

protected:

    DPrx() = default;

    explicit DPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond
};

class TestIntfPrx : public ::Ice::Proxy<TestIntfPrx, ::Ice::ObjectPrx>
{
public:

    DoubleSeq opDoubleArray(const ::std::pair<const double*, const double*>& inSeq, DoubleSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<DoubleSeq, DoubleSeq>> opDoubleArrayAsync(const ::std::pair<const double*, const double*>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opDoubleArrayAsync(const ::std::pair<const double*, const double*>& inSeq,
                       ::std::function<void(::std::pair<const double*, const double*>, ::std::pair<const double*, const double*>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opDoubleArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<DoubleSeq, DoubleSeq>>>&, const ::std::pair<const double*, const double*>&, const ::Ice::Context&) const;
    /// \endcond

    BoolSeq opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, BoolSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<BoolSeq, BoolSeq>> opBoolArrayAsync(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opBoolArrayAsync(const ::std::pair<const bool*, const bool*>& inSeq,
                     ::std::function<void(::std::pair<const bool*, const bool*>, ::std::pair<const bool*, const bool*>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opBoolArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BoolSeq, BoolSeq>>>&, const ::std::pair<const bool*, const bool*>&, const ::Ice::Context&) const;
    /// \endcond

    ByteList opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, ByteList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<ByteList, ByteList>> opByteArrayAsync(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opByteArrayAsync(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq,
                     ::std::function<void(::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>, ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opByteArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteList, ByteList>>>&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::Ice::Context&) const;
    /// \endcond

    VariableList opVariableArray(const ::std::pair<const Variable*, const Variable*>& inSeq, VariableList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<VariableList, VariableList>> opVariableArrayAsync(const ::std::pair<const Variable*, const Variable*>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opVariableArrayAsync(const ::std::pair<const Variable*, const Variable*>& inSeq,
                         ::std::function<void(::std::pair<const ::Test::Variable*, const ::Test::Variable*>, ::std::pair<const ::Test::Variable*, const ::Test::Variable*>)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opVariableArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<VariableList, VariableList>>>&, const ::std::pair<const Variable*, const Variable*>&, const ::Ice::Context&) const;
    /// \endcond

    BoolSeq opBoolRange(const BoolSeq& inSeq, BoolSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<BoolSeq, BoolSeq>> opBoolRangeAsync(const BoolSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opBoolRangeAsync(const BoolSeq& inSeq,
                     ::std::function<void(::Test::BoolSeq, ::Test::BoolSeq)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opBoolRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BoolSeq, BoolSeq>>>&, const BoolSeq&, const ::Ice::Context&) const;
    /// \endcond

    ByteList opByteRange(const ByteList& inSeq, ByteList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<ByteList, ByteList>> opByteRangeAsync(const ByteList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opByteRangeAsync(const ByteList& inSeq,
                     ::std::function<void(::Test::ByteList, ::Test::ByteList)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opByteRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteList, ByteList>>>&, const ByteList&, const ::Ice::Context&) const;
    /// \endcond

    VariableList opVariableRange(const VariableList& inSeq, VariableList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<VariableList, VariableList>> opVariableRangeAsync(const VariableList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opVariableRangeAsync(const VariableList& inSeq,
                         ::std::function<void(::Test::VariableList, ::Test::VariableList)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opVariableRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<VariableList, VariableList>>>&, const VariableList&, const ::Ice::Context&) const;
    /// \endcond

    ByteList opByteRangeType(const ByteList& inSeq, ByteList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<ByteList, ByteList>> opByteRangeTypeAsync(const ByteList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opByteRangeTypeAsync(const ByteList& inSeq,
                         ::std::function<void(::Test::ByteList, ::Test::ByteList)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opByteRangeType(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteList, ByteList>>>&, const ByteList&, const ::Ice::Context&) const;
    /// \endcond

    VariableList opVariableRangeType(const VariableList& inSeq, VariableList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<VariableList, VariableList>> opVariableRangeTypeAsync(const VariableList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opVariableRangeTypeAsync(const VariableList& inSeq,
                             ::std::function<void(::Test::VariableList, ::Test::VariableList)> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opVariableRangeType(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<VariableList, VariableList>>>&, const VariableList&, const ::Ice::Context&) const;
    /// \endcond

    std::deque<bool> opBoolSeq(const std::deque<bool>& inSeq, std::deque<bool>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<std::deque<bool>, std::deque<bool>>> opBoolSeqAsync(const std::deque<bool>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opBoolSeqAsync(const std::deque<bool>& inSeq,
                   ::std::function<void(std::deque<bool>, std::deque<bool>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opBoolSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque<bool>, std::deque<bool>>>>&, const std::deque<bool>&, const ::Ice::Context&) const;
    /// \endcond

    BoolList opBoolList(const BoolList& inSeq, BoolList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<BoolList, BoolList>> opBoolListAsync(const BoolList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opBoolListAsync(const BoolList& inSeq,
                    ::std::function<void(::Test::BoolList, ::Test::BoolList)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opBoolList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BoolList, BoolList>>>&, const BoolList&, const ::Ice::Context&) const;
    /// \endcond

    BoolDequeList opBoolDequeList(const BoolDequeList& inSeq, BoolDequeList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<BoolDequeList, BoolDequeList>> opBoolDequeListAsync(const BoolDequeList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opBoolDequeListAsync(const BoolDequeList& inSeq,
                         ::std::function<void(::Test::BoolDequeList, ::Test::BoolDequeList)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opBoolDequeList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BoolDequeList, BoolDequeList>>>&, const BoolDequeList&, const ::Ice::Context&) const;
    /// \endcond

    BoolDequeList opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq, BoolDequeList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<BoolDequeList, BoolDequeList>> opBoolDequeListArrayAsync(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opBoolDequeListArrayAsync(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq,
                              ::std::function<void(::std::pair<const std::deque<bool>*, const std::deque<bool>*>, ::std::pair<const std::deque<bool>*, const std::deque<bool>*>)> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opBoolDequeListArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BoolDequeList, BoolDequeList>>>&, const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, const ::Ice::Context&) const;
    /// \endcond

    BoolDequeList opBoolDequeListRange(const BoolDequeList& inSeq, BoolDequeList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<BoolDequeList, BoolDequeList>> opBoolDequeListRangeAsync(const BoolDequeList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opBoolDequeListRangeAsync(const BoolDequeList& inSeq,
                              ::std::function<void(::Test::BoolDequeList, ::Test::BoolDequeList)> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opBoolDequeListRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BoolDequeList, BoolDequeList>>>&, const BoolDequeList&, const ::Ice::Context&) const;
    /// \endcond

    std::deque< ::Ice::Byte> opByteSeq(const std::deque< ::Ice::Byte>& inSeq, std::deque< ::Ice::Byte>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<std::deque< ::Ice::Byte>, std::deque< ::Ice::Byte>>> opByteSeqAsync(const std::deque< ::Ice::Byte>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opByteSeqAsync(const std::deque< ::Ice::Byte>& inSeq,
                   ::std::function<void(std::deque< ::Ice::Byte>, std::deque< ::Ice::Byte>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque< ::Ice::Byte>, std::deque< ::Ice::Byte>>>>&, const std::deque< ::Ice::Byte>&, const ::Ice::Context&) const;
    /// \endcond

    ByteList opByteList(const ByteList& inSeq, ByteList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<ByteList, ByteList>> opByteListAsync(const ByteList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opByteListAsync(const ByteList& inSeq,
                    ::std::function<void(::Test::ByteList, ::Test::ByteList)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opByteList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteList, ByteList>>>&, const ByteList&, const ::Ice::Context&) const;
    /// \endcond

    MyByteSeq opMyByteSeq(const MyByteSeq& inSeq, MyByteSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<MyByteSeq, MyByteSeq>> opMyByteSeqAsync(const MyByteSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opMyByteSeqAsync(const MyByteSeq& inSeq,
                     ::std::function<void(MyByteSeq, MyByteSeq)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opMyByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<MyByteSeq, MyByteSeq>>>&, const MyByteSeq&, const ::Ice::Context&) const;
    /// \endcond

    ::std::string opString(const Util::string_view& inString, ::std::string& outString, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::string, ::std::string>> opStringAsync(const Util::string_view& inString, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opStringAsync(const Util::string_view& inString,
                  ::std::function<void(Util::string_view, Util::string_view)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opString(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::string, ::std::string>>>&, const Util::string_view&, const ::Ice::Context&) const;
    /// \endcond

    std::deque<std::string> opStringSeq(const std::deque<std::string>& inSeq, std::deque<std::string>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<std::deque<std::string>, std::deque<std::string>>> opStringSeqAsync(const std::deque<std::string>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opStringSeqAsync(const std::deque<std::string>& inSeq,
                     ::std::function<void(std::deque<std::string>, std::deque<std::string>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opStringSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque<std::string>, std::deque<std::string>>>>&, const std::deque<std::string>&, const ::Ice::Context&) const;
    /// \endcond

    StringList opStringList(const StringList& inSeq, StringList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<StringList, StringList>> opStringListAsync(const StringList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opStringListAsync(const StringList& inSeq,
                      ::std::function<void(::Test::StringList, ::Test::StringList)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opStringList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringList, StringList>>>&, const StringList&, const ::Ice::Context&) const;
    /// \endcond

    std::deque< ::Test::Fixed> opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, std::deque< ::Test::Fixed>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<std::deque< ::Test::Fixed>, std::deque< ::Test::Fixed>>> opFixedSeqAsync(const std::deque< ::Test::Fixed>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opFixedSeqAsync(const std::deque< ::Test::Fixed>& inSeq,
                    ::std::function<void(std::deque< ::Test::Fixed>, std::deque< ::Test::Fixed>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opFixedSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque< ::Test::Fixed>, std::deque< ::Test::Fixed>>>>&, const std::deque< ::Test::Fixed>&, const ::Ice::Context&) const;
    /// \endcond

    FixedList opFixedList(const FixedList& inSeq, FixedList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<FixedList, FixedList>> opFixedListAsync(const FixedList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opFixedListAsync(const FixedList& inSeq,
                     ::std::function<void(::Test::FixedList, ::Test::FixedList)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opFixedList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<FixedList, FixedList>>>&, const FixedList&, const ::Ice::Context&) const;
    /// \endcond

    std::deque< ::Test::Variable> opVariableSeq(const std::deque< ::Test::Variable>& inSeq, std::deque< ::Test::Variable>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<std::deque< ::Test::Variable>, std::deque< ::Test::Variable>>> opVariableSeqAsync(const std::deque< ::Test::Variable>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opVariableSeqAsync(const std::deque< ::Test::Variable>& inSeq,
                       ::std::function<void(std::deque< ::Test::Variable>, std::deque< ::Test::Variable>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opVariableSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque< ::Test::Variable>, std::deque< ::Test::Variable>>>>&, const std::deque< ::Test::Variable>&, const ::Ice::Context&) const;
    /// \endcond

    VariableList opVariableList(const VariableList& inSeq, VariableList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<VariableList, VariableList>> opVariableListAsync(const VariableList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opVariableListAsync(const VariableList& inSeq,
                        ::std::function<void(::Test::VariableList, ::Test::VariableList)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opVariableList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<VariableList, VariableList>>>&, const VariableList&, const ::Ice::Context&) const;
    /// \endcond

    std::deque< ::Test::StringStringDict> opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, std::deque< ::Test::StringStringDict>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<std::deque< ::Test::StringStringDict>, std::deque< ::Test::StringStringDict>>> opStringStringDictSeqAsync(const std::deque< ::Test::StringStringDict>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opStringStringDictSeqAsync(const std::deque< ::Test::StringStringDict>& inSeq,
                               ::std::function<void(std::deque< ::Test::StringStringDict>, std::deque< ::Test::StringStringDict>)> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opStringStringDictSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque< ::Test::StringStringDict>, std::deque< ::Test::StringStringDict>>>>&, const std::deque< ::Test::StringStringDict>&, const ::Ice::Context&) const;
    /// \endcond

    StringStringDictList opStringStringDictList(const StringStringDictList& inSeq, StringStringDictList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<StringStringDictList, StringStringDictList>> opStringStringDictListAsync(const StringStringDictList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opStringStringDictListAsync(const StringStringDictList& inSeq,
                                ::std::function<void(::Test::StringStringDictList, ::Test::StringStringDictList)> response,
                                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                ::std::function<void(bool)> sent = nullptr,
                                const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opStringStringDictList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringStringDictList, StringStringDictList>>>&, const StringStringDictList&, const ::Ice::Context&) const;
    /// \endcond

    std::deque< ::Test::E> opESeq(const std::deque< ::Test::E>& inSeq, std::deque< ::Test::E>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<std::deque< ::Test::E>, std::deque< ::Test::E>>> opESeqAsync(const std::deque< ::Test::E>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opESeqAsync(const std::deque< ::Test::E>& inSeq,
                ::std::function<void(std::deque< ::Test::E>, std::deque< ::Test::E>)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opESeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque< ::Test::E>, std::deque< ::Test::E>>>>&, const std::deque< ::Test::E>&, const ::Ice::Context&) const;
    /// \endcond

    EList opEList(const EList& inSeq, EList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<EList, EList>> opEListAsync(const EList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opEListAsync(const EList& inSeq,
                 ::std::function<void(::Test::EList, ::Test::EList)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opEList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<EList, EList>>>&, const EList&, const ::Ice::Context&) const;
    /// \endcond

    std::deque<::Test::DPrxPtr> opDPrxSeq(const std::deque<::Test::DPrxPtr>& inSeq, std::deque<::Test::DPrxPtr>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<std::deque<::Test::DPrxPtr>, std::deque<::Test::DPrxPtr>>> opDPrxSeqAsync(const std::deque<::Test::DPrxPtr>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opDPrxSeqAsync(const std::deque<::Test::DPrxPtr>& inSeq,
                   ::std::function<void(std::deque<::Test::DPrxPtr>, std::deque<::Test::DPrxPtr>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opDPrxSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque<::Test::DPrxPtr>, std::deque<::Test::DPrxPtr>>>>&, const std::deque<::Test::DPrxPtr>&, const ::Ice::Context&) const;
    /// \endcond

    DPrxList opDPrxList(const DPrxList& inSeq, DPrxList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<DPrxList, DPrxList>> opDPrxListAsync(const DPrxList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opDPrxListAsync(const DPrxList& inSeq,
                    ::std::function<void(::Test::DPrxList, ::Test::DPrxList)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opDPrxList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<DPrxList, DPrxList>>>&, const DPrxList&, const ::Ice::Context&) const;
    /// \endcond

    std::deque<std::shared_ptr<Test::C>> opCSeq(const std::deque<std::shared_ptr<Test::C>>& inSeq, std::deque<std::shared_ptr<Test::C>>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>>> opCSeqAsync(const std::deque<std::shared_ptr<Test::C>>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opCSeqAsync(const std::deque<std::shared_ptr<Test::C>>& inSeq,
                ::std::function<void(std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opCSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>>>>&, const std::deque<std::shared_ptr<Test::C>>&, const ::Ice::Context&) const;
    /// \endcond

    CList opCList(const CList& inSeq, CList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<CList, CList>> opCListAsync(const CList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opCListAsync(const CList& inSeq,
                 ::std::function<void(::Test::CList, ::Test::CList)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opCList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<CList, CList>>>&, const CList&, const ::Ice::Context&) const;
    /// \endcond

    ClassStruct opClassStruct(const ClassStruct& inS, const ClassStructSeq& inSeq, ClassStruct& outS, ClassStructSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<ClassStruct, ClassStruct, ClassStructSeq>> opClassStructAsync(const ClassStruct& inS, const ClassStructSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opClassStructAsync(const ClassStruct& inS, const ClassStructSeq& inSeq,
                       ::std::function<void(::Test::ClassStruct, ::Test::ClassStruct, ::Test::ClassStructSeq)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opClassStruct(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ClassStruct, ClassStruct, ClassStructSeq>>>&, const ClassStruct&, const ClassStructSeq&, const ::Ice::Context&) const;
    /// \endcond

    void opOutArrayByteSeq(const ByteSeq& org, ByteSeq& copy, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<ByteSeq> opOutArrayByteSeqAsync(const ByteSeq& org, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opOutArrayByteSeqAsync(const ByteSeq& org,
                           ::std::function<void(::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opOutArrayByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ByteSeq>>&, const ByteSeq&, const ::Ice::Context&) const;
    /// \endcond

    void opOutRangeByteSeq(const ByteSeq& org, ByteSeq& copy, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<ByteSeq> opOutRangeByteSeqAsync(const ByteSeq& org, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opOutRangeByteSeqAsync(const ByteSeq& org,
                           ::std::function<void(::Test::ByteSeq)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opOutRangeByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ByteSeq>>&, const ByteSeq&, const ::Ice::Context&) const;
    /// \endcond

    IntStringDict opIntStringDict(const IntStringDict& idict, IntStringDict& odict, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<IntStringDict, IntStringDict>> opIntStringDictAsync(const IntStringDict& idict, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opIntStringDictAsync(const IntStringDict& idict,
                         ::std::function<void(::Test::IntStringDict, ::Test::IntStringDict)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opIntStringDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<IntStringDict, IntStringDict>>>&, const IntStringDict&, const ::Ice::Context&) const;
    /// \endcond

    ::Test::CustomMap< ::Ice::Long, ::Ice::Long> opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, ::Test::CustomMap<std::string, ::Ice::Int>& odict, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::Test::CustomMap< ::Ice::Long, ::Ice::Long>, ::Test::CustomMap<std::string, ::Ice::Int>>> opVarDictAsync(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opVarDictAsync(const ::Test::CustomMap<std::string, ::Ice::Int>& idict,
                   ::std::function<void(::Test::CustomMap< ::Ice::Long, ::Ice::Long>, ::Test::CustomMap<std::string, ::Ice::Int>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opVarDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::Test::CustomMap< ::Ice::Long, ::Ice::Long>, ::Test::CustomMap<std::string, ::Ice::Int>>>>&, const ::Test::CustomMap<std::string, ::Ice::Int>&, const ::Ice::Context&) const;
    /// \endcond

    ::Test::CustomMap< ::Ice::Int, std::string> opCustomIntStringDict(const ::std::map< ::Ice::Int, ::Util::string_view>& idict, ::Test::CustomMap< ::Ice::Int, std::string>& odict, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::Test::CustomMap< ::Ice::Int, std::string>, ::Test::CustomMap< ::Ice::Int, std::string>>> opCustomIntStringDictAsync(const ::std::map< ::Ice::Int, ::Util::string_view>& idict, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opCustomIntStringDictAsync(const ::std::map< ::Ice::Int, ::Util::string_view>& idict,
                               ::std::function<void(::std::map< ::Ice::Int, ::Util::string_view>, ::std::map< ::Ice::Int, ::Util::string_view>)> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opCustomIntStringDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::Test::CustomMap< ::Ice::Int, std::string>, ::Test::CustomMap< ::Ice::Int, std::string>>>>&, const ::std::map< ::Ice::Int, ::Util::string_view>&, const ::Ice::Context&) const;
    /// \endcond

    ShortBuffer opShortBuffer(const ShortBuffer& inS, ShortBuffer& outS, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<ShortBuffer, ShortBuffer>> opShortBufferAsync(const ShortBuffer& inS, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opShortBufferAsync(const ShortBuffer& inS,
                       ::std::function<void(::Test::ShortBuffer, ::Test::ShortBuffer)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opShortBuffer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ShortBuffer, ShortBuffer>>>&, const ShortBuffer&, const ::Ice::Context&) const;
    /// \endcond

    ::Test::CustomBuffer<bool> opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, ::Test::CustomBuffer<bool>& outS, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>>> opBoolBufferAsync(const ::Test::CustomBuffer<bool>& inS, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opBoolBufferAsync(const ::Test::CustomBuffer<bool>& inS,
                      ::std::function<void(::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opBoolBuffer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>>>>&, const ::Test::CustomBuffer<bool>&, const ::Ice::Context&) const;
    /// \endcond

    BufferStruct opBufferStruct(const BufferStruct& s, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<BufferStruct> opBufferStructAsync(const BufferStruct& s, const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    opBufferStructAsync(const BufferStruct& s,
                        ::std::function<void(::Test::BufferStruct)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opBufferStruct(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<BufferStruct>>&, const BufferStruct&, const ::Ice::Context&) const;
    /// \endcond

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> shutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)const;

    ::std::function<void()>
    shutdownAsync(::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    explicit TestIntfPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    TestIntfPrx(const TestIntfPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    TestIntfPrx(TestIntfPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    TestIntfPrx(const ::std::shared_ptr<::Ice::Communicator>& communicator, const ::std::string& proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    TestIntfPrx& operator=(const TestIntfPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    TestIntfPrx& operator=(TestIntfPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static TestIntfPrx _fromReference(::IceInternal::ReferencePtr ref) { return TestIntfPrx(::std::move(ref)); }

protected:

    TestIntfPrx() = default;

    explicit TestIntfPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond
};

}

namespace Test
{

struct Fixed
{
    short s;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const short&> ice_tuple() const
    {
        return std::tie(s);
    }
};

struct Variable
{
    ::std::string s;
    ::Test::BoolList bl;
    std::list<std::string> ss;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::Test::BoolList&, const std::list<std::string>&> ice_tuple() const
    {
        return std::tie(s, bl, ss);
    }
};

struct ClassOtherStruct
{
    int x;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(x);
    }
};

struct ClassStruct
{
    ::Test::ClassOtherStructSeq otherSeq;
    ::Test::ClassOtherStruct other;
    int y;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::ClassOtherStructSeq&, const ::Test::ClassOtherStruct&, const int&> ice_tuple() const
    {
        return std::tie(otherSeq, other, y);
    }
};

struct BufferStruct
{
    ::Test::ByteBuffer byteBuf;
    ::Test::BoolBuffer boolBuf;
    ::Test::ShortBuffer shortBuf;
    ::Test::IntBuffer intBuf;
    ::Test::LongBuffer longBuf;
    ::Test::FloatBuffer floatBuf;
    ::Test::DoubleBuffer doubleBuf;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::ByteBuffer&, const ::Test::BoolBuffer&, const ::Test::ShortBuffer&, const ::Test::IntBuffer&, const ::Test::LongBuffer&, const ::Test::FloatBuffer&, const ::Test::DoubleBuffer&> ice_tuple() const
    {
        return std::tie(byteBuf, boolBuf, shortBuf, intBuf, longBuf, floatBuf, doubleBuf);
    }
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace Test
{

class C : public ::Ice::ValueHelper<C, ::Ice::Value>
{
public:

    virtual ~C();

    C() = default;

    C(const C&) = default;
    C(C&&) = default;
    C& operator=(const C&) = default;
    C& operator=(C&&) = default;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

/// \cond INTERNAL
static C _iceS_C_init;
/// \endcond

class DictClass : public ::Ice::ValueHelper<DictClass, ::Ice::Value>
{
public:

    virtual ~DictClass();

    DictClass() = default;

    DictClass(const DictClass&) = default;
    DictClass(DictClass&&) = default;
    DictClass& operator=(const DictClass&) = default;
    DictClass& operator=(DictClass&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit DictClass(const ::Test::IntStringDict& isdict) :
        isdict(isdict)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::IntStringDict&> ice_tuple() const
    {
        return std::tie(isdict);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::Test::IntStringDict isdict;
};

}

namespace Test
{

class D : public virtual ::Ice::Object
{
public:

    using ProxyType = DPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

class TestIntf : public virtual ::Ice::Object
{
public:

    using ProxyType = TestIntfPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Encapsulates the results of a call to opDoubleArray.
     */
    struct OpDoubleArrayResult
    {
        DoubleSeq returnValue;
        DoubleSeq outSeq;
    };

    virtual DoubleSeq opDoubleArray(::std::pair<const double*, const double*> inSeq, DoubleSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDoubleArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolArray.
     */
    struct OpBoolArrayResult
    {
        BoolSeq returnValue;
        BoolSeq outSeq;
    };

    virtual BoolSeq opBoolArray(::std::pair<const bool*, const bool*> inSeq, BoolSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteArray.
     */
    struct OpByteArrayResult
    {
        ByteList returnValue;
        ByteList outSeq;
    };

    virtual ByteList opByteArray(::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> inSeq, ByteList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opVariableArray.
     */
    struct OpVariableArrayResult
    {
        VariableList returnValue;
        VariableList outSeq;
    };

    virtual VariableList opVariableArray(::std::pair<const Variable*, const Variable*> inSeq, VariableList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolRange.
     */
    struct OpBoolRangeResult
    {
        BoolSeq returnValue;
        BoolSeq outSeq;
    };

    virtual BoolSeq opBoolRange(BoolSeq inSeq, BoolSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteRange.
     */
    struct OpByteRangeResult
    {
        ByteList returnValue;
        ByteList outSeq;
    };

    virtual ByteList opByteRange(ByteList inSeq, ByteList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opVariableRange.
     */
    struct OpVariableRangeResult
    {
        VariableList returnValue;
        VariableList outSeq;
    };

    virtual VariableList opVariableRange(VariableList inSeq, VariableList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteRangeType.
     */
    struct OpByteRangeTypeResult
    {
        ByteList returnValue;
        ByteList outSeq;
    };

    virtual ByteList opByteRangeType(ByteList inSeq, ByteList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteRangeType(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opVariableRangeType.
     */
    struct OpVariableRangeTypeResult
    {
        VariableList returnValue;
        VariableList outSeq;
    };

    virtual VariableList opVariableRangeType(VariableList inSeq, VariableList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableRangeType(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolSeq.
     */
    struct OpBoolSeqResult
    {
        std::deque<bool> returnValue;
        std::deque<bool> outSeq;
    };

    virtual std::deque<bool> opBoolSeq(std::deque<bool> inSeq, std::deque<bool>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolList.
     */
    struct OpBoolListResult
    {
        BoolList returnValue;
        BoolList outSeq;
    };

    virtual BoolList opBoolList(BoolList inSeq, BoolList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolDequeList.
     */
    struct OpBoolDequeListResult
    {
        BoolDequeList returnValue;
        BoolDequeList outSeq;
    };

    virtual BoolDequeList opBoolDequeList(BoolDequeList inSeq, BoolDequeList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolDequeList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolDequeListArray.
     */
    struct OpBoolDequeListArrayResult
    {
        BoolDequeList returnValue;
        BoolDequeList outSeq;
    };

    virtual BoolDequeList opBoolDequeListArray(::std::pair<const std::deque<bool>*, const std::deque<bool>*> inSeq, BoolDequeList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolDequeListArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolDequeListRange.
     */
    struct OpBoolDequeListRangeResult
    {
        BoolDequeList returnValue;
        BoolDequeList outSeq;
    };

    virtual BoolDequeList opBoolDequeListRange(BoolDequeList inSeq, BoolDequeList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolDequeListRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteSeq.
     */
    struct OpByteSeqResult
    {
        std::deque< ::Ice::Byte> returnValue;
        std::deque< ::Ice::Byte> outSeq;
    };

    virtual std::deque< ::Ice::Byte> opByteSeq(std::deque< ::Ice::Byte> inSeq, std::deque< ::Ice::Byte>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteList.
     */
    struct OpByteListResult
    {
        ByteList returnValue;
        ByteList outSeq;
    };

    virtual ByteList opByteList(ByteList inSeq, ByteList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMyByteSeq.
     */
    struct OpMyByteSeqResult
    {
        MyByteSeq returnValue;
        MyByteSeq outSeq;
    };

    virtual MyByteSeq opMyByteSeq(MyByteSeq inSeq, MyByteSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opString.
     */
    struct OpStringResult
    {
        ::std::string returnValue;
        ::std::string outString;
    };

    virtual ::std::string opString(Util::string_view inString, ::std::string& outString, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opString(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringSeq.
     */
    struct OpStringSeqResult
    {
        std::deque<std::string> returnValue;
        std::deque<std::string> outSeq;
    };

    virtual std::deque<std::string> opStringSeq(std::deque<std::string> inSeq, std::deque<std::string>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringList.
     */
    struct OpStringListResult
    {
        StringList returnValue;
        StringList outSeq;
    };

    virtual StringList opStringList(StringList inSeq, StringList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFixedSeq.
     */
    struct OpFixedSeqResult
    {
        std::deque< ::Test::Fixed> returnValue;
        std::deque< ::Test::Fixed> outSeq;
    };

    virtual std::deque< ::Test::Fixed> opFixedSeq(std::deque< ::Test::Fixed> inSeq, std::deque< ::Test::Fixed>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFixedSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFixedList.
     */
    struct OpFixedListResult
    {
        FixedList returnValue;
        FixedList outSeq;
    };

    virtual FixedList opFixedList(FixedList inSeq, FixedList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFixedList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opVariableSeq.
     */
    struct OpVariableSeqResult
    {
        std::deque< ::Test::Variable> returnValue;
        std::deque< ::Test::Variable> outSeq;
    };

    virtual std::deque< ::Test::Variable> opVariableSeq(std::deque< ::Test::Variable> inSeq, std::deque< ::Test::Variable>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opVariableList.
     */
    struct OpVariableListResult
    {
        VariableList returnValue;
        VariableList outSeq;
    };

    virtual VariableList opVariableList(VariableList inSeq, VariableList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringStringDictSeq.
     */
    struct OpStringStringDictSeqResult
    {
        std::deque< ::Test::StringStringDict> returnValue;
        std::deque< ::Test::StringStringDict> outSeq;
    };

    virtual std::deque< ::Test::StringStringDict> opStringStringDictSeq(std::deque< ::Test::StringStringDict> inSeq, std::deque< ::Test::StringStringDict>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringStringDictSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringStringDictList.
     */
    struct OpStringStringDictListResult
    {
        StringStringDictList returnValue;
        StringStringDictList outSeq;
    };

    virtual StringStringDictList opStringStringDictList(StringStringDictList inSeq, StringStringDictList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringStringDictList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opESeq.
     */
    struct OpESeqResult
    {
        std::deque< ::Test::E> returnValue;
        std::deque< ::Test::E> outSeq;
    };

    virtual std::deque< ::Test::E> opESeq(std::deque< ::Test::E> inSeq, std::deque< ::Test::E>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opESeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opEList.
     */
    struct OpEListResult
    {
        EList returnValue;
        EList outSeq;
    };

    virtual EList opEList(EList inSeq, EList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opEList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opDPrxSeq.
     */
    struct OpDPrxSeqResult
    {
        std::deque<::Test::DPrxPtr> returnValue;
        std::deque<::Test::DPrxPtr> outSeq;
    };

    virtual std::deque<::Test::DPrxPtr> opDPrxSeq(std::deque<::Test::DPrxPtr> inSeq, std::deque<::Test::DPrxPtr>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDPrxSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opDPrxList.
     */
    struct OpDPrxListResult
    {
        DPrxList returnValue;
        DPrxList outSeq;
    };

    virtual DPrxList opDPrxList(DPrxList inSeq, DPrxList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDPrxList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opCSeq.
     */
    struct OpCSeqResult
    {
        std::deque<std::shared_ptr<Test::C>> returnValue;
        std::deque<std::shared_ptr<Test::C>> outSeq;
    };

    virtual std::deque<std::shared_ptr<Test::C>> opCSeq(std::deque<std::shared_ptr<Test::C>> inSeq, std::deque<std::shared_ptr<Test::C>>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opCSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opCList.
     */
    struct OpCListResult
    {
        CList returnValue;
        CList outSeq;
    };

    virtual CList opCList(CList inSeq, CList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opCList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opClassStruct.
     */
    struct OpClassStructResult
    {
        ClassStruct returnValue;
        ClassStruct outS;
        ClassStructSeq outSeq;
    };

    virtual ClassStruct opClassStruct(ClassStruct inS, ClassStructSeq inSeq, ClassStruct& outS, ClassStructSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opClassStruct(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opOutArrayByteSeq(ByteSeq org, ByteSeq& copy, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOutArrayByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opOutRangeByteSeq(ByteSeq org, ByteSeq& copy, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOutRangeByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opIntStringDict.
     */
    struct OpIntStringDictResult
    {
        IntStringDict returnValue;
        IntStringDict odict;
    };

    virtual IntStringDict opIntStringDict(IntStringDict idict, IntStringDict& odict, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntStringDict(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opVarDict.
     */
    struct OpVarDictResult
    {
        ::Test::CustomMap< ::Ice::Long, ::Ice::Long> returnValue;
        ::Test::CustomMap<std::string, ::Ice::Int> odict;
    };

    virtual ::Test::CustomMap< ::Ice::Long, ::Ice::Long> opVarDict(::Test::CustomMap<std::string, ::Ice::Int> idict, ::Test::CustomMap<std::string, ::Ice::Int>& odict, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVarDict(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opCustomIntStringDict.
     */
    struct OpCustomIntStringDictResult
    {
        ::Test::CustomMap< ::Ice::Int, std::string> returnValue;
        ::Test::CustomMap< ::Ice::Int, std::string> odict;
    };

    virtual ::Test::CustomMap< ::Ice::Int, std::string> opCustomIntStringDict(::std::map< ::Ice::Int, ::Util::string_view> idict, ::Test::CustomMap< ::Ice::Int, std::string>& odict, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opCustomIntStringDict(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opShortBuffer.
     */
    struct OpShortBufferResult
    {
        ShortBuffer returnValue;
        ShortBuffer outS;
    };

    virtual ShortBuffer opShortBuffer(ShortBuffer inS, ShortBuffer& outS, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortBuffer(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolBuffer.
     */
    struct OpBoolBufferResult
    {
        ::Test::CustomBuffer<bool> returnValue;
        ::Test::CustomBuffer<bool> outS;
    };

    virtual ::Test::CustomBuffer<bool> opBoolBuffer(::Test::CustomBuffer<bool> inS, ::Test::CustomBuffer<bool>& outS, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolBuffer(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual BufferStruct opBufferStruct(BufferStruct s, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBufferStruct(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void shutdown(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::Test::Fixed>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::Test::Fixed, S>
{
    static void read(S* istr, ::Test::Fixed& v)
    {
        istr->readAll(v.s);
    }
};

template<>
struct StreamableTraits<::Test::Variable>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 3;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::Variable, S>
{
    static void read(S* istr, ::Test::Variable& v)
    {
        istr->readAll(v.s, v.bl, v.ss);
    }
};

template<>
struct StreamableTraits< ::Test::E>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::Test::ClassOtherStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::Test::ClassOtherStruct, S>
{
    static void read(S* istr, ::Test::ClassOtherStruct& v)
    {
        istr->readAll(v.x);
    }
};

template<>
struct StreamableTraits<::Test::ClassStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 9;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::ClassStruct, S>
{
    static void read(S* istr, ::Test::ClassStruct& v)
    {
        istr->readAll(v.otherSeq, v.other, v.y);
    }
};

template<typename S>
struct StreamReader<::Test::DictClass, S>
{
    static void read(S* istr, ::Test::DictClass& v)
    {
        istr->readAll(v.isdict);
    }
};

template<>
struct StreamableTraits<::Test::BufferStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::BufferStruct, S>
{
    static void read(S* istr, ::Test::BufferStruct& v)
    {
        istr->readAll(v.byteBuf, v.boolBuf, v.shortBuf, v.intBuf, v.longBuf, v.floatBuf, v.doubleBuf);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace Test
{

using CPtr = ::std::shared_ptr<C>;

using DPtr = ::std::shared_ptr<D>;

using DictClassPtr = ::std::shared_ptr<DictClass>;

using TestIntfPtr = ::std::shared_ptr<TestIntf>;

}
/// \endcond

#include <IceUtil/PopDisableWarnings.h>
#endif
